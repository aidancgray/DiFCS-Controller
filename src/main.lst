CCS PCH C Compiler, Version 5.117, 2138               15-Dec-25 16:26

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43702 bytes (67%)
                           Largest free fragment is 21832
               RAM used:   1798 (50%) at main() level
                           1909 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A2C4
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   025C
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00330:  DATA 32,30
00332:  DATA 32,35
00334:  DATA 31,32
00336:  DATA 30,38
00338:  DATA 00,00
0033A:  DATA 30,30
0033C:  DATA 30,30
0033E:  DATA 00,00
00340:  DATA 25,64
00342:  DATA 2C,4D
00344:  DATA 41,4E
00346:  DATA 55,41
00348:  DATA 4C,2C
0034A:  DATA 00,00
0034C:  DATA 25,64
0034E:  DATA 2C,4D
00350:  DATA 41,47
00352:  DATA 53,4E
00354:  DATA 53,2C
00356:  DATA 00,00
00358:  DATA 43,4E
0035A:  DATA 54,2C
0035C:  DATA 25,75
0035E:  DATA 2C,25
00360:  DATA 2E,30
00362:  DATA 66,2C
00364:  DATA 25,2E
00366:  DATA 30,66
00368:  DATA 3B,00
0036A:  DATA 50,4F
0036C:  DATA 53,2C
0036E:  DATA 25,75
00370:  DATA 2C,25
00372:  DATA 33,2E
00374:  DATA 33,66
00376:  DATA 3B,00
00378:  DATA 4F,55
0037A:  DATA 54,2C
0037C:  DATA 25,75
0037E:  DATA 2C,2D
00380:  DATA 2C,25
00382:  DATA 4C,75
00384:  DATA 3B,00
00386:  DATA 4F,55
00388:  DATA 54,2C
0038A:  DATA 25,75
0038C:  DATA 2C,2B
0038E:  DATA 2C,25
00390:  DATA 4C,75
00392:  DATA 3B,00
*
006D8:  ADDWF  FE8,W
006DA:  CLRF   FF7
006DC:  RLCF   FF7,F
006DE:  ADDLW  F3
006E0:  MOVWF  FF6
006E2:  MOVLW  06
006E4:  ADDWFC FF7,F
006E6:  TBLRD*-
006E8:  MOVF   FF5,W
006EA:  MOVWF  FFA
006EC:  TBLRD*
006EE:  MOVF   FF5,W
006F0:  MOVWF  FF9
006F2:  DATA A2,06
006F4:  DATA AC,06
006F6:  DATA B6,06
006F8:  DATA C0,06
*
00880:  MOVLB  7
00882:  MOVF   x41,W
00884:  MULWF  x43
00886:  MOVFF  FF3,01
0088A:  MOVFF  FF4,00
0088E:  MULWF  x44
00890:  MOVF   FF3,W
00892:  ADDWF  00,F
00894:  MOVF   x42,W
00896:  MULWF  x43
00898:  MOVF   FF3,W
0089A:  ADDWFC 00,W
0089C:  MOVWF  02
0089E:  MOVLB  0
008A0:  RETURN 0
008A2:  MOVLB  7
008A4:  MOVF   x3B,W
008A6:  CLRF   01
008A8:  SUBWF  x3A,W
008AA:  BC    08B2
008AC:  MOVFF  73A,00
008B0:  BRA    08CA
008B2:  CLRF   00
008B4:  MOVLW  08
008B6:  MOVWF  x3C
008B8:  RLCF   x3A,F
008BA:  RLCF   00,F
008BC:  MOVF   x3B,W
008BE:  SUBWF  00,W
008C0:  BTFSC  FD8.0
008C2:  MOVWF  00
008C4:  RLCF   01,F
008C6:  DECFSZ x3C,F
008C8:  BRA    08B8
008CA:  MOVLB  0
008CC:  RETURN 0
*
00D34:  MOVLW  8E
00D36:  MOVWF  00
00D38:  MOVFF  74B,01
00D3C:  MOVFF  74A,02
00D40:  CLRF   03
00D42:  MOVF   01,F
00D44:  BNZ   0D58
00D46:  MOVFF  02,01
00D4A:  CLRF   02
00D4C:  MOVLW  08
00D4E:  SUBWF  00,F
00D50:  MOVF   01,F
00D52:  BNZ   0D58
00D54:  CLRF   00
00D56:  BRA    0D68
00D58:  BCF    FD8.0
00D5A:  BTFSC  01.7
00D5C:  BRA    0D66
00D5E:  RLCF   02,F
00D60:  RLCF   01,F
00D62:  DECF   00,F
00D64:  BRA    0D58
00D66:  BCF    01.7
00D68:  RETURN 0
00D6A:  MOVLB  7
00D6C:  MOVF   x50,W
00D6E:  BTFSC  FD8.2
00D70:  BRA    0E54
00D72:  MOVWF  00
00D74:  MOVF   x54,W
00D76:  BTFSC  FD8.2
00D78:  BRA    0E54
00D7A:  ADDWF  00,F
00D7C:  BNC   0D86
00D7E:  MOVLW  81
00D80:  ADDWF  00,F
00D82:  BC    0E54
00D84:  BRA    0D8E
00D86:  MOVLW  7F
00D88:  SUBWF  00,F
00D8A:  BNC   0E54
00D8C:  BZ    0E54
00D8E:  MOVFF  751,758
00D92:  MOVF   x55,W
00D94:  XORWF  x58,F
00D96:  BSF    x51.7
00D98:  BSF    x55.7
00D9A:  MOVF   x53,W
00D9C:  MULWF  x57
00D9E:  MOVFF  FF4,75A
00DA2:  MOVF   x52,W
00DA4:  MULWF  x56
00DA6:  MOVFF  FF4,03
00DAA:  MOVFF  FF3,759
00DAE:  MULWF  x57
00DB0:  MOVF   FF3,W
00DB2:  ADDWF  x5A,F
00DB4:  MOVF   FF4,W
00DB6:  ADDWFC x59,F
00DB8:  MOVLW  00
00DBA:  ADDWFC 03,F
00DBC:  MOVF   x53,W
00DBE:  MULWF  x56
00DC0:  MOVF   FF3,W
00DC2:  ADDWF  x5A,F
00DC4:  MOVF   FF4,W
00DC6:  ADDWFC x59,F
00DC8:  MOVLW  00
00DCA:  CLRF   02
00DCC:  ADDWFC 03,F
00DCE:  ADDWFC 02,F
00DD0:  MOVF   x51,W
00DD2:  MULWF  x57
00DD4:  MOVF   FF3,W
00DD6:  ADDWF  x59,F
00DD8:  MOVF   FF4,W
00DDA:  ADDWFC 03,F
00DDC:  MOVLW  00
00DDE:  ADDWFC 02,F
00DE0:  MOVF   x51,W
00DE2:  MULWF  x56
00DE4:  MOVF   FF3,W
00DE6:  ADDWF  03,F
00DE8:  MOVF   FF4,W
00DEA:  ADDWFC 02,F
00DEC:  MOVLW  00
00DEE:  CLRF   01
00DF0:  ADDWFC 01,F
00DF2:  MOVF   x53,W
00DF4:  MULWF  x55
00DF6:  MOVF   FF3,W
00DF8:  ADDWF  x59,F
00DFA:  MOVF   FF4,W
00DFC:  ADDWFC 03,F
00DFE:  MOVLW  00
00E00:  ADDWFC 02,F
00E02:  ADDWFC 01,F
00E04:  MOVF   x52,W
00E06:  MULWF  x55
00E08:  MOVF   FF3,W
00E0A:  ADDWF  03,F
00E0C:  MOVF   FF4,W
00E0E:  ADDWFC 02,F
00E10:  MOVLW  00
00E12:  ADDWFC 01,F
00E14:  MOVF   x51,W
00E16:  MULWF  x55
00E18:  MOVF   FF3,W
00E1A:  ADDWF  02,F
00E1C:  MOVF   FF4,W
00E1E:  ADDWFC 01,F
00E20:  INCF   00,F
00E22:  BTFSC  01.7
00E24:  BRA    0E30
00E26:  RLCF   x59,F
00E28:  RLCF   03,F
00E2A:  RLCF   02,F
00E2C:  RLCF   01,F
00E2E:  DECF   00,F
00E30:  MOVLW  00
00E32:  BTFSS  x59.7
00E34:  BRA    0E4A
00E36:  INCF   03,F
00E38:  ADDWFC 02,F
00E3A:  ADDWFC 01,F
00E3C:  MOVF   01,W
00E3E:  BNZ   0E4A
00E40:  MOVF   02,W
00E42:  BNZ   0E4A
00E44:  MOVF   03,W
00E46:  BNZ   0E4A
00E48:  INCF   00,F
00E4A:  BTFSC  x58.7
00E4C:  BSF    01.7
00E4E:  BTFSS  x58.7
00E50:  BCF    01.7
00E52:  BRA    0E5C
00E54:  CLRF   00
00E56:  CLRF   01
00E58:  CLRF   02
00E5A:  CLRF   03
00E5C:  MOVLB  0
00E5E:  RETURN 0
00E60:  MOVLW  80
00E62:  BTFSS  FD8.1
00E64:  BRA    0E6A
00E66:  MOVLB  7
00E68:  XORWF  x4F,F
00E6A:  MOVLB  7
00E6C:  CLRF   x54
00E6E:  CLRF   x55
00E70:  MOVFF  74B,753
00E74:  MOVF   x4F,W
00E76:  XORWF  x53,F
00E78:  MOVF   x4A,W
00E7A:  BTFSC  FD8.2
00E7C:  BRA    103C
00E7E:  MOVWF  x52
00E80:  MOVWF  00
00E82:  MOVF   x4E,W
00E84:  BTFSC  FD8.2
00E86:  BRA    104E
00E88:  SUBWF  x52,F
00E8A:  BTFSC  FD8.2
00E8C:  BRA    0F94
00E8E:  BNC   0F0C
00E90:  MOVFF  74F,758
00E94:  BSF    x58.7
00E96:  MOVFF  750,757
00E9A:  MOVFF  751,756
00E9E:  CLRF   x55
00EA0:  BCF    FD8.0
00EA2:  RRCF   x58,F
00EA4:  RRCF   x57,F
00EA6:  RRCF   x56,F
00EA8:  RRCF   x55,F
00EAA:  DECFSZ x52,F
00EAC:  BRA    0E9E
00EAE:  BTFSS  x53.7
00EB0:  BRA    0EB8
00EB2:  BSF    x54.0
00EB4:  BRA    1076
00EB6:  BCF    x54.0
00EB8:  BCF    x52.0
00EBA:  BSF    x54.4
00EBC:  MOVLW  07
00EBE:  MOVWF  FEA
00EC0:  MOVLW  4D
00EC2:  MOVWF  FE9
00EC4:  BRA    109C
00EC6:  BCF    x54.4
00EC8:  BTFSC  x53.7
00ECA:  BRA    0EE0
00ECC:  BTFSS  x52.0
00ECE:  BRA    0EF6
00ED0:  RRCF   x58,F
00ED2:  RRCF   x57,F
00ED4:  RRCF   x56,F
00ED6:  RRCF   x55,F
00ED8:  INCF   00,F
00EDA:  BTFSC  FD8.2
00EDC:  BRA    106C
00EDE:  BRA    0EF6
00EE0:  BTFSC  x58.7
00EE2:  BRA    0EFC
00EE4:  BCF    FD8.0
00EE6:  RLCF   x55,F
00EE8:  RLCF   x56,F
00EEA:  RLCF   x57,F
00EEC:  RLCF   x58,F
00EEE:  DECF   00,F
00EF0:  BTFSC  FD8.2
00EF2:  BRA    106C
00EF4:  BRA    0EE0
00EF6:  BSF    x54.6
00EF8:  BRA    0FD4
00EFA:  BCF    x54.6
00EFC:  MOVFF  74B,753
00F00:  BTFSS  x4B.7
00F02:  BRA    0F08
00F04:  BSF    x58.7
00F06:  BRA    105E
00F08:  BCF    x58.7
00F0A:  BRA    105E
00F0C:  MOVFF  74E,752
00F10:  MOVFF  74E,00
00F14:  MOVF   x4A,W
00F16:  SUBWF  x52,F
00F18:  MOVFF  74B,758
00F1C:  BSF    x58.7
00F1E:  MOVFF  74C,757
00F22:  MOVFF  74D,756
00F26:  CLRF   x55
00F28:  BCF    FD8.0
00F2A:  RRCF   x58,F
00F2C:  RRCF   x57,F
00F2E:  RRCF   x56,F
00F30:  RRCF   x55,F
00F32:  DECFSZ x52,F
00F34:  BRA    0F26
00F36:  BTFSS  x53.7
00F38:  BRA    0F40
00F3A:  BSF    x54.1
00F3C:  BRA    1076
00F3E:  BCF    x54.1
00F40:  BCF    x52.0
00F42:  BSF    x54.5
00F44:  MOVLW  07
00F46:  MOVWF  FEA
00F48:  MOVLW  51
00F4A:  MOVWF  FE9
00F4C:  BRA    109C
00F4E:  BCF    x54.5
00F50:  BTFSC  x53.7
00F52:  BRA    0F68
00F54:  BTFSS  x52.0
00F56:  BRA    0F7E
00F58:  RRCF   x58,F
00F5A:  RRCF   x57,F
00F5C:  RRCF   x56,F
00F5E:  RRCF   x55,F
00F60:  INCF   00,F
00F62:  BTFSC  FD8.2
00F64:  BRA    106C
00F66:  BRA    0F7E
00F68:  BTFSC  x58.7
00F6A:  BRA    0F84
00F6C:  BCF    FD8.0
00F6E:  RLCF   x55,F
00F70:  RLCF   x56,F
00F72:  RLCF   x57,F
00F74:  RLCF   x58,F
00F76:  DECF   00,F
00F78:  BTFSC  FD8.2
00F7A:  BRA    106C
00F7C:  BRA    0F68
00F7E:  BSF    x54.7
00F80:  BRA    0FD4
00F82:  BCF    x54.7
00F84:  MOVFF  74F,753
00F88:  BTFSS  x4F.7
00F8A:  BRA    0F90
00F8C:  BSF    x58.7
00F8E:  BRA    105E
00F90:  BCF    x58.7
00F92:  BRA    105E
00F94:  MOVFF  74F,758
00F98:  BSF    x58.7
00F9A:  MOVFF  750,757
00F9E:  MOVFF  751,756
00FA2:  BTFSS  x53.7
00FA4:  BRA    0FAE
00FA6:  BCF    x58.7
00FA8:  BSF    x54.2
00FAA:  BRA    1076
00FAC:  BCF    x54.2
00FAE:  CLRF   x55
00FB0:  BCF    x52.0
00FB2:  MOVLW  07
00FB4:  MOVWF  FEA
00FB6:  MOVLW  4D
00FB8:  MOVWF  FE9
00FBA:  BRA    109C
00FBC:  BTFSC  x53.7
00FBE:  BRA    0FF8
00FC0:  MOVFF  74B,753
00FC4:  BTFSS  x52.0
00FC6:  BRA    0FD4
00FC8:  RRCF   x58,F
00FCA:  RRCF   x57,F
00FCC:  RRCF   x56,F
00FCE:  RRCF   x55,F
00FD0:  INCF   00,F
00FD2:  BZ    106C
00FD4:  BTFSS  x55.7
00FD6:  BRA    0FEE
00FD8:  INCF   x56,F
00FDA:  BNZ   0FEE
00FDC:  INCF   x57,F
00FDE:  BNZ   0FEE
00FE0:  INCF   x58,F
00FE2:  BNZ   0FEE
00FE4:  RRCF   x58,F
00FE6:  RRCF   x57,F
00FE8:  RRCF   x56,F
00FEA:  INCF   00,F
00FEC:  BZ    106C
00FEE:  BTFSC  x54.6
00FF0:  BRA    0EFA
00FF2:  BTFSC  x54.7
00FF4:  BRA    0F82
00FF6:  BRA    1030
00FF8:  MOVLW  80
00FFA:  XORWF  x58,F
00FFC:  BTFSS  x58.7
00FFE:  BRA    1008
01000:  BRA    1076
01002:  MOVFF  74F,753
01006:  BRA    101C
01008:  MOVFF  74B,753
0100C:  MOVF   x58,F
0100E:  BNZ   101C
01010:  MOVF   x57,F
01012:  BNZ   101C
01014:  MOVF   x56,F
01016:  BNZ   101C
01018:  CLRF   00
0101A:  BRA    105E
0101C:  BTFSC  x58.7
0101E:  BRA    1030
01020:  BCF    FD8.0
01022:  RLCF   x55,F
01024:  RLCF   x56,F
01026:  RLCF   x57,F
01028:  RLCF   x58,F
0102A:  DECFSZ 00,F
0102C:  BRA    101C
0102E:  BRA    106C
01030:  BTFSS  x53.7
01032:  BRA    1038
01034:  BSF    x58.7
01036:  BRA    105E
01038:  BCF    x58.7
0103A:  BRA    105E
0103C:  MOVFF  74E,00
01040:  MOVFF  74F,758
01044:  MOVFF  750,757
01048:  MOVFF  751,756
0104C:  BRA    105E
0104E:  MOVFF  74A,00
01052:  MOVFF  74B,758
01056:  MOVFF  74C,757
0105A:  MOVFF  74D,756
0105E:  MOVFF  758,01
01062:  MOVFF  757,02
01066:  MOVFF  756,03
0106A:  BRA    10D4
0106C:  CLRF   00
0106E:  CLRF   01
01070:  CLRF   02
01072:  CLRF   03
01074:  BRA    10D4
01076:  CLRF   x55
01078:  COMF   x56,F
0107A:  COMF   x57,F
0107C:  COMF   x58,F
0107E:  COMF   x55,F
01080:  INCF   x55,F
01082:  BNZ   108E
01084:  INCF   x56,F
01086:  BNZ   108E
01088:  INCF   x57,F
0108A:  BNZ   108E
0108C:  INCF   x58,F
0108E:  BTFSC  x54.0
01090:  BRA    0EB6
01092:  BTFSC  x54.1
01094:  BRA    0F3E
01096:  BTFSC  x54.2
01098:  BRA    0FAC
0109A:  BRA    1002
0109C:  MOVF   FEF,W
0109E:  ADDWF  x56,F
010A0:  BNC   10AC
010A2:  INCF   x57,F
010A4:  BNZ   10AC
010A6:  INCF   x58,F
010A8:  BTFSC  FD8.2
010AA:  BSF    x52.0
010AC:  MOVF   FED,F
010AE:  MOVF   FEF,W
010B0:  ADDWF  x57,F
010B2:  BNC   10BA
010B4:  INCF   x58,F
010B6:  BTFSC  FD8.2
010B8:  BSF    x52.0
010BA:  MOVF   FED,F
010BC:  MOVF   FEF,W
010BE:  BTFSC  FEF.7
010C0:  BRA    10C4
010C2:  XORLW  80
010C4:  ADDWF  x58,F
010C6:  BTFSC  FD8.0
010C8:  BSF    x52.0
010CA:  BTFSC  x54.4
010CC:  BRA    0EC6
010CE:  BTFSC  x54.5
010D0:  BRA    0F4E
010D2:  BRA    0FBC
010D4:  MOVLB  0
010D6:  RETURN 0
*
0162E:  ADDWF  FE8,W
01630:  CLRF   FF7
01632:  RLCF   FF7,F
01634:  ADDLW  49
01636:  MOVWF  FF6
01638:  MOVLW  16
0163A:  ADDWFC FF7,F
0163C:  TBLRD*-
0163E:  MOVF   FF5,W
01640:  MOVWF  FFA
01642:  TBLRD*
01644:  MOVF   FF5,W
01646:  MOVWF  FF9
01648:  DATA F0,10
0164A:  DATA B0,11
0164C:  DATA 70,12
0164E:  DATA 30,13
01650:  DATA F0,13
01652:  DATA B0,14
01654:  DATA 70,15
01656:  BTFSC  FD8.1
01658:  BRA    1662
0165A:  MOVLW  07
0165C:  MOVWF  FEA
0165E:  MOVLW  39
01660:  MOVWF  FE9
01662:  MOVLB  7
01664:  MOVF   x34,W
01666:  XORWF  x38,W
01668:  ANDLW  80
0166A:  MOVWF  x3E
0166C:  BTFSS  x34.7
0166E:  BRA    1686
01670:  COMF   x31,F
01672:  COMF   x32,F
01674:  COMF   x33,F
01676:  COMF   x34,F
01678:  INCF   x31,F
0167A:  BTFSC  FD8.2
0167C:  INCF   x32,F
0167E:  BTFSC  FD8.2
01680:  INCF   x33,F
01682:  BTFSC  FD8.2
01684:  INCF   x34,F
01686:  BTFSS  x38.7
01688:  BRA    16A0
0168A:  COMF   x35,F
0168C:  COMF   x36,F
0168E:  COMF   x37,F
01690:  COMF   x38,F
01692:  INCF   x35,F
01694:  BTFSC  FD8.2
01696:  INCF   x36,F
01698:  BTFSC  FD8.2
0169A:  INCF   x37,F
0169C:  BTFSC  FD8.2
0169E:  INCF   x38,F
016A0:  CLRF   00
016A2:  CLRF   01
016A4:  CLRF   02
016A6:  CLRF   03
016A8:  CLRF   x39
016AA:  CLRF   x3A
016AC:  CLRF   x3B
016AE:  CLRF   x3C
016B0:  MOVF   x38,W
016B2:  IORWF  x37,W
016B4:  IORWF  x36,W
016B6:  IORWF  x35,W
016B8:  BZ    1712
016BA:  MOVLW  20
016BC:  MOVWF  x3D
016BE:  BCF    FD8.0
016C0:  RLCF   x31,F
016C2:  RLCF   x32,F
016C4:  RLCF   x33,F
016C6:  RLCF   x34,F
016C8:  RLCF   x39,F
016CA:  RLCF   x3A,F
016CC:  RLCF   x3B,F
016CE:  RLCF   x3C,F
016D0:  MOVF   x38,W
016D2:  SUBWF  x3C,W
016D4:  BNZ   16E6
016D6:  MOVF   x37,W
016D8:  SUBWF  x3B,W
016DA:  BNZ   16E6
016DC:  MOVF   x36,W
016DE:  SUBWF  x3A,W
016E0:  BNZ   16E6
016E2:  MOVF   x35,W
016E4:  SUBWF  x39,W
016E6:  BNC   1706
016E8:  MOVF   x35,W
016EA:  SUBWF  x39,F
016EC:  MOVF   x36,W
016EE:  BTFSS  FD8.0
016F0:  INCFSZ x36,W
016F2:  SUBWF  x3A,F
016F4:  MOVF   x37,W
016F6:  BTFSS  FD8.0
016F8:  INCFSZ x37,W
016FA:  SUBWF  x3B,F
016FC:  MOVF   x38,W
016FE:  BTFSS  FD8.0
01700:  INCFSZ x38,W
01702:  SUBWF  x3C,F
01704:  BSF    FD8.0
01706:  RLCF   00,F
01708:  RLCF   01,F
0170A:  RLCF   02,F
0170C:  RLCF   03,F
0170E:  DECFSZ x3D,F
01710:  BRA    16BE
01712:  BTFSS  x3E.7
01714:  BRA    172C
01716:  COMF   00,F
01718:  COMF   01,F
0171A:  COMF   02,F
0171C:  COMF   03,F
0171E:  INCF   00,F
01720:  BTFSC  FD8.2
01722:  INCF   01,F
01724:  BTFSC  FD8.2
01726:  INCF   02,F
01728:  BTFSC  FD8.2
0172A:  INCF   03,F
0172C:  MOVFF  739,FEF
01730:  MOVFF  73A,FEC
01734:  MOVFF  73B,FEC
01738:  MOVFF  73C,FEC
0173C:  MOVLB  0
0173E:  RETURN 0
*
01C9C:  MOVLW  B6
01C9E:  MOVWF  00
01CA0:  CLRF   03
01CA2:  CLRF   02
01CA4:  CLRF   01
01CA6:  MOVLB  7
01CA8:  BCF    x14.0
01CAA:  BTFSS  x13.7
01CAC:  BRA    1CC6
01CAE:  BSF    x14.0
01CB0:  COMF   x10,F
01CB2:  COMF   x11,F
01CB4:  COMF   x12,F
01CB6:  COMF   x13,F
01CB8:  INCF   x10,F
01CBA:  BNZ   1CC6
01CBC:  INCF   x11,F
01CBE:  BNZ   1CC6
01CC0:  INCF   x12,F
01CC2:  BTFSC  FD8.2
01CC4:  INCF   x13,F
01CC6:  MOVF   x10,W
01CC8:  IORWF  x11,W
01CCA:  IORWF  x12,W
01CCC:  IORWF  x13,W
01CCE:  BNZ   1CD4
01CD0:  CLRF   00
01CD2:  BRA    1CF2
01CD4:  BCF    FD8.0
01CD6:  BTFSC  01.7
01CD8:  BRA    1CEC
01CDA:  RLCF   x10,F
01CDC:  RLCF   x11,F
01CDE:  RLCF   x12,F
01CE0:  RLCF   x13,F
01CE2:  RLCF   03,F
01CE4:  RLCF   02,F
01CE6:  RLCF   01,F
01CE8:  DECFSZ 00,F
01CEA:  BRA    1CD4
01CEC:  BCF    01.7
01CEE:  BTFSC  x14.0
01CF0:  BSF    01.7
01CF2:  MOVLB  0
01CF4:  RETURN 0
01CF6:  MOVFF  747,74E
01CFA:  MOVLB  7
01CFC:  MOVF   x4B,W
01CFE:  XORWF  x4E,F
01D00:  BTFSS  x4E.7
01D02:  BRA    1D0E
01D04:  BCF    FD8.2
01D06:  BCF    FD8.0
01D08:  BTFSC  x47.7
01D0A:  BSF    FD8.0
01D0C:  BRA    1D6C
01D0E:  MOVFF  747,74E
01D12:  MOVFF  74A,74F
01D16:  MOVF   x46,W
01D18:  SUBWF  x4F,F
01D1A:  BZ    1D28
01D1C:  BTFSS  x4E.7
01D1E:  BRA    1D6C
01D20:  MOVF   FD8,W
01D22:  XORLW  01
01D24:  MOVWF  FD8
01D26:  BRA    1D6C
01D28:  MOVFF  74B,74F
01D2C:  MOVF   x47,W
01D2E:  SUBWF  x4F,F
01D30:  BZ    1D3E
01D32:  BTFSS  x4E.7
01D34:  BRA    1D6C
01D36:  MOVF   FD8,W
01D38:  XORLW  01
01D3A:  MOVWF  FD8
01D3C:  BRA    1D6C
01D3E:  MOVFF  74C,74F
01D42:  MOVF   x48,W
01D44:  SUBWF  x4F,F
01D46:  BZ    1D54
01D48:  BTFSS  x4E.7
01D4A:  BRA    1D6C
01D4C:  MOVF   FD8,W
01D4E:  XORLW  01
01D50:  MOVWF  FD8
01D52:  BRA    1D6C
01D54:  MOVFF  74D,74F
01D58:  MOVF   x49,W
01D5A:  SUBWF  x4F,F
01D5C:  BZ    1D6A
01D5E:  BTFSS  x4E.7
01D60:  BRA    1D6C
01D62:  MOVF   FD8,W
01D64:  XORLW  01
01D66:  MOVWF  FD8
01D68:  BRA    1D6C
01D6A:  BCF    FD8.0
01D6C:  MOVLB  0
01D6E:  RETURN 0
01D70:  MOVLB  7
01D72:  MOVF   x3F,W
01D74:  BTFSC  FD8.2
01D76:  BRA    1EC2
01D78:  MOVWF  x4B
01D7A:  MOVF   x43,W
01D7C:  BTFSC  FD8.2
01D7E:  BRA    1EC2
01D80:  SUBWF  x4B,F
01D82:  BNC   1D8E
01D84:  MOVLW  7F
01D86:  ADDWF  x4B,F
01D88:  BTFSC  FD8.0
01D8A:  BRA    1EC2
01D8C:  BRA    1D9A
01D8E:  MOVLW  81
01D90:  SUBWF  x4B,F
01D92:  BTFSS  FD8.0
01D94:  BRA    1EC2
01D96:  BTFSC  FD8.2
01D98:  BRA    1EC2
01D9A:  MOVFF  74B,00
01D9E:  CLRF   01
01DA0:  CLRF   02
01DA2:  CLRF   03
01DA4:  CLRF   x4A
01DA6:  MOVFF  740,749
01DAA:  BSF    x49.7
01DAC:  MOVFF  741,748
01DB0:  MOVFF  742,747
01DB4:  MOVLW  19
01DB6:  MOVWF  x4B
01DB8:  MOVF   x46,W
01DBA:  SUBWF  x47,F
01DBC:  BC    1DD8
01DBE:  MOVLW  01
01DC0:  SUBWF  x48,F
01DC2:  BC    1DD8
01DC4:  SUBWF  x49,F
01DC6:  BC    1DD8
01DC8:  SUBWF  x4A,F
01DCA:  BC    1DD8
01DCC:  INCF   x4A,F
01DCE:  INCF   x49,F
01DD0:  INCF   x48,F
01DD2:  MOVF   x46,W
01DD4:  ADDWF  x47,F
01DD6:  BRA    1E28
01DD8:  MOVF   x45,W
01DDA:  SUBWF  x48,F
01DDC:  BC    1E02
01DDE:  MOVLW  01
01DE0:  SUBWF  x49,F
01DE2:  BC    1E02
01DE4:  SUBWF  x4A,F
01DE6:  BC    1E02
01DE8:  INCF   x4A,F
01DEA:  INCF   x49,F
01DEC:  MOVF   x45,W
01DEE:  ADDWF  x48,F
01DF0:  MOVF   x46,W
01DF2:  ADDWF  x47,F
01DF4:  BNC   1E28
01DF6:  INCF   x48,F
01DF8:  BNZ   1E28
01DFA:  INCF   x49,F
01DFC:  BNZ   1E28
01DFE:  INCF   x4A,F
01E00:  BRA    1E28
01E02:  MOVF   x44,W
01E04:  IORLW  80
01E06:  SUBWF  x49,F
01E08:  BC    1E26
01E0A:  MOVLW  01
01E0C:  SUBWF  x4A,F
01E0E:  BC    1E26
01E10:  INCF   x4A,F
01E12:  MOVF   x44,W
01E14:  IORLW  80
01E16:  ADDWF  x49,F
01E18:  MOVF   x45,W
01E1A:  ADDWF  x48,F
01E1C:  BNC   1DF0
01E1E:  INCF   x49,F
01E20:  BNZ   1DF0
01E22:  INCF   x4A,F
01E24:  BRA    1DF0
01E26:  BSF    03.0
01E28:  DECFSZ x4B,F
01E2A:  BRA    1E2E
01E2C:  BRA    1E44
01E2E:  BCF    FD8.0
01E30:  RLCF   x47,F
01E32:  RLCF   x48,F
01E34:  RLCF   x49,F
01E36:  RLCF   x4A,F
01E38:  BCF    FD8.0
01E3A:  RLCF   03,F
01E3C:  RLCF   02,F
01E3E:  RLCF   01,F
01E40:  RLCF   x4C,F
01E42:  BRA    1DB8
01E44:  BTFSS  x4C.0
01E46:  BRA    1E54
01E48:  BCF    FD8.0
01E4A:  RRCF   01,F
01E4C:  RRCF   02,F
01E4E:  RRCF   03,F
01E50:  RRCF   x4C,F
01E52:  BRA    1E58
01E54:  DECF   00,F
01E56:  BZ    1EC2
01E58:  BTFSC  x4C.7
01E5A:  BRA    1E98
01E5C:  BCF    FD8.0
01E5E:  RLCF   x47,F
01E60:  RLCF   x48,F
01E62:  RLCF   x49,F
01E64:  RLCF   x4A,F
01E66:  MOVF   x46,W
01E68:  SUBWF  x47,F
01E6A:  BC    1E7A
01E6C:  MOVLW  01
01E6E:  SUBWF  x48,F
01E70:  BC    1E7A
01E72:  SUBWF  x49,F
01E74:  BC    1E7A
01E76:  SUBWF  x4A,F
01E78:  BNC   1EAE
01E7A:  MOVF   x45,W
01E7C:  SUBWF  x48,F
01E7E:  BC    1E8A
01E80:  MOVLW  01
01E82:  SUBWF  x49,F
01E84:  BC    1E8A
01E86:  SUBWF  x4A,F
01E88:  BNC   1EAE
01E8A:  MOVF   x44,W
01E8C:  IORLW  80
01E8E:  SUBWF  x49,F
01E90:  BC    1E98
01E92:  MOVLW  01
01E94:  SUBWF  x4A,F
01E96:  BNC   1EAE
01E98:  INCF   03,F
01E9A:  BNZ   1EAE
01E9C:  INCF   02,F
01E9E:  BNZ   1EAE
01EA0:  INCF   01,F
01EA2:  BNZ   1EAE
01EA4:  INCF   00,F
01EA6:  BZ    1EC2
01EA8:  RRCF   01,F
01EAA:  RRCF   02,F
01EAC:  RRCF   03,F
01EAE:  MOVFF  740,74B
01EB2:  MOVF   x44,W
01EB4:  XORWF  x4B,F
01EB6:  BTFSS  x4B.7
01EB8:  BRA    1EBE
01EBA:  BSF    01.7
01EBC:  BRA    1ECA
01EBE:  BCF    01.7
01EC0:  BRA    1ECA
01EC2:  CLRF   00
01EC4:  CLRF   01
01EC6:  CLRF   02
01EC8:  CLRF   03
01ECA:  MOVLB  0
01ECC:  RETURN 0
*
02678:  ADDWF  FE8,W
0267A:  CLRF   FF7
0267C:  RLCF   FF7,F
0267E:  ADDLW  93
02680:  MOVWF  FF6
02682:  MOVLW  26
02684:  ADDWFC FF7,F
02686:  TBLRD*-
02688:  MOVF   FF5,W
0268A:  MOVWF  FFA
0268C:  TBLRD*
0268E:  MOVF   FF5,W
02690:  MOVWF  FF9
02692:  DATA 80,25
02694:  DATA 9A,25
02696:  DATA EE,25
02698:  DATA 52,26
0269A:  MOVLW  8E
0269C:  MOVWF  00
0269E:  MOVFF  73D,01
026A2:  MOVFF  73C,02
026A6:  CLRF   03
026A8:  BTFSS  01.7
026AA:  BRA    26B6
026AC:  COMF   01,F
026AE:  COMF   02,F
026B0:  INCF   02,F
026B2:  BNZ   26B6
026B4:  INCF   01,F
026B6:  MOVF   01,F
026B8:  BNZ   26CC
026BA:  MOVFF  02,01
026BE:  CLRF   02
026C0:  MOVLW  08
026C2:  SUBWF  00,F
026C4:  MOVF   01,F
026C6:  BNZ   26CC
026C8:  CLRF   00
026CA:  BRA    26E8
026CC:  BCF    FD8.0
026CE:  BTFSC  01.7
026D0:  BRA    26DA
026D2:  RLCF   02,F
026D4:  RLCF   01,F
026D6:  DECF   00,F
026D8:  BRA    26CC
026DA:  MOVLB  7
026DC:  BTFSS  x3D.7
026DE:  BRA    26E4
026E0:  MOVLB  0
026E2:  BRA    26E8
026E4:  BCF    01.7
026E6:  MOVLB  0
026E8:  RETURN 0
026EA:  MOVLW  8E
026EC:  MOVWF  00
026EE:  MOVLB  7
026F0:  MOVF   x46,W
026F2:  SUBWF  00,F
026F4:  MOVFF  747,02
026F8:  MOVFF  748,01
026FC:  BSF    02.7
026FE:  MOVF   00,F
02700:  BZ    2714
02702:  BCF    FD8.0
02704:  MOVF   02,F
02706:  BNZ   270C
02708:  MOVF   01,F
0270A:  BZ    2714
0270C:  RRCF   02,F
0270E:  RRCF   01,F
02710:  DECFSZ 00,F
02712:  BRA    2702
02714:  BTFSS  x47.7
02716:  BRA    2722
02718:  COMF   01,F
0271A:  COMF   02,F
0271C:  INCF   01,F
0271E:  BTFSC  FD8.2
02720:  INCF   02,F
02722:  MOVLB  0
02724:  RETURN 0
*
045DE:  MOVLB  7
045E0:  MOVF   x0D,W
045E2:  ANDLW  07
045E4:  MOVWF  00
045E6:  RRCF   x0D,W
045E8:  MOVWF  01
045EA:  RRCF   01,F
045EC:  RRCF   01,F
045EE:  MOVLW  1F
045F0:  ANDWF  01,F
045F2:  MOVF   01,W
045F4:  ADDWF  x0E,W
045F6:  MOVWF  FE9
045F8:  MOVLW  00
045FA:  ADDWFC x0F,W
045FC:  MOVWF  FEA
045FE:  MOVFF  FEF,01
04602:  INCF   00,F
04604:  BRA    4608
04606:  RRCF   01,F
04608:  DECFSZ 00,F
0460A:  BRA    4606
0460C:  MOVLW  01
0460E:  ANDWF  01,F
04610:  MOVLB  0
04612:  RETURN 0
*
05020:  MOVF   FEF,F
05022:  BZ    5048
05024:  MOVFF  FEA,704
05028:  MOVFF  FE9,703
0502C:  MOVF   FEF,W
0502E:  MOVLB  E
05030:  BTFSS  xC8.4
05032:  BRA    5030
05034:  MOVWF  F99
05036:  MOVFF  704,FEA
0503A:  MOVFF  703,FE9
0503E:  INCF   FE9,F
05040:  BTFSC  FD8.2
05042:  INCF   FEA,F
05044:  MOVLB  0
05046:  BRA    5020
05048:  GOTO   5068 (RETURN)
*
0563A:  MOVFF  565,FEA
0563E:  MOVFF  564,FE9
05642:  MOVFF  750,FEF
05646:  INCF   FE9,F
05648:  BTFSC  FD8.2
0564A:  INCF   FEA,F
0564C:  CLRF   FEF
0564E:  MOVLB  5
05650:  INCF   x64,F
05652:  BTFSC  FD8.2
05654:  INCF   x65,F
05656:  MOVLB  0
05658:  RETURN 0
0565A:  MOVF   FEF,F
0565C:  BZ    567C
0565E:  MOVFF  FEA,708
05662:  MOVFF  FE9,707
05666:  MOVFF  FEF,750
0566A:  RCALL  563A
0566C:  MOVFF  708,FEA
05670:  MOVFF  707,FE9
05674:  INCF   FE9,F
05676:  BTFSC  FD8.2
05678:  INCF   FEA,F
0567A:  BRA    565A
0567C:  RETURN 0
*
05730:  TBLRD*+
05732:  MOVF   FF5,F
05734:  BZ    574E
05736:  MOVFF  FF6,70E
0573A:  MOVFF  FF7,70F
0573E:  MOVFF  FF5,750
05742:  RCALL  563A
05744:  MOVFF  70E,FF6
05748:  MOVFF  70F,FF7
0574C:  BRA    5730
0574E:  RETURN 0
*
05872:  MOVLB  7
05874:  MOVF   x68,W
05876:  XORWF  x6A,W
05878:  ANDLW  80
0587A:  MOVWF  x6C
0587C:  BTFSS  x68.7
0587E:  BRA    588A
05880:  COMF   x67,F
05882:  COMF   x68,F
05884:  INCF   x67,F
05886:  BTFSC  FD8.2
05888:  INCF   x68,F
0588A:  BTFSS  x6A.7
0588C:  BRA    5898
0588E:  COMF   x69,F
05890:  COMF   x6A,F
05892:  INCF   x69,F
05894:  BTFSC  FD8.2
05896:  INCF   x6A,F
05898:  MOVF   x67,W
0589A:  MULWF  x69
0589C:  MOVFF  FF3,01
058A0:  MOVFF  FF4,00
058A4:  MULWF  x6A
058A6:  MOVF   FF3,W
058A8:  ADDWF  00,F
058AA:  MOVF   x68,W
058AC:  MULWF  x69
058AE:  MOVF   FF3,W
058B0:  ADDWFC 00,W
058B2:  MOVWF  02
058B4:  BTFSS  x6C.7
058B6:  BRA    58C2
058B8:  COMF   01,F
058BA:  COMF   02,F
058BC:  INCF   01,F
058BE:  BTFSC  FD8.2
058C0:  INCF   02,F
058C2:  MOVLB  0
058C4:  GOTO   5B58 (RETURN)
*
05C1C:  MOVLW  20
05C1E:  MOVLB  7
05C20:  BTFSS  x35.4
05C22:  MOVLW  30
05C24:  MOVWF  x36
05C26:  MOVFF  734,00
05C2A:  BTFSS  00.7
05C2C:  BRA    5C3E
05C2E:  COMF   00,F
05C30:  INCF   00,F
05C32:  MOVFF  00,734
05C36:  MOVLW  2D
05C38:  MOVWF  x36
05C3A:  BSF    x35.7
05C3C:  BSF    x35.0
05C3E:  MOVF   01,W
05C40:  MOVFF  734,73A
05C44:  MOVLW  64
05C46:  MOVWF  x3B
05C48:  MOVLB  0
05C4A:  CALL   08A2
05C4E:  MOVFF  00,734
05C52:  MOVLW  30
05C54:  ADDWF  01,W
05C56:  MOVLB  7
05C58:  MOVWF  x37
05C5A:  MOVFF  734,73A
05C5E:  MOVLW  0A
05C60:  MOVWF  x3B
05C62:  MOVLB  0
05C64:  CALL   08A2
05C68:  MOVLW  30
05C6A:  ADDWF  00,W
05C6C:  MOVLB  7
05C6E:  MOVWF  x39
05C70:  MOVLW  30
05C72:  ADDWF  01,W
05C74:  MOVWF  x38
05C76:  MOVFF  736,00
05C7A:  MOVLW  30
05C7C:  SUBWF  x37,W
05C7E:  BZ    5C88
05C80:  BSF    x35.1
05C82:  BTFSC  x35.7
05C84:  BSF    x35.2
05C86:  BRA    5CAC
05C88:  MOVFF  736,737
05C8C:  MOVLW  20
05C8E:  MOVWF  x36
05C90:  MOVLW  30
05C92:  SUBWF  x38,W
05C94:  BZ    5C9E
05C96:  BSF    x35.0
05C98:  BTFSC  x35.7
05C9A:  BSF    x35.1
05C9C:  BRA    5CAC
05C9E:  BTFSS  FD8.2
05CA0:  BSF    x35.0
05CA2:  BNZ   5CAC
05CA4:  MOVFF  737,738
05CA8:  MOVLW  20
05CAA:  MOVWF  x37
05CAC:  BTFSC  x35.2
05CAE:  BRA    5CBA
05CB0:  BTFSC  x35.1
05CB2:  BRA    5CC2
05CB4:  BTFSC  x35.0
05CB6:  BRA    5CCA
05CB8:  BRA    5CD2
05CBA:  MOVFF  736,750
05CBE:  MOVLB  0
05CC0:  RCALL  563A
05CC2:  MOVFF  737,750
05CC6:  MOVLB  0
05CC8:  RCALL  563A
05CCA:  MOVFF  738,750
05CCE:  MOVLB  0
05CD0:  RCALL  563A
05CD2:  MOVFF  739,750
05CD6:  MOVLB  0
05CD8:  RCALL  563A
05CDA:  RETURN 0
*
05E80:  MOVLB  7
05E82:  MOVF   x22,W
05E84:  ANDLW  07
05E86:  MOVWF  00
05E88:  RRCF   x22,W
05E8A:  MOVWF  01
05E8C:  RRCF   01,F
05E8E:  RRCF   01,F
05E90:  MOVLW  1F
05E92:  ANDWF  01,F
05E94:  MOVF   01,W
05E96:  ADDWF  x24,W
05E98:  MOVWF  FE9
05E9A:  MOVLW  00
05E9C:  ADDWFC x25,W
05E9E:  MOVWF  FEA
05EA0:  CLRF   01
05EA2:  INCF   01,F
05EA4:  INCF   00,F
05EA6:  BRA    5EAA
05EA8:  RLCF   01,F
05EAA:  DECFSZ 00,F
05EAC:  BRA    5EA8
05EAE:  MOVF   x23,F
05EB0:  BZ    5EB8
05EB2:  MOVF   01,W
05EB4:  IORWF  FEF,F
05EB6:  BRA    5EBE
05EB8:  COMF   01,F
05EBA:  MOVF   01,W
05EBC:  ANDWF  FEF,F
05EBE:  MOVLB  0
05EC0:  RETURN 0
*
06070:  TBLRD*+
06072:  MOVFF  FF6,710
06076:  MOVFF  FF7,711
0607A:  MOVFF  FF5,750
0607E:  CALL   563A
06082:  MOVFF  710,FF6
06086:  MOVFF  711,FF7
0608A:  MOVLB  7
0608C:  DECFSZ x0F,F
0608E:  BRA    6092
06090:  BRA    6096
06092:  MOVLB  0
06094:  BRA    6070
06096:  MOVLB  0
06098:  RETURN 0
*
06440:  MOVLB  7
06442:  MOVF   x50,W
06444:  SUBLW  B6
06446:  MOVWF  x50
06448:  CLRF   03
0644A:  MOVFF  751,754
0644E:  BSF    x51.7
06450:  BCF    FD8.0
06452:  RRCF   x51,F
06454:  RRCF   x52,F
06456:  RRCF   x53,F
06458:  RRCF   03,F
0645A:  RRCF   02,F
0645C:  RRCF   01,F
0645E:  RRCF   00,F
06460:  DECFSZ x50,F
06462:  BRA    6450
06464:  BTFSS  x54.7
06466:  BRA    647E
06468:  COMF   00,F
0646A:  COMF   01,F
0646C:  COMF   02,F
0646E:  COMF   03,F
06470:  INCF   00,F
06472:  BTFSC  FD8.2
06474:  INCF   01,F
06476:  BTFSC  FD8.2
06478:  INCF   02,F
0647A:  BTFSC  FD8.2
0647C:  INCF   03,F
0647E:  MOVLB  0
06480:  RETURN 0
06482:  BTFSC  FD8.1
06484:  BRA    648E
06486:  MOVLW  07
06488:  MOVWF  FEA
0648A:  MOVLW  58
0648C:  MOVWF  FE9
0648E:  CLRF   00
06490:  CLRF   01
06492:  CLRF   02
06494:  CLRF   03
06496:  MOVLB  7
06498:  CLRF   x58
0649A:  CLRF   x59
0649C:  CLRF   x5A
0649E:  CLRF   x5B
064A0:  MOVF   x57,W
064A2:  IORWF  x56,W
064A4:  IORWF  x55,W
064A6:  IORWF  x54,W
064A8:  BZ    6502
064AA:  MOVLW  20
064AC:  MOVWF  x5C
064AE:  BCF    FD8.0
064B0:  RLCF   x50,F
064B2:  RLCF   x51,F
064B4:  RLCF   x52,F
064B6:  RLCF   x53,F
064B8:  RLCF   x58,F
064BA:  RLCF   x59,F
064BC:  RLCF   x5A,F
064BE:  RLCF   x5B,F
064C0:  MOVF   x57,W
064C2:  SUBWF  x5B,W
064C4:  BNZ   64D6
064C6:  MOVF   x56,W
064C8:  SUBWF  x5A,W
064CA:  BNZ   64D6
064CC:  MOVF   x55,W
064CE:  SUBWF  x59,W
064D0:  BNZ   64D6
064D2:  MOVF   x54,W
064D4:  SUBWF  x58,W
064D6:  BNC   64F6
064D8:  MOVF   x54,W
064DA:  SUBWF  x58,F
064DC:  MOVF   x55,W
064DE:  BTFSS  FD8.0
064E0:  INCFSZ x55,W
064E2:  SUBWF  x59,F
064E4:  MOVF   x56,W
064E6:  BTFSS  FD8.0
064E8:  INCFSZ x56,W
064EA:  SUBWF  x5A,F
064EC:  MOVF   x57,W
064EE:  BTFSS  FD8.0
064F0:  INCFSZ x57,W
064F2:  SUBWF  x5B,F
064F4:  BSF    FD8.0
064F6:  RLCF   00,F
064F8:  RLCF   01,F
064FA:  RLCF   02,F
064FC:  RLCF   03,F
064FE:  DECFSZ x5C,F
06500:  BRA    64AE
06502:  MOVFF  758,FEF
06506:  MOVFF  759,FEC
0650A:  MOVFF  75A,FEC
0650E:  MOVFF  75B,FEC
06512:  MOVLB  0
06514:  RETURN 0
06516:  MOVF   FE9,W
06518:  MOVLB  7
0651A:  MOVWF  x48
0651C:  MOVF   x47,W
0651E:  MOVWF  x4A
06520:  BZ    655A
06522:  MOVFF  746,753
06526:  MOVFF  745,752
0652A:  MOVFF  744,751
0652E:  MOVFF  743,750
06532:  CLRF   x57
06534:  CLRF   x56
06536:  MOVLW  20
06538:  MOVWF  x55
0653A:  MOVLW  82
0653C:  MOVWF  x54
0653E:  MOVLB  0
06540:  CALL   0D6A
06544:  MOVFF  03,746
06548:  MOVFF  02,745
0654C:  MOVFF  01,744
06550:  MOVFF  00,743
06554:  MOVLB  7
06556:  DECFSZ x4A,F
06558:  BRA    6522
0655A:  MOVFF  746,753
0655E:  MOVFF  745,752
06562:  MOVFF  744,751
06566:  MOVFF  743,750
0656A:  MOVLB  0
0656C:  RCALL  6440
0656E:  MOVFF  03,746
06572:  MOVFF  02,745
06576:  MOVFF  01,744
0657A:  MOVFF  00,743
0657E:  MOVLB  7
06580:  BTFSS  x46.7
06582:  BRA    659E
06584:  DECF   x48,F
06586:  BSF    x48.5
06588:  COMF   x43,F
0658A:  COMF   x44,F
0658C:  COMF   x45,F
0658E:  COMF   x46,F
06590:  INCF   x43,F
06592:  BTFSC  FD8.2
06594:  INCF   x44,F
06596:  BTFSC  FD8.2
06598:  INCF   x45,F
0659A:  BTFSC  FD8.2
0659C:  INCF   x46,F
0659E:  MOVLW  3B
065A0:  MOVWF  x4F
065A2:  MOVLW  9A
065A4:  MOVWF  x4E
065A6:  MOVLW  CA
065A8:  MOVWF  x4D
065AA:  CLRF   x4C
065AC:  MOVLW  0A
065AE:  MOVWF  x4A
065B0:  MOVF   x47,W
065B2:  BTFSC  FD8.2
065B4:  INCF   x48,F
065B6:  BSF    FD8.1
065B8:  MOVLW  07
065BA:  MOVWF  FEA
065BC:  MOVLW  43
065BE:  MOVWF  FE9
065C0:  MOVFF  746,753
065C4:  MOVFF  745,752
065C8:  MOVFF  744,751
065CC:  MOVFF  743,750
065D0:  MOVFF  74F,757
065D4:  MOVFF  74E,756
065D8:  MOVFF  74D,755
065DC:  MOVFF  74C,754
065E0:  MOVLB  0
065E2:  RCALL  6482
065E4:  MOVF   01,W
065E6:  MOVF   00,F
065E8:  BNZ   6610
065EA:  MOVLB  7
065EC:  INCF   x47,W
065EE:  SUBWF  x4A,W
065F0:  BTFSS  FD8.2
065F2:  BRA    65F8
065F4:  MOVLB  0
065F6:  BRA    6610
065F8:  MOVF   x48,W
065FA:  BZ    6616
065FC:  ANDLW  0F
065FE:  SUBWF  x4A,W
06600:  BZ    6604
06602:  BC    668C
06604:  BTFSC  x48.7
06606:  BRA    668C
06608:  BTFSC  x48.6
0660A:  BRA    6616
0660C:  MOVLW  20
0660E:  BRA    667E
06610:  MOVLW  20
06612:  MOVLB  7
06614:  ANDWF  x48,F
06616:  BTFSS  x48.5
06618:  BRA    6638
0661A:  BCF    x48.5
0661C:  MOVF   x47,W
0661E:  BTFSS  FD8.2
06620:  DECF   x48,F
06622:  MOVF   00,W
06624:  MOVWF  x48
06626:  MOVLW  2D
06628:  MOVWF  x50
0662A:  MOVLB  0
0662C:  CALL   563A
06630:  MOVLB  7
06632:  MOVF   x48,W
06634:  MOVWF  00
06636:  CLRF   x48
06638:  MOVF   x47,W
0663A:  SUBWF  x4A,W
0663C:  BNZ   6658
0663E:  MOVF   00,W
06640:  MOVWF  x48
06642:  MOVLW  2E
06644:  MOVWF  x50
06646:  MOVLB  0
06648:  CALL   563A
0664C:  MOVLB  7
0664E:  MOVF   x48,W
06650:  MOVWF  00
06652:  MOVLW  20
06654:  ANDWF  x48,F
06656:  MOVLW  00
06658:  MOVLW  30
0665A:  BTFSS  x48.5
0665C:  BRA    667E
0665E:  BCF    x48.5
06660:  MOVF   x47,W
06662:  BTFSS  FD8.2
06664:  DECF   x48,F
06666:  MOVF   00,W
06668:  MOVWF  x48
0666A:  MOVLW  2D
0666C:  MOVWF  x50
0666E:  MOVLB  0
06670:  CALL   563A
06674:  MOVLB  7
06676:  MOVF   x48,W
06678:  MOVWF  00
0667A:  CLRF   x48
0667C:  MOVLW  30
0667E:  ADDWF  00,F
06680:  MOVFF  00,750
06684:  MOVLB  0
06686:  CALL   563A
0668A:  MOVLB  7
0668C:  BCF    FD8.1
0668E:  MOVFF  74F,753
06692:  MOVFF  74E,752
06696:  MOVFF  74D,751
0669A:  MOVFF  74C,750
0669E:  CLRF   x57
066A0:  CLRF   x56
066A2:  CLRF   x55
066A4:  MOVLW  0A
066A6:  MOVWF  x54
066A8:  MOVLB  0
066AA:  RCALL  6482
066AC:  MOVFF  03,74F
066B0:  MOVFF  02,74E
066B4:  MOVFF  01,74D
066B8:  MOVFF  00,74C
066BC:  MOVLB  7
066BE:  DECFSZ x4A,F
066C0:  BRA    65B6
066C2:  MOVLB  0
066C4:  RETURN 0
*
0912E:  MOVF   FE9,W
09130:  MOVLB  7
09132:  MOVWF  x3D
09134:  BTFSS  x3C.7
09136:  BRA    9152
09138:  DECF   x3D,F
0913A:  BSF    x3D.5
0913C:  COMF   x39,F
0913E:  COMF   x3A,F
09140:  COMF   x3B,F
09142:  COMF   x3C,F
09144:  INCF   x39,F
09146:  BTFSC  FD8.2
09148:  INCF   x3A,F
0914A:  BTFSC  FD8.2
0914C:  INCF   x3B,F
0914E:  BTFSC  FD8.2
09150:  INCF   x3C,F
09152:  MOVLW  3B
09154:  MOVWF  x44
09156:  MOVLW  9A
09158:  MOVWF  x43
0915A:  MOVLW  CA
0915C:  MOVWF  x42
0915E:  CLRF   x41
09160:  MOVLW  0A
09162:  MOVWF  x3F
09164:  BSF    FD8.1
09166:  MOVLW  07
09168:  MOVWF  FEA
0916A:  MOVLW  39
0916C:  MOVWF  FE9
0916E:  MOVFF  73C,753
09172:  MOVFF  73B,752
09176:  MOVFF  73A,751
0917A:  MOVFF  739,750
0917E:  MOVFF  744,757
09182:  MOVFF  743,756
09186:  MOVFF  742,755
0918A:  MOVFF  741,754
0918E:  MOVLB  0
09190:  CALL   6482
09194:  MOVF   01,W
09196:  MOVF   00,F
09198:  BNZ   91C0
0919A:  MOVLB  7
0919C:  MOVF   x3F,W
0919E:  XORLW  01
091A0:  BTFSS  FD8.2
091A2:  BRA    91A8
091A4:  MOVLB  0
091A6:  BRA    91C0
091A8:  MOVF   x3D,W
091AA:  BZ    91C6
091AC:  ANDLW  0F
091AE:  SUBWF  x3F,W
091B0:  BZ    91B4
091B2:  BC    9210
091B4:  BTFSC  x3D.7
091B6:  BRA    9210
091B8:  BTFSC  x3D.6
091BA:  BRA    91C6
091BC:  MOVLW  20
091BE:  BRA    9202
091C0:  MOVLW  20
091C2:  MOVLB  7
091C4:  ANDWF  x3D,F
091C6:  BTFSS  x3D.5
091C8:  BRA    91E2
091CA:  BCF    x3D.5
091CC:  MOVFF  00,73D
091D0:  MOVLW  2D
091D2:  MOVWF  x50
091D4:  MOVLB  0
091D6:  CALL   563A
091DA:  MOVLB  7
091DC:  MOVFF  73D,00
091E0:  CLRF   x3D
091E2:  MOVLW  30
091E4:  BTFSS  x3D.5
091E6:  BRA    9202
091E8:  BCF    x3D.5
091EA:  MOVFF  00,73D
091EE:  MOVLW  2D
091F0:  MOVWF  x50
091F2:  MOVLB  0
091F4:  CALL   563A
091F8:  MOVLB  7
091FA:  MOVFF  73D,00
091FE:  CLRF   x3D
09200:  MOVLW  30
09202:  ADDWF  00,F
09204:  MOVFF  00,750
09208:  MOVLB  0
0920A:  CALL   563A
0920E:  MOVLB  7
09210:  BCF    FD8.1
09212:  MOVFF  744,753
09216:  MOVFF  743,752
0921A:  MOVFF  742,751
0921E:  MOVFF  741,750
09222:  CLRF   x57
09224:  CLRF   x56
09226:  CLRF   x55
09228:  MOVLW  0A
0922A:  MOVWF  x54
0922C:  MOVLB  0
0922E:  CALL   6482
09232:  MOVFF  03,744
09236:  MOVFF  02,743
0923A:  MOVFF  01,742
0923E:  MOVFF  00,741
09242:  MOVLB  7
09244:  DECFSZ x3F,F
09246:  BRA    9164
09248:  MOVLB  0
0924A:  RETURN 0
*
0A0FE:  MOVF   01,W
0A100:  MOVFF  706,73A
0A104:  MOVLW  64
0A106:  MOVLB  7
0A108:  MOVWF  x3B
0A10A:  MOVLB  0
0A10C:  CALL   08A2
0A110:  MOVFF  00,706
0A114:  MOVF   01,W
0A116:  MOVLW  30
0A118:  BNZ   A12A
0A11A:  MOVLB  7
0A11C:  BTFSS  x07.1
0A11E:  BRA    A140
0A120:  BTFSC  x07.3
0A122:  BRA    A140
0A124:  BTFSC  x07.4
0A126:  MOVLW  20
0A128:  BRA    A132
0A12A:  MOVLB  7
0A12C:  BCF    x07.3
0A12E:  BCF    x07.4
0A130:  BSF    x07.0
0A132:  ADDWF  01,F
0A134:  MOVFF  01,750
0A138:  MOVLB  0
0A13A:  CALL   563A
0A13E:  MOVLB  7
0A140:  MOVFF  706,73A
0A144:  MOVLW  0A
0A146:  MOVWF  x3B
0A148:  MOVLB  0
0A14A:  CALL   08A2
0A14E:  MOVFF  00,706
0A152:  MOVF   01,W
0A154:  MOVLW  30
0A156:  BNZ   A168
0A158:  MOVLB  7
0A15A:  BTFSC  x07.3
0A15C:  BRA    A174
0A15E:  BTFSS  x07.0
0A160:  BRA    A174
0A162:  BTFSC  x07.4
0A164:  MOVLW  20
0A166:  MOVLB  0
0A168:  ADDWF  01,F
0A16A:  MOVFF  01,750
0A16E:  CALL   563A
0A172:  MOVLB  7
0A174:  MOVLW  30
0A176:  ADDWF  x06,F
0A178:  MOVFF  706,750
0A17C:  MOVLB  0
0A17E:  CALL   563A
0A182:  RETURN 0
0A184:  MOVFF  FEA,708
0A188:  MOVFF  FE9,707
0A18C:  MOVLB  7
0A18E:  SWAPF  x01,W
0A190:  IORLW  F0
0A192:  MOVWF  x03
0A194:  ADDWF  x03,F
0A196:  ADDLW  E2
0A198:  MOVWF  x04
0A19A:  ADDLW  32
0A19C:  MOVWF  x06
0A19E:  MOVF   x01,W
0A1A0:  ANDLW  0F
0A1A2:  ADDWF  x04,F
0A1A4:  ADDWF  x04,F
0A1A6:  ADDWF  x06,F
0A1A8:  ADDLW  E9
0A1AA:  MOVWF  x05
0A1AC:  ADDWF  x05,F
0A1AE:  ADDWF  x05,F
0A1B0:  SWAPF  x00,W
0A1B2:  ANDLW  0F
0A1B4:  ADDWF  x05,F
0A1B6:  ADDWF  x06,F
0A1B8:  RLCF   x05,F
0A1BA:  RLCF   x06,F
0A1BC:  COMF   x06,F
0A1BE:  RLCF   x06,F
0A1C0:  MOVF   x00,W
0A1C2:  ANDLW  0F
0A1C4:  ADDWF  x06,F
0A1C6:  RLCF   x03,F
0A1C8:  MOVLW  07
0A1CA:  MOVWF  x02
0A1CC:  MOVLW  0A
0A1CE:  DECF   x05,F
0A1D0:  ADDWF  x06,F
0A1D2:  BNC   A1CE
0A1D4:  DECF   x04,F
0A1D6:  ADDWF  x05,F
0A1D8:  BNC   A1D4
0A1DA:  DECF   x03,F
0A1DC:  ADDWF  x04,F
0A1DE:  BNC   A1DA
0A1E0:  DECF   x02,F
0A1E2:  ADDWF  x03,F
0A1E4:  BNC   A1E0
0A1E6:  MOVLW  07
0A1E8:  MOVWF  FEA
0A1EA:  MOVLW  02
0A1EC:  MOVWF  FE9
0A1EE:  MOVLW  07
0A1F0:  ANDWF  x07,W
0A1F2:  BCF    x07.6
0A1F4:  ADDWF  FE9,F
0A1F6:  MOVLW  00
0A1F8:  ADDWFC FEA,F
0A1FA:  MOVF   FE9,W
0A1FC:  SUBLW  06
0A1FE:  BNZ   A208
0A200:  MOVF   FEA,W
0A202:  SUBLW  07
0A204:  BNZ   A208
0A206:  BSF    x07.6
0A208:  MOVF   FEF,W
0A20A:  MOVWF  00
0A20C:  BNZ   A21E
0A20E:  BTFSC  x07.6
0A210:  BRA    A21E
0A212:  BTFSC  x07.4
0A214:  BRA    A242
0A216:  BTFSC  x07.3
0A218:  BRA    A21E
0A21A:  MOVLW  20
0A21C:  BRA    A224
0A21E:  BSF    x07.3
0A220:  BCF    x07.4
0A222:  MOVLW  30
0A224:  ADDWF  00,F
0A226:  MOVFF  FEA,701
0A22A:  MOVFF  FE9,700
0A22E:  MOVFF  00,750
0A232:  MOVLB  0
0A234:  CALL   563A
0A238:  MOVFF  701,FEA
0A23C:  MOVFF  700,FE9
0A240:  MOVLB  7
0A242:  MOVF   FEE,W
0A244:  BTFSS  x07.6
0A246:  BRA    A1FA
0A248:  MOVLB  0
0A24A:  RETURN 0
*
0A29E:  MOVF   FEF,F
0A2A0:  BZ    A2C0
0A2A2:  MOVFF  FEA,6FC
0A2A6:  MOVFF  FE9,6FB
0A2AA:  MOVFF  FEF,6FD
0A2AE:  RCALL  A24C
0A2B0:  MOVFF  6FC,FEA
0A2B4:  MOVFF  6FB,FE9
0A2B8:  INCF   FE9,F
0A2BA:  BTFSC  FD8.2
0A2BC:  INCF   FEA,F
0A2BE:  BRA    A29E
0A2C0:  GOTO   AA82 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00394:  MOVLW  07
00396:  MOVWF  FEA
00398:  MOVLW  01
0039A:  MOVWF  FE9
0039C:  MOVF   FEF,W
0039E:  BZ    03BC
003A0:  MOVLW  14
003A2:  MOVWF  01
003A4:  CLRF   00
003A6:  DECFSZ 00,F
003A8:  BRA    03A6
003AA:  DECFSZ 01,F
003AC:  BRA    03A4
003AE:  MOVLW  BF
003B0:  MOVWF  00
003B2:  DECFSZ 00,F
003B4:  BRA    03B2
003B6:  BRA    03B8
003B8:  DECFSZ FEF,F
003BA:  BRA    03A0
003BC:  RETURN 0
*
00710:  MOVLW  01
00712:  MOVLB  7
00714:  SUBWF  x07,F
00716:  BNC   072E
00718:  MOVLW  07
0071A:  MOVWF  FEA
0071C:  MOVWF  FE9
0071E:  MOVF   FEF,W
00720:  BZ    072E
00722:  MOVLW  04
00724:  MOVWF  00
00726:  DECFSZ 00,F
00728:  BRA    0726
0072A:  DECFSZ FEF,F
0072C:  BRA    0722
0072E:  MOVLB  0
00730:  RETURN 0
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003BE:  MOVLW  CF
003C0:  MOVWF  F87
003C2:  CLRF   F82
....................    output_b(portB_reset);
003C4:  MOVLW  04
003C6:  MOVWF  F88
003C8:  CLRF   F83
....................    output_c(portC_reset);
003CA:  MOVLW  93
003CC:  MOVWF  F89
003CE:  CLRF   F84
....................    output_d(portD_reset);
003D0:  MOVLW  1F
003D2:  MOVWF  F8A
003D4:  CLRF   F85
....................    output_e(portE_reset);
003D6:  BCF    F8B.0
003D8:  BCF    F8B.1
003DA:  BCF    F8B.2
003DC:  BCF    F8B.3
003DE:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003E0:  MOVLB  F
003E2:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003E4:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003E6:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003E8:  SETF   x20
....................    port_e_pullups(portE_pullups);
003EA:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003EC:  MOVLW  40
003EE:  MOVWF  x0C
003F0:  CLRF   x14
003F2:  MOVLW  03
003F4:  MOVWF  x1C
003F6:  MOVLW  0F
003F8:  MOVWF  x21
003FA:  CLRF   x29
003FC:  MOVLB  0
003FE:  GOTO   A6D4 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
056B8:  MOVFF  742,FEA
056BC:  MOVLB  7
056BE:  MOVFF  741,FE9
056C2:  MOVFF  FEF,745
056C6:  MOVFF  744,FEA
056CA:  MOVFF  743,FE9
056CE:  MOVF   FEF,W
056D0:  SUBWF  x45,W
056D2:  BNZ   5702
....................       if (*s1 == '\0')
056D4:  MOVFF  742,03
056D8:  MOVFF  741,FE9
056DC:  MOVFF  03,FEA
056E0:  MOVF   FEF,F
056E2:  BNZ   56EA
....................          return(0);
056E4:  MOVLW  00
056E6:  MOVWF  01
056E8:  BRA    572C
056EA:  MOVFF  742,03
056EE:  MOVF   x41,W
056F0:  INCF   x41,F
056F2:  BTFSC  FD8.2
056F4:  INCF   x42,F
056F6:  INCF   x43,F
056F8:  BTFSC  FD8.2
056FA:  INCF   x44,F
056FC:  MOVLB  0
056FE:  BRA    56B8
05700:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
05702:  MOVFF  742,03
05706:  MOVFF  741,FE9
0570A:  MOVFF  03,FEA
0570E:  MOVFF  FEF,745
05712:  MOVFF  744,03
05716:  MOVFF  743,FE9
0571A:  MOVFF  03,FEA
0571E:  MOVF   FEF,W
05720:  SUBWF  x45,W
05722:  BC    5728
05724:  MOVLW  FF
05726:  BRA    572A
05728:  MOVLW  01
0572A:  MOVWF  01
0572C:  MOVLB  0
0572E:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05828:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
0582C:  MOVFF  767,76D
05830:  MOVFF  766,76C
05834:  MOVLB  7
05836:  MOVF   x6A,F
05838:  BNZ   5840
0583A:  MOVF   x69,W
0583C:  SUBLW  00
0583E:  BC    5868
....................       if(*su==uc)
05840:  MOVFF  76D,FEA
05844:  MOVFF  76C,FE9
05848:  MOVF   x6B,W
0584A:  SUBWF  FEF,W
0584C:  BNZ   5858
....................       return su;
0584E:  MOVFF  76C,01
05852:  MOVFF  76D,02
05856:  BRA    586E
05858:  INCF   x6C,F
0585A:  BTFSC  FD8.2
0585C:  INCF   x6D,F
0585E:  MOVF   x69,W
05860:  BTFSC  FD8.2
05862:  DECF   x6A,F
05864:  DECF   x69,F
05866:  BRA    5836
....................    return NULL;
05868:  MOVLW  00
0586A:  MOVWF  01
0586C:  MOVWF  02
0586E:  MOVLB  0
05870:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
05602:  MOVFF  742,744
05606:  MOVFF  741,743
0560A:  MOVFF  744,FEA
0560E:  MOVLB  7
05610:  MOVFF  743,FE9
05614:  MOVF   FEF,F
05616:  BZ    5624
05618:  INCF   x43,F
0561A:  BTFSC  FD8.2
0561C:  INCF   x44,F
0561E:  MOVLB  0
05620:  BRA    560A
05622:  MOVLB  7
....................    return(sc - s);
05624:  MOVF   x41,W
05626:  SUBWF  x43,W
05628:  MOVWF  00
0562A:  MOVF   x42,W
0562C:  SUBWFB x44,W
0562E:  MOVWF  03
05630:  MOVFF  00,01
05634:  MOVWF  02
05636:  MOVLB  0
05638:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06C3E:  MOVLB  7
06C40:  CLRF   x1B
06C42:  CLRF   x1A
06C44:  CLRF   x19
06C46:  MOVLW  7F
06C48:  MOVWF  x18
06C4A:  CLRF   x1F
06C4C:  CLRF   x1E
06C4E:  CLRF   x1D
06C50:  CLRF   x1C
06C52:  BSF    x20.0
06C54:  BCF    x20.1
06C56:  BCF    x20.2
06C58:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06C5A:  MOVF   x14,W
06C5C:  IORWF  x15,W
06C5E:  BNZ   6C6A
....................       return 0;
06C60:  CLRF   00
06C62:  CLRF   01
06C64:  CLRF   02
06C66:  CLRF   03
06C68:  BRA    6E94
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06C6A:  MOVF   x22,W
06C6C:  INCF   x22,F
06C6E:  ADDWF  x14,W
06C70:  MOVWF  FE9
06C72:  MOVLW  00
06C74:  ADDWFC x15,W
06C76:  MOVWF  FEA
06C78:  MOVFF  FEF,721
06C7C:  MOVF   x21,F
06C7E:  BTFSC  FD8.2
06C80:  BRA    6E18
....................    {
....................       if (skip && !isspace(c))
06C82:  BTFSS  x20.0
06C84:  BRA    6CA4
06C86:  MOVF   x21,W
06C88:  SUBLW  20
06C8A:  BZ    6CA4
....................       {
....................          skip = 0;
06C8C:  BCF    x20.0
....................          if (c == '+')
06C8E:  MOVF   x21,W
06C90:  SUBLW  2B
06C92:  BNZ   6C9A
....................          {
....................             sign = 0;
06C94:  BCF    x20.1
....................             continue;
06C96:  BRA    6E00
....................          }            
06C98:  BRA    6CA4
....................          else if (c == '-')
06C9A:  MOVF   x21,W
06C9C:  SUBLW  2D
06C9E:  BNZ   6CA4
....................          {
....................             sign = 1;
06CA0:  BSF    x20.1
....................             continue;
06CA2:  BRA    6E00
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06CA4:  BTFSC  x20.0
06CA6:  BRA    6CB6
06CA8:  MOVF   x21,W
06CAA:  SUBLW  2E
06CAC:  BNZ   6CB6
06CAE:  BTFSC  x20.2
06CB0:  BRA    6CB6
....................          point = 1;
06CB2:  BSF    x20.2
06CB4:  BRA    6E00
....................       else if (!skip && isdigit(c))
06CB6:  BTFSC  x20.0
06CB8:  BRA    6DFA
06CBA:  MOVF   x21,W
06CBC:  SUBLW  2F
06CBE:  BTFSC  FD8.0
06CC0:  BRA    6DFA
06CC2:  MOVF   x21,W
06CC4:  SUBLW  39
06CC6:  BTFSS  FD8.0
06CC8:  BRA    6DFA
....................       {
....................          c -= '0';
06CCA:  MOVLW  30
06CCC:  SUBWF  x21,F
....................          if (point)
06CCE:  BTFSS  x20.2
06CD0:  BRA    6D80
....................          {
....................             pow10 = pow10 * 10.0;
06CD2:  MOVFF  71B,753
06CD6:  MOVFF  71A,752
06CDA:  MOVFF  719,751
06CDE:  MOVFF  718,750
06CE2:  CLRF   x57
06CE4:  CLRF   x56
06CE6:  MOVLW  20
06CE8:  MOVWF  x55
06CEA:  MOVLW  82
06CEC:  MOVWF  x54
06CEE:  MOVLB  0
06CF0:  CALL   0D6A
06CF4:  MOVFF  03,71B
06CF8:  MOVFF  02,71A
06CFC:  MOVFF  01,719
06D00:  MOVFF  00,718
....................             result += (float)c / pow10;   
06D04:  MOVLB  7
06D06:  CLRF   x4B
06D08:  MOVFF  721,74A
06D0C:  MOVLB  0
06D0E:  CALL   0D34
06D12:  MOVFF  03,726
06D16:  MOVFF  02,725
06D1A:  MOVFF  01,724
06D1E:  MOVFF  00,723
06D22:  MOVFF  03,742
06D26:  MOVFF  02,741
06D2A:  MOVFF  01,740
06D2E:  MOVFF  00,73F
06D32:  MOVFF  71B,746
06D36:  MOVFF  71A,745
06D3A:  MOVFF  719,744
06D3E:  MOVFF  718,743
06D42:  CALL   1D70
06D46:  BCF    FD8.1
06D48:  MOVFF  71F,74D
06D4C:  MOVFF  71E,74C
06D50:  MOVFF  71D,74B
06D54:  MOVFF  71C,74A
06D58:  MOVFF  03,751
06D5C:  MOVFF  02,750
06D60:  MOVFF  01,74F
06D64:  MOVFF  00,74E
06D68:  CALL   0E60
06D6C:  MOVFF  03,71F
06D70:  MOVFF  02,71E
06D74:  MOVFF  01,71D
06D78:  MOVFF  00,71C
....................          }
06D7C:  BRA    6DF6
06D7E:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06D80:  CLRF   x53
06D82:  CLRF   x52
06D84:  MOVLW  20
06D86:  MOVWF  x51
06D88:  MOVLW  82
06D8A:  MOVWF  x50
06D8C:  MOVFF  71F,757
06D90:  MOVFF  71E,756
06D94:  MOVFF  71D,755
06D98:  MOVFF  71C,754
06D9C:  MOVLB  0
06D9E:  CALL   0D6A
06DA2:  MOVFF  03,726
06DA6:  MOVFF  02,725
06DAA:  MOVFF  01,724
06DAE:  MOVFF  00,723
06DB2:  MOVLB  7
06DB4:  CLRF   x4B
06DB6:  MOVFF  721,74A
06DBA:  MOVLB  0
06DBC:  CALL   0D34
06DC0:  BCF    FD8.1
06DC2:  MOVFF  726,74D
06DC6:  MOVFF  725,74C
06DCA:  MOVFF  724,74B
06DCE:  MOVFF  723,74A
06DD2:  MOVFF  03,751
06DD6:  MOVFF  02,750
06DDA:  MOVFF  01,74F
06DDE:  MOVFF  00,74E
06DE2:  CALL   0E60
06DE6:  MOVFF  03,71F
06DEA:  MOVFF  02,71E
06DEE:  MOVFF  01,71D
06DF2:  MOVFF  00,71C
....................          }
....................       }
06DF6:  BRA    6E02
06DF8:  MOVLB  7
....................       else if (!skip)
06DFA:  BTFSC  x20.0
06DFC:  BRA    6E00
....................          break;
06DFE:  BRA    6E18
06E00:  MOVLB  0
06E02:  MOVLB  7
06E04:  MOVF   x22,W
06E06:  INCF   x22,F
06E08:  ADDWF  x14,W
06E0A:  MOVWF  FE9
06E0C:  MOVLW  00
06E0E:  ADDWFC x15,W
06E10:  MOVWF  FEA
06E12:  MOVFF  FEF,721
06E16:  BRA    6C7C
....................    }
.................... 
....................    if (sign)
06E18:  BTFSS  x20.1
06E1A:  BRA    6E50
....................       result = -1*result;
06E1C:  CLRF   x53
06E1E:  CLRF   x52
06E20:  MOVLW  80
06E22:  MOVWF  x51
06E24:  MOVLW  7F
06E26:  MOVWF  x50
06E28:  MOVFF  71F,757
06E2C:  MOVFF  71E,756
06E30:  MOVFF  71D,755
06E34:  MOVFF  71C,754
06E38:  MOVLB  0
06E3A:  CALL   0D6A
06E3E:  MOVFF  03,71F
06E42:  MOVFF  02,71E
06E46:  MOVFF  01,71D
06E4A:  MOVFF  00,71C
06E4E:  MOVLB  7
....................       
....................    if(endptr)
06E50:  MOVF   x16,W
06E52:  IORWF  x17,W
06E54:  BZ    6E84
....................    {
....................       if (ptr) {
06E56:  MOVF   x22,F
06E58:  BZ    6E72
....................          ptr--;
06E5A:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06E5C:  MOVFF  717,FEA
06E60:  MOVFF  716,FE9
06E64:  MOVF   x22,W
06E66:  ADDWF  x14,W
06E68:  MOVWF  FEF
06E6A:  MOVLW  00
06E6C:  ADDWFC x15,W
06E6E:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06E70:  BRA    6E84
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06E72:  MOVFF  717,FEA
06E76:  MOVFF  716,FE9
06E7A:  MOVFF  715,FEC
06E7E:  MOVF   FED,F
06E80:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06E84:  MOVFF  71C,00
06E88:  MOVFF  71D,01
06E8C:  MOVFF  71E,02
06E90:  MOVFF  71F,03
06E94:  MOVLB  0
06E96:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
058C8:  MOVLB  7
058CA:  CLRF   x3F
058CC:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
058CE:  MOVLW  30
058D0:  MOVWF  x41
058D2:  MOVLW  31
058D4:  MOVWF  x42
058D6:  MOVLW  32
058D8:  MOVWF  x43
058DA:  MOVLW  33
058DC:  MOVWF  x44
058DE:  MOVLW  34
058E0:  MOVWF  x45
058E2:  MOVLW  35
058E4:  MOVWF  x46
058E6:  MOVLW  36
058E8:  MOVWF  x47
058EA:  MOVLW  37
058EC:  MOVWF  x48
058EE:  MOVLW  38
058F0:  MOVWF  x49
058F2:  MOVLW  39
058F4:  MOVWF  x4A
058F6:  MOVLW  61
058F8:  MOVWF  x4B
058FA:  MOVLW  62
058FC:  MOVWF  x4C
058FE:  MOVLW  63
05900:  MOVWF  x4D
05902:  MOVLW  64
05904:  MOVWF  x4E
05906:  MOVLW  65
05908:  MOVWF  x4F
0590A:  MOVLW  66
0590C:  MOVWF  x50
0590E:  MOVLW  67
05910:  MOVWF  x51
05912:  MOVLW  68
05914:  MOVWF  x52
05916:  MOVLW  69
05918:  MOVWF  x53
0591A:  MOVLW  6A
0591C:  MOVWF  x54
0591E:  MOVLW  6B
05920:  MOVWF  x55
05922:  MOVLW  6C
05924:  MOVWF  x56
05926:  MOVLW  6D
05928:  MOVWF  x57
0592A:  MOVLW  6E
0592C:  MOVWF  x58
0592E:  MOVLW  6F
05930:  MOVWF  x59
05932:  MOVLW  70
05934:  MOVWF  x5A
05936:  MOVLW  71
05938:  MOVWF  x5B
0593A:  MOVLW  73
0593C:  MOVWF  x5C
0593E:  MOVLW  74
05940:  MOVWF  x5D
05942:  MOVLW  75
05944:  MOVWF  x5E
05946:  MOVLW  76
05948:  MOVWF  x5F
0594A:  MOVLW  77
0594C:  MOVWF  x60
0594E:  MOVLW  78
05950:  MOVWF  x61
05952:  MOVLW  79
05954:  MOVWF  x62
05956:  MOVLW  7A
05958:  MOVWF  x63
0595A:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
0595C:  MOVFF  734,739
05960:  MOVFF  733,738
05964:  MOVFF  739,FEA
05968:  MOVFF  738,FE9
0596C:  MOVF   FEF,W
0596E:  SUBLW  20
05970:  BNZ   597A
05972:  INCF   x38,F
05974:  BTFSC  FD8.2
05976:  INCF   x39,F
05978:  BRA    5964
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
0597A:  MOVFF  739,03
0597E:  MOVFF  738,FE9
05982:  MOVFF  03,FEA
05986:  MOVF   FEF,W
05988:  SUBLW  2D
0598A:  BZ    599A
0598C:  MOVFF  739,FEA
05990:  MOVFF  738,FE9
05994:  MOVF   FEF,W
05996:  SUBLW  2B
05998:  BNZ   59AC
0599A:  MOVFF  739,FEA
0599E:  MOVF   x38,W
059A0:  INCF   x38,F
059A2:  BTFSC  FD8.2
059A4:  INCF   x39,F
059A6:  MOVWF  FE9
059A8:  MOVF   FEF,W
059AA:  BRA    59AE
059AC:  MOVLW  2B
059AE:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
059B0:  MOVF   x40,W
059B2:  SUBLW  2D
059B4:  BZ    59CA
059B6:  BTFSC  x37.7
059B8:  BRA    59CA
059BA:  DECFSZ x37,W
059BC:  BRA    59C0
059BE:  BRA    59CA
059C0:  BTFSC  x37.7
059C2:  BRA    59CE
059C4:  MOVF   x37,W
059C6:  SUBLW  24
059C8:  BC    59CE
....................    goto StrtoulGO;
059CA:  BRA    5BD6
059CC:  BRA    5AC6
.................... 
....................    else if (base)
059CE:  MOVF   x37,F
059D0:  BZ    5A5E
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
059D2:  MOVF   x37,W
059D4:  SUBLW  10
059D6:  BNZ   5A12
059D8:  MOVFF  739,FEA
059DC:  MOVFF  738,FE9
059E0:  MOVF   FEF,W
059E2:  SUBLW  30
059E4:  BNZ   5A12
059E6:  MOVLW  01
059E8:  ADDWF  x38,W
059EA:  MOVWF  FE9
059EC:  MOVLW  00
059EE:  ADDWFC x39,W
059F0:  MOVWF  FEA
059F2:  MOVF   FEF,W
059F4:  SUBLW  78
059F6:  BZ    5A0A
059F8:  MOVLW  01
059FA:  ADDWF  x38,W
059FC:  MOVWF  FE9
059FE:  MOVLW  00
05A00:  ADDWFC x39,W
05A02:  MOVWF  FEA
05A04:  MOVF   FEF,W
05A06:  SUBLW  58
05A08:  BNZ   5A12
....................          sc+=2;
05A0A:  MOVLW  02
05A0C:  ADDWF  x38,F
05A0E:  MOVLW  00
05A10:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05A12:  MOVF   x37,W
05A14:  SUBLW  08
05A16:  BNZ   5A2E
05A18:  MOVFF  739,FEA
05A1C:  MOVFF  738,FE9
05A20:  MOVF   FEF,W
05A22:  SUBLW  30
05A24:  BNZ   5A2E
....................          sc+=1;
05A26:  MOVLW  01
05A28:  ADDWF  x38,F
05A2A:  MOVLW  00
05A2C:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05A2E:  MOVF   x37,W
05A30:  SUBLW  02
05A32:  BNZ   5A5C
05A34:  MOVFF  739,FEA
05A38:  MOVFF  738,FE9
05A3C:  MOVF   FEF,W
05A3E:  SUBLW  30
05A40:  BNZ   5A5C
05A42:  MOVLW  01
05A44:  ADDWF  x38,W
05A46:  MOVWF  FE9
05A48:  MOVLW  00
05A4A:  ADDWFC x39,W
05A4C:  MOVWF  FEA
05A4E:  MOVF   FEF,W
05A50:  SUBLW  62
05A52:  BNZ   5A5C
....................          sc+=2;
05A54:  MOVLW  02
05A56:  ADDWF  x38,F
05A58:  MOVLW  00
05A5A:  ADDWFC x39,F
.................... 
....................    }
05A5C:  BRA    5AC6
....................    else if(*sc!='0') // base is 0, find base
05A5E:  MOVFF  739,FEA
05A62:  MOVFF  738,FE9
05A66:  MOVF   FEF,W
05A68:  SUBLW  30
05A6A:  BZ    5A72
....................       base=10;
05A6C:  MOVLW  0A
05A6E:  MOVWF  x37
05A70:  BRA    5AC6
....................    else if (sc[1]=='x' || sc[1]=='X')
05A72:  MOVLW  01
05A74:  ADDWF  x38,W
05A76:  MOVWF  FE9
05A78:  MOVLW  00
05A7A:  ADDWFC x39,W
05A7C:  MOVWF  FEA
05A7E:  MOVF   FEF,W
05A80:  SUBLW  78
05A82:  BZ    5A96
05A84:  MOVLW  01
05A86:  ADDWF  x38,W
05A88:  MOVWF  FE9
05A8A:  MOVLW  00
05A8C:  ADDWFC x39,W
05A8E:  MOVWF  FEA
05A90:  MOVF   FEF,W
05A92:  SUBLW  58
05A94:  BNZ   5AA4
....................       base =16,sc+=2;
05A96:  MOVLW  10
05A98:  MOVWF  x37
05A9A:  MOVLW  02
05A9C:  ADDWF  x38,F
05A9E:  MOVLW  00
05AA0:  ADDWFC x39,F
05AA2:  BRA    5AC6
....................    else if(sc[1]=='b')
05AA4:  MOVLW  01
05AA6:  ADDWF  x38,W
05AA8:  MOVWF  FE9
05AAA:  MOVLW  00
05AAC:  ADDWFC x39,W
05AAE:  MOVWF  FEA
05AB0:  MOVF   FEF,W
05AB2:  SUBLW  62
05AB4:  BNZ   5AC2
....................       base=2,sc+=2;
05AB6:  MOVLW  02
05AB8:  MOVWF  x37
05ABA:  ADDWF  x38,F
05ABC:  MOVLW  00
05ABE:  ADDWFC x39,F
05AC0:  BRA    5AC6
....................    else
....................       base=8;
05AC2:  MOVLW  08
05AC4:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05AC6:  MOVFF  739,73B
05ACA:  MOVFF  738,73A
05ACE:  MOVFF  739,FEA
05AD2:  MOVFF  738,FE9
05AD6:  MOVF   FEF,W
05AD8:  SUBLW  30
05ADA:  BNZ   5AE4
05ADC:  INCF   x38,F
05ADE:  BTFSC  FD8.2
05AE0:  INCF   x39,F
05AE2:  BRA    5ACE
....................    sd=memchr(digits,tolower(*sc),base);
05AE4:  MOVFF  739,03
05AE8:  MOVFF  738,FE9
05AEC:  MOVFF  03,FEA
05AF0:  MOVFF  FEF,765
05AF4:  MOVF   x65,W
05AF6:  SUBLW  40
05AF8:  BC    5B06
05AFA:  MOVF   x65,W
05AFC:  SUBLW  5A
05AFE:  BNC   5B06
05B00:  MOVF   x65,W
05B02:  IORLW  20
05B04:  BRA    5B08
05B06:  MOVF   x65,W
05B08:  MOVWF  x65
05B0A:  MOVLW  07
05B0C:  MOVWF  x67
05B0E:  MOVLW  41
05B10:  MOVWF  x66
05B12:  MOVFF  765,768
05B16:  CLRF   x6A
05B18:  MOVFF  737,769
05B1C:  BTFSC  x69.7
05B1E:  DECF   x6A,F
05B20:  MOVLB  0
05B22:  RCALL  5828
05B24:  MOVFF  02,73D
05B28:  MOVFF  01,73C
....................    for(; sd!=0; )
05B2C:  MOVLB  7
05B2E:  MOVF   x3C,F
05B30:  BNZ   5B36
05B32:  MOVF   x3D,F
05B34:  BZ    5BCA
....................    {
....................       x=x*base+(int16)(sd-digits);
05B36:  CLRF   03
05B38:  MOVF   x37,W
05B3A:  MOVWF  00
05B3C:  BTFSC  FE8.7
05B3E:  DECF   03,F
05B40:  MOVWF  x65
05B42:  MOVFF  03,766
05B46:  MOVFF  73F,768
05B4A:  MOVFF  73E,767
05B4E:  MOVFF  03,76A
05B52:  MOVWF  x69
05B54:  MOVLB  0
05B56:  BRA    5872
05B58:  MOVFF  01,765
05B5C:  MOVLW  41
05B5E:  MOVLB  7
05B60:  SUBWF  x3C,W
05B62:  MOVWF  00
05B64:  MOVLW  07
05B66:  SUBWFB x3D,W
05B68:  MOVWF  03
05B6A:  MOVF   00,W
05B6C:  ADDWF  01,W
05B6E:  MOVWF  01
05B70:  MOVF   02,W
05B72:  ADDWFC 03,F
05B74:  MOVFF  01,73E
05B78:  MOVFF  03,73F
....................       ++sc;
05B7C:  INCF   x38,F
05B7E:  BTFSC  FD8.2
05B80:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05B82:  MOVFF  739,FEA
05B86:  MOVFF  738,FE9
05B8A:  MOVFF  FEF,765
05B8E:  MOVF   x65,W
05B90:  SUBLW  40
05B92:  BC    5BA0
05B94:  MOVF   x65,W
05B96:  SUBLW  5A
05B98:  BNC   5BA0
05B9A:  MOVF   x65,W
05B9C:  IORLW  20
05B9E:  BRA    5BA2
05BA0:  MOVF   x65,W
05BA2:  MOVWF  x65
05BA4:  MOVLW  07
05BA6:  MOVWF  x67
05BA8:  MOVLW  41
05BAA:  MOVWF  x66
05BAC:  MOVFF  765,768
05BB0:  CLRF   x6A
05BB2:  MOVFF  737,769
05BB6:  BTFSC  x69.7
05BB8:  DECF   x6A,F
05BBA:  MOVLB  0
05BBC:  RCALL  5828
05BBE:  MOVFF  02,73D
05BC2:  MOVFF  01,73C
05BC6:  BRA    5B2C
05BC8:  MOVLB  7
....................    }
....................    if(s1==sc)
05BCA:  MOVF   x38,W
05BCC:  SUBWF  x3A,W
05BCE:  BNZ   5BF8
05BD0:  MOVF   x39,W
05BD2:  SUBWF  x3B,W
05BD4:  BNZ   5BF8
....................    {
....................    StrtoulGO:
....................       if (endptr)
05BD6:  MOVLB  7
05BD8:  MOVF   x35,W
05BDA:  IORWF  x36,W
05BDC:  BZ    5BF0
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05BDE:  MOVFF  736,FEA
05BE2:  MOVFF  735,FE9
05BE6:  MOVFF  734,FEC
05BEA:  MOVF   FED,F
05BEC:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05BF0:  MOVLW  00
05BF2:  MOVWF  01
05BF4:  MOVWF  02
05BF6:  BRA    5C18
....................    }
....................    if (endptr)
05BF8:  MOVF   x35,W
05BFA:  IORWF  x36,W
05BFC:  BZ    5C10
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05BFE:  MOVFF  736,FEA
05C02:  MOVFF  735,FE9
05C06:  MOVFF  739,FEC
05C0A:  MOVF   FED,F
05C0C:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05C10:  MOVFF  73E,01
05C14:  MOVFF  73F,02
05C18:  MOVLB  0
05C1A:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00464:  MOVLB  7
00466:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00468:  CLRF   x00
0046A:  MOVLB  6
0046C:  MOVF   xFF,W
0046E:  MOVLB  7
00470:  SUBWF  x00,W
00472:  BC    04D4
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
00474:  MOVF   x00,W
00476:  MOVLB  6
00478:  ADDWF  xFD,W
0047A:  MOVLB  7
0047C:  MOVWF  x01
0047E:  MOVLW  00
00480:  MOVLB  6
00482:  ADDWFC xFE,W
00484:  MOVLB  7
00486:  MOVWF  x02
00488:  MOVF   x00,W
0048A:  MOVLB  6
0048C:  ADDWF  xFB,W
0048E:  MOVWF  01
00490:  MOVLW  00
00492:  ADDWFC xFC,W
00494:  MOVWF  03
00496:  MOVF   01,W
00498:  MOVWF  FE9
0049A:  MOVFF  03,FEA
0049E:  MOVFF  FEF,703
004A2:  BSF    F7F.7
004A4:  MOVF   FF2,W
004A6:  MOVWF  00
004A8:  BCF    FF2.7
004AA:  MOVFF  702,F7A
004AE:  MOVFF  701,F79
004B2:  MOVLW  31
004B4:  MOVWF  F7B
004B6:  MOVFF  703,F7C
004BA:  MOVLB  F
004BC:  MOVLW  55
004BE:  MOVWF  F81
004C0:  MOVLW  AA
004C2:  MOVWF  F81
004C4:  BSF    F80.4
004C6:  BTFSC  F80.4
004C8:  BRA    04C6
004CA:  MOVF   00,W
004CC:  IORWF  FF2,F
004CE:  MOVLB  7
004D0:  INCF   x00,F
004D2:  BRA    046A
....................    }
004D4:  MOVLB  0
004D6:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
00402:  MOVLB  7
00404:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00406:  CLRF   x00
00408:  MOVLB  6
0040A:  MOVF   xFF,W
0040C:  MOVLB  7
0040E:  SUBWF  x00,W
00410:  BC    0460
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00412:  MOVF   x00,W
00414:  MOVLB  6
00416:  ADDWF  xFB,W
00418:  MOVWF  01
0041A:  MOVLW  00
0041C:  ADDWFC xFC,W
0041E:  MOVWF  03
00420:  MOVF   01,W
00422:  MOVWF  FE9
00424:  MOVFF  03,FEA
00428:  MOVLB  7
0042A:  MOVF   x00,W
0042C:  MOVLB  6
0042E:  ADDWF  xFD,W
00430:  MOVLB  7
00432:  MOVWF  x03
00434:  MOVLW  00
00436:  MOVLB  6
00438:  ADDWFC xFE,W
0043A:  MOVLB  7
0043C:  MOVWF  x04
0043E:  BSF    F7F.7
00440:  MOVFF  FF2,705
00444:  BCF    FF2.7
00446:  MOVFF  704,F7A
0044A:  MOVFF  703,F79
0044E:  MOVLW  31
00450:  MOVWF  F7B
00452:  BSF    F80.0
00454:  MOVF   F7C,W
00456:  BTFSC  x05.7
00458:  BSF    FF2.7
0045A:  MOVWF  FEF
0045C:  INCF   x00,F
0045E:  BRA    0408
....................    }
00460:  MOVLB  0
00462:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004D8:  MOVLB  6
004DA:  CLRF   xFC
004DC:  MOVLW  20
004DE:  MOVWF  xFB
004E0:  CLRF   xFE
004E2:  CLRF   xFD
004E4:  MOVLW  80
004E6:  MOVWF  xFF
004E8:  MOVLB  0
004EA:  RCALL  0464
....................    delay_ms(1);
004EC:  MOVLW  01
004EE:  MOVLB  7
004F0:  MOVWF  x01
004F2:  MOVLB  0
004F4:  RCALL  0394
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004F6:  MOVLB  6
004F8:  CLRF   xFC
004FA:  MOVLW  70
004FC:  MOVWF  xFB
004FE:  CLRF   xFE
00500:  MOVLW  80
00502:  MOVWF  xFD
00504:  MOVLW  02
00506:  MOVWF  xFF
00508:  MOVLB  0
0050A:  RCALL  0464
....................    delay_ms(1);
0050C:  MOVLW  01
0050E:  MOVLB  7
00510:  MOVWF  x01
00512:  MOVLB  0
00514:  RCALL  0394
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
00516:  MOVLB  6
00518:  CLRF   xFC
0051A:  MOVLW  71
0051C:  MOVWF  xFB
0051E:  CLRF   xFE
00520:  MOVLW  90
00522:  MOVWF  xFD
00524:  MOVLW  02
00526:  MOVWF  xFF
00528:  MOVLB  0
0052A:  RCALL  0464
....................    delay_ms(1);
0052C:  MOVLW  01
0052E:  MOVLB  7
00530:  MOVWF  x01
00532:  MOVLB  0
00534:  RCALL  0394
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00536:  MOVLB  6
00538:  CLRF   xFC
0053A:  MOVLW  72
0053C:  MOVWF  xFB
0053E:  CLRF   xFE
00540:  MOVLW  A0
00542:  MOVWF  xFD
00544:  MOVLW  20
00546:  MOVWF  xFF
00548:  MOVLB  0
0054A:  RCALL  0464
....................    delay_ms(1);
0054C:  MOVLW  01
0054E:  MOVLB  7
00550:  MOVWF  x01
00552:  MOVLB  0
00554:  RCALL  0394
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00556:  MOVLB  6
00558:  CLRF   xFC
0055A:  MOVLW  92
0055C:  MOVWF  xFB
0055E:  CLRF   xFE
00560:  MOVLW  C0
00562:  MOVWF  xFD
00564:  MOVLW  30
00566:  MOVWF  xFF
00568:  MOVLB  0
0056A:  RCALL  0464
....................    delay_ms(1);
0056C:  MOVLW  01
0056E:  MOVLB  7
00570:  MOVWF  x01
00572:  MOVLB  0
00574:  RCALL  0394
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00576:  MOVLB  6
00578:  CLRF   xFC
0057A:  MOVLW  C2
0057C:  MOVWF  xFB
0057E:  CLRF   xFE
00580:  MOVLW  F0
00582:  MOVWF  xFD
00584:  MOVLW  38
00586:  MOVWF  xFF
00588:  MOVLB  0
0058A:  RCALL  0464
....................    delay_ms(1);
0058C:  MOVLW  01
0058E:  MOVLB  7
00590:  MOVWF  x01
00592:  MOVLB  0
00594:  RCALL  0394
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00596:  MOVLB  6
00598:  CLRF   xFC
0059A:  MOVLW  FA
0059C:  MOVWF  xFB
0059E:  MOVLW  01
005A0:  MOVWF  xFE
005A2:  MOVLW  40
005A4:  MOVWF  xFD
005A6:  MOVLW  01
005A8:  MOVWF  xFF
005AA:  MOVLB  0
005AC:  RCALL  0464
....................    delay_ms(1);
005AE:  MOVLW  01
005B0:  MOVLB  7
005B2:  MOVWF  x01
005B4:  MOVLB  0
005B6:  RCALL  0394
005B8:  GOTO   0688 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005BC:  MOVLB  6
005BE:  CLRF   xFC
005C0:  MOVLW  20
005C2:  MOVWF  xFB
005C4:  CLRF   xFE
005C6:  CLRF   xFD
005C8:  MOVLW  80
005CA:  MOVWF  xFF
005CC:  MOVLB  0
005CE:  RCALL  0402
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005D0:  MOVLB  6
005D2:  CLRF   xFC
005D4:  MOVLW  70
005D6:  MOVWF  xFB
005D8:  CLRF   xFE
005DA:  MOVLW  80
005DC:  MOVWF  xFD
005DE:  MOVLW  02
005E0:  MOVWF  xFF
005E2:  MOVLB  0
005E4:  RCALL  0402
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005E6:  MOVLB  6
005E8:  CLRF   xFC
005EA:  MOVLW  71
005EC:  MOVWF  xFB
005EE:  CLRF   xFE
005F0:  MOVLW  90
005F2:  MOVWF  xFD
005F4:  MOVLW  02
005F6:  MOVWF  xFF
005F8:  MOVLB  0
005FA:  RCALL  0402
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005FC:  MOVLB  6
005FE:  CLRF   xFC
00600:  MOVLW  72
00602:  MOVWF  xFB
00604:  CLRF   xFE
00606:  MOVLW  A0
00608:  MOVWF  xFD
0060A:  MOVLW  20
0060C:  MOVWF  xFF
0060E:  MOVLB  0
00610:  RCALL  0402
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00612:  MOVLB  6
00614:  CLRF   xFC
00616:  MOVLW  92
00618:  MOVWF  xFB
0061A:  CLRF   xFE
0061C:  MOVLW  C0
0061E:  MOVWF  xFD
00620:  MOVLW  30
00622:  MOVWF  xFF
00624:  MOVLB  0
00626:  RCALL  0402
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00628:  MOVLB  6
0062A:  CLRF   xFC
0062C:  MOVLW  C2
0062E:  MOVWF  xFB
00630:  CLRF   xFE
00632:  MOVLW  F0
00634:  MOVWF  xFD
00636:  MOVLW  38
00638:  MOVWF  xFF
0063A:  MOVLB  0
0063C:  RCALL  0402
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0063E:  MOVLB  6
00640:  CLRF   xFC
00642:  MOVLW  FA
00644:  MOVWF  xFB
00646:  MOVLW  01
00648:  MOVWF  xFE
0064A:  MOVLW  40
0064C:  MOVWF  xFD
0064E:  MOVLW  01
00650:  MOVWF  xFF
00652:  MOVLB  0
00654:  RCALL  0402
00656:  GOTO   068C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0065A:  MOVLB  6
0065C:  CLRF   xFC
0065E:  MOVLW  FA
00660:  MOVWF  xFB
00662:  MOVLW  01
00664:  MOVWF  xFE
00666:  MOVLW  40
00668:  MOVWF  xFD
0066A:  MOVLW  01
0066C:  MOVWF  xFF
0066E:  MOVLB  0
00670:  RCALL  0402
....................    delay_ms(1);
00672:  MOVLW  01
00674:  MOVLB  7
00676:  MOVWF  x01
00678:  MOVLB  0
0067A:  RCALL  0394
....................    if (paramsValid != isValid)
0067C:  MOVF   xFA,W
0067E:  SUBLW  AA
00680:  BZ    068A
....................    {
....................       paramsValid = isValid;
00682:  MOVLW  AA
00684:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
00686:  BRA    04D8
....................    }
00688:  BRA    068C
....................    else
....................    {
....................       params_load_from_ee();
0068A:  BRA    05BC
....................    }
0068C:  GOTO   A6D8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00138:  MOVLW  1F
0013A:  MOVWF  F8A
0013C:  BSF    F85.5
....................    output_high(_CS1);
0013E:  MOVWF  F8A
00140:  BSF    F85.6
....................    output_high(_CS2);
00142:  MOVWF  F8A
00144:  BSF    F85.7
....................    output_high(_CS3); 
00146:  MOVLW  04
00148:  MOVWF  F88
0014A:  BSF    F83.0
....................    delay_us(10);
0014C:  MOVLW  35
0014E:  MOVWF  00
00150:  DECFSZ 00,F
00152:  BRA    0150
00154:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
00690:  RCALL  0138
....................    switch(ch)
00692:  MOVLB  7
00694:  MOVF   x0C,W
00696:  ADDLW  FC
00698:  BC    06CC
0069A:  ADDLW  04
0069C:  MOVLB  0
0069E:  GOTO   06D8
....................    {
....................       case 0:
....................          output_low(_CS0);
006A2:  MOVLW  1F
006A4:  MOVWF  F8A
006A6:  BCF    F85.5
....................       break; 
006A8:  MOVLB  7
006AA:  BRA    06CC
....................       case 1:
....................          output_low(_CS1);
006AC:  MOVLW  1F
006AE:  MOVWF  F8A
006B0:  BCF    F85.6
....................       break;   
006B2:  MOVLB  7
006B4:  BRA    06CC
....................       case 2:
....................          output_low(_CS2);
006B6:  MOVLW  1F
006B8:  MOVWF  F8A
006BA:  BCF    F85.7
....................       break;
006BC:  MOVLB  7
006BE:  BRA    06CC
....................       case 3:
....................          output_low(_CS3);
006C0:  MOVLW  04
006C2:  MOVWF  F88
006C4:  BCF    F83.0
....................       break;              
006C6:  MOVLB  7
006C8:  BRA    06CC
006CA:  MOVLB  7
....................    }
....................    delay_us(10);
006CC:  MOVLW  35
006CE:  MOVWF  00
006D0:  DECFSZ 00,F
006D2:  BRA    06D0
006D4:  MOVLB  0
006D6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00156:  RCALL  0138
....................    switch(block)
00158:  MOVLB  7
0015A:  MOVF   x74,W
0015C:  XORLW  00
0015E:  MOVLB  0
00160:  BZ    0168
00162:  XORLW  01
00164:  BZ    0174
00166:  BRA    0180
....................    {
....................       case 0:
....................          output_low(_CS0);
00168:  MOVLW  1F
0016A:  MOVWF  F8A
0016C:  BCF    F85.5
....................          output_low(_CS1);
0016E:  MOVWF  F8A
00170:  BCF    F85.6
....................       break; 
00172:  BRA    0180
....................       case 1:         
....................          output_low(_CS2);
00174:  MOVLW  1F
00176:  MOVWF  F8A
00178:  BCF    F85.7
....................          output_low(_CS3);
0017A:  MOVLW  04
0017C:  MOVWF  F88
0017E:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
00180:  MOVLW  35
00182:  MOVWF  00
00184:  DECFSZ 00,F
00186:  BRA    0184
00188:  GOTO   0192 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007C2:  MOVLW  1F
007C4:  MOVWF  F8A
007C6:  BCF    F85.5
....................    output_low(_CS1);
007C8:  MOVWF  F8A
007CA:  BCF    F85.6
....................    output_low(_CS2);
007CC:  MOVWF  F8A
007CE:  BCF    F85.7
....................    output_low(_CS3);
007D0:  MOVLW  04
007D2:  MOVWF  F88
007D4:  BCF    F83.0
....................    delay_us(10);
007D6:  MOVLW  35
007D8:  MOVWF  00
007DA:  DECFSZ 00,F
007DC:  BRA    07DA
007DE:  GOTO   07E4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006FA:  MOVFF  70A,70C
006FE:  RCALL  0690
....................    spi_write2(command);
00700:  MOVLB  E
00702:  MOVF   x8D,W
00704:  MOVFF  70B,E8D
00708:  RRCF   x90,W
0070A:  BNC   0708
0070C:  MOVLB  0
0070E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018C:  MOVFF  772,774
00190:  BRA    0156
....................    spi_write2(command);
00192:  MOVLB  E
00194:  MOVF   x8D,W
00196:  MOVFF  773,E8D
0019A:  RRCF   x90,W
0019C:  BNC   019A
0019E:  MOVLB  0
001A0:  GOTO   01B2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
007E2:  BRA    07C2
....................    spi_write2(command);
007E4:  MOVLB  E
007E6:  MOVF   x8D,W
007E8:  MOVFF  701,E8D
007EC:  RRCF   x90,W
007EE:  BNC   07EC
007F0:  MOVLB  0
007F2:  GOTO   0800 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0080E:  MOVFF  709,70C
00812:  RCALL  0690
....................    spi_read2(command);
00814:  MOVLB  E
00816:  MOVF   x8D,W
00818:  MOVFF  70A,E8D
0081C:  RRCF   x90,W
0081E:  BNC   081C
00820:  MOVLB  0
00822:  GOTO   0834 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00732:  MOVLB  7
00734:  MOVF   x07,W
00736:  IORLW  40
00738:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0073A:  MOVFF  706,70A
0073E:  MOVFF  709,70B
00742:  MOVLB  0
00744:  RCALL  06FA
....................    spi_write2(data);
00746:  MOVLB  E
00748:  MOVF   x8D,W
0074A:  MOVFF  708,E8D
0074E:  RRCF   x90,W
00750:  BNC   074E
....................    ads_deselect_all();
00752:  MOVLB  0
00754:  RCALL  0138
00756:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A4:  MOVFF  771,772
001A8:  MOVLW  08
001AA:  MOVLB  7
001AC:  MOVWF  x73
001AE:  MOVLB  0
001B0:  BRA    018C
....................    delay_us(10);
001B2:  MOVLW  35
001B4:  MOVWF  00
001B6:  DECFSZ 00,F
001B8:  BRA    01B6
....................    ads_deselect_all();
001BA:  RCALL  0138
001BC:  GOTO   0202 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
007F6:  MOVLW  08
007F8:  MOVLB  7
007FA:  MOVWF  x01
007FC:  MOVLB  0
007FE:  BRA    07E2
....................    delay_us(10);
00800:  MOVLW  35
00802:  MOVWF  00
00804:  DECFSZ 00,F
00806:  BRA    0804
....................    ads_deselect_all();
00808:  RCALL  0138
0080A:  GOTO   0990 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00826:  MOVFF  704,709
0082A:  MOVLW  10
0082C:  MOVLB  7
0082E:  MOVWF  x0A
00830:  MOVLB  0
00832:  BRA    080E
....................    data.dBytes[3] = 0;
00834:  MOVLB  7
00836:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
00838:  MOVLB  E
0083A:  MOVF   x8D,W
0083C:  CLRF   x8D
0083E:  RRCF   x90,W
00840:  BNC   083E
00842:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
00846:  MOVF   x8D,W
00848:  CLRF   x8D
0084A:  RRCF   x90,W
0084C:  BNC   084A
0084E:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
00852:  MOVF   x8D,W
00854:  CLRF   x8D
00856:  RRCF   x90,W
00858:  BNC   0856
0085A:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
0085E:  MOVLB  7
00860:  MOVF   x07,W
00862:  ANDLW  80
00864:  BZ    086A
00866:  MOVLW  FF
00868:  IORWF  x08,F
....................    
....................    ads_deselect_all();
0086A:  MOVLB  0
0086C:  RCALL  0138
....................    return data.dWord;
0086E:  MOVFF  705,00
00872:  MOVFF  706,01
00876:  MOVFF  707,02
0087A:  MOVFF  708,03
0087E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00758:  MOVFF  701,70A
0075C:  MOVLW  06
0075E:  MOVLB  7
00760:  MOVWF  x0B
00762:  MOVLB  0
00764:  RCALL  06FA
....................    delay_us(300);                    
00766:  MOVLW  02
00768:  MOVLB  7
0076A:  MOVWF  x06
0076C:  MOVLW  96
0076E:  MOVWF  x07
00770:  MOVLB  0
00772:  RCALL  0710
00774:  MOVLB  7
00776:  DECFSZ x06,F
00778:  BRA    076C
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0077A:  MOVFF  701,706
0077E:  CLRF   x07
00780:  MOVFF  702,708
00784:  MOVLB  0
00786:  RCALL  0732
....................    ads_write_reg(ch, reg1, rc1);
00788:  MOVFF  701,706
0078C:  MOVLW  04
0078E:  MOVLB  7
00790:  MOVWF  x07
00792:  MOVFF  703,708
00796:  MOVLB  0
00798:  RCALL  0732
....................    ads_write_reg(ch, reg2, rc2);
0079A:  MOVFF  701,706
0079E:  MOVLW  08
007A0:  MOVLB  7
007A2:  MOVWF  x07
007A4:  MOVFF  704,708
007A8:  MOVLB  0
007AA:  RCALL  0732
....................    ads_write_reg(ch, reg3, rc3);  
007AC:  MOVFF  701,706
007B0:  MOVLW  0C
007B2:  MOVLB  7
007B4:  MOVWF  x07
007B6:  MOVFF  705,708
007BA:  MOVLB  0
007BC:  RCALL  0732
007BE:  GOTO   096A (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02726:  MOVLB  7
02728:  BCF    x45.0
....................    y = x;
0272A:  MOVFF  739,73E
0272E:  MOVFF  738,73D
02732:  MOVFF  737,73C
02736:  MOVFF  736,73B
.................... 
....................    if (x < 0)
0273A:  MOVFF  739,749
0273E:  MOVFF  738,748
02742:  MOVFF  737,747
02746:  MOVFF  736,746
0274A:  CLRF   x4D
0274C:  CLRF   x4C
0274E:  CLRF   x4B
02750:  CLRF   x4A
02752:  MOVLB  0
02754:  CALL   1CF6
02758:  BNC   2766
....................    {
....................       s = 1;
0275A:  MOVLB  7
0275C:  BSF    x45.0
....................       y = -y;
0275E:  MOVF   x3C,W
02760:  XORLW  80
02762:  MOVWF  x3C
02764:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
02766:  MOVFF  73E,749
0276A:  MOVFF  73D,748
0276E:  MOVFF  73C,747
02772:  MOVFF  73B,746
02776:  MOVLB  7
02778:  CLRF   x4D
0277A:  CLRF   x4C
0277C:  CLRF   x4B
0277E:  MOVLW  8E
02780:  MOVWF  x4A
02782:  MOVLB  0
02784:  CALL   1CF6
02788:  BC    278C
0278A:  BNZ   27BC
....................       res = (float32)(unsigned int16)y;
0278C:  MOVFF  73E,749
02790:  MOVFF  73D,748
02794:  MOVFF  73C,747
02798:  MOVFF  73B,746
0279C:  RCALL  26EA
0279E:  MOVFF  02,74B
027A2:  MOVFF  01,74A
027A6:  CALL   0D34
027AA:  MOVFF  03,742
027AE:  MOVFF  02,741
027B2:  MOVFF  01,740
027B6:  MOVFF  00,73F
027BA:  BRA    295E
.................... 
....................  else if (y < 10000000.0)
027BC:  MOVFF  73E,749
027C0:  MOVFF  73D,748
027C4:  MOVFF  73C,747
027C8:  MOVFF  73B,746
027CC:  MOVLW  80
027CE:  MOVLB  7
027D0:  MOVWF  x4D
027D2:  MOVLW  96
027D4:  MOVWF  x4C
027D6:  MOVLW  18
027D8:  MOVWF  x4B
027DA:  MOVLW  96
027DC:  MOVWF  x4A
027DE:  MOVLB  0
027E0:  CALL   1CF6
027E4:  BTFSS  FD8.0
027E6:  BRA    294E
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
027E8:  MOVFF  73E,753
027EC:  MOVFF  73D,752
027F0:  MOVFF  73C,751
027F4:  MOVFF  73B,750
027F8:  MOVLB  7
027FA:  CLRF   x57
027FC:  CLRF   x56
027FE:  CLRF   x55
02800:  MOVLW  70
02802:  MOVWF  x54
02804:  MOVLB  0
02806:  CALL   0D6A
0280A:  MOVFF  03,749
0280E:  MOVFF  02,748
02812:  MOVFF  01,747
02816:  MOVFF  00,746
0281A:  RCALL  26EA
0281C:  MOVFF  02,744
02820:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
02824:  MOVFF  73E,753
02828:  MOVFF  73D,752
0282C:  MOVFF  73C,751
02830:  MOVFF  73B,750
02834:  MOVLB  7
02836:  CLRF   x57
02838:  CLRF   x56
0283A:  CLRF   x55
0283C:  MOVLW  70
0283E:  MOVWF  x54
02840:  MOVLB  0
02842:  CALL   0D6A
02846:  MOVFF  03,749
0284A:  MOVFF  02,748
0284E:  MOVFF  01,747
02852:  MOVFF  00,746
02856:  MOVFF  744,74B
0285A:  MOVFF  743,74A
0285E:  CALL   0D34
02862:  BSF    FD8.1
02864:  MOVFF  749,74D
02868:  MOVFF  748,74C
0286C:  MOVFF  747,74B
02870:  MOVFF  746,74A
02874:  MOVFF  03,751
02878:  MOVFF  02,750
0287C:  MOVFF  01,74F
02880:  MOVFF  00,74E
02884:  CALL   0E60
02888:  MOVLB  7
0288A:  CLRF   x53
0288C:  CLRF   x52
0288E:  CLRF   x51
02890:  MOVLW  8E
02892:  MOVWF  x50
02894:  MOVFF  03,757
02898:  MOVFF  02,756
0289C:  MOVFF  01,755
028A0:  MOVFF  00,754
028A4:  MOVLB  0
028A6:  CALL   0D6A
028AA:  MOVFF  03,73E
028AE:  MOVFF  02,73D
028B2:  MOVFF  01,73C
028B6:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028BA:  MOVFF  744,74B
028BE:  MOVFF  743,74A
028C2:  CALL   0D34
028C6:  MOVLB  7
028C8:  CLRF   x53
028CA:  CLRF   x52
028CC:  CLRF   x51
028CE:  MOVLW  8E
028D0:  MOVWF  x50
028D2:  MOVFF  03,757
028D6:  MOVFF  02,756
028DA:  MOVFF  01,755
028DE:  MOVFF  00,754
028E2:  MOVLB  0
028E4:  CALL   0D6A
028E8:  MOVFF  03,742
028EC:  MOVFF  02,741
028F0:  MOVFF  01,740
028F4:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
028F8:  MOVFF  73E,749
028FC:  MOVFF  73D,748
02900:  MOVFF  73C,747
02904:  MOVFF  73B,746
02908:  RCALL  26EA
0290A:  MOVFF  02,74B
0290E:  MOVFF  01,74A
02912:  CALL   0D34
02916:  BCF    FD8.1
02918:  MOVFF  742,74D
0291C:  MOVFF  741,74C
02920:  MOVFF  740,74B
02924:  MOVFF  73F,74A
02928:  MOVFF  03,751
0292C:  MOVFF  02,750
02930:  MOVFF  01,74F
02934:  MOVFF  00,74E
02938:  CALL   0E60
0293C:  MOVFF  03,742
02940:  MOVFF  02,741
02944:  MOVFF  01,740
02948:  MOVFF  00,73F
....................    }
0294C:  BRA    295E
.................... 
....................  else
....................   res = y;
0294E:  MOVFF  73E,742
02952:  MOVFF  73D,741
02956:  MOVFF  73C,740
0295A:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
0295E:  MOVFF  73E,749
02962:  MOVFF  73D,748
02966:  MOVFF  73C,747
0296A:  MOVFF  73B,746
0296E:  RCALL  26EA
02970:  MOVFF  02,74B
02974:  MOVFF  01,74A
02978:  CALL   0D34
0297C:  BSF    FD8.1
0297E:  MOVFF  73E,74D
02982:  MOVFF  73D,74C
02986:  MOVFF  73C,74B
0298A:  MOVFF  73B,74A
0298E:  MOVFF  03,751
02992:  MOVFF  02,750
02996:  MOVFF  01,74F
0299A:  MOVFF  00,74E
0299E:  CALL   0E60
029A2:  MOVFF  03,73E
029A6:  MOVFF  02,73D
029AA:  MOVFF  01,73C
029AE:  MOVFF  00,73B
.................... 
....................  if (s)
029B2:  MOVLB  7
029B4:  BTFSS  x45.0
029B6:  BRA    29BE
....................   res = -res;
029B8:  MOVF   x40,W
029BA:  XORLW  80
029BC:  MOVWF  x40
.................... 
....................  if (y != 0)
029BE:  MOVFF  73E,749
029C2:  MOVFF  73D,748
029C6:  MOVFF  73C,747
029CA:  MOVFF  73B,746
029CE:  CLRF   x4D
029D0:  CLRF   x4C
029D2:  CLRF   x4B
029D4:  CLRF   x4A
029D6:  MOVLB  0
029D8:  CALL   1CF6
029DC:  BZ    2A56
....................  {
....................   if (s == 1 && n == 0)
029DE:  MOVLB  7
029E0:  BTFSS  x45.0
029E2:  BRA    2A1C
029E4:  MOVF   x3A,F
029E6:  BNZ   2A1C
....................    res -= 1.0;
029E8:  BSF    FD8.1
029EA:  MOVFF  742,74D
029EE:  MOVFF  741,74C
029F2:  MOVFF  740,74B
029F6:  MOVFF  73F,74A
029FA:  CLRF   x51
029FC:  CLRF   x50
029FE:  CLRF   x4F
02A00:  MOVLW  7F
02A02:  MOVWF  x4E
02A04:  MOVLB  0
02A06:  CALL   0E60
02A0A:  MOVFF  03,742
02A0E:  MOVFF  02,741
02A12:  MOVFF  01,740
02A16:  MOVFF  00,73F
02A1A:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A1C:  BTFSC  x45.0
02A1E:  BRA    2A58
02A20:  DECFSZ x3A,W
02A22:  BRA    2A58
....................    res += 1.0;
02A24:  BCF    FD8.1
02A26:  MOVFF  742,74D
02A2A:  MOVFF  741,74C
02A2E:  MOVFF  740,74B
02A32:  MOVFF  73F,74A
02A36:  CLRF   x51
02A38:  CLRF   x50
02A3A:  CLRF   x4F
02A3C:  MOVLW  7F
02A3E:  MOVWF  x4E
02A40:  MOVLB  0
02A42:  CALL   0E60
02A46:  MOVFF  03,742
02A4A:  MOVFF  02,741
02A4E:  MOVFF  01,740
02A52:  MOVFF  00,73F
02A56:  MOVLB  7
....................  }
....................  if (x == 0)
02A58:  MOVFF  739,749
02A5C:  MOVFF  738,748
02A60:  MOVFF  737,747
02A64:  MOVFF  736,746
02A68:  CLRF   x4D
02A6A:  CLRF   x4C
02A6C:  CLRF   x4B
02A6E:  CLRF   x4A
02A70:  MOVLB  0
02A72:  CALL   1CF6
02A76:  BNZ   2A84
....................     res = 0;
02A78:  MOVLB  7
02A7A:  CLRF   x42
02A7C:  CLRF   x41
02A7E:  CLRF   x40
02A80:  CLRF   x3F
02A82:  MOVLB  0
.................... 
....................  return (res);
02A84:  MOVFF  73F,00
02A88:  MOVFF  740,01
02A8C:  MOVFF  741,02
02A90:  MOVFF  742,03
02A94:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AB4:  MOVFF  735,739
02AB8:  MOVFF  734,738
02ABC:  MOVFF  733,737
02AC0:  MOVFF  732,736
02AC4:  MOVLB  7
02AC6:  CLRF   x3A
02AC8:  MOVLB  0
02ACA:  RCALL  2726
02ACC:  GOTO   2BD8 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02A96:  MOVFF  735,739
02A9A:  MOVFF  734,738
02A9E:  MOVFF  733,737
02AA2:  MOVFF  732,736
02AA6:  MOVLW  01
02AA8:  MOVLB  7
02AAA:  MOVWF  x3A
02AAC:  MOVLB  0
02AAE:  RCALL  2726
02AB0:  GOTO   2B90 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02AD0:  MOVFF  729,749
02AD4:  MOVFF  728,748
02AD8:  MOVFF  727,747
02ADC:  MOVFF  726,746
02AE0:  MOVLB  7
02AE2:  CLRF   x4D
02AE4:  CLRF   x4C
02AE6:  CLRF   x4B
02AE8:  CLRF   x4A
02AEA:  MOVLB  0
02AEC:  CALL   1CF6
02AF0:  BTFSC  FD8.2
02AF2:  BRA    2C34
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02AF4:  MOVFF  725,742
02AF8:  MOVFF  724,741
02AFC:  MOVFF  723,740
02B00:  MOVFF  722,73F
02B04:  MOVFF  729,746
02B08:  MOVFF  728,745
02B0C:  MOVFF  727,744
02B10:  MOVFF  726,743
02B14:  CALL   1D70
02B18:  MOVFF  03,731
02B1C:  MOVFF  02,730
02B20:  MOVFF  01,72F
02B24:  MOVFF  00,72E
02B28:  MOVFF  03,749
02B2C:  MOVFF  02,748
02B30:  MOVFF  01,747
02B34:  MOVFF  00,746
02B38:  MOVLB  7
02B3A:  CLRF   x4D
02B3C:  CLRF   x4C
02B3E:  CLRF   x4B
02B40:  CLRF   x4A
02B42:  MOVLB  0
02B44:  CALL   1CF6
02B48:  BNC   2B92
02B4A:  MOVFF  725,742
02B4E:  MOVFF  724,741
02B52:  MOVFF  723,740
02B56:  MOVFF  722,73F
02B5A:  MOVFF  729,746
02B5E:  MOVFF  728,745
02B62:  MOVFF  727,744
02B66:  MOVFF  726,743
02B6A:  CALL   1D70
02B6E:  MOVFF  03,731
02B72:  MOVFF  02,730
02B76:  MOVFF  01,72F
02B7A:  MOVFF  00,72E
02B7E:  MOVFF  03,735
02B82:  MOVFF  02,734
02B86:  MOVFF  01,733
02B8A:  MOVFF  00,732
02B8E:  BRA    2A96
02B90:  BRA    2BD8
02B92:  MOVFF  725,742
02B96:  MOVFF  724,741
02B9A:  MOVFF  723,740
02B9E:  MOVFF  722,73F
02BA2:  MOVFF  729,746
02BA6:  MOVFF  728,745
02BAA:  MOVFF  727,744
02BAE:  MOVFF  726,743
02BB2:  CALL   1D70
02BB6:  MOVFF  03,731
02BBA:  MOVFF  02,730
02BBE:  MOVFF  01,72F
02BC2:  MOVFF  00,72E
02BC6:  MOVFF  03,735
02BCA:  MOVFF  02,734
02BCE:  MOVFF  01,733
02BD2:  MOVFF  00,732
02BD6:  BRA    2AB4
02BD8:  MOVFF  03,72D
02BDC:  MOVFF  02,72C
02BE0:  MOVFF  01,72B
02BE4:  MOVFF  00,72A
....................       return(x-(i*y));
02BE8:  MOVFF  72D,753
02BEC:  MOVFF  72C,752
02BF0:  MOVFF  72B,751
02BF4:  MOVFF  72A,750
02BF8:  MOVFF  729,757
02BFC:  MOVFF  728,756
02C00:  MOVFF  727,755
02C04:  MOVFF  726,754
02C08:  CALL   0D6A
02C0C:  BSF    FD8.1
02C0E:  MOVFF  725,74D
02C12:  MOVFF  724,74C
02C16:  MOVFF  723,74B
02C1A:  MOVFF  722,74A
02C1E:  MOVFF  03,751
02C22:  MOVFF  02,750
02C26:  MOVFF  01,74F
02C2A:  MOVFF  00,74E
02C2E:  CALL   0E60
02C32:  BRA    2C34
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C34:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02FCA:  MOVFF  729,753
02FCE:  MOVFF  728,752
02FD2:  MOVFF  727,751
02FD6:  MOVFF  726,750
02FDA:  MOVLW  3B
02FDC:  MOVLB  7
02FDE:  MOVWF  x57
02FE0:  MOVLW  AA
02FE2:  MOVWF  x56
02FE4:  MOVLW  38
02FE6:  MOVWF  x55
02FE8:  MOVLW  7F
02FEA:  MOVWF  x54
02FEC:  MOVLB  0
02FEE:  CALL   0D6A
02FF2:  MOVFF  03,749
02FF6:  MOVFF  02,748
02FFA:  MOVFF  01,747
02FFE:  MOVFF  00,746
03002:  CALL   26EA
03006:  MOVFF  01,736
....................    s = 0;
0300A:  MOVLB  7
0300C:  BCF    x37.0
....................    y = x;
0300E:  MOVFF  729,72D
03012:  MOVFF  728,72C
03016:  MOVFF  727,72B
0301A:  MOVFF  726,72A
.................... 
....................    if (x < 0)
0301E:  MOVFF  729,749
03022:  MOVFF  728,748
03026:  MOVFF  727,747
0302A:  MOVFF  726,746
0302E:  CLRF   x4D
03030:  CLRF   x4C
03032:  CLRF   x4B
03034:  CLRF   x4A
03036:  MOVLB  0
03038:  CALL   1CF6
0303C:  BNC   304C
....................    {
....................       s = 1;
0303E:  MOVLB  7
03040:  BSF    x37.0
....................       n = -n;
03042:  NEGF   x36
....................       y = -y;
03044:  MOVF   x2B,W
03046:  XORLW  80
03048:  MOVWF  x2B
0304A:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
0304C:  MOVLB  7
0304E:  CLRF   x31
03050:  CLRF   x30
03052:  CLRF   x2F
03054:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03056:  MOVLW  07
03058:  MOVWF  x39
0305A:  MOVLW  2E
0305C:  MOVFF  739,FEA
03060:  MOVWF  FE9
03062:  MOVLW  7F
03064:  ADDWF  x36,W
03066:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
03068:  MOVFF  72D,753
0306C:  MOVFF  72C,752
03070:  MOVFF  72B,751
03074:  MOVFF  72A,750
03078:  MOVLW  3B
0307A:  MOVWF  x57
0307C:  MOVLW  AA
0307E:  MOVWF  x56
03080:  MOVLW  38
03082:  MOVWF  x55
03084:  MOVLW  7F
03086:  MOVWF  x54
03088:  MOVLB  0
0308A:  CALL   0D6A
0308E:  MOVFF  03,73B
03092:  MOVFF  02,73A
03096:  MOVFF  01,739
0309A:  MOVFF  00,738
0309E:  MOVLB  7
030A0:  CLRF   x3D
030A2:  MOVFF  736,73C
030A6:  BTFSC  x3C.7
030A8:  DECF   x3D,F
030AA:  MOVLB  0
030AC:  CALL   269A
030B0:  BSF    FD8.1
030B2:  MOVFF  73B,74D
030B6:  MOVFF  73A,74C
030BA:  MOVFF  739,74B
030BE:  MOVFF  738,74A
030C2:  MOVFF  03,751
030C6:  MOVFF  02,750
030CA:  MOVFF  01,74F
030CE:  MOVFF  00,74E
030D2:  CALL   0E60
030D6:  MOVFF  03,72D
030DA:  MOVFF  02,72C
030DE:  MOVFF  01,72B
030E2:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
030E6:  MOVLW  7C
030E8:  MOVLB  7
030EA:  MOVWF  x53
030EC:  MOVLW  88
030EE:  MOVWF  x52
030F0:  MOVLW  59
030F2:  MOVWF  x51
030F4:  MOVLW  72
030F6:  MOVWF  x50
030F8:  MOVFF  72D,757
030FC:  MOVFF  72C,756
03100:  MOVFF  72B,755
03104:  MOVFF  72A,754
03108:  MOVLB  0
0310A:  CALL   0D6A
0310E:  MOVFF  03,73B
03112:  MOVFF  02,73A
03116:  MOVFF  01,739
0311A:  MOVFF  00,738
0311E:  BCF    FD8.1
03120:  MOVFF  03,74D
03124:  MOVFF  02,74C
03128:  MOVFF  01,74B
0312C:  MOVFF  00,74A
03130:  MOVLW  E0
03132:  MOVLB  7
03134:  MOVWF  x51
03136:  MOVLW  97
03138:  MOVWF  x50
0313A:  MOVLW  26
0313C:  MOVWF  x4F
0313E:  MOVLW  75
03140:  MOVWF  x4E
03142:  MOVLB  0
03144:  CALL   0E60
03148:  MOVFF  03,735
0314C:  MOVFF  02,734
03150:  MOVFF  01,733
03154:  MOVFF  00,732
....................    r = r*y + pe[2];
03158:  MOVFF  735,753
0315C:  MOVFF  734,752
03160:  MOVFF  733,751
03164:  MOVFF  732,750
03168:  MOVFF  72D,757
0316C:  MOVFF  72C,756
03170:  MOVFF  72B,755
03174:  MOVFF  72A,754
03178:  CALL   0D6A
0317C:  MOVFF  03,73B
03180:  MOVFF  02,73A
03184:  MOVFF  01,739
03188:  MOVFF  00,738
0318C:  BCF    FD8.1
0318E:  MOVFF  03,74D
03192:  MOVFF  02,74C
03196:  MOVFF  01,74B
0319A:  MOVFF  00,74A
0319E:  MOVLW  C4
031A0:  MOVLB  7
031A2:  MOVWF  x51
031A4:  MOVLW  1D
031A6:  MOVWF  x50
031A8:  MOVLW  1E
031AA:  MOVWF  x4F
031AC:  MOVLW  78
031AE:  MOVWF  x4E
031B0:  MOVLB  0
031B2:  CALL   0E60
031B6:  MOVFF  03,735
031BA:  MOVFF  02,734
031BE:  MOVFF  01,733
031C2:  MOVFF  00,732
....................    r = r*y + pe[3];
031C6:  MOVFF  735,753
031CA:  MOVFF  734,752
031CE:  MOVFF  733,751
031D2:  MOVFF  732,750
031D6:  MOVFF  72D,757
031DA:  MOVFF  72C,756
031DE:  MOVFF  72B,755
031E2:  MOVFF  72A,754
031E6:  CALL   0D6A
031EA:  MOVFF  03,73B
031EE:  MOVFF  02,73A
031F2:  MOVFF  01,739
031F6:  MOVFF  00,738
031FA:  BCF    FD8.1
031FC:  MOVFF  03,74D
03200:  MOVFF  02,74C
03204:  MOVFF  01,74B
03208:  MOVFF  00,74A
0320C:  MOVLW  5E
0320E:  MOVLB  7
03210:  MOVWF  x51
03212:  MOVLW  50
03214:  MOVWF  x50
03216:  MOVLW  63
03218:  MOVWF  x4F
0321A:  MOVLW  7A
0321C:  MOVWF  x4E
0321E:  MOVLB  0
03220:  CALL   0E60
03224:  MOVFF  03,735
03228:  MOVFF  02,734
0322C:  MOVFF  01,733
03230:  MOVFF  00,732
....................    r = r*y + pe[4];
03234:  MOVFF  735,753
03238:  MOVFF  734,752
0323C:  MOVFF  733,751
03240:  MOVFF  732,750
03244:  MOVFF  72D,757
03248:  MOVFF  72C,756
0324C:  MOVFF  72B,755
03250:  MOVFF  72A,754
03254:  CALL   0D6A
03258:  MOVFF  03,73B
0325C:  MOVFF  02,73A
03260:  MOVFF  01,739
03264:  MOVFF  00,738
03268:  BCF    FD8.1
0326A:  MOVFF  03,74D
0326E:  MOVFF  02,74C
03272:  MOVFF  01,74B
03276:  MOVFF  00,74A
0327A:  MOVLW  1A
0327C:  MOVLB  7
0327E:  MOVWF  x51
03280:  MOVLW  FE
03282:  MOVWF  x50
03284:  MOVLW  75
03286:  MOVWF  x4F
03288:  MOVLW  7C
0328A:  MOVWF  x4E
0328C:  MOVLB  0
0328E:  CALL   0E60
03292:  MOVFF  03,735
03296:  MOVFF  02,734
0329A:  MOVFF  01,733
0329E:  MOVFF  00,732
....................    r = r*y + pe[5];
032A2:  MOVFF  735,753
032A6:  MOVFF  734,752
032AA:  MOVFF  733,751
032AE:  MOVFF  732,750
032B2:  MOVFF  72D,757
032B6:  MOVFF  72C,756
032BA:  MOVFF  72B,755
032BE:  MOVFF  72A,754
032C2:  CALL   0D6A
032C6:  MOVFF  03,73B
032CA:  MOVFF  02,73A
032CE:  MOVFF  01,739
032D2:  MOVFF  00,738
032D6:  BCF    FD8.1
032D8:  MOVFF  03,74D
032DC:  MOVFF  02,74C
032E0:  MOVFF  01,74B
032E4:  MOVFF  00,74A
032E8:  MOVLW  18
032EA:  MOVLB  7
032EC:  MOVWF  x51
032EE:  MOVLW  72
032F0:  MOVWF  x50
032F2:  MOVLW  31
032F4:  MOVWF  x4F
032F6:  MOVLW  7E
032F8:  MOVWF  x4E
032FA:  MOVLB  0
032FC:  CALL   0E60
03300:  MOVFF  03,735
03304:  MOVFF  02,734
03308:  MOVFF  01,733
0330C:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
03310:  MOVFF  72D,753
03314:  MOVFF  72C,752
03318:  MOVFF  72B,751
0331C:  MOVFF  72A,750
03320:  MOVFF  735,757
03324:  MOVFF  734,756
03328:  MOVFF  733,755
0332C:  MOVFF  732,754
03330:  CALL   0D6A
03334:  BCF    FD8.1
03336:  MOVLB  7
03338:  CLRF   x4D
0333A:  CLRF   x4C
0333C:  CLRF   x4B
0333E:  MOVLW  7F
03340:  MOVWF  x4A
03342:  MOVFF  03,751
03346:  MOVFF  02,750
0334A:  MOVFF  01,74F
0334E:  MOVFF  00,74E
03352:  MOVLB  0
03354:  CALL   0E60
03358:  MOVFF  731,753
0335C:  MOVFF  730,752
03360:  MOVFF  72F,751
03364:  MOVFF  72E,750
03368:  MOVFF  03,757
0336C:  MOVFF  02,756
03370:  MOVFF  01,755
03374:  MOVFF  00,754
03378:  CALL   0D6A
0337C:  MOVFF  03,731
03380:  MOVFF  02,730
03384:  MOVFF  01,72F
03388:  MOVFF  00,72E
.................... 
....................    if (s)
0338C:  MOVLB  7
0338E:  BTFSS  x37.0
03390:  BRA    33C4
....................       res = 1.0/res;
03392:  CLRF   x42
03394:  CLRF   x41
03396:  CLRF   x40
03398:  MOVLW  7F
0339A:  MOVWF  x3F
0339C:  MOVFF  731,746
033A0:  MOVFF  730,745
033A4:  MOVFF  72F,744
033A8:  MOVFF  72E,743
033AC:  MOVLB  0
033AE:  CALL   1D70
033B2:  MOVFF  03,731
033B6:  MOVFF  02,730
033BA:  MOVFF  01,72F
033BE:  MOVFF  00,72E
033C2:  MOVLB  7
....................    return(res);
033C4:  MOVFF  72E,00
033C8:  MOVFF  72F,01
033CC:  MOVFF  730,02
033D0:  MOVFF  731,03
033D4:  MOVLB  0
033D6:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C36:  MOVFF  729,72D
02C3A:  MOVFF  728,72C
02C3E:  MOVFF  727,72B
02C42:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C46:  MOVFF  72D,749
02C4A:  MOVFF  72C,748
02C4E:  MOVFF  72B,747
02C52:  MOVFF  72A,746
02C56:  MOVLB  7
02C58:  CLRF   x4D
02C5A:  CLRF   x4C
02C5C:  CLRF   x4B
02C5E:  MOVLW  7F
02C60:  MOVWF  x4A
02C62:  MOVLB  0
02C64:  CALL   1CF6
02C68:  BTFSC  FD8.2
02C6A:  BRA    2FAC
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02C6C:  MOVLW  07
02C6E:  MOVLB  7
02C70:  MOVWF  x3C
02C72:  MOVLW  2A
02C74:  MOVFF  73C,FEA
02C78:  MOVWF  FE9
02C7A:  MOVLW  7E
02C7C:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02C7E:  BSF    FD8.1
02C80:  MOVFF  72D,74D
02C84:  MOVFF  72C,74C
02C88:  MOVFF  72B,74B
02C8C:  MOVFF  72A,74A
02C90:  CLRF   x51
02C92:  CLRF   x50
02C94:  CLRF   x4F
02C96:  MOVLW  7F
02C98:  MOVWF  x4E
02C9A:  MOVLB  0
02C9C:  CALL   0E60
02CA0:  MOVFF  03,73E
02CA4:  MOVFF  02,73D
02CA8:  MOVFF  01,73C
02CAC:  MOVFF  00,73B
02CB0:  BCF    FD8.1
02CB2:  MOVFF  72D,74D
02CB6:  MOVFF  72C,74C
02CBA:  MOVFF  72B,74B
02CBE:  MOVFF  72A,74A
02CC2:  MOVLB  7
02CC4:  CLRF   x51
02CC6:  CLRF   x50
02CC8:  CLRF   x4F
02CCA:  MOVLW  7F
02CCC:  MOVWF  x4E
02CCE:  MOVLB  0
02CD0:  CALL   0E60
02CD4:  MOVFF  73E,742
02CD8:  MOVFF  73D,741
02CDC:  MOVFF  73C,740
02CE0:  MOVFF  73B,73F
02CE4:  MOVFF  03,746
02CE8:  MOVFF  02,745
02CEC:  MOVFF  01,744
02CF0:  MOVFF  00,743
02CF4:  CALL   1D70
02CF8:  MOVFF  03,72D
02CFC:  MOVFF  02,72C
02D00:  MOVFF  01,72B
02D04:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D08:  MOVFF  72D,753
02D0C:  MOVFF  72C,752
02D10:  MOVFF  72B,751
02D14:  MOVFF  72A,750
02D18:  MOVFF  72D,757
02D1C:  MOVFF  72C,756
02D20:  MOVFF  72B,755
02D24:  MOVFF  72A,754
02D28:  CALL   0D6A
02D2C:  MOVFF  03,739
02D30:  MOVFF  02,738
02D34:  MOVFF  01,737
02D38:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D3C:  MOVLW  99
02D3E:  MOVLB  7
02D40:  MOVWF  x53
02D42:  MOVLW  47
02D44:  MOVWF  x52
02D46:  MOVLW  8A
02D48:  MOVWF  x51
02D4A:  MOVLW  7F
02D4C:  MOVWF  x50
02D4E:  MOVFF  739,757
02D52:  MOVFF  738,756
02D56:  MOVFF  737,755
02D5A:  MOVFF  736,754
02D5E:  MOVLB  0
02D60:  CALL   0D6A
02D64:  MOVFF  03,73E
02D68:  MOVFF  02,73D
02D6C:  MOVFF  01,73C
02D70:  MOVFF  00,73B
02D74:  BCF    FD8.1
02D76:  MOVFF  03,74D
02D7A:  MOVFF  02,74C
02D7E:  MOVFF  01,74B
02D82:  MOVFF  00,74A
02D86:  MOVLB  7
02D88:  CLRF   x51
02D8A:  CLRF   x50
02D8C:  CLRF   x4F
02D8E:  MOVLW  80
02D90:  MOVWF  x4E
02D92:  MOVLB  0
02D94:  CALL   0E60
02D98:  MOVFF  03,731
02D9C:  MOVFF  02,730
02DA0:  MOVFF  01,72F
02DA4:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DA8:  MOVLW  4C
02DAA:  MOVLB  7
02DAC:  MOVWF  x53
02DAE:  MOVLW  F3
02DB0:  MOVWF  x52
02DB2:  MOVLW  3A
02DB4:  MOVWF  x51
02DB6:  MOVLW  7B
02DB8:  MOVWF  x50
02DBA:  MOVFF  739,757
02DBE:  MOVFF  738,756
02DC2:  MOVFF  737,755
02DC6:  MOVFF  736,754
02DCA:  MOVLB  0
02DCC:  CALL   0D6A
02DD0:  MOVFF  03,73E
02DD4:  MOVFF  02,73D
02DD8:  MOVFF  01,73C
02DDC:  MOVFF  00,73B
02DE0:  BCF    FD8.1
02DE2:  MOVFF  03,74D
02DE6:  MOVFF  02,74C
02DEA:  MOVFF  01,74B
02DEE:  MOVFF  00,74A
02DF2:  MOVLW  2B
02DF4:  MOVLB  7
02DF6:  MOVWF  x51
02DF8:  MOVLW  9D
02DFA:  MOVWF  x50
02DFC:  MOVLW  DF
02DFE:  MOVWF  x4F
02E00:  MOVLW  7E
02E02:  MOVWF  x4E
02E04:  MOVLB  0
02E06:  CALL   0E60
02E0A:  MOVFF  03,735
02E0E:  MOVFF  02,734
02E12:  MOVFF  01,733
02E16:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E1A:  MOVFF  735,753
02E1E:  MOVFF  734,752
02E22:  MOVFF  733,751
02E26:  MOVFF  732,750
02E2A:  MOVFF  739,757
02E2E:  MOVFF  738,756
02E32:  MOVFF  737,755
02E36:  MOVFF  736,754
02E3A:  CALL   0D6A
02E3E:  MOVFF  03,73E
02E42:  MOVFF  02,73D
02E46:  MOVFF  01,73C
02E4A:  MOVFF  00,73B
02E4E:  BCF    FD8.1
02E50:  MOVFF  03,74D
02E54:  MOVFF  02,74C
02E58:  MOVFF  01,74B
02E5C:  MOVFF  00,74A
02E60:  MOVLB  7
02E62:  CLRF   x51
02E64:  CLRF   x50
02E66:  CLRF   x4F
02E68:  MOVLW  7F
02E6A:  MOVWF  x4E
02E6C:  MOVLB  0
02E6E:  CALL   0E60
02E72:  MOVFF  03,735
02E76:  MOVFF  02,734
02E7A:  MOVFF  01,733
02E7E:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02E82:  MOVFF  72D,753
02E86:  MOVFF  72C,752
02E8A:  MOVFF  72B,751
02E8E:  MOVFF  72A,750
02E92:  MOVFF  731,757
02E96:  MOVFF  730,756
02E9A:  MOVFF  72F,755
02E9E:  MOVFF  72E,754
02EA2:  CALL   0D6A
02EA6:  MOVFF  03,73E
02EAA:  MOVFF  02,73D
02EAE:  MOVFF  01,73C
02EB2:  MOVFF  00,73B
02EB6:  MOVFF  03,742
02EBA:  MOVFF  02,741
02EBE:  MOVFF  01,740
02EC2:  MOVFF  00,73F
02EC6:  MOVFF  735,746
02ECA:  MOVFF  734,745
02ECE:  MOVFF  733,744
02ED2:  MOVFF  732,743
02ED6:  CALL   1D70
02EDA:  MOVFF  03,731
02EDE:  MOVFF  02,730
02EE2:  MOVFF  01,72F
02EE6:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02EEA:  MOVLW  07
02EEC:  MOVLB  7
02EEE:  MOVWF  x3C
02EF0:  MOVLW  26
02EF2:  MOVFF  73C,FEA
02EF6:  MOVWF  FE9
02EF8:  MOVLW  7E
02EFA:  SUBWF  FEF,W
02EFC:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02EFE:  BTFSS  x3A.7
02F00:  BRA    2F2C
....................          r = -(float32)-n;
02F02:  MOVLW  00
02F04:  BSF    FD8.0
02F06:  SUBFWB x3A,W
02F08:  CLRF   x3D
02F0A:  MOVWF  x3C
02F0C:  BTFSC  x3C.7
02F0E:  DECF   x3D,F
02F10:  MOVLB  0
02F12:  CALL   269A
02F16:  MOVFF  00,732
02F1A:  MOVF   01,W
02F1C:  XORLW  80
02F1E:  MOVLB  7
02F20:  MOVWF  x33
02F22:  MOVFF  02,734
02F26:  MOVFF  03,735
02F2A:  BRA    2F4E
....................       else
....................          r = (float32)n;
02F2C:  CLRF   x3D
02F2E:  MOVFF  73A,73C
02F32:  BTFSC  x3C.7
02F34:  DECF   x3D,F
02F36:  MOVLB  0
02F38:  CALL   269A
02F3C:  MOVFF  03,735
02F40:  MOVFF  02,734
02F44:  MOVFF  01,733
02F48:  MOVFF  00,732
02F4C:  MOVLB  7
.................... 
....................       res += r*LN2;
02F4E:  MOVFF  735,753
02F52:  MOVFF  734,752
02F56:  MOVFF  733,751
02F5A:  MOVFF  732,750
02F5E:  MOVLW  18
02F60:  MOVWF  x57
02F62:  MOVLW  72
02F64:  MOVWF  x56
02F66:  MOVLW  31
02F68:  MOVWF  x55
02F6A:  MOVLW  7E
02F6C:  MOVWF  x54
02F6E:  MOVLB  0
02F70:  CALL   0D6A
02F74:  BCF    FD8.1
02F76:  MOVFF  731,74D
02F7A:  MOVFF  730,74C
02F7E:  MOVFF  72F,74B
02F82:  MOVFF  72E,74A
02F86:  MOVFF  03,751
02F8A:  MOVFF  02,750
02F8E:  MOVFF  01,74F
02F92:  MOVFF  00,74E
02F96:  CALL   0E60
02F9A:  MOVFF  03,731
02F9E:  MOVFF  02,730
02FA2:  MOVFF  01,72F
02FA6:  MOVFF  00,72E
....................    }
02FAA:  BRA    2FB8
.................... 
....................    else
....................       res = 0.0;
02FAC:  MOVLB  7
02FAE:  CLRF   x31
02FB0:  CLRF   x30
02FB2:  CLRF   x2F
02FB4:  CLRF   x2E
02FB6:  MOVLB  0
.................... 
....................    return(res);
02FB8:  MOVFF  72E,00
02FBC:  MOVFF  72F,01
02FC0:  MOVFF  730,02
02FC4:  MOVFF  731,03
02FC8:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
033D8:  MOVFF  71D,749
033DC:  MOVFF  71C,748
033E0:  MOVFF  71B,747
033E4:  MOVFF  71A,746
033E8:  MOVLB  7
033EA:  CLRF   x4D
033EC:  CLRF   x4C
033EE:  CLRF   x4B
033F0:  CLRF   x4A
033F2:  MOVLB  0
033F4:  CALL   1CF6
033F8:  BTFSS  FD8.0
033FA:  BRA    3596
033FC:  MOVFF  721,725
03400:  MOVFF  720,724
03404:  MOVFF  71F,723
03408:  MOVFF  71E,722
0340C:  MOVLB  7
0340E:  CLRF   x29
03410:  CLRF   x28
03412:  CLRF   x27
03414:  MOVLW  7F
03416:  MOVWF  x26
03418:  MOVLB  0
0341A:  CALL   2AD0
0341E:  MOVFF  03,725
03422:  MOVFF  02,724
03426:  MOVFF  01,723
0342A:  MOVFF  00,722
0342E:  MOVFF  03,749
03432:  MOVFF  02,748
03436:  MOVFF  01,747
0343A:  MOVFF  00,746
0343E:  MOVLB  7
03440:  CLRF   x4D
03442:  CLRF   x4C
03444:  CLRF   x4B
03446:  CLRF   x4A
03448:  MOVLB  0
0344A:  CALL   1CF6
0344E:  BTFSS  FD8.2
03450:  BRA    3596
....................       if(fmod(y, 2) == 0) {
03452:  MOVFF  721,725
03456:  MOVFF  720,724
0345A:  MOVFF  71F,723
0345E:  MOVFF  71E,722
03462:  MOVLB  7
03464:  CLRF   x29
03466:  CLRF   x28
03468:  CLRF   x27
0346A:  MOVLW  80
0346C:  MOVWF  x26
0346E:  MOVLB  0
03470:  CALL   2AD0
03474:  MOVFF  03,725
03478:  MOVFF  02,724
0347C:  MOVFF  01,723
03480:  MOVFF  00,722
03484:  MOVFF  03,749
03488:  MOVFF  02,748
0348C:  MOVFF  01,747
03490:  MOVFF  00,746
03494:  MOVLB  7
03496:  CLRF   x4D
03498:  CLRF   x4C
0349A:  CLRF   x4B
0349C:  CLRF   x4A
0349E:  MOVLB  0
034A0:  CALL   1CF6
034A4:  BNZ   351C
....................          return (exp(log(-x) * y));
034A6:  MOVLB  7
034A8:  MOVF   x1B,W
034AA:  XORLW  80
034AC:  MOVWF  x23
034AE:  MOVFF  71D,729
034B2:  MOVFF  71C,728
034B6:  MOVWF  x27
034B8:  MOVFF  71A,726
034BC:  MOVLB  0
034BE:  CALL   2C36
034C2:  MOVFF  03,725
034C6:  MOVFF  02,724
034CA:  MOVFF  01,723
034CE:  MOVFF  00,722
034D2:  MOVFF  03,753
034D6:  MOVFF  02,752
034DA:  MOVFF  01,751
034DE:  MOVFF  00,750
034E2:  MOVFF  721,757
034E6:  MOVFF  720,756
034EA:  MOVFF  71F,755
034EE:  MOVFF  71E,754
034F2:  CALL   0D6A
034F6:  MOVFF  03,725
034FA:  MOVFF  02,724
034FE:  MOVFF  01,723
03502:  MOVFF  00,722
03506:  MOVFF  03,729
0350A:  MOVFF  02,728
0350E:  MOVFF  01,727
03512:  MOVFF  00,726
03516:  RCALL  2FCA
03518:  BRA    36D4
....................       } else {
0351A:  BRA    3594
....................          return (-exp(log(-x) * y));
0351C:  MOVLB  7
0351E:  MOVF   x1B,W
03520:  XORLW  80
03522:  MOVWF  x23
03524:  MOVFF  71D,729
03528:  MOVFF  71C,728
0352C:  MOVWF  x27
0352E:  MOVFF  71A,726
03532:  MOVLB  0
03534:  CALL   2C36
03538:  MOVFF  03,725
0353C:  MOVFF  02,724
03540:  MOVFF  01,723
03544:  MOVFF  00,722
03548:  MOVFF  03,753
0354C:  MOVFF  02,752
03550:  MOVFF  01,751
03554:  MOVFF  00,750
03558:  MOVFF  721,757
0355C:  MOVFF  720,756
03560:  MOVFF  71F,755
03564:  MOVFF  71E,754
03568:  CALL   0D6A
0356C:  MOVFF  03,725
03570:  MOVFF  02,724
03574:  MOVFF  01,723
03578:  MOVFF  00,722
0357C:  MOVFF  03,729
03580:  MOVFF  02,728
03584:  MOVFF  01,727
03588:  MOVFF  00,726
0358C:  RCALL  2FCA
0358E:  MOVLW  80
03590:  XORWF  01,F
03592:  BRA    36D4
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
03594:  BRA    36D4
03596:  MOVFF  71D,749
0359A:  MOVFF  71C,748
0359E:  MOVFF  71B,747
035A2:  MOVFF  71A,746
035A6:  MOVLB  7
035A8:  CLRF   x4D
035AA:  CLRF   x4C
035AC:  CLRF   x4B
035AE:  CLRF   x4A
035B0:  MOVLB  0
035B2:  CALL   1CF6
035B6:  BNC   3618
035B8:  MOVFF  721,725
035BC:  MOVFF  720,724
035C0:  MOVFF  71F,723
035C4:  MOVFF  71E,722
035C8:  MOVLB  7
035CA:  CLRF   x29
035CC:  CLRF   x28
035CE:  CLRF   x27
035D0:  MOVLW  7F
035D2:  MOVWF  x26
035D4:  MOVLB  0
035D6:  CALL   2AD0
035DA:  MOVFF  03,725
035DE:  MOVFF  02,724
035E2:  MOVFF  01,723
035E6:  MOVFF  00,722
035EA:  MOVFF  03,749
035EE:  MOVFF  02,748
035F2:  MOVFF  01,747
035F6:  MOVFF  00,746
035FA:  MOVLB  7
035FC:  CLRF   x4D
035FE:  CLRF   x4C
03600:  CLRF   x4B
03602:  CLRF   x4A
03604:  MOVLB  0
03606:  CALL   1CF6
0360A:  BZ    3618
....................       return 0;
0360C:  CLRF   00
0360E:  CLRF   01
03610:  CLRF   02
03612:  CLRF   03
03614:  BRA    36D4
....................    } else {
03616:  BRA    36D4
....................       if(x != 0 || 0 >= y) {
03618:  MOVFF  71D,749
0361C:  MOVFF  71C,748
03620:  MOVFF  71B,747
03624:  MOVFF  71A,746
03628:  MOVLB  7
0362A:  CLRF   x4D
0362C:  CLRF   x4C
0362E:  CLRF   x4B
03630:  CLRF   x4A
03632:  MOVLB  0
03634:  CALL   1CF6
03638:  BNZ   365E
0363A:  MOVFF  721,749
0363E:  MOVFF  720,748
03642:  MOVFF  71F,747
03646:  MOVFF  71E,746
0364A:  MOVLB  7
0364C:  CLRF   x4D
0364E:  CLRF   x4C
03650:  CLRF   x4B
03652:  CLRF   x4A
03654:  MOVLB  0
03656:  CALL   1CF6
0365A:  BC    365E
0365C:  BNZ   36CC
....................          return (exp(log(x) * y));
0365E:  MOVFF  71D,729
03662:  MOVFF  71C,728
03666:  MOVFF  71B,727
0366A:  MOVFF  71A,726
0366E:  CALL   2C36
03672:  MOVFF  03,725
03676:  MOVFF  02,724
0367A:  MOVFF  01,723
0367E:  MOVFF  00,722
03682:  MOVFF  03,753
03686:  MOVFF  02,752
0368A:  MOVFF  01,751
0368E:  MOVFF  00,750
03692:  MOVFF  721,757
03696:  MOVFF  720,756
0369A:  MOVFF  71F,755
0369E:  MOVFF  71E,754
036A2:  CALL   0D6A
036A6:  MOVFF  03,725
036AA:  MOVFF  02,724
036AE:  MOVFF  01,723
036B2:  MOVFF  00,722
036B6:  MOVFF  03,729
036BA:  MOVFF  02,728
036BE:  MOVFF  01,727
036C2:  MOVFF  00,726
036C6:  RCALL  2FCA
036C8:  BRA    36D4
....................       } else return 0;
036CA:  BRA    36D4
036CC:  CLRF   00
036CE:  CLRF   01
036D0:  CLRF   02
036D2:  CLRF   03
....................    }
036D4:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01ECE:  MOVLB  7
01ED0:  BCF    x38.0
....................    flag = 0;
01ED2:  BCF    x38.1
....................    y = x;
01ED4:  MOVFF  72B,72F
01ED8:  MOVFF  72A,72E
01EDC:  MOVFF  729,72D
01EE0:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01EE4:  MOVFF  72B,749
01EE8:  MOVFF  72A,748
01EEC:  MOVFF  729,747
01EF0:  MOVFF  728,746
01EF4:  CLRF   x4D
01EF6:  CLRF   x4C
01EF8:  CLRF   x4B
01EFA:  CLRF   x4A
01EFC:  MOVLB  0
01EFE:  RCALL  1CF6
01F00:  BNC   1F0E
....................    {
....................       s = 1;
01F02:  MOVLB  7
01F04:  BSF    x38.0
....................       y = -y;
01F06:  MOVF   x2D,W
01F08:  XORLW  80
01F0A:  MOVWF  x2D
01F0C:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F0E:  MOVLB  7
01F10:  CLRF   x49
01F12:  CLRF   x48
01F14:  CLRF   x47
01F16:  MOVLW  7F
01F18:  MOVWF  x46
01F1A:  MOVFF  72F,74D
01F1E:  MOVFF  72E,74C
01F22:  MOVFF  72D,74B
01F26:  MOVFF  72C,74A
01F2A:  MOVLB  0
01F2C:  RCALL  1CF6
01F2E:  BNC   1F66
....................    {
....................       y = 1.0/y;
01F30:  MOVLB  7
01F32:  CLRF   x42
01F34:  CLRF   x41
01F36:  CLRF   x40
01F38:  MOVLW  7F
01F3A:  MOVWF  x3F
01F3C:  MOVFF  72F,746
01F40:  MOVFF  72E,745
01F44:  MOVFF  72D,744
01F48:  MOVFF  72C,743
01F4C:  MOVLB  0
01F4E:  RCALL  1D70
01F50:  MOVFF  03,72F
01F54:  MOVFF  02,72E
01F58:  MOVFF  01,72D
01F5C:  MOVFF  00,72C
....................       flag = 1;
01F60:  MOVLB  7
01F62:  BSF    x38.1
01F64:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01F66:  MOVLW  0A
01F68:  MOVLB  7
01F6A:  MOVWF  x53
01F6C:  MOVLW  89
01F6E:  MOVWF  x52
01F70:  MOVLW  34
01F72:  MOVWF  x51
01F74:  MOVLW  7C
01F76:  MOVWF  x50
01F78:  MOVFF  72F,757
01F7C:  MOVFF  72E,756
01F80:  MOVFF  72D,755
01F84:  MOVFF  72C,754
01F88:  MOVLB  0
01F8A:  CALL   0D6A
01F8E:  MOVFF  03,73C
01F92:  MOVFF  02,73B
01F96:  MOVFF  01,73A
01F9A:  MOVFF  00,739
01F9E:  MOVFF  03,753
01FA2:  MOVFF  02,752
01FA6:  MOVFF  01,751
01FAA:  MOVFF  00,750
01FAE:  MOVFF  72F,757
01FB2:  MOVFF  72E,756
01FB6:  MOVFF  72D,755
01FBA:  MOVFF  72C,754
01FBE:  CALL   0D6A
01FC2:  MOVFF  03,73C
01FC6:  MOVFF  02,73B
01FCA:  MOVFF  01,73A
01FCE:  MOVFF  00,739
01FD2:  BCF    FD8.1
01FD4:  MOVFF  03,74D
01FD8:  MOVFF  02,74C
01FDC:  MOVFF  01,74B
01FE0:  MOVFF  00,74A
01FE4:  MOVLW  7C
01FE6:  MOVLB  7
01FE8:  MOVWF  x51
01FEA:  MOVLW  79
01FEC:  MOVWF  x50
01FEE:  MOVLW  35
01FF0:  MOVWF  x4F
01FF2:  MOVLW  81
01FF4:  MOVWF  x4E
01FF6:  MOVLB  0
01FF8:  CALL   0E60
01FFC:  MOVFF  03,733
02000:  MOVFF  02,732
02004:  MOVFF  01,731
02008:  MOVFF  00,730
....................    res = res*y*y + pat[2];
0200C:  MOVFF  733,753
02010:  MOVFF  732,752
02014:  MOVFF  731,751
02018:  MOVFF  730,750
0201C:  MOVFF  72F,757
02020:  MOVFF  72E,756
02024:  MOVFF  72D,755
02028:  MOVFF  72C,754
0202C:  CALL   0D6A
02030:  MOVFF  03,73C
02034:  MOVFF  02,73B
02038:  MOVFF  01,73A
0203C:  MOVFF  00,739
02040:  MOVFF  03,753
02044:  MOVFF  02,752
02048:  MOVFF  01,751
0204C:  MOVFF  00,750
02050:  MOVFF  72F,757
02054:  MOVFF  72E,756
02058:  MOVFF  72D,755
0205C:  MOVFF  72C,754
02060:  CALL   0D6A
02064:  MOVFF  03,73C
02068:  MOVFF  02,73B
0206C:  MOVFF  01,73A
02070:  MOVFF  00,739
02074:  BCF    FD8.1
02076:  MOVFF  03,74D
0207A:  MOVFF  02,74C
0207E:  MOVFF  01,74B
02082:  MOVFF  00,74A
02086:  MOVLW  3F
02088:  MOVLB  7
0208A:  MOVWF  x51
0208C:  MOVLW  02
0208E:  MOVWF  x50
02090:  MOVLW  33
02092:  MOVWF  x4F
02094:  MOVLW  83
02096:  MOVWF  x4E
02098:  MOVLB  0
0209A:  CALL   0E60
0209E:  MOVFF  03,733
020A2:  MOVFF  02,732
020A6:  MOVFF  01,731
020AA:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020AE:  MOVFF  733,753
020B2:  MOVFF  732,752
020B6:  MOVFF  731,751
020BA:  MOVFF  730,750
020BE:  MOVFF  72F,757
020C2:  MOVFF  72E,756
020C6:  MOVFF  72D,755
020CA:  MOVFF  72C,754
020CE:  CALL   0D6A
020D2:  MOVFF  03,73C
020D6:  MOVFF  02,73B
020DA:  MOVFF  01,73A
020DE:  MOVFF  00,739
020E2:  MOVFF  03,753
020E6:  MOVFF  02,752
020EA:  MOVFF  01,751
020EE:  MOVFF  00,750
020F2:  MOVFF  72F,757
020F6:  MOVFF  72E,756
020FA:  MOVFF  72D,755
020FE:  MOVFF  72C,754
02102:  CALL   0D6A
02106:  MOVFF  03,73C
0210A:  MOVFF  02,73B
0210E:  MOVFF  01,73A
02112:  MOVFF  00,739
02116:  BCF    FD8.1
02118:  MOVFF  03,74D
0211C:  MOVFF  02,74C
02120:  MOVFF  01,74B
02124:  MOVFF  00,74A
02128:  MOVLW  33
0212A:  MOVLB  7
0212C:  MOVWF  x51
0212E:  MOVLW  8C
02130:  MOVWF  x50
02132:  MOVLW  1E
02134:  MOVWF  x4F
02136:  MOVLW  83
02138:  MOVWF  x4E
0213A:  MOVLB  0
0213C:  CALL   0E60
02140:  MOVFF  03,733
02144:  MOVFF  02,732
02148:  MOVFF  01,731
0214C:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
02150:  MOVLB  7
02152:  CLRF   x53
02154:  CLRF   x52
02156:  CLRF   x51
02158:  MOVLW  7F
0215A:  MOVWF  x50
0215C:  MOVFF  72F,757
02160:  MOVFF  72E,756
02164:  MOVFF  72D,755
02168:  MOVFF  72C,754
0216C:  MOVLB  0
0216E:  CALL   0D6A
02172:  MOVFF  03,73C
02176:  MOVFF  02,73B
0217A:  MOVFF  01,73A
0217E:  MOVFF  00,739
02182:  MOVFF  03,753
02186:  MOVFF  02,752
0218A:  MOVFF  01,751
0218E:  MOVFF  00,750
02192:  MOVFF  72F,757
02196:  MOVFF  72E,756
0219A:  MOVFF  72D,755
0219E:  MOVFF  72C,754
021A2:  CALL   0D6A
021A6:  MOVFF  03,73C
021AA:  MOVFF  02,73B
021AE:  MOVFF  01,73A
021B2:  MOVFF  00,739
021B6:  BCF    FD8.1
021B8:  MOVFF  03,74D
021BC:  MOVFF  02,74C
021C0:  MOVFF  01,74B
021C4:  MOVFF  00,74A
021C8:  MOVLW  1B
021CA:  MOVLB  7
021CC:  MOVWF  x51
021CE:  MOVLW  E4
021D0:  MOVWF  x50
021D2:  MOVLW  35
021D4:  MOVWF  x4F
021D6:  MOVLW  82
021D8:  MOVWF  x4E
021DA:  MOVLB  0
021DC:  CALL   0E60
021E0:  MOVFF  03,737
021E4:  MOVFF  02,736
021E8:  MOVFF  01,735
021EC:  MOVFF  00,734
....................    r = r*y*y + qat[2];
021F0:  MOVFF  737,753
021F4:  MOVFF  736,752
021F8:  MOVFF  735,751
021FC:  MOVFF  734,750
02200:  MOVFF  72F,757
02204:  MOVFF  72E,756
02208:  MOVFF  72D,755
0220C:  MOVFF  72C,754
02210:  CALL   0D6A
02214:  MOVFF  03,73C
02218:  MOVFF  02,73B
0221C:  MOVFF  01,73A
02220:  MOVFF  00,739
02224:  MOVFF  03,753
02228:  MOVFF  02,752
0222C:  MOVFF  01,751
02230:  MOVFF  00,750
02234:  MOVFF  72F,757
02238:  MOVFF  72E,756
0223C:  MOVFF  72D,755
02240:  MOVFF  72C,754
02244:  CALL   0D6A
02248:  MOVFF  03,73C
0224C:  MOVFF  02,73B
02250:  MOVFF  01,73A
02254:  MOVFF  00,739
02258:  BCF    FD8.1
0225A:  MOVFF  03,74D
0225E:  MOVFF  02,74C
02262:  MOVFF  01,74B
02266:  MOVFF  00,74A
0226A:  MOVLW  A4
0226C:  MOVLB  7
0226E:  MOVWF  x51
02270:  MOVLW  DB
02272:  MOVWF  x50
02274:  MOVLW  67
02276:  MOVWF  x4F
02278:  MOVLW  83
0227A:  MOVWF  x4E
0227C:  MOVLB  0
0227E:  CALL   0E60
02282:  MOVFF  03,737
02286:  MOVFF  02,736
0228A:  MOVFF  01,735
0228E:  MOVFF  00,734
....................    r = r*y*y + qat[3];
02292:  MOVFF  737,753
02296:  MOVFF  736,752
0229A:  MOVFF  735,751
0229E:  MOVFF  734,750
022A2:  MOVFF  72F,757
022A6:  MOVFF  72E,756
022AA:  MOVFF  72D,755
022AE:  MOVFF  72C,754
022B2:  CALL   0D6A
022B6:  MOVFF  03,73C
022BA:  MOVFF  02,73B
022BE:  MOVFF  01,73A
022C2:  MOVFF  00,739
022C6:  MOVFF  03,753
022CA:  MOVFF  02,752
022CE:  MOVFF  01,751
022D2:  MOVFF  00,750
022D6:  MOVFF  72F,757
022DA:  MOVFF  72E,756
022DE:  MOVFF  72D,755
022E2:  MOVFF  72C,754
022E6:  CALL   0D6A
022EA:  MOVFF  03,73C
022EE:  MOVFF  02,73B
022F2:  MOVFF  01,73A
022F6:  MOVFF  00,739
022FA:  BCF    FD8.1
022FC:  MOVFF  03,74D
02300:  MOVFF  02,74C
02304:  MOVFF  01,74B
02308:  MOVFF  00,74A
0230C:  MOVLW  33
0230E:  MOVLB  7
02310:  MOVWF  x51
02312:  MOVLW  8C
02314:  MOVWF  x50
02316:  MOVLW  1E
02318:  MOVWF  x4F
0231A:  MOVLW  83
0231C:  MOVWF  x4E
0231E:  MOVLB  0
02320:  CALL   0E60
02324:  MOVFF  03,737
02328:  MOVFF  02,736
0232C:  MOVFF  01,735
02330:  MOVFF  00,734
.................... 
....................    res = y*res/r;
02334:  MOVFF  72F,753
02338:  MOVFF  72E,752
0233C:  MOVFF  72D,751
02340:  MOVFF  72C,750
02344:  MOVFF  733,757
02348:  MOVFF  732,756
0234C:  MOVFF  731,755
02350:  MOVFF  730,754
02354:  CALL   0D6A
02358:  MOVFF  03,73C
0235C:  MOVFF  02,73B
02360:  MOVFF  01,73A
02364:  MOVFF  00,739
02368:  MOVFF  03,742
0236C:  MOVFF  02,741
02370:  MOVFF  01,740
02374:  MOVFF  00,73F
02378:  MOVFF  737,746
0237C:  MOVFF  736,745
02380:  MOVFF  735,744
02384:  MOVFF  734,743
02388:  RCALL  1D70
0238A:  MOVFF  03,733
0238E:  MOVFF  02,732
02392:  MOVFF  01,731
02396:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
0239A:  MOVLB  7
0239C:  BTFSS  x38.1
0239E:  BRA    23DA
....................       res = PI_DIV_BY_TWO - res;
023A0:  BSF    FD8.1
023A2:  MOVLW  DB
023A4:  MOVWF  x4D
023A6:  MOVLW  0F
023A8:  MOVWF  x4C
023AA:  MOVLW  49
023AC:  MOVWF  x4B
023AE:  MOVLW  7F
023B0:  MOVWF  x4A
023B2:  MOVFF  733,751
023B6:  MOVFF  732,750
023BA:  MOVFF  731,74F
023BE:  MOVFF  730,74E
023C2:  MOVLB  0
023C4:  CALL   0E60
023C8:  MOVFF  03,733
023CC:  MOVFF  02,732
023D0:  MOVFF  01,731
023D4:  MOVFF  00,730
023D8:  MOVLB  7
....................    if (s)
023DA:  BTFSS  x38.0
023DC:  BRA    23E4
....................       res = -res;
023DE:  MOVF   x31,W
023E0:  XORLW  80
023E2:  MOVWF  x31
.................... 
....................    return(res);
023E4:  MOVFF  730,00
023E8:  MOVFF  731,01
023EC:  MOVFF  732,02
023F0:  MOVFF  733,03
023F4:  MOVLB  0
023F6:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
023F8:  MOVLB  7
023FA:  BCF    x26.0
....................    quad=0; //quadrant
023FC:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
023FE:  MOVFF  71D,749
02402:  MOVFF  71C,748
02406:  MOVFF  71B,747
0240A:  MOVFF  71A,746
0240E:  CLRF   x4D
02410:  CLRF   x4C
02412:  CLRF   x4B
02414:  CLRF   x4A
02416:  MOVLB  0
02418:  RCALL  1CF6
0241A:  BC    241E
0241C:  BNZ   2448
0241E:  MOVFF  721,749
02422:  MOVFF  720,748
02426:  MOVFF  71F,747
0242A:  MOVFF  71E,746
0242E:  MOVLB  7
02430:  CLRF   x4D
02432:  CLRF   x4C
02434:  CLRF   x4B
02436:  CLRF   x4A
02438:  MOVLB  0
0243A:  RCALL  1CF6
0243C:  BC    2440
0243E:  BNZ   2444
02440:  MOVLW  03
02442:  BRA    2446
02444:  MOVLW  04
02446:  BRA    246E
02448:  MOVFF  721,749
0244C:  MOVFF  720,748
02450:  MOVFF  71F,747
02454:  MOVFF  71E,746
02458:  MOVLB  7
0245A:  CLRF   x4D
0245C:  CLRF   x4C
0245E:  CLRF   x4B
02460:  CLRF   x4A
02462:  MOVLB  0
02464:  RCALL  1CF6
02466:  BNC   246C
02468:  MOVLW  02
0246A:  BRA    246E
0246C:  MOVLW  01
0246E:  MOVLB  7
02470:  MOVWF  x27
....................    if(y<0.0)
02472:  MOVFF  71D,749
02476:  MOVFF  71C,748
0247A:  MOVFF  71B,747
0247E:  MOVFF  71A,746
02482:  CLRF   x4D
02484:  CLRF   x4C
02486:  CLRF   x4B
02488:  CLRF   x4A
0248A:  MOVLB  0
0248C:  RCALL  1CF6
0248E:  BNC   249C
....................    {
....................       sign=1;
02490:  MOVLB  7
02492:  BSF    x26.0
....................       y=-y;
02494:  MOVF   x1B,W
02496:  XORLW  80
02498:  MOVWF  x1B
0249A:  MOVLB  0
....................    }
....................    if(x<0.0)
0249C:  MOVFF  721,749
024A0:  MOVFF  720,748
024A4:  MOVFF  71F,747
024A8:  MOVFF  71E,746
024AC:  MOVLB  7
024AE:  CLRF   x4D
024B0:  CLRF   x4C
024B2:  CLRF   x4B
024B4:  CLRF   x4A
024B6:  MOVLB  0
024B8:  RCALL  1CF6
024BA:  BNC   24C6
....................    {
....................       x=-x;
024BC:  MOVLB  7
024BE:  MOVF   x1F,W
024C0:  XORLW  80
024C2:  MOVWF  x1F
024C4:  MOVLB  0
....................    }
....................    if (x==0.0)
024C6:  MOVFF  721,749
024CA:  MOVFF  720,748
024CE:  MOVFF  71F,747
024D2:  MOVFF  71E,746
024D6:  MOVLB  7
024D8:  CLRF   x4D
024DA:  CLRF   x4C
024DC:  CLRF   x4B
024DE:  CLRF   x4A
024E0:  MOVLB  0
024E2:  RCALL  1CF6
024E4:  BNZ   253A
....................    {
....................       if(y==0.0)
024E6:  MOVFF  71D,749
024EA:  MOVFF  71C,748
024EE:  MOVFF  71B,747
024F2:  MOVFF  71A,746
024F6:  MOVLB  7
024F8:  CLRF   x4D
024FA:  CLRF   x4C
024FC:  CLRF   x4B
024FE:  CLRF   x4A
02500:  MOVLB  0
02502:  CALL   1CF6
02506:  BNZ   250A
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02508:  BRA    2538
....................       else
....................       {
....................          if(sign)
0250A:  MOVLB  7
0250C:  BTFSS  x26.0
0250E:  BRA    2524
....................          {
....................          return (-(PI_DIV_BY_TWO));
02510:  MOVLW  7F
02512:  MOVWF  00
02514:  MOVLW  C9
02516:  MOVWF  01
02518:  MOVLW  0F
0251A:  MOVWF  02
0251C:  MOVLW  DB
0251E:  MOVWF  03
02520:  BRA    2672
....................          }
02522:  BRA    2536
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
02524:  MOVLW  7F
02526:  MOVWF  00
02528:  MOVLW  49
0252A:  MOVWF  01
0252C:  MOVLW  0F
0252E:  MOVWF  02
02530:  MOVLW  DB
02532:  MOVWF  03
02534:  BRA    2672
02536:  MOVLB  0
....................          }
....................       }
....................    }
02538:  BRA    2670
....................    else
....................    {
....................       z=y/x;
0253A:  MOVFF  71D,742
0253E:  MOVFF  71C,741
02542:  MOVFF  71B,740
02546:  MOVFF  71A,73F
0254A:  MOVFF  721,746
0254E:  MOVFF  720,745
02552:  MOVFF  71F,744
02556:  MOVFF  71E,743
0255A:  RCALL  1D70
0255C:  MOVFF  03,725
02560:  MOVFF  02,724
02564:  MOVFF  01,723
02568:  MOVFF  00,722
....................       switch(quad)
0256C:  MOVLW  01
0256E:  MOVLB  7
02570:  SUBWF  x27,W
02572:  ADDLW  FC
02574:  BTFSC  FD8.0
02576:  BRA    2672
02578:  ADDLW  04
0257A:  MOVLB  0
0257C:  GOTO   2678
....................       {
....................          case 1:
....................          {
....................             return atan(z);
02580:  MOVFF  725,72B
02584:  MOVFF  724,72A
02588:  MOVFF  723,729
0258C:  MOVFF  722,728
02590:  RCALL  1ECE
02592:  MOVLB  7
02594:  BRA    2672
....................             break;
02596:  BRA    2672
02598:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
0259A:  MOVFF  725,72B
0259E:  MOVFF  724,72A
025A2:  MOVFF  723,729
025A6:  MOVFF  722,728
025AA:  RCALL  1ECE
025AC:  MOVFF  FEA,729
025B0:  MOVFF  FE9,728
025B4:  BSF    FD8.1
025B6:  MOVLW  DB
025B8:  MOVLB  7
025BA:  MOVWF  x4D
025BC:  MOVLW  0F
025BE:  MOVWF  x4C
025C0:  MOVLW  49
025C2:  MOVWF  x4B
025C4:  MOVLW  80
025C6:  MOVWF  x4A
025C8:  MOVFF  03,751
025CC:  MOVFF  02,750
025D0:  MOVFF  01,74F
025D4:  MOVFF  00,74E
025D8:  MOVLB  0
025DA:  CALL   0E60
025DE:  MOVFF  729,FEA
025E2:  MOVFF  728,FE9
025E6:  MOVLB  7
025E8:  BRA    2672
....................             break;
025EA:  BRA    2672
025EC:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
025EE:  MOVFF  725,72B
025F2:  MOVFF  724,72A
025F6:  MOVFF  723,729
025FA:  MOVFF  722,728
025FE:  RCALL  1ECE
02600:  MOVFF  03,72B
02604:  MOVFF  02,72A
02608:  MOVFF  01,729
0260C:  MOVFF  00,728
02610:  MOVFF  FEA,72D
02614:  MOVFF  FE9,72C
02618:  BSF    FD8.1
0261A:  MOVFF  03,74D
0261E:  MOVFF  02,74C
02622:  MOVFF  01,74B
02626:  MOVFF  00,74A
0262A:  MOVLW  DB
0262C:  MOVLB  7
0262E:  MOVWF  x51
02630:  MOVLW  0F
02632:  MOVWF  x50
02634:  MOVLW  49
02636:  MOVWF  x4F
02638:  MOVLW  80
0263A:  MOVWF  x4E
0263C:  MOVLB  0
0263E:  CALL   0E60
02642:  MOVFF  72D,FEA
02646:  MOVFF  72C,FE9
0264A:  MOVLB  7
0264C:  BRA    2672
....................             break;
0264E:  BRA    2672
02650:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
02652:  MOVFF  725,72B
02656:  MOVFF  724,72A
0265A:  MOVFF  723,729
0265E:  MOVFF  722,728
02662:  RCALL  1ECE
02664:  MOVLW  80
02666:  XORWF  01,F
02668:  MOVLB  7
0266A:  BRA    2672
....................             break;
0266C:  BRA    2672
0266E:  MOVLB  0
02670:  MOVLB  7
....................          }
....................       }
....................    }
02672:  MOVLB  0
02674:  GOTO   3D7E (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
008CE:  MOVFF  730,FEA
008D2:  MOVLB  7
008D4:  MOVFF  72F,FE9
008D8:  CLRF   x42
008DA:  MOVFF  FEF,741
008DE:  CLRF   x44
008E0:  MOVLW  04
008E2:  MOVWF  x43
008E4:  MOVLB  0
008E6:  RCALL  0880
008E8:  MOVF   01,W
008EA:  MOVLB  7
008EC:  ADDWF  x2D,W
008EE:  MOVWF  FE9
008F0:  MOVF   x2E,W
008F2:  ADDWFC 02,W
008F4:  MOVWF  FEA
008F6:  MOVFF  731,FEF
008FA:  MOVFF  732,FEC
008FE:  MOVFF  733,FEC
00902:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
00906:  MOVFF  730,736
0090A:  MOVFF  730,FEA
0090E:  MOVFF  72F,FE9
00912:  MOVLW  01
00914:  ADDWF  FEF,W
00916:  MOVWF  x38
00918:  MOVWF  x3A
0091A:  MOVLW  05
0091C:  MOVWF  x3B
0091E:  MOVLB  0
00920:  RCALL  08A2
00922:  MOVLB  7
00924:  MOVFF  736,FEA
00928:  MOVFF  72F,FE9
0092C:  MOVFF  00,FEF
00930:  MOVLB  0
00932:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
010D8:  MOVLB  F
010DA:  BTFSC  x5B.0
010DC:  BRA    1628
....................       switch (state)
010DE:  MOVLB  1
010E0:  MOVF   xE6,W
010E2:  ADDLW  F9
010E4:  BTFSC  FD8.0
010E6:  BRA    1626
010E8:  ADDLW  07
010EA:  MOVLB  0
010EC:  GOTO   162E
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
010F0:  MOVLB  F
010F2:  BTFSC  x5B.0
010F4:  BRA    10F2
010F6:  MOVFF  F5F,02
010FA:  MOVFF  F5E,01
010FE:  MOVFF  02,6FC
01102:  MOVFF  01,6FB
01106:  MOVFF  02,74B
0110A:  MOVFF  01,74A
0110E:  MOVLB  0
01110:  RCALL  0D34
01112:  MOVFF  03,753
01116:  MOVFF  02,752
0111A:  MOVFF  01,751
0111E:  MOVFF  00,750
01122:  MOVFF  C9,757
01126:  MOVFF  C8,756
0112A:  MOVFF  C7,755
0112E:  MOVFF  C6,754
01132:  RCALL  0D6A
01134:  MOVFF  03,6FE
01138:  MOVFF  02,6FD
0113C:  MOVFF  01,6FC
01140:  MOVFF  00,6FB
01144:  BCF    FD8.1
01146:  MOVFF  03,74D
0114A:  MOVFF  02,74C
0114E:  MOVFF  01,74B
01152:  MOVFF  00,74A
01156:  MOVFF  C5,751
0115A:  MOVFF  C4,750
0115E:  MOVFF  C3,74F
01162:  MOVFF  C2,74E
01166:  RCALL  0E60
01168:  MOVFF  03,FE
0116C:  MOVFF  02,FD
01170:  MOVFF  01,FC
01174:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
01178:  MOVLB  F
0117A:  MOVF   x5A,W
0117C:  ANDLW  3F
0117E:  MOVWF  01
01180:  MOVLW  10
01182:  MOVWF  x5A
01184:  BTFSS  x5B.7
01186:  BRA    1196
01188:  MOVF   01,W
0118A:  SUBLW  10
0118C:  BZ    1196
0118E:  BSF    x5B.0
01190:  NOP   
01192:  BTFSC  x5B.0
01194:  BRA    1192
....................             delay_ms(10);
01196:  MOVLW  0A
01198:  MOVLB  7
0119A:  MOVWF  x01
0119C:  MOVLB  0
0119E:  CALL   0394
....................             read_adc(ADC_START_ONLY);
011A2:  MOVLB  F
011A4:  BSF    x5B.0
011A6:  NOP   
....................             state = 1;
011A8:  MOVLW  01
011AA:  MOVLB  1
011AC:  MOVWF  xE6
....................          break;
011AE:  BRA    1626
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011B0:  MOVLB  F
011B2:  BTFSC  x5B.0
011B4:  BRA    11B2
011B6:  MOVFF  F5F,02
011BA:  MOVFF  F5E,01
011BE:  MOVFF  02,6FC
011C2:  MOVFF  01,6FB
011C6:  MOVFF  02,74B
011CA:  MOVFF  01,74A
011CE:  MOVLB  0
011D0:  RCALL  0D34
011D2:  MOVFF  03,753
011D6:  MOVFF  02,752
011DA:  MOVFF  01,751
011DE:  MOVFF  00,750
011E2:  MOVFF  D1,757
011E6:  MOVFF  D0,756
011EA:  MOVFF  CF,755
011EE:  MOVFF  CE,754
011F2:  RCALL  0D6A
011F4:  MOVFF  03,6FE
011F8:  MOVFF  02,6FD
011FC:  MOVFF  01,6FC
01200:  MOVFF  00,6FB
01204:  BCF    FD8.1
01206:  MOVFF  03,74D
0120A:  MOVFF  02,74C
0120E:  MOVFF  01,74B
01212:  MOVFF  00,74A
01216:  MOVFF  CD,751
0121A:  MOVFF  CC,750
0121E:  MOVFF  CB,74F
01222:  MOVFF  CA,74E
01226:  RCALL  0E60
01228:  MOVFF  03,102
0122C:  MOVFF  02,101
01230:  MOVFF  01,100
01234:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
01238:  MOVLB  F
0123A:  MOVF   x5A,W
0123C:  ANDLW  3F
0123E:  MOVWF  01
01240:  MOVLW  18
01242:  MOVWF  x5A
01244:  BTFSS  x5B.7
01246:  BRA    1256
01248:  MOVF   01,W
0124A:  SUBLW  18
0124C:  BZ    1256
0124E:  BSF    x5B.0
01250:  NOP   
01252:  BTFSC  x5B.0
01254:  BRA    1252
....................             delay_ms(10);
01256:  MOVLW  0A
01258:  MOVLB  7
0125A:  MOVWF  x01
0125C:  MOVLB  0
0125E:  CALL   0394
....................             read_adc(ADC_START_ONLY);
01262:  MOVLB  F
01264:  BSF    x5B.0
01266:  NOP   
....................             state = 2;
01268:  MOVLW  02
0126A:  MOVLB  1
0126C:  MOVWF  xE6
....................          break;
0126E:  BRA    1626
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
01270:  MOVLB  F
01272:  BTFSC  x5B.0
01274:  BRA    1272
01276:  MOVFF  F5F,02
0127A:  MOVFF  F5E,01
0127E:  MOVFF  02,6FC
01282:  MOVFF  01,6FB
01286:  MOVFF  02,74B
0128A:  MOVFF  01,74A
0128E:  MOVLB  0
01290:  RCALL  0D34
01292:  MOVFF  03,753
01296:  MOVFF  02,752
0129A:  MOVFF  01,751
0129E:  MOVFF  00,750
012A2:  MOVFF  D9,757
012A6:  MOVFF  D8,756
012AA:  MOVFF  D7,755
012AE:  MOVFF  D6,754
012B2:  RCALL  0D6A
012B4:  MOVFF  03,6FE
012B8:  MOVFF  02,6FD
012BC:  MOVFF  01,6FC
012C0:  MOVFF  00,6FB
012C4:  BCF    FD8.1
012C6:  MOVFF  03,74D
012CA:  MOVFF  02,74C
012CE:  MOVFF  01,74B
012D2:  MOVFF  00,74A
012D6:  MOVFF  D5,751
012DA:  MOVFF  D4,750
012DE:  MOVFF  D3,74F
012E2:  MOVFF  D2,74E
012E6:  RCALL  0E60
012E8:  MOVFF  03,106
012EC:  MOVFF  02,105
012F0:  MOVFF  01,104
012F4:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
012F8:  MOVLB  F
012FA:  MOVF   x5A,W
012FC:  ANDLW  3F
012FE:  MOVWF  01
01300:  MOVLW  19
01302:  MOVWF  x5A
01304:  BTFSS  x5B.7
01306:  BRA    1316
01308:  MOVF   01,W
0130A:  SUBLW  19
0130C:  BZ    1316
0130E:  BSF    x5B.0
01310:  NOP   
01312:  BTFSC  x5B.0
01314:  BRA    1312
....................             delay_ms(10);
01316:  MOVLW  0A
01318:  MOVLB  7
0131A:  MOVWF  x01
0131C:  MOVLB  0
0131E:  CALL   0394
....................             read_adc(ADC_START_ONLY);
01322:  MOVLB  F
01324:  BSF    x5B.0
01326:  NOP   
....................             state = 3;
01328:  MOVLW  03
0132A:  MOVLB  1
0132C:  MOVWF  xE6
....................          break;
0132E:  BRA    1626
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
01330:  MOVLB  F
01332:  BTFSC  x5B.0
01334:  BRA    1332
01336:  MOVFF  F5F,02
0133A:  MOVFF  F5E,01
0133E:  MOVFF  02,6FC
01342:  MOVFF  01,6FB
01346:  MOVFF  02,74B
0134A:  MOVFF  01,74A
0134E:  MOVLB  0
01350:  RCALL  0D34
01352:  MOVFF  03,753
01356:  MOVFF  02,752
0135A:  MOVFF  01,751
0135E:  MOVFF  00,750
01362:  MOVFF  E1,757
01366:  MOVFF  E0,756
0136A:  MOVFF  DF,755
0136E:  MOVFF  DE,754
01372:  RCALL  0D6A
01374:  MOVFF  03,6FE
01378:  MOVFF  02,6FD
0137C:  MOVFF  01,6FC
01380:  MOVFF  00,6FB
01384:  BCF    FD8.1
01386:  MOVFF  03,74D
0138A:  MOVFF  02,74C
0138E:  MOVFF  01,74B
01392:  MOVFF  00,74A
01396:  MOVFF  DD,751
0139A:  MOVFF  DC,750
0139E:  MOVFF  DB,74F
013A2:  MOVFF  DA,74E
013A6:  RCALL  0E60
013A8:  MOVFF  03,10A
013AC:  MOVFF  02,109
013B0:  MOVFF  01,108
013B4:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013B8:  MOVLB  F
013BA:  MOVF   x5A,W
013BC:  ANDLW  3F
013BE:  MOVWF  01
013C0:  MOVLW  11
013C2:  MOVWF  x5A
013C4:  BTFSS  x5B.7
013C6:  BRA    13D6
013C8:  MOVF   01,W
013CA:  SUBLW  11
013CC:  BZ    13D6
013CE:  BSF    x5B.0
013D0:  NOP   
013D2:  BTFSC  x5B.0
013D4:  BRA    13D2
....................             delay_ms(10);
013D6:  MOVLW  0A
013D8:  MOVLB  7
013DA:  MOVWF  x01
013DC:  MOVLB  0
013DE:  CALL   0394
....................             read_adc(ADC_START_ONLY);
013E2:  MOVLB  F
013E4:  BSF    x5B.0
013E6:  NOP   
....................             state = 4;
013E8:  MOVLW  04
013EA:  MOVLB  1
013EC:  MOVWF  xE6
....................          break;
013EE:  BRA    1626
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
013F0:  MOVLB  F
013F2:  BTFSC  x5B.0
013F4:  BRA    13F2
013F6:  MOVFF  F5F,02
013FA:  MOVFF  F5E,01
013FE:  MOVFF  02,6FC
01402:  MOVFF  01,6FB
01406:  MOVFF  02,74B
0140A:  MOVFF  01,74A
0140E:  MOVLB  0
01410:  RCALL  0D34
01412:  MOVFF  03,753
01416:  MOVFF  02,752
0141A:  MOVFF  01,751
0141E:  MOVFF  00,750
01422:  MOVFF  E9,757
01426:  MOVFF  E8,756
0142A:  MOVFF  E7,755
0142E:  MOVFF  E6,754
01432:  RCALL  0D6A
01434:  MOVFF  03,6FE
01438:  MOVFF  02,6FD
0143C:  MOVFF  01,6FC
01440:  MOVFF  00,6FB
01444:  BCF    FD8.1
01446:  MOVFF  03,74D
0144A:  MOVFF  02,74C
0144E:  MOVFF  01,74B
01452:  MOVFF  00,74A
01456:  MOVFF  E5,751
0145A:  MOVFF  E4,750
0145E:  MOVFF  E3,74F
01462:  MOVFF  E2,74E
01466:  RCALL  0E60
01468:  MOVFF  03,10E
0146C:  MOVFF  02,10D
01470:  MOVFF  01,10C
01474:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
01478:  MOVLB  F
0147A:  MOVF   x5A,W
0147C:  ANDLW  3F
0147E:  MOVWF  01
01480:  MOVLW  1B
01482:  MOVWF  x5A
01484:  BTFSS  x5B.7
01486:  BRA    1496
01488:  MOVF   01,W
0148A:  SUBLW  1B
0148C:  BZ    1496
0148E:  BSF    x5B.0
01490:  NOP   
01492:  BTFSC  x5B.0
01494:  BRA    1492
....................             delay_ms(10);
01496:  MOVLW  0A
01498:  MOVLB  7
0149A:  MOVWF  x01
0149C:  MOVLB  0
0149E:  CALL   0394
....................             read_adc(ADC_START_ONLY);
014A2:  MOVLB  F
014A4:  BSF    x5B.0
014A6:  NOP   
....................             state = 5;
014A8:  MOVLW  05
014AA:  MOVLB  1
014AC:  MOVWF  xE6
....................          break;
014AE:  BRA    1626
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014B0:  MOVLB  F
014B2:  BTFSC  x5B.0
014B4:  BRA    14B2
014B6:  MOVFF  F5F,02
014BA:  MOVFF  F5E,01
014BE:  MOVFF  02,6FC
014C2:  MOVFF  01,6FB
014C6:  MOVFF  02,74B
014CA:  MOVFF  01,74A
014CE:  MOVLB  0
014D0:  RCALL  0D34
014D2:  MOVFF  03,753
014D6:  MOVFF  02,752
014DA:  MOVFF  01,751
014DE:  MOVFF  00,750
014E2:  MOVFF  F1,757
014E6:  MOVFF  F0,756
014EA:  MOVFF  EF,755
014EE:  MOVFF  EE,754
014F2:  RCALL  0D6A
014F4:  MOVFF  03,6FE
014F8:  MOVFF  02,6FD
014FC:  MOVFF  01,6FC
01500:  MOVFF  00,6FB
01504:  BCF    FD8.1
01506:  MOVFF  03,74D
0150A:  MOVFF  02,74C
0150E:  MOVFF  01,74B
01512:  MOVFF  00,74A
01516:  MOVFF  ED,751
0151A:  MOVFF  EC,750
0151E:  MOVFF  EB,74F
01522:  MOVFF  EA,74E
01526:  RCALL  0E60
01528:  MOVFF  03,112
0152C:  MOVFF  02,111
01530:  MOVFF  01,110
01534:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
01538:  MOVLB  F
0153A:  MOVF   x5A,W
0153C:  ANDLW  3F
0153E:  MOVWF  01
01540:  MOVLW  1A
01542:  MOVWF  x5A
01544:  BTFSS  x5B.7
01546:  BRA    1556
01548:  MOVF   01,W
0154A:  SUBLW  1A
0154C:  BZ    1556
0154E:  BSF    x5B.0
01550:  NOP   
01552:  BTFSC  x5B.0
01554:  BRA    1552
....................             delay_ms(10);
01556:  MOVLW  0A
01558:  MOVLB  7
0155A:  MOVWF  x01
0155C:  MOVLB  0
0155E:  CALL   0394
....................             read_adc(ADC_START_ONLY);
01562:  MOVLB  F
01564:  BSF    x5B.0
01566:  NOP   
....................             state = 6;
01568:  MOVLW  06
0156A:  MOVLB  1
0156C:  MOVWF  xE6
....................          break;
0156E:  BRA    1626
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01570:  MOVLB  F
01572:  BTFSC  x5B.0
01574:  BRA    1572
01576:  MOVFF  F5F,02
0157A:  MOVFF  F5E,01
0157E:  MOVFF  02,6FC
01582:  MOVFF  01,6FB
01586:  MOVFF  02,74B
0158A:  MOVFF  01,74A
0158E:  MOVLB  0
01590:  CALL   0D34
01594:  MOVFF  03,753
01598:  MOVFF  02,752
0159C:  MOVFF  01,751
015A0:  MOVFF  00,750
015A4:  MOVFF  F9,757
015A8:  MOVFF  F8,756
015AC:  MOVFF  F7,755
015B0:  MOVFF  F6,754
015B4:  CALL   0D6A
015B8:  MOVFF  03,6FE
015BC:  MOVFF  02,6FD
015C0:  MOVFF  01,6FC
015C4:  MOVFF  00,6FB
015C8:  BCF    FD8.1
015CA:  MOVFF  03,74D
015CE:  MOVFF  02,74C
015D2:  MOVFF  01,74B
015D6:  MOVFF  00,74A
015DA:  MOVFF  F5,751
015DE:  MOVFF  F4,750
015E2:  MOVFF  F3,74F
015E6:  MOVFF  F2,74E
015EA:  RCALL  0E60
015EC:  MOVFF  03,116
015F0:  MOVFF  02,115
015F4:  MOVFF  01,114
015F8:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
015FC:  MOVLB  F
015FE:  MOVF   x5A,W
01600:  ANDLW  3F
01602:  MOVWF  01
01604:  MOVLW  06
01606:  MOVWF  x5A
01608:  BTFSS  x5B.7
0160A:  BRA    161A
0160C:  MOVF   01,W
0160E:  SUBLW  06
01610:  BZ    161A
01612:  BSF    x5B.0
01614:  NOP   
01616:  BTFSC  x5B.0
01618:  BRA    1616
....................             read_adc(ADC_START_ONLY);
0161A:  BSF    x5B.0
0161C:  NOP   
....................             state = 0;
0161E:  MOVLB  1
01620:  CLRF   xE6
....................          break;   
01622:  BRA    1626
01624:  MOVLB  1
01626:  MOVLB  F
....................       }
....................    }
01628:  MOVLB  0
0162A:  GOTO   A6F6 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
036D6:  MOVLB  7
036D8:  MOVF   x03,W
036DA:  MULLW  26
036DC:  MOVF   FF3,W
036DE:  CLRF   x0D
036E0:  MOVWF  x0C
036E2:  MOVLW  10
036E4:  ADDWF  x0C,W
036E6:  MOVWF  01
036E8:  MOVLW  00
036EA:  ADDWFC x0D,W
036EC:  MOVWF  03
036EE:  MOVF   01,W
036F0:  ADDLW  17
036F2:  MOVWF  01
036F4:  MOVLW  01
036F6:  ADDWFC 03,F
036F8:  MOVFF  01,70C
036FC:  MOVFF  03,70D
03700:  MOVF   x03,W
03702:  MULLW  26
03704:  MOVF   FF3,W
03706:  CLRF   x0F
03708:  MOVWF  x0E
0370A:  MOVLW  08
0370C:  ADDWF  x0E,W
0370E:  MOVWF  01
03710:  MOVLW  00
03712:  ADDWFC x0F,W
03714:  MOVWF  03
03716:  MOVF   01,W
03718:  ADDLW  17
0371A:  MOVWF  FE9
0371C:  MOVLW  01
0371E:  ADDWFC 03,W
03720:  MOVWF  FEA
03722:  MOVFF  FEF,00
03726:  MOVFF  FEC,01
0372A:  MOVFF  FEC,02
0372E:  MOVFF  FEC,03
03732:  MOVFF  70D,FEA
03736:  MOVFF  70C,FE9
0373A:  MOVFF  00,FEF
0373E:  MOVFF  01,FEC
03742:  MOVFF  02,FEC
03746:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
0374A:  MOVF   x03,W
0374C:  MULLW  26
0374E:  MOVF   FF3,W
03750:  CLRF   x0D
03752:  MOVWF  x0C
03754:  MOVLW  14
03756:  ADDWF  x0C,W
03758:  MOVWF  01
0375A:  MOVLW  00
0375C:  ADDWFC x0D,W
0375E:  MOVWF  03
03760:  MOVF   01,W
03762:  ADDLW  17
03764:  MOVWF  01
03766:  MOVLW  01
03768:  ADDWFC 03,F
0376A:  MOVFF  01,70C
0376E:  MOVFF  03,70D
03772:  MOVF   x03,W
03774:  MULLW  26
03776:  MOVF   FF3,W
03778:  CLRF   x0F
0377A:  MOVWF  x0E
0377C:  MOVLW  0C
0377E:  ADDWF  x0E,W
03780:  MOVWF  01
03782:  MOVLW  00
03784:  ADDWFC x0F,W
03786:  MOVWF  03
03788:  MOVF   01,W
0378A:  ADDLW  17
0378C:  MOVWF  FE9
0378E:  MOVLW  01
03790:  ADDWFC 03,W
03792:  MOVWF  FEA
03794:  MOVFF  FEF,00
03798:  MOVFF  FEC,01
0379C:  MOVFF  FEC,02
037A0:  MOVFF  FEC,03
037A4:  MOVFF  70D,FEA
037A8:  MOVFF  70C,FE9
037AC:  MOVFF  00,FEF
037B0:  MOVFF  01,FEC
037B4:  MOVFF  02,FEC
037B8:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037BC:  MOVF   x03,W
037BE:  MULLW  26
037C0:  MOVF   FF3,W
037C2:  CLRF   x0D
037C4:  MOVWF  x0C
037C6:  MOVLW  17
037C8:  ADDWF  x0C,W
037CA:  MOVWF  01
037CC:  MOVLW  01
037CE:  ADDWFC x0D,W
037D0:  MOVWF  03
037D2:  MOVFF  01,70E
037D6:  MOVWF  x0F
037D8:  MOVF   x03,W
037DA:  MULLW  09
037DC:  MOVF   FF3,W
037DE:  CLRF   x11
037E0:  MOVWF  x10
037E2:  MOVLW  01
037E4:  ADDWF  x10,W
037E6:  MOVWF  01
037E8:  MOVLW  00
037EA:  ADDWFC x11,W
037EC:  MOVWF  03
037EE:  MOVF   01,W
037F0:  ADDLW  D4
037F2:  MOVWF  FE9
037F4:  MOVLW  01
037F6:  ADDWFC 03,W
037F8:  MOVWF  FEA
037FA:  MOVFF  FEF,710
037FE:  MOVFF  FEC,01
03802:  MOVFF  FEC,02
03806:  MOVFF  FEC,03
0380A:  MOVFF  03,713
0380E:  MOVFF  02,712
03812:  MOVFF  01,711
03816:  MOVLB  0
03818:  CALL   1C9C
0381C:  MOVFF  70F,FEA
03820:  MOVFF  70E,FE9
03824:  MOVFF  00,FEF
03828:  MOVFF  01,FEC
0382C:  MOVFF  02,FEC
03830:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
03834:  MOVLB  7
03836:  MOVF   x03,W
03838:  MULLW  26
0383A:  MOVF   FF3,W
0383C:  CLRF   x0D
0383E:  MOVWF  x0C
03840:  MOVLW  04
03842:  ADDWF  x0C,W
03844:  MOVWF  01
03846:  MOVLW  00
03848:  ADDWFC x0D,W
0384A:  MOVWF  03
0384C:  MOVF   01,W
0384E:  ADDLW  17
03850:  MOVWF  01
03852:  MOVLW  01
03854:  ADDWFC 03,F
03856:  MOVFF  01,70C
0385A:  MOVFF  03,70D
0385E:  MOVF   x03,W
03860:  MULLW  09
03862:  MOVF   FF3,W
03864:  CLRF   x0F
03866:  MOVWF  x0E
03868:  MOVLW  05
0386A:  ADDWF  x0E,W
0386C:  MOVWF  01
0386E:  MOVLW  00
03870:  ADDWFC x0F,W
03872:  MOVWF  03
03874:  MOVF   01,W
03876:  ADDLW  D4
03878:  MOVWF  FE9
0387A:  MOVLW  01
0387C:  ADDWFC 03,W
0387E:  MOVWF  FEA
03880:  MOVFF  FEF,710
03884:  MOVFF  FEC,01
03888:  MOVFF  FEC,02
0388C:  MOVFF  FEC,03
03890:  MOVFF  03,713
03894:  MOVFF  02,712
03898:  MOVFF  01,711
0389C:  MOVLB  0
0389E:  CALL   1C9C
038A2:  MOVFF  70D,FEA
038A6:  MOVFF  70C,FE9
038AA:  MOVFF  00,FEF
038AE:  MOVFF  01,FEC
038B2:  MOVFF  02,FEC
038B6:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038BA:  MOVLB  7
038BC:  MOVF   x03,W
038BE:  MULLW  26
038C0:  MOVF   FF3,W
038C2:  CLRF   x0D
038C4:  MOVWF  x0C
038C6:  MOVLW  08
038C8:  ADDWF  x0C,W
038CA:  MOVWF  01
038CC:  MOVLW  00
038CE:  ADDWFC x0D,W
038D0:  MOVWF  03
038D2:  MOVF   01,W
038D4:  ADDLW  17
038D6:  MOVWF  01
038D8:  MOVLW  01
038DA:  ADDWFC 03,F
038DC:  MOVFF  01,70C
038E0:  MOVFF  03,70D
038E4:  MOVF   x03,W
038E6:  MULLW  26
038E8:  MOVF   FF3,W
038EA:  CLRF   x0F
038EC:  MOVWF  x0E
038EE:  MOVLW  17
038F0:  ADDWF  x0E,W
038F2:  MOVWF  FE9
038F4:  MOVLW  01
038F6:  ADDWFC x0F,W
038F8:  MOVWF  FEA
038FA:  MOVFF  FEF,750
038FE:  MOVFF  FEC,751
03902:  MOVFF  FEC,752
03906:  MOVFF  FEC,753
0390A:  MOVF   x03,W
0390C:  MULLW  10
0390E:  MOVF   FF3,W
03910:  CLRF   x15
03912:  MOVWF  x14
03914:  MOVLW  08
03916:  ADDWF  x14,W
03918:  MOVWF  01
0391A:  MOVLW  00
0391C:  ADDWFC x15,W
0391E:  MOVWF  03
03920:  MOVF   01,W
03922:  ADDLW  72
03924:  MOVWF  FE9
03926:  MOVLW  00
03928:  ADDWFC 03,W
0392A:  MOVWF  FEA
0392C:  MOVFF  FEF,754
03930:  MOVFF  FEC,01
03934:  MOVFF  FEC,02
03938:  MOVFF  FEC,03
0393C:  MOVFF  03,757
03940:  MOVFF  02,756
03944:  MOVFF  01,755
03948:  MOVLB  0
0394A:  CALL   0D6A
0394E:  MOVFF  03,74D
03952:  MOVFF  02,74C
03956:  MOVFF  01,74B
0395A:  MOVFF  00,74A
0395E:  MOVLB  7
03960:  MOVF   x03,W
03962:  MULLW  10
03964:  MOVF   FF3,W
03966:  CLRF   x15
03968:  MOVWF  x14
0396A:  MOVLW  72
0396C:  ADDWF  x14,W
0396E:  MOVWF  FE9
03970:  MOVLW  00
03972:  ADDWFC x15,W
03974:  MOVWF  FEA
03976:  MOVFF  FEF,74E
0397A:  MOVFF  FEC,01
0397E:  MOVFF  FEC,02
03982:  MOVFF  FEC,03
03986:  BCF    FD8.1
03988:  MOVFF  03,751
0398C:  MOVFF  02,750
03990:  MOVFF  01,74F
03994:  MOVLB  0
03996:  CALL   0E60
0399A:  MOVFF  70D,FEA
0399E:  MOVFF  70C,FE9
039A2:  MOVFF  00,FEF
039A6:  MOVFF  01,FEC
039AA:  MOVFF  02,FEC
039AE:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039B2:  MOVLB  7
039B4:  MOVF   x03,W
039B6:  MULLW  26
039B8:  MOVF   FF3,W
039BA:  CLRF   x0D
039BC:  MOVWF  x0C
039BE:  MOVLW  0C
039C0:  ADDWF  x0C,W
039C2:  MOVWF  01
039C4:  MOVLW  00
039C6:  ADDWFC x0D,W
039C8:  MOVWF  03
039CA:  MOVF   01,W
039CC:  ADDLW  17
039CE:  MOVWF  01
039D0:  MOVLW  01
039D2:  ADDWFC 03,F
039D4:  MOVFF  01,70C
039D8:  MOVFF  03,70D
039DC:  MOVF   x03,W
039DE:  MULLW  26
039E0:  MOVF   FF3,W
039E2:  CLRF   x0F
039E4:  MOVWF  x0E
039E6:  MOVLW  04
039E8:  ADDWF  x0E,W
039EA:  MOVWF  01
039EC:  MOVLW  00
039EE:  ADDWFC x0F,W
039F0:  MOVWF  03
039F2:  MOVF   01,W
039F4:  ADDLW  17
039F6:  MOVWF  FE9
039F8:  MOVLW  01
039FA:  ADDWFC 03,W
039FC:  MOVWF  FEA
039FE:  MOVFF  FEF,750
03A02:  MOVFF  FEC,751
03A06:  MOVFF  FEC,752
03A0A:  MOVFF  FEC,753
03A0E:  MOVF   x03,W
03A10:  MULLW  10
03A12:  MOVF   FF3,W
03A14:  CLRF   x13
03A16:  MOVWF  x12
03A18:  MOVLW  0C
03A1A:  ADDWF  x12,W
03A1C:  MOVWF  01
03A1E:  MOVLW  00
03A20:  ADDWFC x13,W
03A22:  MOVWF  03
03A24:  MOVF   01,W
03A26:  ADDLW  72
03A28:  MOVWF  FE9
03A2A:  MOVLW  00
03A2C:  ADDWFC 03,W
03A2E:  MOVWF  FEA
03A30:  MOVFF  FEF,754
03A34:  MOVFF  FEC,01
03A38:  MOVFF  FEC,02
03A3C:  MOVFF  FEC,03
03A40:  MOVFF  03,757
03A44:  MOVFF  02,756
03A48:  MOVFF  01,755
03A4C:  MOVLB  0
03A4E:  CALL   0D6A
03A52:  MOVFF  03,74D
03A56:  MOVFF  02,74C
03A5A:  MOVFF  01,74B
03A5E:  MOVFF  00,74A
03A62:  MOVLB  7
03A64:  MOVF   x03,W
03A66:  MULLW  10
03A68:  MOVF   FF3,W
03A6A:  CLRF   x13
03A6C:  MOVWF  x12
03A6E:  MOVLW  04
03A70:  ADDWF  x12,W
03A72:  MOVWF  01
03A74:  MOVLW  00
03A76:  ADDWFC x13,W
03A78:  MOVWF  03
03A7A:  MOVF   01,W
03A7C:  ADDLW  72
03A7E:  MOVWF  FE9
03A80:  MOVLW  00
03A82:  ADDWFC 03,W
03A84:  MOVWF  FEA
03A86:  MOVFF  FEF,74E
03A8A:  MOVFF  FEC,01
03A8E:  MOVFF  FEC,02
03A92:  MOVFF  FEC,03
03A96:  BCF    FD8.1
03A98:  MOVFF  03,751
03A9C:  MOVFF  02,750
03AA0:  MOVFF  01,74F
03AA4:  MOVLB  0
03AA6:  CALL   0E60
03AAA:  MOVFF  70D,FEA
03AAE:  MOVFF  70C,FE9
03AB2:  MOVFF  00,FEF
03AB6:  MOVFF  01,FEC
03ABA:  MOVFF  02,FEC
03ABE:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AC2:  MOVLB  7
03AC4:  CLRF   x07
03AC6:  CLRF   x06
03AC8:  CLRF   x05
03ACA:  CLRF   x04
03ACC:  CLRF   x0B
03ACE:  CLRF   x0A
03AD0:  CLRF   x09
03AD2:  MOVLW  7F
03AD4:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03AD6:  MOVF   x03,W
03AD8:  MULLW  26
03ADA:  MOVF   FF3,W
03ADC:  CLRF   x0D
03ADE:  MOVWF  x0C
03AE0:  MOVLW  0C
03AE2:  ADDWF  x0C,W
03AE4:  MOVWF  01
03AE6:  MOVLW  00
03AE8:  ADDWFC x0D,W
03AEA:  MOVWF  03
03AEC:  MOVF   01,W
03AEE:  ADDLW  17
03AF0:  MOVWF  FE9
03AF2:  MOVLW  01
03AF4:  ADDWFC 03,W
03AF6:  MOVWF  FEA
03AF8:  MOVFF  FEF,746
03AFC:  MOVFF  FEC,747
03B00:  MOVFF  FEC,748
03B04:  MOVFF  FEC,749
03B08:  CLRF   x4D
03B0A:  CLRF   x4C
03B0C:  CLRF   x4B
03B0E:  CLRF   x4A
03B10:  MOVLB  0
03B12:  CALL   1CF6
03B16:  BTFSS  FD8.0
03B18:  BRA    3C82
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B1A:  MOVLB  7
03B1C:  MOVF   x03,W
03B1E:  MULLW  26
03B20:  MOVF   FF3,W
03B22:  CLRF   x0D
03B24:  MOVWF  x0C
03B26:  MOVLW  08
03B28:  ADDWF  x0C,W
03B2A:  MOVWF  01
03B2C:  MOVLW  00
03B2E:  ADDWFC x0D,W
03B30:  MOVWF  03
03B32:  MOVF   01,W
03B34:  ADDLW  17
03B36:  MOVWF  FE9
03B38:  MOVLW  01
03B3A:  ADDWFC 03,W
03B3C:  MOVWF  FEA
03B3E:  MOVFF  FEF,74A
03B42:  MOVFF  FEC,70D
03B46:  MOVFF  FEC,74C
03B4A:  MOVFF  FEC,74D
03B4E:  CLRF   x49
03B50:  CLRF   x48
03B52:  CLRF   x47
03B54:  CLRF   x46
03B56:  MOVFF  70D,74B
03B5A:  MOVLB  0
03B5C:  CALL   1CF6
03B60:  BNC   3BCE
03B62:  MOVLB  7
03B64:  MOVF   x03,W
03B66:  MULLW  26
03B68:  MOVF   FF3,W
03B6A:  CLRF   x0D
03B6C:  MOVWF  x0C
03B6E:  MOVLW  10
03B70:  ADDWF  x0C,W
03B72:  MOVWF  01
03B74:  MOVLW  00
03B76:  ADDWFC x0D,W
03B78:  MOVWF  03
03B7A:  MOVF   01,W
03B7C:  ADDLW  17
03B7E:  MOVWF  FE9
03B80:  MOVLW  01
03B82:  ADDWFC 03,W
03B84:  MOVWF  FEA
03B86:  MOVFF  FEF,746
03B8A:  MOVFF  FEC,747
03B8E:  MOVFF  FEC,748
03B92:  MOVFF  FEC,749
03B96:  CLRF   x4D
03B98:  CLRF   x4C
03B9A:  CLRF   x4B
03B9C:  CLRF   x4A
03B9E:  MOVLB  0
03BA0:  CALL   1CF6
03BA4:  BNC   3BCE
....................          adcVals[ch].npoles--;
03BA6:  MOVLB  7
03BA8:  MOVF   x03,W
03BAA:  MULLW  26
03BAC:  MOVF   FF3,W
03BAE:  CLRF   x0D
03BB0:  MOVWF  x0C
03BB2:  MOVLW  1C
03BB4:  ADDWF  x0C,W
03BB6:  MOVWF  01
03BB8:  MOVLW  00
03BBA:  ADDWFC x0D,W
03BBC:  MOVWF  03
03BBE:  MOVF   01,W
03BC0:  ADDLW  17
03BC2:  MOVWF  FE9
03BC4:  MOVLW  01
03BC6:  ADDWFC 03,W
03BC8:  MOVWF  FEA
03BCA:  DECF   FEF,F
....................       }
03BCC:  BRA    3C80
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03BCE:  MOVLB  7
03BD0:  MOVF   x03,W
03BD2:  MULLW  26
03BD4:  MOVF   FF3,W
03BD6:  CLRF   x0D
03BD8:  MOVWF  x0C
03BDA:  MOVLW  08
03BDC:  ADDWF  x0C,W
03BDE:  MOVWF  01
03BE0:  MOVLW  00
03BE2:  ADDWFC x0D,W
03BE4:  MOVWF  03
03BE6:  MOVF   01,W
03BE8:  ADDLW  17
03BEA:  MOVWF  FE9
03BEC:  MOVLW  01
03BEE:  ADDWFC 03,W
03BF0:  MOVWF  FEA
03BF2:  MOVFF  FEF,746
03BF6:  MOVFF  FEC,70D
03BFA:  MOVFF  FEC,748
03BFE:  MOVFF  FEC,749
03C02:  MOVFF  70D,747
03C06:  CLRF   x4D
03C08:  CLRF   x4C
03C0A:  CLRF   x4B
03C0C:  CLRF   x4A
03C0E:  MOVLB  0
03C10:  CALL   1CF6
03C14:  BNC   3C82
03C16:  MOVLB  7
03C18:  MOVF   x03,W
03C1A:  MULLW  26
03C1C:  MOVF   FF3,W
03C1E:  CLRF   x0D
03C20:  MOVWF  x0C
03C22:  MOVLW  10
03C24:  ADDWF  x0C,W
03C26:  MOVWF  01
03C28:  MOVLW  00
03C2A:  ADDWFC x0D,W
03C2C:  MOVWF  03
03C2E:  MOVF   01,W
03C30:  ADDLW  17
03C32:  MOVWF  FE9
03C34:  MOVLW  01
03C36:  ADDWFC 03,W
03C38:  MOVWF  FEA
03C3A:  MOVFF  FEF,74A
03C3E:  MOVFF  FEC,74B
03C42:  MOVFF  FEC,74C
03C46:  MOVFF  FEC,74D
03C4A:  CLRF   x49
03C4C:  CLRF   x48
03C4E:  CLRF   x47
03C50:  CLRF   x46
03C52:  MOVLB  0
03C54:  CALL   1CF6
03C58:  BNC   3C82
....................          adcVals[ch].npoles++;
03C5A:  MOVLB  7
03C5C:  MOVF   x03,W
03C5E:  MULLW  26
03C60:  MOVF   FF3,W
03C62:  CLRF   x0D
03C64:  MOVWF  x0C
03C66:  MOVLW  1C
03C68:  ADDWF  x0C,W
03C6A:  MOVWF  01
03C6C:  MOVLW  00
03C6E:  ADDWFC x0D,W
03C70:  MOVWF  03
03C72:  MOVF   01,W
03C74:  ADDLW  17
03C76:  MOVWF  FE9
03C78:  MOVLW  01
03C7A:  ADDWFC 03,W
03C7C:  MOVWF  FEA
03C7E:  INCF   FEF,F
03C80:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03C82:  MOVLB  7
03C84:  MOVF   x03,W
03C86:  MULLW  26
03C88:  MOVF   FF3,W
03C8A:  CLRF   x0D
03C8C:  MOVWF  x0C
03C8E:  MOVLW  18
03C90:  ADDWF  x0C,W
03C92:  MOVWF  01
03C94:  MOVLW  00
03C96:  ADDWFC x0D,W
03C98:  MOVWF  03
03C9A:  MOVF   01,W
03C9C:  ADDLW  17
03C9E:  MOVWF  01
03CA0:  MOVLW  01
03CA2:  ADDWFC 03,F
03CA4:  MOVFF  01,70C
03CA8:  MOVFF  03,70D
03CAC:  MOVFF  70B,753
03CB0:  MOVFF  70A,752
03CB4:  MOVFF  709,751
03CB8:  MOVFF  708,750
03CBC:  MOVLW  AA
03CBE:  MOVWF  x57
03CC0:  MOVLW  27
03CC2:  MOVWF  x56
03CC4:  MOVLW  1F
03CC6:  MOVWF  x55
03CC8:  MOVLW  86
03CCA:  MOVWF  x54
03CCC:  MOVLB  0
03CCE:  CALL   0D6A
03CD2:  MOVFF  03,711
03CD6:  MOVFF  02,710
03CDA:  MOVFF  01,70F
03CDE:  MOVFF  00,70E
03CE2:  MOVLB  7
03CE4:  MOVF   x03,W
03CE6:  MULLW  26
03CE8:  MOVF   FF3,W
03CEA:  CLRF   x13
03CEC:  MOVWF  x12
03CEE:  MOVLW  08
03CF0:  ADDWF  x12,W
03CF2:  MOVWF  01
03CF4:  MOVLW  00
03CF6:  ADDWFC x13,W
03CF8:  MOVWF  03
03CFA:  MOVF   01,W
03CFC:  ADDLW  17
03CFE:  MOVWF  FE9
03D00:  MOVLW  01
03D02:  ADDWFC 03,W
03D04:  MOVWF  FEA
03D06:  MOVFF  FEF,712
03D0A:  MOVFF  FEC,713
03D0E:  MOVFF  FEC,714
03D12:  MOVFF  FEC,715
03D16:  MOVF   x03,W
03D18:  MULLW  26
03D1A:  MOVF   FF3,W
03D1C:  CLRF   x17
03D1E:  MOVWF  x16
03D20:  MOVLW  0C
03D22:  ADDWF  x16,W
03D24:  MOVWF  01
03D26:  MOVLW  00
03D28:  ADDWFC x17,W
03D2A:  MOVWF  03
03D2C:  MOVF   01,W
03D2E:  ADDLW  17
03D30:  MOVWF  FE9
03D32:  MOVLW  01
03D34:  ADDWFC 03,W
03D36:  MOVWF  FEA
03D38:  MOVFF  FEF,00
03D3C:  MOVFF  FEC,01
03D40:  MOVFF  FEC,02
03D44:  MOVFF  FEC,03
03D48:  MOVFF  03,719
03D4C:  MOVFF  02,718
03D50:  MOVFF  01,717
03D54:  MOVFF  00,716
03D58:  MOVFF  715,71D
03D5C:  MOVFF  714,71C
03D60:  MOVFF  713,71B
03D64:  MOVFF  712,71A
03D68:  MOVFF  03,721
03D6C:  MOVFF  02,720
03D70:  MOVFF  01,71F
03D74:  MOVFF  00,71E
03D78:  MOVLB  0
03D7A:  GOTO   23F8
03D7E:  MOVFF  711,753
03D82:  MOVFF  710,752
03D86:  MOVFF  70F,751
03D8A:  MOVFF  70E,750
03D8E:  MOVFF  03,757
03D92:  MOVFF  02,756
03D96:  MOVFF  01,755
03D9A:  MOVFF  00,754
03D9E:  CALL   0D6A
03DA2:  MOVFF  70D,FEA
03DA6:  MOVFF  70C,FE9
03DAA:  MOVFF  00,FEF
03DAE:  MOVFF  01,FEC
03DB2:  MOVFF  02,FEC
03DB6:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DBA:  MOVLB  7
03DBC:  MOVF   x03,W
03DBE:  MULLW  26
03DC0:  MOVF   FF3,W
03DC2:  CLRF   x0D
03DC4:  MOVWF  x0C
03DC6:  MOVLW  18
03DC8:  ADDWF  x0C,W
03DCA:  MOVWF  01
03DCC:  MOVLW  00
03DCE:  ADDWFC x0D,W
03DD0:  MOVWF  03
03DD2:  MOVF   01,W
03DD4:  ADDLW  17
03DD6:  MOVWF  FE9
03DD8:  MOVLW  01
03DDA:  ADDWFC 03,W
03DDC:  MOVWF  FEA
03DDE:  MOVFF  FEF,70C
03DE2:  MOVFF  FEC,70D
03DE6:  MOVFF  FEC,70E
03DEA:  MOVFF  FEC,70F
03DEE:  CLRF   x53
03DF0:  CLRF   x52
03DF2:  MOVLW  7A
03DF4:  MOVWF  x51
03DF6:  MOVLW  88
03DF8:  MOVWF  x50
03DFA:  MOVFF  70B,757
03DFE:  MOVFF  70A,756
03E02:  MOVFF  709,755
03E06:  MOVFF  708,754
03E0A:  MOVLB  0
03E0C:  CALL   0D6A
03E10:  MOVFF  03,713
03E14:  MOVFF  02,712
03E18:  MOVFF  01,711
03E1C:  MOVFF  00,710
03E20:  MOVLB  7
03E22:  MOVF   x03,W
03E24:  MULLW  26
03E26:  MOVF   FF3,W
03E28:  CLRF   x15
03E2A:  MOVWF  x14
03E2C:  MOVLW  1C
03E2E:  ADDWF  x14,W
03E30:  MOVWF  01
03E32:  MOVLW  00
03E34:  ADDWFC x15,W
03E36:  MOVWF  03
03E38:  MOVF   01,W
03E3A:  ADDLW  17
03E3C:  MOVWF  FE9
03E3E:  MOVLW  01
03E40:  ADDWFC 03,W
03E42:  MOVWF  FEA
03E44:  MOVF   FEF,W
03E46:  CLRF   x3D
03E48:  MOVWF  x3C
03E4A:  BTFSC  x3C.7
03E4C:  DECF   x3D,F
03E4E:  MOVLB  0
03E50:  CALL   269A
03E54:  MOVFF  713,753
03E58:  MOVFF  712,752
03E5C:  MOVFF  711,751
03E60:  MOVFF  710,750
03E64:  MOVFF  03,757
03E68:  MOVFF  02,756
03E6C:  MOVFF  01,755
03E70:  MOVFF  00,754
03E74:  CALL   0D6A
03E78:  MOVFF  FEA,711
03E7C:  MOVFF  FE9,710
03E80:  BCF    FD8.1
03E82:  MOVFF  70F,74D
03E86:  MOVFF  70E,74C
03E8A:  MOVFF  70D,74B
03E8E:  MOVFF  70C,74A
03E92:  MOVFF  03,751
03E96:  MOVFF  02,750
03E9A:  MOVFF  01,74F
03E9E:  MOVFF  00,74E
03EA2:  CALL   0E60
03EA6:  MOVFF  711,FEA
03EAA:  MOVFF  710,FE9
03EAE:  MOVFF  03,707
03EB2:  MOVFF  02,706
03EB6:  MOVFF  01,705
03EBA:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EBE:  MOVLB  7
03EC0:  MOVF   x03,W
03EC2:  MULLW  26
03EC4:  MOVF   FF3,W
03EC6:  CLRF   x0D
03EC8:  MOVWF  x0C
03ECA:  MOVLW  1D
03ECC:  ADDWF  x0C,W
03ECE:  MOVWF  01
03ED0:  MOVLW  00
03ED2:  ADDWFC x0D,W
03ED4:  MOVWF  03
03ED6:  MOVF   01,W
03ED8:  ADDLW  17
03EDA:  MOVWF  01
03EDC:  MOVLW  01
03EDE:  ADDWFC 03,F
03EE0:  MOVFF  01,70C
03EE4:  MOVFF  03,70D
03EE8:  MOVF   x03,W
03EEA:  MULLW  18
03EEC:  MOVF   FF3,W
03EEE:  CLRF   x0F
03EF0:  MOVWF  x0E
03EF2:  MOVLW  14
03EF4:  ADDWF  x0E,W
03EF6:  MOVWF  01
03EF8:  MOVLW  00
03EFA:  ADDWFC x0F,W
03EFC:  MOVWF  03
03EFE:  MOVF   01,W
03F00:  ADDLW  92
03F02:  MOVWF  FE9
03F04:  MOVLW  00
03F06:  ADDWFC 03,W
03F08:  MOVWF  FEA
03F0A:  MOVFF  FEF,754
03F0E:  MOVFF  FEC,01
03F12:  MOVFF  FEC,02
03F16:  MOVFF  FEC,03
03F1A:  MOVFF  707,753
03F1E:  MOVFF  706,752
03F22:  MOVFF  705,751
03F26:  MOVFF  704,750
03F2A:  MOVFF  03,757
03F2E:  MOVFF  02,756
03F32:  MOVFF  01,755
03F36:  MOVLB  0
03F38:  CALL   0D6A
03F3C:  MOVFF  03,711
03F40:  MOVFF  02,710
03F44:  MOVFF  01,70F
03F48:  MOVFF  00,70E
03F4C:  MOVFF  03,71D
03F50:  MOVFF  02,71C
03F54:  MOVFF  01,71B
03F58:  MOVFF  00,71A
03F5C:  MOVLB  7
03F5E:  CLRF   x21
03F60:  CLRF   x20
03F62:  MOVLW  20
03F64:  MOVWF  x1F
03F66:  MOVLW  81
03F68:  MOVWF  x1E
03F6A:  MOVLB  0
03F6C:  CALL   33D8
03F70:  MOVFF  03,711
03F74:  MOVFF  02,710
03F78:  MOVFF  01,70F
03F7C:  MOVFF  00,70E
03F80:  MOVLB  7
03F82:  MOVF   x03,W
03F84:  MULLW  18
03F86:  MOVF   FF3,W
03F88:  CLRF   x13
03F8A:  MOVWF  x12
03F8C:  MOVLW  10
03F8E:  ADDWF  x12,W
03F90:  MOVWF  01
03F92:  MOVLW  00
03F94:  ADDWFC x13,W
03F96:  MOVWF  03
03F98:  MOVF   01,W
03F9A:  ADDLW  92
03F9C:  MOVWF  FE9
03F9E:  MOVLW  00
03FA0:  ADDWFC 03,W
03FA2:  MOVWF  FEA
03FA4:  MOVFF  FEF,754
03FA8:  MOVFF  FEC,01
03FAC:  MOVFF  FEC,02
03FB0:  MOVFF  FEC,03
03FB4:  MOVFF  707,753
03FB8:  MOVFF  706,752
03FBC:  MOVFF  705,751
03FC0:  MOVFF  704,750
03FC4:  MOVFF  03,757
03FC8:  MOVFF  02,756
03FCC:  MOVFF  01,755
03FD0:  MOVLB  0
03FD2:  CALL   0D6A
03FD6:  MOVFF  03,715
03FDA:  MOVFF  02,714
03FDE:  MOVFF  01,713
03FE2:  MOVFF  00,712
03FE6:  MOVFF  03,71D
03FEA:  MOVFF  02,71C
03FEE:  MOVFF  01,71B
03FF2:  MOVFF  00,71A
03FF6:  MOVLB  7
03FF8:  CLRF   x21
03FFA:  CLRF   x20
03FFC:  CLRF   x1F
03FFE:  MOVLW  81
04000:  MOVWF  x1E
04002:  MOVLB  0
04004:  CALL   33D8
04008:  MOVFF  FEA,713
0400C:  MOVFF  FE9,712
04010:  BCF    FD8.1
04012:  MOVFF  711,74D
04016:  MOVFF  710,74C
0401A:  MOVFF  70F,74B
0401E:  MOVFF  70E,74A
04022:  MOVFF  03,751
04026:  MOVFF  02,750
0402A:  MOVFF  01,74F
0402E:  MOVFF  00,74E
04032:  CALL   0E60
04036:  MOVFF  713,FEA
0403A:  MOVFF  712,FE9
0403E:  MOVFF  03,711
04042:  MOVFF  02,710
04046:  MOVFF  01,70F
0404A:  MOVFF  00,70E
0404E:  MOVLB  7
04050:  MOVF   x03,W
04052:  MULLW  18
04054:  MOVF   FF3,W
04056:  CLRF   x15
04058:  MOVWF  x14
0405A:  MOVLW  0C
0405C:  ADDWF  x14,W
0405E:  MOVWF  01
04060:  MOVLW  00
04062:  ADDWFC x15,W
04064:  MOVWF  03
04066:  MOVF   01,W
04068:  ADDLW  92
0406A:  MOVWF  FE9
0406C:  MOVLW  00
0406E:  ADDWFC 03,W
04070:  MOVWF  FEA
04072:  MOVFF  FEF,754
04076:  MOVFF  FEC,01
0407A:  MOVFF  FEC,02
0407E:  MOVFF  FEC,03
04082:  MOVFF  707,753
04086:  MOVFF  706,752
0408A:  MOVFF  705,751
0408E:  MOVFF  704,750
04092:  MOVFF  03,757
04096:  MOVFF  02,756
0409A:  MOVFF  01,755
0409E:  MOVLB  0
040A0:  CALL   0D6A
040A4:  MOVFF  03,717
040A8:  MOVFF  02,716
040AC:  MOVFF  01,715
040B0:  MOVFF  00,714
040B4:  MOVFF  03,71D
040B8:  MOVFF  02,71C
040BC:  MOVFF  01,71B
040C0:  MOVFF  00,71A
040C4:  MOVLB  7
040C6:  CLRF   x21
040C8:  CLRF   x20
040CA:  MOVLW  40
040CC:  MOVWF  x1F
040CE:  MOVLW  80
040D0:  MOVWF  x1E
040D2:  MOVLB  0
040D4:  CALL   33D8
040D8:  MOVFF  FEA,715
040DC:  MOVFF  FE9,714
040E0:  BCF    FD8.1
040E2:  MOVFF  711,74D
040E6:  MOVFF  710,74C
040EA:  MOVFF  70F,74B
040EE:  MOVFF  70E,74A
040F2:  MOVFF  03,751
040F6:  MOVFF  02,750
040FA:  MOVFF  01,74F
040FE:  MOVFF  00,74E
04102:  CALL   0E60
04106:  MOVFF  715,FEA
0410A:  MOVFF  714,FE9
0410E:  MOVFF  03,711
04112:  MOVFF  02,710
04116:  MOVFF  01,70F
0411A:  MOVFF  00,70E
0411E:  MOVLB  7
04120:  MOVF   x03,W
04122:  MULLW  18
04124:  MOVF   FF3,W
04126:  CLRF   x17
04128:  MOVWF  x16
0412A:  MOVLW  08
0412C:  ADDWF  x16,W
0412E:  MOVWF  01
04130:  MOVLW  00
04132:  ADDWFC x17,W
04134:  MOVWF  03
04136:  MOVF   01,W
04138:  ADDLW  92
0413A:  MOVWF  FE9
0413C:  MOVLW  00
0413E:  ADDWFC 03,W
04140:  MOVWF  FEA
04142:  MOVFF  FEF,754
04146:  MOVFF  FEC,01
0414A:  MOVFF  FEC,02
0414E:  MOVFF  FEC,03
04152:  MOVFF  707,753
04156:  MOVFF  706,752
0415A:  MOVFF  705,751
0415E:  MOVFF  704,750
04162:  MOVFF  03,757
04166:  MOVFF  02,756
0416A:  MOVFF  01,755
0416E:  MOVLB  0
04170:  CALL   0D6A
04174:  MOVFF  03,719
04178:  MOVFF  02,718
0417C:  MOVFF  01,717
04180:  MOVFF  00,716
04184:  MOVFF  03,71D
04188:  MOVFF  02,71C
0418C:  MOVFF  01,71B
04190:  MOVFF  00,71A
04194:  MOVLB  7
04196:  CLRF   x21
04198:  CLRF   x20
0419A:  CLRF   x1F
0419C:  MOVLW  80
0419E:  MOVWF  x1E
041A0:  MOVLB  0
041A2:  CALL   33D8
041A6:  MOVFF  FEA,717
041AA:  MOVFF  FE9,716
041AE:  BCF    FD8.1
041B0:  MOVFF  711,74D
041B4:  MOVFF  710,74C
041B8:  MOVFF  70F,74B
041BC:  MOVFF  70E,74A
041C0:  MOVFF  03,751
041C4:  MOVFF  02,750
041C8:  MOVFF  01,74F
041CC:  MOVFF  00,74E
041D0:  CALL   0E60
041D4:  MOVFF  717,FEA
041D8:  MOVFF  716,FE9
041DC:  MOVFF  03,711
041E0:  MOVFF  02,710
041E4:  MOVFF  01,70F
041E8:  MOVFF  00,70E
041EC:  MOVLB  7
041EE:  MOVF   x03,W
041F0:  MULLW  18
041F2:  MOVF   FF3,W
041F4:  CLRF   x19
041F6:  MOVWF  x18
041F8:  MOVLW  04
041FA:  ADDWF  x18,W
041FC:  MOVWF  01
041FE:  MOVLW  00
04200:  ADDWFC x19,W
04202:  MOVWF  03
04204:  MOVF   01,W
04206:  ADDLW  92
04208:  MOVWF  FE9
0420A:  MOVLW  00
0420C:  ADDWFC 03,W
0420E:  MOVWF  FEA
04210:  MOVFF  FEF,754
04214:  MOVFF  FEC,01
04218:  MOVFF  FEC,02
0421C:  MOVFF  FEC,03
04220:  MOVFF  707,753
04224:  MOVFF  706,752
04228:  MOVFF  705,751
0422C:  MOVFF  704,750
04230:  MOVFF  03,757
04234:  MOVFF  02,756
04238:  MOVFF  01,755
0423C:  MOVLB  0
0423E:  CALL   0D6A
04242:  MOVFF  FEA,719
04246:  MOVFF  FE9,718
0424A:  BCF    FD8.1
0424C:  MOVFF  711,74D
04250:  MOVFF  710,74C
04254:  MOVFF  70F,74B
04258:  MOVFF  70E,74A
0425C:  MOVFF  03,751
04260:  MOVFF  02,750
04264:  MOVFF  01,74F
04268:  MOVFF  00,74E
0426C:  CALL   0E60
04270:  MOVFF  719,FEA
04274:  MOVFF  718,FE9
04278:  MOVFF  03,74D
0427C:  MOVFF  02,74C
04280:  MOVFF  01,74B
04284:  MOVFF  00,74A
04288:  MOVLB  7
0428A:  MOVF   x03,W
0428C:  MULLW  18
0428E:  MOVF   FF3,W
04290:  CLRF   x1B
04292:  MOVWF  x1A
04294:  MOVLW  92
04296:  ADDWF  x1A,W
04298:  MOVWF  FE9
0429A:  MOVLW  00
0429C:  ADDWFC x1B,W
0429E:  MOVWF  FEA
042A0:  MOVFF  FEF,74E
042A4:  MOVFF  FEC,01
042A8:  MOVFF  FEC,02
042AC:  MOVFF  FEC,03
042B0:  BCF    FD8.1
042B2:  MOVFF  03,751
042B6:  MOVFF  02,750
042BA:  MOVFF  01,74F
042BE:  MOVLB  0
042C0:  CALL   0E60
042C4:  MOVFF  70D,FEA
042C8:  MOVFF  70C,FE9
042CC:  MOVFF  00,FEF
042D0:  MOVFF  01,FEC
042D4:  MOVFF  02,FEC
042D8:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
042DC:  MOVLB  7
042DE:  MOVF   x03,F
042E0:  BNZ   433E
042E2:  MOVF   x03,W
042E4:  MULLW  26
042E6:  MOVF   FF3,W
042E8:  CLRF   x0D
042EA:  MOVWF  x0C
042EC:  MOVLW  1D
042EE:  ADDWF  x0C,W
042F0:  MOVWF  01
042F2:  MOVLW  00
042F4:  ADDWFC x0D,W
042F6:  MOVWF  03
042F8:  MOVF   01,W
042FA:  ADDLW  17
042FC:  MOVWF  FE9
042FE:  MOVLW  01
04300:  ADDWFC 03,W
04302:  MOVWF  FEA
04304:  MOVFF  FEF,750
04308:  MOVFF  FEC,751
0430C:  MOVFF  FEC,752
04310:  MOVFF  FEC,753
04314:  MOVF   FED,F
04316:  MOVF   FED,F
04318:  MOVF   FED,F
0431A:  CLRF   x57
0431C:  CLRF   x56
0431E:  MOVLW  80
04320:  MOVWF  x55
04322:  MOVLW  7F
04324:  MOVWF  x54
04326:  MOVLB  0
04328:  CALL   0D6A
0432C:  MOVFF  00,FEF
04330:  MOVFF  01,FEC
04334:  MOVFF  02,FEC
04338:  MOVFF  03,FEC
0433C:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
0433E:  MOVF   x03,W
04340:  MULLW  28
04342:  MOVF   FF3,W
04344:  CLRF   x0D
04346:  MOVWF  x0C
04348:  MOVLW  14
0434A:  ADDWF  x0C,W
0434C:  MOVWF  01
0434E:  MOVLW  00
04350:  ADDWFC x0D,W
04352:  MOVWF  03
04354:  MOVF   01,W
04356:  ADDLW  20
04358:  MOVWF  01
0435A:  MOVLW  00
0435C:  ADDWFC 03,F
0435E:  MOVFF  01,70C
04362:  MOVFF  03,70D
04366:  MOVF   x03,W
04368:  MULLW  28
0436A:  MOVF   FF3,W
0436C:  CLRF   x0F
0436E:  MOVWF  x0E
04370:  MOVLW  10
04372:  ADDWF  x0E,W
04374:  MOVWF  01
04376:  MOVLW  00
04378:  ADDWFC x0F,W
0437A:  MOVWF  03
0437C:  MOVF   01,W
0437E:  ADDLW  20
04380:  MOVWF  FE9
04382:  MOVLW  00
04384:  ADDWFC 03,W
04386:  MOVWF  FEA
04388:  MOVFF  FEF,00
0438C:  MOVFF  FEC,01
04390:  MOVFF  FEC,02
04394:  MOVFF  FEC,03
04398:  MOVFF  70D,FEA
0439C:  MOVFF  70C,FE9
043A0:  MOVFF  00,FEF
043A4:  MOVFF  01,FEC
043A8:  MOVFF  02,FEC
043AC:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043B0:  MOVF   x03,W
043B2:  MULLW  28
043B4:  MOVF   FF3,W
043B6:  CLRF   x0D
043B8:  MOVWF  x0C
043BA:  MOVLW  10
043BC:  ADDWF  x0C,W
043BE:  MOVWF  01
043C0:  MOVLW  00
043C2:  ADDWFC x0D,W
043C4:  MOVWF  03
043C6:  MOVF   01,W
043C8:  ADDLW  20
043CA:  MOVWF  01
043CC:  MOVLW  00
043CE:  ADDWFC 03,F
043D0:  MOVFF  01,70C
043D4:  MOVFF  03,70D
043D8:  MOVF   x03,W
043DA:  MULLW  26
043DC:  MOVF   FF3,W
043DE:  CLRF   x0F
043E0:  MOVWF  x0E
043E2:  MOVLW  1D
043E4:  ADDWF  x0E,W
043E6:  MOVWF  01
043E8:  MOVLW  00
043EA:  ADDWFC x0F,W
043EC:  MOVWF  03
043EE:  MOVF   01,W
043F0:  ADDLW  17
043F2:  MOVWF  FE9
043F4:  MOVLW  01
043F6:  ADDWFC 03,W
043F8:  MOVWF  FEA
043FA:  MOVFF  FEF,00
043FE:  MOVFF  FEC,01
04402:  MOVFF  FEC,02
04406:  MOVFF  FEC,03
0440A:  MOVFF  70D,FEA
0440E:  MOVFF  70C,FE9
04412:  MOVFF  00,FEF
04416:  MOVFF  01,FEC
0441A:  MOVFF  02,FEC
0441E:  MOVFF  03,FEC
04422:  MOVLB  0
04424:  GOTO   4584 (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001C0:  MOVLB  1
001C2:  MOVF   xE7,W
001C4:  MULLW  09
001C6:  MOVF   FF3,W
001C8:  MOVLB  7
001CA:  CLRF   x72
001CC:  MOVWF  x71
001CE:  MOVLW  D4
001D0:  ADDWF  x71,W
001D2:  MOVWF  FE9
001D4:  MOVLW  01
001D6:  ADDWFC x72,W
001D8:  MOVWF  FEA
001DA:  BTFSC  FEF.1
001DC:  BRA    0256
....................       smData[ch].adcBusy = true;
001DE:  MOVLB  1
001E0:  MOVF   xE7,W
001E2:  MULLW  09
001E4:  MOVF   FF3,W
001E6:  MOVLB  7
001E8:  CLRF   x72
001EA:  MOVWF  x71
001EC:  MOVLW  D4
001EE:  ADDWF  x71,W
001F0:  MOVWF  FE9
001F2:  MOVLW  01
001F4:  ADDWFC x72,W
001F6:  MOVWF  FEA
001F8:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
001FA:  MOVFF  1E7,771
001FE:  MOVLB  0
00200:  BRA    01A4
....................       ch = !ch;
00202:  MOVLB  1
00204:  MOVF   xE7,F
00206:  BZ    020C
00208:  MOVLW  00
0020A:  BRA    020E
0020C:  MOVLW  01
0020E:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00210:  MOVF   xE7,F
00212:  BZ    0218
00214:  MOVLW  00
00216:  BRA    021A
00218:  MOVLW  01
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x72
00222:  MOVWF  x71
00224:  MOVLW  D4
00226:  ADDWF  x71,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x72,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00232:  MOVLB  1
00234:  MOVF   xE7,F
00236:  BZ    023C
00238:  MOVLW  00
0023A:  BRA    023E
0023C:  MOVLW  01
0023E:  MULLW  09
00240:  MOVF   FF3,W
00242:  MOVLB  7
00244:  CLRF   x72
00246:  MOVWF  x71
00248:  MOVLW  D4
0024A:  ADDWF  x71,W
0024C:  MOVWF  FE9
0024E:  MOVLW  01
00250:  ADDWFC x72,W
00252:  MOVWF  FEA
00254:  BCF    FEF.1
....................    }
00256:  MOVLB  0
00258:  GOTO   031A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
01740:  MOVLB  7
01742:  CLRF   x17
01744:  CLRF   x16
01746:  CLRF   x15
01748:  CLRF   x14
0174A:  CLRF   x1B
0174C:  CLRF   x1A
0174E:  CLRF   x19
01750:  CLRF   x18
01752:  CLRF   x1F
01754:  CLRF   x1E
01756:  CLRF   x1D
01758:  CLRF   x1C
0175A:  CLRF   x23
0175C:  CLRF   x22
0175E:  CLRF   x21
01760:  CLRF   x20
01762:  CLRF   x27
01764:  CLRF   x26
01766:  CLRF   x25
01768:  CLRF   x24
0176A:  CLRF   x2B
0176C:  CLRF   x2A
0176E:  CLRF   x29
01770:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
01772:  MOVF   x03,F
01774:  BNZ   1798
....................       sQ_ch = sQ_x;
01776:  MOVLW  01
01778:  MOVWF  x0D
0177A:  MOVLW  80
0177C:  MOVWF  x0C
....................       cQ_ch = cQ_x;
0177E:  MOVLW  01
01780:  MOVWF  x0F
01782:  MOVLW  94
01784:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
01786:  MOVLW  01
01788:  MOVWF  x11
0178A:  MOVLW  D0
0178C:  MOVWF  x10
....................       cIn_ch = &cIn_x;
0178E:  MOVLW  01
01790:  MOVWF  x13
01792:  MOVLW  D1
01794:  MOVWF  x12
....................    }
01796:  BRA    17BC
....................    else if (ch==1){
01798:  DECFSZ x03,W
0179A:  BRA    17BC
....................       sQ_ch = sQ_y;
0179C:  MOVLW  01
0179E:  MOVWF  x0D
017A0:  MOVLW  A8
017A2:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017A4:  MOVLW  01
017A6:  MOVWF  x0F
017A8:  MOVLW  BC
017AA:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017AC:  MOVLW  01
017AE:  MOVWF  x11
017B0:  MOVLW  D2
017B2:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017B4:  MOVLW  01
017B6:  MOVWF  x13
017B8:  MOVLW  D3
017BA:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017BC:  MOVFF  70D,72E
017C0:  MOVFF  70C,72D
017C4:  MOVFF  711,730
017C8:  MOVFF  710,72F
017CC:  MOVFF  707,734
017D0:  MOVFF  706,733
017D4:  MOVFF  705,732
017D8:  MOVFF  704,731
017DC:  MOVLB  0
017DE:  CALL   08CE
....................    push(cQ_ch, cIn_ch, cosCnts);
017E2:  MOVFF  70F,72E
017E6:  MOVFF  70E,72D
017EA:  MOVFF  713,730
017EE:  MOVFF  712,72F
017F2:  MOVFF  70B,734
017F6:  MOVFF  70A,733
017FA:  MOVFF  709,732
017FE:  MOVFF  708,731
01802:  CALL   08CE
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01806:  MOVLB  7
01808:  MOVFF  70C,FE9
0180C:  MOVFF  70D,FEA
01810:  MOVFF  FEF,71C
01814:  MOVFF  FEC,71D
01818:  MOVFF  FEC,71E
0181C:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
01820:  MOVFF  70C,FE9
01824:  MOVFF  70D,FEA
01828:  MOVFF  FEF,720
0182C:  MOVFF  FEC,721
01830:  MOVFF  FEC,722
01834:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
01838:  MOVFF  70E,FE9
0183C:  MOVFF  70F,FEA
01840:  MOVFF  FEF,724
01844:  MOVFF  FEC,725
01848:  MOVFF  FEC,726
0184C:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
01850:  MOVFF  70E,FE9
01854:  MOVFF  70F,FEA
01858:  MOVFF  FEF,728
0185C:  MOVFF  FEC,729
01860:  MOVFF  FEC,72A
01864:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
01868:  MOVLW  01
0186A:  MOVWF  x2C
0186C:  MOVF   x2C,W
0186E:  SUBLW  04
01870:  BTFSS  FD8.0
01872:  BRA    1B82
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
01874:  CLRF   x42
01876:  MOVFF  72C,741
0187A:  CLRF   x44
0187C:  MOVLW  04
0187E:  MOVWF  x43
01880:  MOVLB  0
01882:  CALL   0880
01886:  MOVFF  02,03
0188A:  MOVF   01,W
0188C:  MOVLB  7
0188E:  ADDWF  x0C,W
01890:  MOVWF  FE9
01892:  MOVF   x0D,W
01894:  ADDWFC 02,W
01896:  MOVWF  FEA
01898:  MOVFF  FEF,00
0189C:  MOVFF  FEC,01
018A0:  MOVFF  FEC,02
018A4:  MOVFF  FEC,03
018A8:  BTFSS  x1F.7
018AA:  BRA    18B2
018AC:  BTFSS  03.7
018AE:  BRA    18D4
018B0:  BRA    18B6
018B2:  BTFSC  03.7
018B4:  BRA    190A
018B6:  MOVF   x1F,W
018B8:  SUBWF  03,W
018BA:  BNC   190A
018BC:  BNZ   18D4
018BE:  MOVF   x1E,W
018C0:  SUBWF  02,W
018C2:  BNC   190A
018C4:  BNZ   18D4
018C6:  MOVF   x1D,W
018C8:  SUBWF  01,W
018CA:  BNC   190A
018CC:  BNZ   18D4
018CE:  MOVF   00,W
018D0:  SUBWF  x1C,W
018D2:  BC    190A
018D4:  CLRF   x42
018D6:  MOVFF  72C,741
018DA:  CLRF   x44
018DC:  MOVLW  04
018DE:  MOVWF  x43
018E0:  MOVLB  0
018E2:  CALL   0880
018E6:  MOVFF  02,03
018EA:  MOVF   01,W
018EC:  MOVLB  7
018EE:  ADDWF  x0C,W
018F0:  MOVWF  FE9
018F2:  MOVF   x0D,W
018F4:  ADDWFC 02,W
018F6:  MOVWF  FEA
018F8:  MOVFF  FEF,71C
018FC:  MOVFF  FEC,71D
01900:  MOVFF  FEC,71E
01904:  MOVFF  FEC,71F
01908:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
0190A:  CLRF   x42
0190C:  MOVFF  72C,741
01910:  CLRF   x44
01912:  MOVLW  04
01914:  MOVWF  x43
01916:  MOVLB  0
01918:  CALL   0880
0191C:  MOVFF  02,03
01920:  MOVF   01,W
01922:  MOVLB  7
01924:  ADDWF  x0C,W
01926:  MOVWF  FE9
01928:  MOVF   x0D,W
0192A:  ADDWFC 02,W
0192C:  MOVWF  FEA
0192E:  MOVFF  FEF,00
01932:  MOVFF  FEC,01
01936:  MOVFF  FEC,02
0193A:  MOVFF  FEC,03
0193E:  BTFSS  03.7
01940:  BRA    1948
01942:  BTFSS  x23.7
01944:  BRA    196A
01946:  BRA    194C
01948:  BTFSC  x23.7
0194A:  BRA    19AE
0194C:  MOVF   03,W
0194E:  SUBWF  x23,W
01950:  BNC   19AE
01952:  BNZ   196A
01954:  MOVF   02,W
01956:  SUBWF  x22,W
01958:  BNC   19AE
0195A:  BNZ   196A
0195C:  MOVF   01,W
0195E:  SUBWF  x21,W
01960:  BNC   19AE
01962:  BNZ   196A
01964:  MOVF   x20,W
01966:  SUBWF  00,W
01968:  BC    19AE
0196A:  CLRF   x42
0196C:  MOVFF  72C,741
01970:  CLRF   x44
01972:  MOVLW  04
01974:  MOVWF  x43
01976:  MOVLB  0
01978:  CALL   0880
0197C:  MOVFF  02,03
01980:  MOVF   01,W
01982:  MOVLB  7
01984:  ADDWF  x0C,W
01986:  MOVWF  FE9
01988:  MOVF   x0D,W
0198A:  ADDWFC 02,W
0198C:  MOVWF  FEA
0198E:  MOVFF  FEF,720
01992:  MOVFF  FEC,721
01996:  MOVFF  FEC,722
0199A:  MOVFF  FEC,723
0199E:  MOVFF  720,00
019A2:  MOVFF  721,01
019A6:  MOVFF  722,02
019AA:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019AE:  CLRF   x42
019B0:  MOVFF  72C,741
019B4:  CLRF   x44
019B6:  MOVLW  04
019B8:  MOVWF  x43
019BA:  MOVLB  0
019BC:  CALL   0880
019C0:  MOVFF  02,03
019C4:  MOVF   01,W
019C6:  MOVLB  7
019C8:  ADDWF  x0E,W
019CA:  MOVWF  FE9
019CC:  MOVF   x0F,W
019CE:  ADDWFC 02,W
019D0:  MOVWF  FEA
019D2:  MOVFF  FEF,00
019D6:  MOVFF  FEC,01
019DA:  MOVFF  FEC,02
019DE:  MOVFF  FEC,03
019E2:  BTFSS  x27.7
019E4:  BRA    19EC
019E6:  BTFSS  03.7
019E8:  BRA    1A0E
019EA:  BRA    19F0
019EC:  BTFSC  03.7
019EE:  BRA    1A52
019F0:  MOVF   x27,W
019F2:  SUBWF  03,W
019F4:  BNC   1A52
019F6:  BNZ   1A0E
019F8:  MOVF   x26,W
019FA:  SUBWF  02,W
019FC:  BNC   1A52
019FE:  BNZ   1A0E
01A00:  MOVF   x25,W
01A02:  SUBWF  01,W
01A04:  BNC   1A52
01A06:  BNZ   1A0E
01A08:  MOVF   00,W
01A0A:  SUBWF  x24,W
01A0C:  BC    1A52
01A0E:  CLRF   x42
01A10:  MOVFF  72C,741
01A14:  CLRF   x44
01A16:  MOVLW  04
01A18:  MOVWF  x43
01A1A:  MOVLB  0
01A1C:  CALL   0880
01A20:  MOVFF  02,03
01A24:  MOVF   01,W
01A26:  MOVLB  7
01A28:  ADDWF  x0E,W
01A2A:  MOVWF  FE9
01A2C:  MOVF   x0F,W
01A2E:  ADDWFC 02,W
01A30:  MOVWF  FEA
01A32:  MOVFF  FEF,724
01A36:  MOVFF  FEC,725
01A3A:  MOVFF  FEC,726
01A3E:  MOVFF  FEC,727
01A42:  MOVFF  724,00
01A46:  MOVFF  725,01
01A4A:  MOVFF  726,02
01A4E:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A52:  CLRF   x42
01A54:  MOVFF  72C,741
01A58:  CLRF   x44
01A5A:  MOVLW  04
01A5C:  MOVWF  x43
01A5E:  MOVLB  0
01A60:  CALL   0880
01A64:  MOVFF  02,03
01A68:  MOVF   01,W
01A6A:  MOVLB  7
01A6C:  ADDWF  x0E,W
01A6E:  MOVWF  FE9
01A70:  MOVF   x0F,W
01A72:  ADDWFC 02,W
01A74:  MOVWF  FEA
01A76:  MOVFF  FEF,00
01A7A:  MOVFF  FEC,01
01A7E:  MOVFF  FEC,02
01A82:  MOVFF  FEC,03
01A86:  BTFSS  03.7
01A88:  BRA    1A90
01A8A:  BTFSS  x2B.7
01A8C:  BRA    1AB2
01A8E:  BRA    1A94
01A90:  BTFSC  x2B.7
01A92:  BRA    1AF6
01A94:  MOVF   03,W
01A96:  SUBWF  x2B,W
01A98:  BNC   1AF6
01A9A:  BNZ   1AB2
01A9C:  MOVF   02,W
01A9E:  SUBWF  x2A,W
01AA0:  BNC   1AF6
01AA2:  BNZ   1AB2
01AA4:  MOVF   01,W
01AA6:  SUBWF  x29,W
01AA8:  BNC   1AF6
01AAA:  BNZ   1AB2
01AAC:  MOVF   x28,W
01AAE:  SUBWF  00,W
01AB0:  BC    1AF6
01AB2:  CLRF   x42
01AB4:  MOVFF  72C,741
01AB8:  CLRF   x44
01ABA:  MOVLW  04
01ABC:  MOVWF  x43
01ABE:  MOVLB  0
01AC0:  CALL   0880
01AC4:  MOVFF  02,03
01AC8:  MOVF   01,W
01ACA:  MOVLB  7
01ACC:  ADDWF  x0E,W
01ACE:  MOVWF  FE9
01AD0:  MOVF   x0F,W
01AD2:  ADDWFC 02,W
01AD4:  MOVWF  FEA
01AD6:  MOVFF  FEF,728
01ADA:  MOVFF  FEC,729
01ADE:  MOVFF  FEC,72A
01AE2:  MOVFF  FEC,72B
01AE6:  MOVFF  728,00
01AEA:  MOVFF  729,01
01AEE:  MOVFF  72A,02
01AF2:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01AF6:  CLRF   x42
01AF8:  MOVFF  72C,741
01AFC:  CLRF   x44
01AFE:  MOVLW  04
01B00:  MOVWF  x43
01B02:  MOVLB  0
01B04:  CALL   0880
01B08:  MOVFF  02,03
01B0C:  MOVF   01,W
01B0E:  MOVLB  7
01B10:  ADDWF  x0C,W
01B12:  MOVWF  FE9
01B14:  MOVF   x0D,W
01B16:  ADDWFC 02,W
01B18:  MOVWF  FEA
01B1A:  MOVFF  FEF,00
01B1E:  MOVFF  FEC,01
01B22:  MOVFF  FEC,02
01B26:  MOVFF  FEC,03
01B2A:  MOVF   00,W
01B2C:  ADDWF  x14,F
01B2E:  MOVF   01,W
01B30:  ADDWFC x15,F
01B32:  MOVF   02,W
01B34:  ADDWFC x16,F
01B36:  MOVF   03,W
01B38:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B3A:  CLRF   x42
01B3C:  MOVFF  72C,741
01B40:  CLRF   x44
01B42:  MOVLW  04
01B44:  MOVWF  x43
01B46:  MOVLB  0
01B48:  CALL   0880
01B4C:  MOVFF  02,03
01B50:  MOVF   01,W
01B52:  MOVLB  7
01B54:  ADDWF  x0E,W
01B56:  MOVWF  FE9
01B58:  MOVF   x0F,W
01B5A:  ADDWFC 02,W
01B5C:  MOVWF  FEA
01B5E:  MOVFF  FEF,00
01B62:  MOVFF  FEC,01
01B66:  MOVFF  FEC,02
01B6A:  MOVFF  FEC,03
01B6E:  MOVF   00,W
01B70:  ADDWF  x18,F
01B72:  MOVF   01,W
01B74:  ADDWFC x19,F
01B76:  MOVF   02,W
01B78:  ADDWFC x1A,F
01B7A:  MOVF   03,W
01B7C:  ADDWFC x1B,F
01B7E:  INCF   x2C,F
01B80:  BRA    186C
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01B82:  MOVF   x20,W
01B84:  ADDWF  x1C,W
01B86:  MOVWF  00
01B88:  MOVF   x21,W
01B8A:  ADDWFC x1D,W
01B8C:  MOVWF  01
01B8E:  MOVF   x22,W
01B90:  ADDWFC x1E,W
01B92:  MOVWF  02
01B94:  MOVF   x23,W
01B96:  ADDWFC x1F,W
01B98:  MOVWF  03
01B9A:  MOVF   00,W
01B9C:  SUBWF  x14,F
01B9E:  MOVF   01,W
01BA0:  SUBWFB x15,F
01BA2:  MOVF   02,W
01BA4:  SUBWFB x16,F
01BA6:  MOVF   03,W
01BA8:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BAA:  MOVF   x28,W
01BAC:  ADDWF  x24,W
01BAE:  MOVWF  00
01BB0:  MOVF   x29,W
01BB2:  ADDWFC x25,W
01BB4:  MOVWF  01
01BB6:  MOVF   x2A,W
01BB8:  ADDWFC x26,W
01BBA:  MOVWF  02
01BBC:  MOVF   x2B,W
01BBE:  ADDWFC x27,W
01BC0:  MOVWF  03
01BC2:  MOVF   00,W
01BC4:  SUBWF  x18,F
01BC6:  MOVF   01,W
01BC8:  SUBWFB x19,F
01BCA:  MOVF   02,W
01BCC:  SUBWFB x1A,F
01BCE:  MOVF   03,W
01BD0:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01BD2:  MOVF   x03,W
01BD4:  MULLW  09
01BD6:  MOVF   FF3,W
01BD8:  CLRF   x2E
01BDA:  MOVWF  x2D
01BDC:  MOVLW  01
01BDE:  ADDWF  x2D,W
01BE0:  MOVWF  01
01BE2:  MOVLW  00
01BE4:  ADDWFC x2E,W
01BE6:  MOVWF  03
01BE8:  MOVF   01,W
01BEA:  ADDLW  D4
01BEC:  MOVWF  FE9
01BEE:  MOVLW  01
01BF0:  ADDWFC 03,W
01BF2:  MOVWF  FEA
01BF4:  MOVFF  FEA,730
01BF8:  MOVFF  FE9,72F
01BFC:  BCF    FD8.1
01BFE:  MOVFF  717,734
01C02:  MOVFF  716,733
01C06:  MOVFF  715,732
01C0A:  MOVFF  714,731
01C0E:  CLRF   x38
01C10:  CLRF   x37
01C12:  CLRF   x36
01C14:  MOVLW  03
01C16:  MOVWF  x35
01C18:  MOVLB  0
01C1A:  RCALL  1656
01C1C:  MOVFF  730,FEA
01C20:  MOVFF  72F,FE9
01C24:  MOVFF  00,FEF
01C28:  MOVFF  01,FEC
01C2C:  MOVFF  02,FEC
01C30:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C34:  MOVLB  7
01C36:  MOVF   x03,W
01C38:  MULLW  09
01C3A:  MOVF   FF3,W
01C3C:  CLRF   x2E
01C3E:  MOVWF  x2D
01C40:  MOVLW  05
01C42:  ADDWF  x2D,W
01C44:  MOVWF  01
01C46:  MOVLW  00
01C48:  ADDWFC x2E,W
01C4A:  MOVWF  03
01C4C:  MOVF   01,W
01C4E:  ADDLW  D4
01C50:  MOVWF  FE9
01C52:  MOVLW  01
01C54:  ADDWFC 03,W
01C56:  MOVWF  FEA
01C58:  MOVFF  FEA,730
01C5C:  MOVFF  FE9,72F
01C60:  BCF    FD8.1
01C62:  MOVFF  71B,734
01C66:  MOVFF  71A,733
01C6A:  MOVFF  719,732
01C6E:  MOVFF  718,731
01C72:  CLRF   x38
01C74:  CLRF   x37
01C76:  CLRF   x36
01C78:  MOVLW  03
01C7A:  MOVWF  x35
01C7C:  MOVLB  0
01C7E:  RCALL  1656
01C80:  MOVFF  730,FEA
01C84:  MOVFF  72F,FE9
01C88:  MOVFF  00,FEF
01C8C:  MOVFF  01,FEC
01C90:  MOVFF  02,FEC
01C94:  MOVFF  03,FEC
01C98:  GOTO   450C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04428:  MOVLB  6
0442A:  CLRF   xFE
0442C:  CLRF   xFD
0442E:  CLRF   xFC
04430:  CLRF   xFB
04432:  MOVLB  7
04434:  CLRF   x02
04436:  CLRF   x01
04438:  CLRF   x00
0443A:  MOVLB  6
0443C:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
0443E:  MOVLB  1
04440:  MOVF   xE8,W
04442:  MULLW  09
04444:  MOVF   FF3,W
04446:  MOVLB  7
04448:  CLRF   x04
0444A:  MOVWF  x03
0444C:  MOVLW  D4
0444E:  ADDWF  x03,W
04450:  MOVWF  FE9
04452:  MOVLW  01
04454:  ADDWFC x04,W
04456:  MOVWF  FEA
04458:  BTFSC  FEF.1
0445A:  BRA    45D8
0445C:  MOVLB  1
0445E:  MOVF   xE8,W
04460:  MULLW  09
04462:  MOVF   FF3,W
04464:  MOVLB  7
04466:  CLRF   x06
04468:  MOVWF  x05
0446A:  MOVLW  D4
0446C:  ADDWF  x05,W
0446E:  MOVWF  FE9
04470:  MOVLW  01
04472:  ADDWFC x06,W
04474:  MOVWF  FEA
04476:  BTFSS  FEF.0
04478:  BRA    45D8
....................       smData[ch].adcBusy = true;
0447A:  MOVLB  1
0447C:  MOVF   xE8,W
0447E:  MULLW  09
04480:  MOVF   FF3,W
04482:  MOVLB  7
04484:  CLRF   x04
04486:  MOVWF  x03
04488:  MOVLW  D4
0448A:  ADDWF  x03,W
0448C:  MOVWF  FE9
0448E:  MOVLW  01
04490:  ADDWFC x04,W
04492:  MOVWF  FEA
04494:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
04496:  BCF    FD8.0
04498:  MOVLB  1
0449A:  RLCF   xE8,W
0449C:  MOVLB  7
0449E:  MOVWF  x03
044A0:  MOVWF  x04
044A2:  MOVLB  0
044A4:  CALL   0826
044A8:  MOVFF  03,6FE
044AC:  MOVFF  02,6FD
044B0:  MOVFF  01,6FC
044B4:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044B8:  BCF    FD8.0
044BA:  MOVLB  1
044BC:  RLCF   xE8,W
044BE:  ADDLW  01
044C0:  MOVLB  7
044C2:  MOVWF  x03
044C4:  MOVWF  x04
044C6:  MOVLB  0
044C8:  CALL   0826
044CC:  MOVFF  03,702
044D0:  MOVFF  02,701
044D4:  MOVFF  01,700
044D8:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
044DC:  MOVLB  1
044DE:  BTFSS  x63.0
044E0:  BRA    4510
....................          iqm_ring_buffer(ch, sinNew, cosNew);
044E2:  MOVFF  1E8,703
044E6:  MOVFF  6FE,707
044EA:  MOVFF  6FD,706
044EE:  MOVFF  6FC,705
044F2:  MOVFF  6FB,704
044F6:  MOVFF  702,70B
044FA:  MOVFF  701,70A
044FE:  MOVFF  700,709
04502:  MOVFF  6FF,708
04506:  MOVLB  0
04508:  GOTO   1740
....................       }
0450C:  BRA    457C
0450E:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
04510:  MOVF   xE8,W
04512:  MULLW  09
04514:  MOVF   FF3,W
04516:  MOVLB  7
04518:  CLRF   x04
0451A:  MOVWF  x03
0451C:  MOVLW  01
0451E:  ADDWF  x03,W
04520:  MOVWF  01
04522:  MOVLW  00
04524:  ADDWFC x04,W
04526:  MOVWF  03
04528:  MOVF   01,W
0452A:  ADDLW  D4
0452C:  MOVWF  FE9
0452E:  MOVLW  01
04530:  ADDWFC 03,W
04532:  MOVWF  FEA
04534:  MOVFF  6FB,FEF
04538:  MOVFF  6FC,FEC
0453C:  MOVFF  6FD,FEC
04540:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
04544:  MOVLB  1
04546:  MOVF   xE8,W
04548:  MULLW  09
0454A:  MOVF   FF3,W
0454C:  MOVLB  7
0454E:  CLRF   x04
04550:  MOVWF  x03
04552:  MOVLW  05
04554:  ADDWF  x03,W
04556:  MOVWF  01
04558:  MOVLW  00
0455A:  ADDWFC x04,W
0455C:  MOVWF  03
0455E:  MOVF   01,W
04560:  ADDLW  D4
04562:  MOVWF  FE9
04564:  MOVLW  01
04566:  ADDWFC 03,W
04568:  MOVWF  FEA
0456A:  MOVFF  6FF,FEF
0456E:  MOVFF  700,FEC
04572:  MOVFF  701,FEC
04576:  MOVFF  702,FEC
0457A:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
0457C:  MOVFF  1E8,703
04580:  GOTO   36D6
....................       ch = !ch;
04584:  MOVLB  1
04586:  MOVF   xE8,F
04588:  BZ    458E
0458A:  MOVLW  00
0458C:  BRA    4590
0458E:  MOVLW  01
04590:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
04592:  MOVF   xE8,F
04594:  BZ    459A
04596:  MOVLW  00
04598:  BRA    459C
0459A:  MOVLW  01
0459C:  MULLW  09
0459E:  MOVF   FF3,W
045A0:  MOVLB  7
045A2:  CLRF   x04
045A4:  MOVWF  x03
045A6:  MOVLW  D4
045A8:  ADDWF  x03,W
045AA:  MOVWF  FE9
045AC:  MOVLW  01
045AE:  ADDWFC x04,W
045B0:  MOVWF  FEA
045B2:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045B4:  MOVLB  1
045B6:  MOVF   xE8,F
045B8:  BZ    45BE
045BA:  MOVLW  00
045BC:  BRA    45C0
045BE:  MOVLW  01
045C0:  MULLW  09
045C2:  MOVF   FF3,W
045C4:  MOVLB  7
045C6:  CLRF   x04
045C8:  MOVWF  x03
045CA:  MOVLW  D4
045CC:  ADDWF  x03,W
045CE:  MOVWF  FE9
045D0:  MOVLW  01
045D2:  ADDWFC x04,W
045D4:  MOVWF  FEA
045D6:  BCF    FEF.1
....................    }
045D8:  MOVLB  0
045DA:  GOTO   A6FA (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
00934:  MOVLB  6
00936:  CLRF   xFB
00938:  CLRF   xFC
0093A:  CLRF   xFD
0093C:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
0093E:  CLRF   xFF
00940:  MOVF   xFF,W
00942:  SUBLW  03
00944:  BNC   097A
....................       rc0=reg0config;
00946:  MOVLW  30
00948:  MOVWF  xFB
....................       rc1=reg1config;
0094A:  MOVLW  10
0094C:  MOVWF  xFC
....................       rc2=reg2config;
0094E:  CLRF   xFD
....................       rc3=reg3config;
00950:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
00952:  MOVFF  6FF,701
00956:  MOVFF  6FB,702
0095A:  MOVFF  6FC,703
0095E:  MOVFF  6FD,704
00962:  MOVFF  6FE,705
00966:  MOVLB  0
00968:  BRA    0758
....................       delay_ms(100);
0096A:  MOVLW  64
0096C:  MOVLB  7
0096E:  MOVWF  x01
00970:  MOVLB  0
00972:  RCALL  0394
00974:  MOVLB  6
00976:  INCF   xFF,F
00978:  BRA    0940
....................    }
....................    
....................    if (adcFilter){
0097A:  MOVLB  1
0097C:  BTFSS  x63.0
0097E:  BRA    0AA0
....................       for (int i = 0; i < BUFFER_SIZE; i++){
00980:  MOVLB  7
00982:  CLRF   x00
00984:  MOVF   x00,W
00986:  SUBLW  04
00988:  BTFSS  FD8.0
0098A:  BRA    0A9E
....................          ads_start_conv_all();
0098C:  MOVLB  0
0098E:  BRA    07F6
....................          delay_ms(50);
00990:  MOVLW  32
00992:  MOVLB  7
00994:  MOVWF  x01
00996:  MOVLB  0
00998:  RCALL  0394
....................          push(sQ_x, &sIn_x, ads_read_data(0));
0099A:  MOVLB  7
0099C:  CLRF   x04
0099E:  MOVLB  0
009A0:  RCALL  0826
009A2:  MOVFF  03,704
009A6:  MOVFF  02,703
009AA:  MOVFF  01,702
009AE:  MOVFF  00,701
009B2:  MOVLW  01
009B4:  MOVLB  7
009B6:  MOVWF  x2E
009B8:  MOVLW  80
009BA:  MOVWF  x2D
009BC:  MOVLW  01
009BE:  MOVWF  x30
009C0:  MOVLW  D0
009C2:  MOVWF  x2F
009C4:  MOVFF  03,734
009C8:  MOVFF  02,733
009CC:  MOVFF  01,732
009D0:  MOVFF  00,731
009D4:  MOVLB  0
009D6:  RCALL  08CE
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
009D8:  MOVLW  01
009DA:  MOVLB  7
009DC:  MOVWF  x04
009DE:  MOVLB  0
009E0:  RCALL  0826
009E2:  MOVFF  03,704
009E6:  MOVFF  02,703
009EA:  MOVFF  01,702
009EE:  MOVFF  00,701
009F2:  MOVLW  01
009F4:  MOVLB  7
009F6:  MOVWF  x2E
009F8:  MOVLW  94
009FA:  MOVWF  x2D
009FC:  MOVLW  01
009FE:  MOVWF  x30
00A00:  MOVLW  D1
00A02:  MOVWF  x2F
00A04:  MOVFF  03,734
00A08:  MOVFF  02,733
00A0C:  MOVFF  01,732
00A10:  MOVFF  00,731
00A14:  MOVLB  0
00A16:  RCALL  08CE
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A18:  MOVLW  02
00A1A:  MOVLB  7
00A1C:  MOVWF  x04
00A1E:  MOVLB  0
00A20:  RCALL  0826
00A22:  MOVFF  03,704
00A26:  MOVFF  02,703
00A2A:  MOVFF  01,702
00A2E:  MOVFF  00,701
00A32:  MOVLW  01
00A34:  MOVLB  7
00A36:  MOVWF  x2E
00A38:  MOVLW  A8
00A3A:  MOVWF  x2D
00A3C:  MOVLW  01
00A3E:  MOVWF  x30
00A40:  MOVLW  D2
00A42:  MOVWF  x2F
00A44:  MOVFF  03,734
00A48:  MOVFF  02,733
00A4C:  MOVFF  01,732
00A50:  MOVFF  00,731
00A54:  MOVLB  0
00A56:  RCALL  08CE
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A58:  MOVLW  03
00A5A:  MOVLB  7
00A5C:  MOVWF  x04
00A5E:  MOVLB  0
00A60:  RCALL  0826
00A62:  MOVFF  03,704
00A66:  MOVFF  02,703
00A6A:  MOVFF  01,702
00A6E:  MOVFF  00,701
00A72:  MOVLW  01
00A74:  MOVLB  7
00A76:  MOVWF  x2E
00A78:  MOVLW  BC
00A7A:  MOVWF  x2D
00A7C:  MOVLW  01
00A7E:  MOVWF  x30
00A80:  MOVLW  D3
00A82:  MOVWF  x2F
00A84:  MOVFF  03,734
00A88:  MOVFF  02,733
00A8C:  MOVFF  01,732
00A90:  MOVFF  00,731
00A94:  MOVLB  0
00A96:  RCALL  08CE
00A98:  MOVLB  7
00A9A:  INCF   x00,F
00A9C:  BRA    0984
00A9E:  MOVLB  1
....................       }
....................    }
00AA0:  MOVLB  0
00AA2:  GOTO   0B06 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00AA6:  MOVLW  00
00AA8:  MOVLB  F
00AAA:  MOVWF  x53
00AAC:  MOVLW  40
00AAE:  MOVWF  x0C
00AB0:  MOVLW  00
00AB2:  MOVWF  x14
00AB4:  MOVLW  03
00AB6:  MOVWF  x1C
00AB8:  MOVLW  0F
00ABA:  MOVWF  x21
00ABC:  MOVLW  00
00ABE:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AC0:  MOVLW  08
00AC2:  MOVWF  x55
00AC4:  CLRF   x56
00AC6:  CLRF   x52
00AC8:  SETF   x57
00ACA:  CLRF   F61
00ACC:  MOVLW  94
00ACE:  MOVWF  x5B
....................    output_high(EN_EXC);
00AD0:  MOVLW  E8
00AD2:  MOVWF  F8B
00AD4:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00AD6:  MOVF   x5A,W
00AD8:  ANDLW  3F
00ADA:  MOVWF  01
00ADC:  MOVLW  06
00ADE:  MOVWF  x5A
00AE0:  BTFSS  x5B.7
00AE2:  BRA    0AF2
00AE4:  MOVF   01,W
00AE6:  SUBLW  06
00AE8:  BZ    0AF2
00AEA:  BSF    x5B.0
00AEC:  NOP   
00AEE:  BTFSC  x5B.0
00AF0:  BRA    0AEE
....................    delay_ms(10);
00AF2:  MOVLW  0A
00AF4:  MOVLB  7
00AF6:  MOVWF  x01
00AF8:  MOVLB  0
00AFA:  RCALL  0394
....................    read_adc(ADC_START_ONLY);
00AFC:  MOVLB  F
00AFE:  BSF    x5B.0
00B00:  NOP   
....................    setup_external_ADCs();
00B02:  MOVLB  0
00B04:  BRA    0934
....................    intTimeoutReg = sensorSampleRate;
00B06:  MOVLB  1
00B08:  CLRF   x7F
00B0A:  MOVLW  32
00B0C:  MOVWF  x7E
00B0E:  MOVLB  0
00B10:  GOTO   A6DC (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046A6:  MOVLB  7
046A8:  MOVF   x01,W
046AA:  MULLW  28
046AC:  MOVF   FF3,W
046AE:  CLRF   x0F
046B0:  MOVWF  x0E
046B2:  MOVLW  0C
046B4:  ADDWF  x0E,W
046B6:  MOVWF  01
046B8:  MOVLW  00
046BA:  ADDWFC x0F,W
046BC:  MOVWF  03
046BE:  MOVF   01,W
046C0:  ADDLW  20
046C2:  MOVWF  FE9
046C4:  MOVLW  00
046C6:  ADDWFC 03,W
046C8:  MOVWF  FEA
046CA:  MOVFF  FEF,74A
046CE:  MOVFF  FEC,74B
046D2:  MOVFF  FEC,74C
046D6:  MOVFF  FEC,74D
046DA:  MOVF   x01,W
046DC:  MULLW  28
046DE:  MOVF   FF3,W
046E0:  CLRF   x13
046E2:  MOVWF  x12
046E4:  MOVLW  10
046E6:  ADDWF  x12,W
046E8:  MOVWF  01
046EA:  MOVLW  00
046EC:  ADDWFC x13,W
046EE:  MOVWF  03
046F0:  MOVF   01,W
046F2:  ADDLW  20
046F4:  MOVWF  FE9
046F6:  MOVLW  00
046F8:  ADDWFC 03,W
046FA:  MOVWF  FEA
046FC:  MOVFF  FEF,74E
04700:  MOVFF  FEC,01
04704:  MOVFF  FEC,02
04708:  MOVFF  FEC,03
0470C:  MOVFF  FEA,713
04710:  MOVFF  FE9,712
04714:  BSF    FD8.1
04716:  MOVFF  03,751
0471A:  MOVFF  02,750
0471E:  MOVFF  01,74F
04722:  MOVLB  0
04724:  CALL   0E60
04728:  MOVFF  713,FEA
0472C:  MOVFF  712,FE9
04730:  MOVFF  03,705
04734:  MOVFF  02,704
04738:  MOVFF  01,703
0473C:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
04740:  MOVLB  7
04742:  MOVF   x01,W
04744:  MULLW  28
04746:  MOVF   FF3,W
04748:  CLRF   x0F
0474A:  MOVWF  x0E
0474C:  MOVLW  1C
0474E:  ADDWF  x0E,W
04750:  MOVWF  01
04752:  MOVLW  00
04754:  ADDWFC x0F,W
04756:  MOVWF  03
04758:  MOVF   01,W
0475A:  ADDLW  20
0475C:  MOVWF  01
0475E:  MOVLW  00
04760:  ADDWFC 03,F
04762:  MOVFF  01,70E
04766:  MOVFF  03,70F
0476A:  MOVFF  03,FEA
0476E:  MOVFF  01,FE9
04772:  MOVFF  FEF,710
04776:  MOVFF  FEC,711
0477A:  MOVFF  FEC,712
0477E:  MOVFF  FEC,713
04782:  MOVF   x01,W
04784:  MULLW  28
04786:  MOVF   FF3,W
04788:  CLRF   x15
0478A:  MOVWF  x14
0478C:  MOVLW  04
0478E:  ADDWF  x14,W
04790:  MOVWF  01
04792:  MOVLW  00
04794:  ADDWFC x15,W
04796:  MOVWF  03
04798:  MOVF   01,W
0479A:  ADDLW  20
0479C:  MOVWF  FE9
0479E:  MOVLW  00
047A0:  ADDWFC 03,W
047A2:  MOVWF  FEA
047A4:  MOVFF  FEF,754
047A8:  MOVFF  FEC,01
047AC:  MOVFF  FEC,02
047B0:  MOVFF  FEC,03
047B4:  MOVFF  705,753
047B8:  MOVFF  704,752
047BC:  MOVFF  703,751
047C0:  MOVFF  702,750
047C4:  MOVFF  03,757
047C8:  MOVFF  02,756
047CC:  MOVFF  01,755
047D0:  MOVLB  0
047D2:  CALL   0D6A
047D6:  BCF    FD8.1
047D8:  MOVFF  713,74D
047DC:  MOVFF  712,74C
047E0:  MOVFF  711,74B
047E4:  MOVFF  710,74A
047E8:  MOVFF  03,751
047EC:  MOVFF  02,750
047F0:  MOVFF  01,74F
047F4:  MOVFF  00,74E
047F8:  CALL   0E60
047FC:  MOVFF  70F,FEA
04800:  MOVFF  70E,FE9
04804:  MOVFF  00,FEF
04808:  MOVFF  01,FEC
0480C:  MOVFF  02,FEC
04810:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
04814:  MOVLB  7
04816:  MOVF   x01,W
04818:  MULLW  28
0481A:  MOVF   FF3,W
0481C:  CLRF   x0F
0481E:  MOVWF  x0E
04820:  MOVLW  1C
04822:  ADDWF  x0E,W
04824:  MOVWF  01
04826:  MOVLW  00
04828:  ADDWFC x0F,W
0482A:  MOVWF  03
0482C:  MOVF   01,W
0482E:  ADDLW  20
04830:  MOVWF  FE9
04832:  MOVLW  00
04834:  ADDWFC 03,W
04836:  MOVWF  FEA
04838:  MOVFF  FEF,74A
0483C:  MOVFF  FEC,70F
04840:  MOVFF  FEC,74C
04844:  MOVFF  FEC,74D
04848:  CLRF   x49
0484A:  CLRF   x48
0484C:  MOVLW  7C
0484E:  MOVWF  x47
04850:  MOVLW  84
04852:  MOVWF  x46
04854:  MOVFF  70F,74B
04858:  MOVLB  0
0485A:  CALL   1CF6
0485E:  BNC   4892
04860:  MOVLB  7
04862:  MOVF   x01,W
04864:  MULLW  28
04866:  MOVF   FF3,W
04868:  CLRF   x0F
0486A:  MOVWF  x0E
0486C:  MOVLW  1C
0486E:  ADDWF  x0E,W
04870:  MOVWF  01
04872:  MOVLW  00
04874:  ADDWFC x0F,W
04876:  MOVWF  03
04878:  MOVF   01,W
0487A:  ADDLW  20
0487C:  MOVWF  FE9
0487E:  MOVLW  00
04880:  ADDWFC 03,W
04882:  MOVWF  FEA
04884:  MOVLW  84
04886:  MOVWF  FEF
04888:  MOVLW  7C
0488A:  MOVWF  FEC
0488C:  CLRF   FEC
0488E:  CLRF   FEC
04890:  BRA    490E
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
04892:  MOVLB  7
04894:  MOVF   x01,W
04896:  MULLW  28
04898:  MOVF   FF3,W
0489A:  CLRF   x0F
0489C:  MOVWF  x0E
0489E:  MOVLW  1C
048A0:  ADDWF  x0E,W
048A2:  MOVWF  01
048A4:  MOVLW  00
048A6:  ADDWFC x0F,W
048A8:  MOVWF  03
048AA:  MOVF   01,W
048AC:  ADDLW  20
048AE:  MOVWF  FE9
048B0:  MOVLW  00
048B2:  ADDWFC 03,W
048B4:  MOVWF  FEA
048B6:  MOVFF  FEF,746
048BA:  MOVFF  FEC,70F
048BE:  MOVFF  FEC,748
048C2:  MOVFF  FEC,749
048C6:  MOVFF  70F,747
048CA:  CLRF   x4D
048CC:  CLRF   x4C
048CE:  MOVLW  C0
048D0:  MOVWF  x4B
048D2:  MOVLW  82
048D4:  MOVWF  x4A
048D6:  MOVLB  0
048D8:  CALL   1CF6
048DC:  BNC   4910
048DE:  MOVLB  7
048E0:  MOVF   x01,W
048E2:  MULLW  28
048E4:  MOVF   FF3,W
048E6:  CLRF   x0F
048E8:  MOVWF  x0E
048EA:  MOVLW  1C
048EC:  ADDWF  x0E,W
048EE:  MOVWF  01
048F0:  MOVLW  00
048F2:  ADDWFC x0F,W
048F4:  MOVWF  03
048F6:  MOVF   01,W
048F8:  ADDLW  20
048FA:  MOVWF  FE9
048FC:  MOVLW  00
048FE:  ADDWFC 03,W
04900:  MOVWF  FEA
04902:  MOVLW  82
04904:  MOVWF  FEF
04906:  MOVLW  C0
04908:  MOVWF  FEC
0490A:  CLRF   FEC
0490C:  CLRF   FEC
0490E:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04910:  MOVLB  7
04912:  MOVF   x01,W
04914:  MULLW  28
04916:  MOVF   FF3,W
04918:  CLRF   x0F
0491A:  MOVWF  x0E
0491C:  MOVLW  20
0491E:  ADDWF  x0E,W
04920:  MOVWF  FE9
04922:  MOVLW  00
04924:  ADDWFC x0F,W
04926:  MOVWF  FEA
04928:  MOVFF  FEF,754
0492C:  MOVFF  FEC,01
04930:  MOVFF  FEC,02
04934:  MOVFF  FEC,03
04938:  MOVFF  705,753
0493C:  MOVFF  704,752
04940:  MOVFF  703,751
04944:  MOVFF  702,750
04948:  MOVFF  03,757
0494C:  MOVFF  02,756
04950:  MOVFF  01,755
04954:  MOVLB  0
04956:  CALL   0D6A
0495A:  MOVFF  03,709
0495E:  MOVFF  02,708
04962:  MOVFF  01,707
04966:  MOVFF  00,706
0496A:  MOVLB  7
0496C:  MOVF   x01,W
0496E:  MULLW  28
04970:  MOVF   FF3,W
04972:  CLRF   x11
04974:  MOVWF  x10
04976:  MOVLW  08
04978:  ADDWF  x10,W
0497A:  MOVWF  01
0497C:  MOVLW  00
0497E:  ADDWFC x11,W
04980:  MOVWF  03
04982:  MOVF   01,W
04984:  ADDLW  20
04986:  MOVWF  FE9
04988:  MOVLW  00
0498A:  ADDWFC 03,W
0498C:  MOVWF  FEA
0498E:  MOVFF  FEF,710
04992:  MOVFF  FEC,711
04996:  MOVFF  FEC,712
0499A:  MOVFF  FEC,713
0499E:  MOVF   x01,W
049A0:  MULLW  28
049A2:  MOVF   FF3,W
049A4:  CLRF   x15
049A6:  MOVWF  x14
049A8:  MOVLW  10
049AA:  ADDWF  x14,W
049AC:  MOVWF  01
049AE:  MOVLW  00
049B0:  ADDWFC x15,W
049B2:  MOVWF  03
049B4:  MOVF   01,W
049B6:  ADDLW  20
049B8:  MOVWF  FE9
049BA:  MOVLW  00
049BC:  ADDWFC 03,W
049BE:  MOVWF  FEA
049C0:  MOVFF  FEF,74A
049C4:  MOVFF  FEC,74B
049C8:  MOVFF  FEC,74C
049CC:  MOVFF  FEC,74D
049D0:  MOVF   x01,W
049D2:  MULLW  28
049D4:  MOVF   FF3,W
049D6:  CLRF   x19
049D8:  MOVWF  x18
049DA:  MOVLW  14
049DC:  ADDWF  x18,W
049DE:  MOVWF  01
049E0:  MOVLW  00
049E2:  ADDWFC x19,W
049E4:  MOVWF  03
049E6:  MOVF   01,W
049E8:  ADDLW  20
049EA:  MOVWF  FE9
049EC:  MOVLW  00
049EE:  ADDWFC 03,W
049F0:  MOVWF  FEA
049F2:  MOVFF  FEF,74E
049F6:  MOVFF  FEC,01
049FA:  MOVFF  FEC,02
049FE:  MOVFF  FEC,03
04A02:  MOVFF  FEA,719
04A06:  MOVFF  FE9,718
04A0A:  BSF    FD8.1
04A0C:  MOVFF  03,751
04A10:  MOVFF  02,750
04A14:  MOVFF  01,74F
04A18:  MOVLB  0
04A1A:  CALL   0E60
04A1E:  MOVFF  719,FEA
04A22:  MOVFF  718,FE9
04A26:  MOVFF  713,753
04A2A:  MOVFF  712,752
04A2E:  MOVFF  711,751
04A32:  MOVFF  710,750
04A36:  MOVFF  03,757
04A3A:  MOVFF  02,756
04A3E:  MOVFF  01,755
04A42:  MOVFF  00,754
04A46:  CALL   0D6A
04A4A:  MOVFF  03,70D
04A4E:  MOVFF  02,70C
04A52:  MOVFF  01,70B
04A56:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A5A:  MOVLB  7
04A5C:  MOVF   x01,W
04A5E:  MULLW  28
04A60:  MOVF   FF3,W
04A62:  CLRF   x0F
04A64:  MOVWF  x0E
04A66:  MOVLW  18
04A68:  ADDWF  x0E,W
04A6A:  MOVWF  01
04A6C:  MOVLW  00
04A6E:  ADDWFC x0F,W
04A70:  MOVWF  03
04A72:  MOVF   01,W
04A74:  ADDLW  20
04A76:  MOVWF  01
04A78:  MOVLW  00
04A7A:  ADDWFC 03,F
04A7C:  MOVFF  01,70E
04A80:  MOVFF  03,70F
04A84:  MOVF   x01,W
04A86:  MULLW  28
04A88:  MOVF   FF3,W
04A8A:  CLRF   x11
04A8C:  MOVWF  x10
04A8E:  MOVLW  1C
04A90:  ADDWF  x10,W
04A92:  MOVWF  01
04A94:  MOVLW  00
04A96:  ADDWFC x11,W
04A98:  MOVWF  03
04A9A:  MOVF   01,W
04A9C:  ADDLW  20
04A9E:  MOVWF  FE9
04AA0:  MOVLW  00
04AA2:  ADDWFC 03,W
04AA4:  MOVWF  FEA
04AA6:  MOVFF  FEF,74E
04AAA:  MOVFF  FEC,01
04AAE:  MOVFF  FEC,02
04AB2:  MOVFF  FEC,03
04AB6:  MOVFF  FEA,711
04ABA:  MOVFF  FE9,710
04ABE:  BCF    FD8.1
04AC0:  MOVFF  709,74D
04AC4:  MOVFF  708,74C
04AC8:  MOVFF  707,74B
04ACC:  MOVFF  706,74A
04AD0:  MOVFF  03,751
04AD4:  MOVFF  02,750
04AD8:  MOVFF  01,74F
04ADC:  MOVLB  0
04ADE:  CALL   0E60
04AE2:  MOVFF  711,FEA
04AE6:  MOVFF  710,FE9
04AEA:  MOVFF  03,715
04AEE:  MOVFF  02,714
04AF2:  MOVFF  01,713
04AF6:  MOVFF  00,712
04AFA:  BCF    FD8.1
04AFC:  MOVFF  03,74D
04B00:  MOVFF  02,74C
04B04:  MOVFF  01,74B
04B08:  MOVFF  00,74A
04B0C:  MOVFF  70D,751
04B10:  MOVFF  70C,750
04B14:  MOVFF  70B,74F
04B18:  MOVFF  70A,74E
04B1C:  CALL   0E60
04B20:  MOVFF  70F,FEA
04B24:  MOVFF  70E,FE9
04B28:  MOVFF  00,FEF
04B2C:  MOVFF  01,FEC
04B30:  MOVFF  02,FEC
04B34:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B38:  MOVLB  7
04B3A:  MOVF   x01,W
04B3C:  MULLW  28
04B3E:  MOVF   FF3,W
04B40:  CLRF   x0F
04B42:  MOVWF  x0E
04B44:  MOVLW  18
04B46:  ADDWF  x0E,W
04B48:  MOVWF  01
04B4A:  MOVLW  00
04B4C:  ADDWFC x0F,W
04B4E:  MOVWF  03
04B50:  MOVF   01,W
04B52:  ADDLW  20
04B54:  MOVWF  FE9
04B56:  MOVLW  00
04B58:  ADDWFC 03,W
04B5A:  MOVWF  FEA
04B5C:  MOVFF  FEF,74A
04B60:  MOVFF  FEC,70F
04B64:  MOVFF  FEC,74C
04B68:  MOVFF  FEC,74D
04B6C:  CLRF   x49
04B6E:  CLRF   x48
04B70:  MOVLW  7C
04B72:  MOVWF  x47
04B74:  MOVLW  84
04B76:  MOVWF  x46
04B78:  MOVFF  70F,74B
04B7C:  MOVLB  0
04B7E:  CALL   1CF6
04B82:  BNC   4BB6
04B84:  MOVLB  7
04B86:  MOVF   x01,W
04B88:  MULLW  28
04B8A:  MOVF   FF3,W
04B8C:  CLRF   x0F
04B8E:  MOVWF  x0E
04B90:  MOVLW  18
04B92:  ADDWF  x0E,W
04B94:  MOVWF  01
04B96:  MOVLW  00
04B98:  ADDWFC x0F,W
04B9A:  MOVWF  03
04B9C:  MOVF   01,W
04B9E:  ADDLW  20
04BA0:  MOVWF  FE9
04BA2:  MOVLW  00
04BA4:  ADDWFC 03,W
04BA6:  MOVWF  FEA
04BA8:  MOVLW  84
04BAA:  MOVWF  FEF
04BAC:  MOVLW  7C
04BAE:  MOVWF  FEC
04BB0:  CLRF   FEC
04BB2:  CLRF   FEC
04BB4:  BRA    4C32
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BB6:  MOVLB  7
04BB8:  MOVF   x01,W
04BBA:  MULLW  28
04BBC:  MOVF   FF3,W
04BBE:  CLRF   x0F
04BC0:  MOVWF  x0E
04BC2:  MOVLW  18
04BC4:  ADDWF  x0E,W
04BC6:  MOVWF  01
04BC8:  MOVLW  00
04BCA:  ADDWFC x0F,W
04BCC:  MOVWF  03
04BCE:  MOVF   01,W
04BD0:  ADDLW  20
04BD2:  MOVWF  FE9
04BD4:  MOVLW  00
04BD6:  ADDWFC 03,W
04BD8:  MOVWF  FEA
04BDA:  MOVFF  FEF,746
04BDE:  MOVFF  FEC,70F
04BE2:  MOVFF  FEC,748
04BE6:  MOVFF  FEC,749
04BEA:  MOVFF  70F,747
04BEE:  CLRF   x4D
04BF0:  CLRF   x4C
04BF2:  MOVLW  C0
04BF4:  MOVWF  x4B
04BF6:  MOVLW  82
04BF8:  MOVWF  x4A
04BFA:  MOVLB  0
04BFC:  CALL   1CF6
04C00:  BNC   4C32
04C02:  MOVLB  7
04C04:  MOVF   x01,W
04C06:  MULLW  28
04C08:  MOVF   FF3,W
04C0A:  CLRF   x0F
04C0C:  MOVWF  x0E
04C0E:  MOVLW  18
04C10:  ADDWF  x0E,W
04C12:  MOVWF  01
04C14:  MOVLW  00
04C16:  ADDWFC x0F,W
04C18:  MOVWF  03
04C1A:  MOVF   01,W
04C1C:  ADDLW  20
04C1E:  MOVWF  FE9
04C20:  MOVLW  00
04C22:  ADDWFC 03,W
04C24:  MOVWF  FEA
04C26:  MOVLW  82
04C28:  MOVWF  FEF
04C2A:  MOVLW  C0
04C2C:  MOVWF  FEC
04C2E:  CLRF   FEC
04C30:  CLRF   FEC
04C32:  MOVLB  0
04C34:  GOTO   4CB2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C38:  MOVLB  6
04C3A:  MOVF   xFE,W
04C3C:  MULLW  28
04C3E:  MOVF   FF3,W
04C40:  MOVLB  7
04C42:  CLRF   x01
04C44:  MOVWF  x00
04C46:  MOVLW  0C
04C48:  ADDWF  x00,W
04C4A:  MOVWF  01
04C4C:  MOVLW  00
04C4E:  ADDWFC x01,W
04C50:  MOVWF  03
04C52:  MOVF   01,W
04C54:  ADDLW  20
04C56:  MOVWF  FE9
04C58:  MOVLW  00
04C5A:  ADDWFC 03,W
04C5C:  MOVWF  FEA
04C5E:  MOVFF  FEF,746
04C62:  MOVFF  FEC,747
04C66:  MOVFF  FEC,748
04C6A:  MOVFF  FEC,749
04C6E:  MOVLB  6
04C70:  MOVF   xFE,W
04C72:  MULLW  28
04C74:  MOVF   FF3,W
04C76:  MOVLB  7
04C78:  CLRF   x05
04C7A:  MOVWF  x04
04C7C:  MOVLW  10
04C7E:  ADDWF  x04,W
04C80:  MOVWF  01
04C82:  MOVLW  00
04C84:  ADDWFC x05,W
04C86:  MOVWF  03
04C88:  MOVF   01,W
04C8A:  ADDLW  20
04C8C:  MOVWF  FE9
04C8E:  MOVLW  00
04C90:  ADDWFC 03,W
04C92:  MOVWF  FEA
04C94:  MOVFF  FEF,74A
04C98:  MOVFF  FEC,74B
04C9C:  MOVFF  FEC,74C
04CA0:  MOVFF  FEC,74D
04CA4:  MOVLB  0
04CA6:  CALL   1CF6
04CAA:  BZ    4CB2
04CAC:  MOVFF  6FE,701
04CB0:  BRA    46A6
....................    if ((index++) >= numChannels) index = 0;
04CB2:  MOVLB  1
04CB4:  MOVF   xE9,W
04CB6:  INCF   xE9,F
04CB8:  SUBLW  01
04CBA:  BC    4CBE
04CBC:  CLRF   xE9
04CBE:  MOVLB  0
04CC0:  GOTO   4DD2 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B14:  CLRF   03
00B16:  MOVF   F91,W
00B18:  MOVFF  700,F91
00B1C:  RRCF   F94,W
00B1E:  BNC   0B1C
00B20:  MOVF   F91,W
00B22:  MOVWF  02
00B24:  MOVFF  6FF,F91
00B28:  RRCF   F94,W
00B2A:  BNC   0B28
00B2C:  MOVF   F91,W
00B2E:  MOVWF  01
00B30:  MOVFF  6FE,F91
00B34:  RRCF   F94,W
00B36:  BNC   0B34
00B38:  MOVFF  F91,00
00B3C:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
04614:  MOVLB  6
04616:  MOVF   xFF,F
04618:  BZ    4660
....................       if (chMap[0] == ch) output_low(INV_HVX);
0461A:  MOVLW  00
0461C:  MOVLB  0
0461E:  BTFSC  x70.0
04620:  MOVLW  01
04622:  MOVLB  6
04624:  SUBWF  xFE,W
04626:  BNZ   462E
04628:  MOVLW  04
0462A:  MOVWF  F88
0462C:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
0462E:  MOVLW  00
04630:  MOVLB  0
04632:  BTFSC  x70.1
04634:  MOVLW  01
04636:  MOVLB  6
04638:  SUBWF  xFE,W
0463A:  BNZ   4642
0463C:  MOVLW  04
0463E:  MOVWF  F88
04640:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
04642:  MOVF   xFE,W
04644:  MULLW  07
04646:  MOVF   FF3,W
04648:  MOVLB  7
0464A:  CLRF   x01
0464C:  MOVWF  x00
0464E:  MOVLW  64
04650:  ADDWF  x00,W
04652:  MOVWF  FE9
04654:  MOVLW  01
04656:  ADDWFC x01,W
04658:  MOVWF  FEA
0465A:  BSF    FEF.0
....................    }
0465C:  BRA    46A2
0465E:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
04660:  MOVLW  00
04662:  MOVLB  0
04664:  BTFSC  x70.0
04666:  MOVLW  01
04668:  MOVLB  6
0466A:  SUBWF  xFE,W
0466C:  BNZ   4674
0466E:  MOVLW  04
04670:  MOVWF  F88
04672:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
04674:  MOVLW  00
04676:  MOVLB  0
04678:  BTFSC  x70.1
0467A:  MOVLW  01
0467C:  MOVLB  6
0467E:  SUBWF  xFE,W
04680:  BNZ   4688
04682:  MOVLW  04
04684:  MOVWF  F88
04686:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
04688:  MOVF   xFE,W
0468A:  MULLW  07
0468C:  MOVF   FF3,W
0468E:  MOVLB  7
04690:  CLRF   x01
04692:  MOVWF  x00
04694:  MOVLW  64
04696:  ADDWF  x00,W
04698:  MOVWF  FE9
0469A:  MOVLW  01
0469C:  ADDWFC x01,W
0469E:  MOVWF  FEA
046A0:  BCF    FEF.0
....................    }
046A2:  MOVLB  0
046A4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CC4:  MOVLB  6
04CC6:  CLRF   xFD
04CC8:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04CCA:  MOVFF  6FB,70D
04CCE:  MOVLB  7
04CD0:  CLRF   x0F
04CD2:  MOVLW  71
04CD4:  MOVWF  x0E
04CD6:  MOVLB  0
04CD8:  RCALL  45DE
04CDA:  MOVF   01,F
04CDC:  BNZ   4DCC
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04CDE:  MOVLB  6
04CE0:  MOVF   xFB,W
04CE2:  MULLW  07
04CE4:  MOVF   FF3,W
04CE6:  CLRF   xFF
04CE8:  MOVWF  xFE
04CEA:  MOVLW  03
04CEC:  ADDWF  xFE,W
04CEE:  MOVWF  01
04CF0:  MOVLW  00
04CF2:  ADDWFC xFF,W
04CF4:  MOVWF  03
04CF6:  MOVF   01,W
04CF8:  ADDLW  64
04CFA:  MOVWF  FE9
04CFC:  MOVLW  01
04CFE:  ADDWFC 03,W
04D00:  MOVWF  FEA
04D02:  MOVFF  FEF,746
04D06:  MOVFF  FEC,747
04D0A:  MOVFF  FEC,748
04D0E:  MOVFF  FEC,749
04D12:  MOVLB  7
04D14:  CLRF   x4D
04D16:  CLRF   x4C
04D18:  CLRF   x4B
04D1A:  CLRF   x4A
04D1C:  MOVLB  0
04D1E:  CALL   1CF6
04D22:  BNC   4D34
04D24:  MOVFF  6FB,6FE
04D28:  MOVLW  01
04D2A:  MOVLB  6
04D2C:  MOVWF  xFF
04D2E:  MOVLB  0
04D30:  RCALL  4614
04D32:  BRA    4D40
....................         else                         invert_voltage(ch, FALSE);
04D34:  MOVFF  6FB,6FE
04D38:  MOVLB  6
04D3A:  CLRF   xFF
04D3C:  MOVLB  0
04D3E:  RCALL  4614
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D40:  MOVLB  6
04D42:  MOVF   xFB,W
04D44:  MULLW  07
04D46:  MOVF   FF3,W
04D48:  CLRF   xFF
04D4A:  MOVWF  xFE
04D4C:  MOVLW  03
04D4E:  ADDWF  xFE,W
04D50:  MOVWF  01
04D52:  MOVLW  00
04D54:  ADDWFC xFF,W
04D56:  MOVWF  03
04D58:  MOVF   01,W
04D5A:  ADDLW  64
04D5C:  MOVWF  FE9
04D5E:  MOVLW  01
04D60:  ADDWFC 03,W
04D62:  MOVWF  FEA
04D64:  MOVFF  FEF,00
04D68:  MOVFF  FEC,01
04D6C:  MOVFF  FEC,02
04D70:  MOVFF  FEC,03
04D74:  BCF    01.7
04D76:  MOVFF  03,701
04D7A:  MOVFF  02,700
04D7E:  MOVFF  01,6FF
04D82:  MOVFF  00,6FE
04D86:  MOVFF  03,753
04D8A:  MOVFF  02,752
04D8E:  MOVFF  01,751
04D92:  MOVFF  00,750
04D96:  MOVLW  66
04D98:  MOVLB  7
04D9A:  MOVWF  x57
04D9C:  MOVLW  D6
04D9E:  MOVWF  x56
04DA0:  MOVLW  23
04DA2:  MOVWF  x55
04DA4:  MOVLW  88
04DA6:  MOVWF  x54
04DA8:  MOVLB  0
04DAA:  CALL   0D6A
04DAE:  MOVFF  03,749
04DB2:  MOVFF  02,748
04DB6:  MOVFF  01,747
04DBA:  MOVFF  00,746
04DBE:  CALL   26EA
04DC2:  MOVFF  02,6FD
04DC6:  MOVFF  01,6FC
....................     }
04DCA:  BRA    4EC2
....................     else {
....................         pid_task(ch);
04DCC:  MOVFF  6FB,6FE
04DD0:  BRA    4C38
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04DD2:  MOVLB  6
04DD4:  MOVF   xFB,W
04DD6:  MULLW  28
04DD8:  MOVF   FF3,W
04DDA:  CLRF   xFF
04DDC:  MOVWF  xFE
04DDE:  MOVLW  18
04DE0:  ADDWF  xFE,W
04DE2:  MOVWF  01
04DE4:  MOVLW  00
04DE6:  ADDWFC xFF,W
04DE8:  MOVWF  03
04DEA:  MOVF   01,W
04DEC:  ADDLW  20
04DEE:  MOVWF  FE9
04DF0:  MOVLW  00
04DF2:  ADDWFC 03,W
04DF4:  MOVWF  FEA
04DF6:  MOVFF  FEF,746
04DFA:  MOVFF  FEC,747
04DFE:  MOVFF  FEC,748
04E02:  MOVFF  FEC,749
04E06:  MOVLB  7
04E08:  CLRF   x4D
04E0A:  CLRF   x4C
04E0C:  CLRF   x4B
04E0E:  CLRF   x4A
04E10:  MOVLB  0
04E12:  CALL   1CF6
04E16:  BNC   4E2A
04E18:  MOVFF  6FB,6FE
04E1C:  MOVLW  01
04E1E:  MOVLB  6
04E20:  MOVWF  xFF
04E22:  MOVLB  0
04E24:  CALL   4614
04E28:  BRA    4E38
....................         else                       invert_voltage(ch, FALSE);
04E2A:  MOVFF  6FB,6FE
04E2E:  MOVLB  6
04E30:  CLRF   xFF
04E32:  MOVLB  0
04E34:  CALL   4614
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E38:  MOVLB  6
04E3A:  MOVF   xFB,W
04E3C:  MULLW  28
04E3E:  MOVF   FF3,W
04E40:  CLRF   xFF
04E42:  MOVWF  xFE
04E44:  MOVLW  18
04E46:  ADDWF  xFE,W
04E48:  MOVWF  01
04E4A:  MOVLW  00
04E4C:  ADDWFC xFF,W
04E4E:  MOVWF  03
04E50:  MOVF   01,W
04E52:  ADDLW  20
04E54:  MOVWF  FE9
04E56:  MOVLW  00
04E58:  ADDWFC 03,W
04E5A:  MOVWF  FEA
04E5C:  MOVFF  FEF,00
04E60:  MOVFF  FEC,01
04E64:  MOVFF  FEC,02
04E68:  MOVFF  FEC,03
04E6C:  BCF    01.7
04E6E:  MOVFF  03,701
04E72:  MOVFF  02,700
04E76:  MOVFF  01,6FF
04E7A:  MOVFF  00,6FE
04E7E:  MOVFF  03,753
04E82:  MOVFF  02,752
04E86:  MOVFF  01,751
04E8A:  MOVFF  00,750
04E8E:  MOVLW  66
04E90:  MOVLB  7
04E92:  MOVWF  x57
04E94:  MOVLW  D6
04E96:  MOVWF  x56
04E98:  MOVLW  23
04E9A:  MOVWF  x55
04E9C:  MOVLW  88
04E9E:  MOVWF  x54
04EA0:  MOVLB  0
04EA2:  CALL   0D6A
04EA6:  MOVFF  03,749
04EAA:  MOVFF  02,748
04EAE:  MOVFF  01,747
04EB2:  MOVFF  00,746
04EB6:  CALL   26EA
04EBA:  MOVFF  02,6FD
04EBE:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04EC2:  MOVLB  6
04EC4:  MOVF   xFB,W
04EC6:  MULLW  07
04EC8:  MOVF   FF3,W
04ECA:  CLRF   xFF
04ECC:  MOVWF  xFE
04ECE:  MOVLW  01
04ED0:  ADDWF  xFE,W
04ED2:  MOVWF  01
04ED4:  MOVLW  00
04ED6:  ADDWFC xFF,W
04ED8:  MOVWF  03
04EDA:  MOVF   01,W
04EDC:  ADDLW  64
04EDE:  MOVWF  FE9
04EE0:  MOVLW  01
04EE2:  ADDWFC 03,W
04EE4:  MOVWF  FEA
04EE6:  MOVFF  6FD,FEC
04EEA:  MOVF   FED,F
04EEC:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04EF0:  MOVLW  00
04EF2:  MOVLB  0
04EF4:  BTFSC  x70.0
04EF6:  MOVLW  01
04EF8:  MOVLB  6
04EFA:  SUBWF  xFB,W
04EFC:  BNZ   4F04
04EFE:  MOVLW  E8
04F00:  MOVWF  F8B
04F02:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F04:  MOVLW  00
04F06:  MOVLB  0
04F08:  BTFSC  x70.1
04F0A:  MOVLW  01
04F0C:  MOVLB  6
04F0E:  SUBWF  xFB,W
04F10:  BNZ   4F18
04F12:  MOVLW  E8
04F14:  MOVWF  F8B
04F16:  BSF    F86.1
....................    
....................     delay_ms(1);
04F18:  MOVLW  01
04F1A:  MOVLB  7
04F1C:  MOVWF  x01
04F1E:  MOVLB  0
04F20:  CALL   0394
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F24:  MOVLW  00
04F26:  BTFSC  x70.0
04F28:  MOVLW  01
04F2A:  MOVLB  6
04F2C:  SUBWF  xFB,W
04F2E:  BNZ   4F36
04F30:  MOVLW  E8
04F32:  MOVWF  F8B
04F34:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F36:  MOVLW  00
04F38:  MOVLB  0
04F3A:  BTFSC  x70.1
04F3C:  MOVLW  01
04F3E:  MOVLB  6
04F40:  SUBWF  xFB,W
04F42:  BNZ   4F4A
04F44:  MOVLW  E8
04F46:  MOVWF  F8B
04F48:  BCF    F86.1
....................     delay_ms(1);
04F4A:  MOVLW  01
04F4C:  MOVLB  7
04F4E:  MOVWF  x01
04F50:  MOVLB  0
04F52:  CALL   0394
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F56:  MOVLB  7
04F58:  CLRF   x01
04F5A:  CLRF   x00
04F5C:  MOVFF  6FD,6FF
04F60:  MOVFF  6FC,6FE
04F64:  MOVLB  0
04F66:  CALL   0B14
....................     delay_ms(1);
04F6A:  MOVLW  01
04F6C:  MOVLB  7
04F6E:  MOVWF  x01
04F70:  MOVLB  0
04F72:  CALL   0394
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F76:  MOVLW  00
04F78:  BTFSC  x70.0
04F7A:  MOVLW  01
04F7C:  MOVLB  6
04F7E:  SUBWF  xFB,W
04F80:  BNZ   4F88
04F82:  MOVLW  E8
04F84:  MOVWF  F8B
04F86:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F88:  MOVLW  00
04F8A:  MOVLB  0
04F8C:  BTFSC  x70.1
04F8E:  MOVLW  01
04F90:  MOVLB  6
04F92:  SUBWF  xFB,W
04F94:  BNZ   4F9C
04F96:  MOVLW  E8
04F98:  MOVWF  F8B
04F9A:  BSF    F86.1
04F9C:  MOVLB  0
04F9E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FA0:  MOVLB  1
04FA2:  MOVF   xEA,W
04FA4:  XORLW  00
04FA6:  MOVLB  0
04FA8:  BZ    4FB0
04FAA:  XORLW  01
04FAC:  BZ    4FC2
04FAE:  BRA    4FD2
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FB0:  MOVLB  6
04FB2:  CLRF   xFB
04FB4:  MOVLB  0
04FB6:  RCALL  4CC4
....................          state = 1;
04FB8:  MOVLW  01
04FBA:  MOVLB  1
04FBC:  MOVWF  xEA
....................       break;
04FBE:  MOVLB  0
04FC0:  BRA    4FD2
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04FC2:  MOVLW  01
04FC4:  MOVLB  6
04FC6:  MOVWF  xFB
04FC8:  MOVLB  0
04FCA:  RCALL  4CC4
....................          state = 0;
04FCC:  MOVLB  1
04FCE:  CLRF   xEA
....................       break;
04FD0:  MOVLB  0
....................    }
04FD2:  GOTO   A70C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B3E:  MOVLB  7
00B40:  CLRF   x01
00B42:  CLRF   x00
00B44:  MOVLB  6
00B46:  CLRF   xFF
00B48:  CLRF   xFE
00B4A:  MOVLB  0
00B4C:  RCALL  0B14
....................    output_low(_SYNC_X);
00B4E:  MOVLW  E8
00B50:  MOVWF  F8B
00B52:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B54:  MOVWF  F8B
00B56:  BCF    F86.1
....................    output_high(_SYNC_X);
00B58:  MOVWF  F8B
00B5A:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B5C:  MOVWF  F8B
00B5E:  BSF    F86.1
00B60:  GOTO   A6E0 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B64:  MOVLB  7
00B66:  MOVF   x01,W
00B68:  SUBLW  03
00B6A:  BTFSS  FD8.0
00B6C:  BRA    0CDA
....................    {
....................       for (int i = 0; i <numParam; i ++)
00B6E:  CLRF   x02
00B70:  MOVF   x02,W
00B72:  SUBLW  06
00B74:  BNC   0BC4
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00B76:  CLRF   x42
00B78:  MOVFF  701,741
00B7C:  CLRF   x44
00B7E:  MOVLW  B5
00B80:  MOVWF  x43
00B82:  MOVLB  0
00B84:  RCALL  0880
00B86:  MOVFF  02,704
00B8A:  MOVFF  01,703
00B8E:  MOVLW  06
00B90:  MOVLB  7
00B92:  ADDWF  x03,F
00B94:  MOVLW  00
00B96:  ADDWFC x04,F
00B98:  CLRF   x42
00B9A:  MOVFF  702,741
00B9E:  CLRF   x44
00BA0:  MOVLW  19
00BA2:  MOVWF  x43
00BA4:  MOVLB  0
00BA6:  RCALL  0880
00BA8:  MOVF   01,W
00BAA:  MOVLB  7
00BAC:  ADDWF  x03,F
00BAE:  MOVF   02,W
00BB0:  ADDWFC x04,F
00BB2:  MOVLW  EB
00BB4:  ADDWF  x03,W
00BB6:  MOVWF  FE9
00BB8:  MOVLW  01
00BBA:  ADDWFC x04,W
00BBC:  MOVWF  FEA
00BBE:  CLRF   FEF
00BC0:  INCF   x02,F
00BC2:  BRA    0B70
....................       }
....................       SERcmd[recNum].t = 0;
00BC4:  CLRF   x42
00BC6:  MOVFF  701,741
00BCA:  CLRF   x44
00BCC:  MOVLW  B5
00BCE:  MOVWF  x43
00BD0:  MOVLB  0
00BD2:  RCALL  0880
00BD4:  MOVFF  01,703
00BD8:  MOVLW  05
00BDA:  MOVLB  7
00BDC:  ADDWF  01,W
00BDE:  MOVWF  01
00BE0:  MOVLW  00
00BE2:  ADDWFC 02,W
00BE4:  MOVWF  03
00BE6:  MOVF   01,W
00BE8:  ADDLW  EB
00BEA:  MOVWF  FE9
00BEC:  MOVLW  01
00BEE:  ADDWFC 03,W
00BF0:  MOVWF  FEA
00BF2:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00BF4:  CLRF   x42
00BF6:  MOVFF  701,741
00BFA:  CLRF   x44
00BFC:  MOVLW  B5
00BFE:  MOVWF  x43
00C00:  MOVLB  0
00C02:  RCALL  0880
00C04:  MOVFF  01,703
00C08:  MOVLW  01
00C0A:  MOVLB  7
00C0C:  ADDWF  01,W
00C0E:  MOVWF  01
00C10:  MOVLW  00
00C12:  ADDWFC 02,W
00C14:  MOVWF  03
00C16:  MOVF   01,W
00C18:  ADDLW  EB
00C1A:  MOVWF  FE9
00C1C:  MOVLW  01
00C1E:  ADDWFC 03,W
00C20:  MOVWF  FEA
00C22:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C24:  CLRF   x42
00C26:  MOVFF  701,741
00C2A:  CLRF   x44
00C2C:  MOVLW  B5
00C2E:  MOVWF  x43
00C30:  MOVLB  0
00C32:  RCALL  0880
00C34:  MOVFF  01,703
00C38:  MOVLW  02
00C3A:  MOVLB  7
00C3C:  ADDWF  01,W
00C3E:  MOVWF  01
00C40:  MOVLW  00
00C42:  ADDWFC 02,W
00C44:  MOVWF  03
00C46:  MOVF   01,W
00C48:  ADDLW  EB
00C4A:  MOVWF  FE9
00C4C:  MOVLW  01
00C4E:  ADDWFC 03,W
00C50:  MOVWF  FEA
00C52:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C54:  CLRF   x42
00C56:  MOVFF  701,741
00C5A:  CLRF   x44
00C5C:  MOVLW  B5
00C5E:  MOVWF  x43
00C60:  MOVLB  0
00C62:  RCALL  0880
00C64:  MOVFF  01,703
00C68:  MOVLW  03
00C6A:  MOVLB  7
00C6C:  ADDWF  01,W
00C6E:  MOVWF  01
00C70:  MOVLW  00
00C72:  ADDWFC 02,W
00C74:  MOVWF  03
00C76:  MOVF   01,W
00C78:  ADDLW  EB
00C7A:  MOVWF  FE9
00C7C:  MOVLW  01
00C7E:  ADDWFC 03,W
00C80:  MOVWF  FEA
00C82:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00C84:  CLRF   x42
00C86:  MOVFF  701,741
00C8A:  CLRF   x44
00C8C:  MOVLW  B5
00C8E:  MOVWF  x43
00C90:  MOVLB  0
00C92:  RCALL  0880
00C94:  MOVFF  01,703
00C98:  MOVLW  04
00C9A:  MOVLB  7
00C9C:  ADDWF  01,W
00C9E:  MOVWF  01
00CA0:  MOVLW  00
00CA2:  ADDWFC 02,W
00CA4:  MOVWF  03
00CA6:  MOVF   01,W
00CA8:  ADDLW  EB
00CAA:  MOVWF  FE9
00CAC:  MOVLW  01
00CAE:  ADDWFC 03,W
00CB0:  MOVWF  FEA
00CB2:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CB4:  CLRF   x42
00CB6:  MOVFF  701,741
00CBA:  CLRF   x44
00CBC:  MOVLW  B5
00CBE:  MOVWF  x43
00CC0:  MOVLB  0
00CC2:  RCALL  0880
00CC4:  MOVLW  EB
00CC6:  MOVLB  7
00CC8:  ADDWF  01,W
00CCA:  MOVWF  FE9
00CCC:  MOVLW  01
00CCE:  ADDWFC 02,W
00CD0:  MOVWF  FEA
00CD2:  BCF    FEF.0
....................       retData[0] = '\0';
00CD4:  MOVLB  4
00CD6:  CLRF   xC1
00CD8:  MOVLB  7
....................    }
00CDA:  MOVLB  0
00CDC:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
055A8:  MOVLB  7
055AA:  CLRF   x42
055AC:  MOVFF  4BF,741
055B0:  CLRF   x44
055B2:  MOVLW  B5
055B4:  MOVWF  x43
055B6:  MOVLB  0
055B8:  CALL   0880
055BC:  MOVFF  02,702
055C0:  MOVFF  01,701
055C4:  MOVLW  EB
055C6:  MOVLB  7
055C8:  ADDWF  01,W
055CA:  MOVWF  FE9
055CC:  MOVLW  01
055CE:  ADDWFC 02,W
055D0:  MOVWF  FEA
055D2:  BTFSC  FEF.0
055D4:  BRA    55F6
....................    {
....................       if (SRI == SWI) return FALSE;
055D6:  MOVLB  4
055D8:  MOVF   xC0,W
055DA:  SUBWF  xBF,W
055DC:  BNZ   55E4
055DE:  MOVLW  00
055E0:  MOVWF  01
055E2:  BRA    55FC
....................       SRI +=1;
055E4:  MOVLW  01
055E6:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
055E8:  MOVF   xBF,W
055EA:  SUBLW  03
055EC:  BC    55F0
055EE:  CLRF   xBF
055F0:  MOVLB  0
055F2:  BRA    55A8
055F4:  MOVLB  7
....................    }
....................    return TRUE;
055F6:  MOVLW  01
055F8:  MOVWF  01
055FA:  MOVLB  4
055FC:  MOVLB  0
055FE:  GOTO   9FD6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
0500E:  MOVLW  01
05010:  MOVLB  4
05012:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
05014:  MOVF   xC0,W
05016:  SUBLW  03
05018:  BC    501C
0501A:  CLRF   xC0
0501C:  MOVLB  0
0501E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
*
0A24C:  MOVFF  FF2,03
0A250:  BCF    FF2.7
0A252:  MOVLW  04
0A254:  MOVWF  F88
0A256:  BCF    F83.7
0A258:  MOVLW  08
0A25A:  MOVWF  01
0A25C:  BRA    A25E
0A25E:  NOP   
0A260:  BSF    01.7
0A262:  BRA    A284
0A264:  BCF    01.7
0A266:  MOVLB  6
0A268:  RRCF   xFD,F
0A26A:  MOVLB  0
0A26C:  BTFSC  FD8.0
0A26E:  BSF    F83.7
0A270:  BTFSS  FD8.0
0A272:  BCF    F83.7
0A274:  BSF    01.6
0A276:  BRA    A284
0A278:  BCF    01.6
0A27A:  DECFSZ 01,F
0A27C:  BRA    A266
0A27E:  BRA    A280
0A280:  NOP   
0A282:  BSF    F83.7
0A284:  MOVLW  84
0A286:  MOVWF  FE9
0A288:  DECFSZ FE9,F
0A28A:  BRA    A288
0A28C:  BRA    A28E
0A28E:  NOP   
0A290:  BTFSC  01.7
0A292:  BRA    A264
0A294:  BTFSC  01.6
0A296:  BRA    A278
0A298:  BTFSC  03.7
0A29A:  BSF    FF2.7
0A29C:  RETURN 0
.................... //!#use rs232(ICD, stream=ICD_STREAM)
.................... 
.................... #ifdef use_RS485
.................... //!#use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,563
000D4:  MOVLB  5
000D6:  MOVFF  F98,01
000DA:  BTFSS  x63.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
*
0504C:  MOVLW  93
0504E:  MOVWF  F89
05050:  BSF    F84.5
....................     delay_us(200);
05052:  MOVLW  C8
05054:  MOVLB  7
05056:  MOVWF  x07
05058:  MOVLB  0
0505A:  CALL   0710
....................     
....................     fprintf(SERIAL, "%s", printBuffer);
0505E:  MOVFF  702,FEA
05062:  MOVFF  701,FE9
05066:  BRA    5020
....................     delay_us(200);
05068:  MOVLW  C8
0506A:  MOVLB  7
0506C:  MOVWF  x07
0506E:  MOVLB  0
05070:  CALL   0710
....................     
....................     output_low(TX_ENABLE);
05074:  MOVLW  93
05076:  MOVWF  F89
05078:  BCF    F84.5
0507A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {   
....................     while (kbhit(SERIAL))
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    0130
....................     {
....................         UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
000F0:  CLRF   03
000F2:  MOVLB  5
000F4:  MOVF   x61,W
000F6:  ADDLW  25
000F8:  MOVWF  FE9
000FA:  MOVLW  05
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,774
00104:  MOVFF  FE9,773
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  774,FEA
00110:  MOVFF  773,FE9
00114:  MOVFF  01,FEF
....................         UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  5
0011C:  ADDWF  x61,F
....................         if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   x61,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   x61
....................         BYTES_AVAILABLE=TRUE;
00126:  MOVLB  1
00128:  BSF    x63.1
0012A:  MOVLB  0
0012C:  BRA    00EA
0012E:  MOVLB  E
....................     }
00130:  BCF    xC8.5
00132:  MOVLB  0
00134:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
04FD6:  CLRF   03
04FD8:  MOVLB  5
04FDA:  MOVF   x62,W
04FDC:  ADDLW  25
04FDE:  MOVWF  FE9
04FE0:  MOVLW  05
04FE2:  ADDWFC 03,W
04FE4:  MOVWF  FEA
04FE6:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
04FEA:  MOVLW  01
04FEC:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
04FEE:  MOVF   x62,W
04FF0:  SUBLW  3B
04FF2:  BC    4FF6
04FF4:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
04FF6:  MOVF   x61,W
04FF8:  SUBWF  x62,W
04FFA:  BNZ   5002
04FFC:  MOVLB  1
04FFE:  BCF    x63.1
05000:  MOVLB  5
....................    return data;
05002:  MOVLB  6
05004:  MOVFF  6FC,01
05008:  MOVLB  0
0500A:  GOTO   50C4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
0507C:  MOVLB  1
0507E:  BTFSS  x63.1
05080:  BRA    559C
05082:  MOVLB  7
05084:  CLRF   x42
05086:  MOVFF  4C0,741
0508A:  CLRF   x44
0508C:  MOVLW  B5
0508E:  MOVWF  x43
05090:  MOVLB  0
05092:  CALL   0880
05096:  MOVFF  02,6FD
0509A:  MOVFF  01,6FC
0509E:  MOVLW  EB
050A0:  MOVLB  6
050A2:  ADDWF  01,W
050A4:  MOVWF  01
050A6:  MOVLW  01
050A8:  ADDWFC 02,W
050AA:  MOVWF  03
050AC:  MOVFF  01,FE9
050B0:  MOVWF  FEA
050B2:  BTFSS  FEF.0
050B4:  BRA    50BA
050B6:  MOVLB  1
050B8:  BRA    559C
....................    {  
....................       output_high(TX_ENABLE);
050BA:  MOVLW  93
050BC:  MOVWF  F89
050BE:  BSF    F84.5
....................       unsigned int8 rxChar = getchFromBuffer();
050C0:  MOVLB  0
050C2:  BRA    4FD6
050C4:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
050C8:  MOVLB  6
050CA:  MOVF   xFB,W
050CC:  SUBLW  0D
050CE:  BZ    50D6
050D0:  MOVF   xFB,W
050D2:  SUBLW  20
050D4:  BNZ   50D8
....................       {
....................       }
050D6:  BRA    5596
....................       else if (rxChar == UART_SOT_CHAR)
050D8:  MOVF   xFB,W
050DA:  SUBLW  7E
050DC:  BNZ   5120
....................       {
....................          resetSERcmd(SWI);
050DE:  MOVFF  4C0,701
050E2:  MOVLB  0
050E4:  CALL   0B64
....................          SERcmd[SWI].t = rxChar;
050E8:  MOVLB  7
050EA:  CLRF   x42
050EC:  MOVFF  4C0,741
050F0:  CLRF   x44
050F2:  MOVLW  B5
050F4:  MOVWF  x43
050F6:  MOVLB  0
050F8:  CALL   0880
050FC:  MOVFF  01,6FC
05100:  MOVLW  05
05102:  MOVLB  6
05104:  ADDWF  01,W
05106:  MOVWF  01
05108:  MOVLW  00
0510A:  ADDWFC 02,W
0510C:  MOVWF  03
0510E:  MOVF   01,W
05110:  ADDLW  EB
05112:  MOVWF  FE9
05114:  MOVLW  01
05116:  ADDWFC 03,W
05118:  MOVWF  FEA
0511A:  MOVFF  6FB,FEF
....................       }
0511E:  BRA    5596
....................       else if (rxChar >= oneByteCmdTestValue)
05120:  MOVF   xFB,W
05122:  SUBLW  7F
05124:  BC    5192
....................       {
....................          resetSERcmd(SWI);
05126:  MOVFF  4C0,701
0512A:  MOVLB  0
0512C:  CALL   0B64
....................          SERcmd[SWI].t = rxChar;
05130:  MOVLB  7
05132:  CLRF   x42
05134:  MOVFF  4C0,741
05138:  CLRF   x44
0513A:  MOVLW  B5
0513C:  MOVWF  x43
0513E:  MOVLB  0
05140:  CALL   0880
05144:  MOVFF  01,6FC
05148:  MOVLW  05
0514A:  MOVLB  6
0514C:  ADDWF  01,W
0514E:  MOVWF  01
05150:  MOVLW  00
05152:  ADDWFC 02,W
05154:  MOVWF  03
05156:  MOVF   01,W
05158:  ADDLW  EB
0515A:  MOVWF  FE9
0515C:  MOVLW  01
0515E:  ADDWFC 03,W
05160:  MOVWF  FEA
05162:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
05166:  MOVLB  7
05168:  CLRF   x42
0516A:  MOVFF  4C0,741
0516E:  CLRF   x44
05170:  MOVLW  B5
05172:  MOVWF  x43
05174:  MOVLB  0
05176:  CALL   0880
0517A:  MOVLW  EB
0517C:  MOVLB  6
0517E:  ADDWF  01,W
05180:  MOVWF  FE9
05182:  MOVLW  01
05184:  ADDWFC 02,W
05186:  MOVWF  FEA
05188:  BSF    FEF.0
....................          setNextSERWriteIndex();
0518A:  MOVLB  0
0518C:  RCALL  500E
....................       }
0518E:  BRA    5594
05190:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
05192:  MOVF   xFB,W
05194:  SUBLW  0A
05196:  BTFSS  FD8.2
05198:  BRA    52A6
....................       {
....................          SERcmd[SWI].full = TRUE;
0519A:  MOVLB  7
0519C:  CLRF   x42
0519E:  MOVFF  4C0,741
051A2:  CLRF   x44
051A4:  MOVLW  B5
051A6:  MOVWF  x43
051A8:  MOVLB  0
051AA:  CALL   0880
051AE:  MOVLW  EB
051B0:  MOVLB  6
051B2:  ADDWF  01,W
051B4:  MOVWF  FE9
051B6:  MOVLW  01
051B8:  ADDWFC 02,W
051BA:  MOVWF  FEA
051BC:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
051BE:  MOVLB  7
051C0:  CLRF   x42
051C2:  MOVFF  4C0,741
051C6:  CLRF   x44
051C8:  MOVLW  B5
051CA:  MOVWF  x43
051CC:  MOVLB  0
051CE:  CALL   0880
051D2:  MOVFF  01,6FC
051D6:  MOVLW  04
051D8:  ADDWF  01,W
051DA:  MOVWF  01
051DC:  MOVLW  00
051DE:  ADDWFC 02,W
051E0:  MOVWF  03
051E2:  MOVF   01,W
051E4:  ADDLW  EB
051E6:  MOVWF  01
051E8:  MOVLW  01
051EA:  ADDWFC 03,F
051EC:  MOVFF  01,6FC
051F0:  MOVFF  03,6FD
051F4:  MOVLB  7
051F6:  CLRF   x42
051F8:  MOVFF  4C0,741
051FC:  CLRF   x44
051FE:  MOVLW  B5
05200:  MOVWF  x43
05202:  MOVLB  0
05204:  CALL   0880
05208:  MOVFF  01,6FE
0520C:  MOVLW  02
0520E:  MOVLB  6
05210:  ADDWF  01,W
05212:  MOVWF  01
05214:  MOVLW  00
05216:  ADDWFC 02,W
05218:  MOVWF  03
0521A:  MOVF   01,W
0521C:  ADDLW  EB
0521E:  MOVWF  FE9
05220:  MOVLW  01
05222:  ADDWFC 03,W
05224:  MOVWF  FEA
05226:  MOVFF  FEF,6FE
0522A:  MOVFF  6FD,FEA
0522E:  MOVFF  6FC,FE9
05232:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
05236:  MOVLB  7
05238:  CLRF   x42
0523A:  MOVFF  4C0,741
0523E:  CLRF   x44
05240:  MOVLW  B5
05242:  MOVWF  x43
05244:  MOVLB  0
05246:  CALL   0880
0524A:  MOVFF  01,6FC
0524E:  MOVLW  01
05250:  MOVLB  6
05252:  ADDWF  01,W
05254:  MOVWF  01
05256:  MOVLW  00
05258:  ADDWFC 02,W
0525A:  MOVWF  03
0525C:  MOVF   01,W
0525E:  ADDLW  EB
05260:  MOVWF  FE9
05262:  MOVLW  01
05264:  ADDWFC 03,W
05266:  MOVWF  FEA
05268:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
0526A:  MOVLB  7
0526C:  CLRF   x42
0526E:  MOVFF  4C0,741
05272:  CLRF   x44
05274:  MOVLW  B5
05276:  MOVWF  x43
05278:  MOVLB  0
0527A:  CALL   0880
0527E:  MOVFF  01,6FC
05282:  MOVLW  02
05284:  MOVLB  6
05286:  ADDWF  01,W
05288:  MOVWF  01
0528A:  MOVLW  00
0528C:  ADDWFC 02,W
0528E:  MOVWF  03
05290:  MOVF   01,W
05292:  ADDLW  EB
05294:  MOVWF  FE9
05296:  MOVLW  01
05298:  ADDWFC 03,W
0529A:  MOVWF  FEA
0529C:  CLRF   FEF
....................          setNextSERWriteIndex();
0529E:  MOVLB  0
052A0:  RCALL  500E
....................       }
052A2:  BRA    5594
052A4:  MOVLB  6
....................       else if (rxChar == delimiter)
052A6:  MOVF   xFB,W
052A8:  SUBLW  2C
052AA:  BNZ   5372
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
052AC:  MOVLB  7
052AE:  CLRF   x42
052B0:  MOVFF  4C0,741
052B4:  CLRF   x44
052B6:  MOVLW  B5
052B8:  MOVWF  x43
052BA:  MOVLB  0
052BC:  CALL   0880
052C0:  MOVFF  02,6FD
052C4:  MOVFF  01,6FC
052C8:  MOVLW  02
052CA:  MOVLB  6
052CC:  ADDWF  01,W
052CE:  MOVWF  01
052D0:  MOVLW  00
052D2:  ADDWFC 02,W
052D4:  MOVWF  03
052D6:  MOVF   01,W
052D8:  ADDLW  EB
052DA:  MOVWF  FE9
052DC:  MOVLW  01
052DE:  ADDWFC 03,W
052E0:  MOVWF  FEA
052E2:  MOVF   FEF,W
052E4:  SUBLW  05
052E6:  BNC   5356
....................          {
....................             SERcmd[SWI].paramIndex +=1;
052E8:  MOVLB  7
052EA:  CLRF   x42
052EC:  MOVFF  4C0,741
052F0:  CLRF   x44
052F2:  MOVLW  B5
052F4:  MOVWF  x43
052F6:  MOVLB  0
052F8:  CALL   0880
052FC:  MOVFF  01,6FC
05300:  MOVLW  02
05302:  MOVLB  6
05304:  ADDWF  01,W
05306:  MOVWF  01
05308:  MOVLW  00
0530A:  ADDWFC 02,W
0530C:  MOVWF  03
0530E:  MOVF   01,W
05310:  ADDLW  EB
05312:  MOVWF  FE9
05314:  MOVLW  01
05316:  ADDWFC 03,W
05318:  MOVWF  FEA
0531A:  MOVLW  01
0531C:  ADDWF  FEF,W
0531E:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
05320:  MOVLB  7
05322:  CLRF   x42
05324:  MOVFF  4C0,741
05328:  CLRF   x44
0532A:  MOVLW  B5
0532C:  MOVWF  x43
0532E:  MOVLB  0
05330:  CALL   0880
05334:  MOVFF  01,6FC
05338:  MOVLW  01
0533A:  MOVLB  6
0533C:  ADDWF  01,W
0533E:  MOVWF  01
05340:  MOVLW  00
05342:  ADDWFC 02,W
05344:  MOVWF  03
05346:  MOVF   01,W
05348:  ADDLW  EB
0534A:  MOVWF  FE9
0534C:  MOVLW  01
0534E:  ADDWFC 03,W
05350:  MOVWF  FEA
05352:  CLRF   FEF
....................          }
05354:  BRA    5370
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
05356:  MOVFF  4C0,701
0535A:  MOVLB  0
0535C:  CALL   0B64
....................             serial_out(retData);
05360:  MOVLW  04
05362:  MOVLB  7
05364:  MOVWF  x02
05366:  MOVLW  C1
05368:  MOVWF  x01
0536A:  MOVLB  0
0536C:  RCALL  504C
0536E:  MOVLB  6
....................          }
....................       }
05370:  BRA    5596
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
05372:  MOVLB  7
05374:  CLRF   x42
05376:  MOVFF  4C0,741
0537A:  CLRF   x44
0537C:  MOVLW  B5
0537E:  MOVWF  x43
05380:  MOVLB  0
05382:  CALL   0880
05386:  MOVFF  02,6FD
0538A:  MOVFF  01,6FC
0538E:  MOVLW  01
05390:  MOVLB  6
05392:  ADDWF  01,W
05394:  MOVWF  01
05396:  MOVLW  00
05398:  ADDWFC 02,W
0539A:  MOVWF  03
0539C:  MOVF   01,W
0539E:  ADDLW  EB
053A0:  MOVWF  FE9
053A2:  MOVLW  01
053A4:  ADDWFC 03,W
053A6:  MOVWF  FEA
053A8:  MOVF   FEF,W
053AA:  SUBLW  18
053AC:  BTFSS  FD8.0
053AE:  BRA    557C
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
053B0:  MOVLB  7
053B2:  CLRF   x42
053B4:  MOVFF  4C0,741
053B8:  CLRF   x44
053BA:  MOVLW  B5
053BC:  MOVWF  x43
053BE:  MOVLB  0
053C0:  CALL   0880
053C4:  MOVFF  02,6FD
053C8:  MOVFF  01,6FC
053CC:  MOVLW  06
053CE:  MOVLB  6
053D0:  ADDWF  xFC,F
053D2:  MOVLW  00
053D4:  ADDWFC xFD,F
053D6:  MOVLB  7
053D8:  CLRF   x42
053DA:  MOVFF  4C0,741
053DE:  CLRF   x44
053E0:  MOVLW  B5
053E2:  MOVWF  x43
053E4:  MOVLB  0
053E6:  CALL   0880
053EA:  MOVFF  02,6FF
053EE:  MOVFF  01,6FE
053F2:  MOVLW  02
053F4:  ADDWF  01,W
053F6:  MOVWF  01
053F8:  MOVLW  00
053FA:  ADDWFC 02,W
053FC:  MOVWF  03
053FE:  MOVF   01,W
05400:  ADDLW  EB
05402:  MOVWF  FE9
05404:  MOVLW  01
05406:  ADDWFC 03,W
05408:  MOVWF  FEA
0540A:  MOVLB  7
0540C:  CLRF   x42
0540E:  MOVFF  FEF,741
05412:  CLRF   x44
05414:  MOVLW  19
05416:  MOVWF  x43
05418:  MOVLB  0
0541A:  CALL   0880
0541E:  MOVFF  02,03
05422:  MOVF   01,W
05424:  MOVLB  6
05426:  ADDWF  xFC,F
05428:  MOVF   02,W
0542A:  ADDWFC xFD,F
0542C:  MOVLB  7
0542E:  CLRF   x42
05430:  MOVFF  4C0,741
05434:  CLRF   x44
05436:  MOVLW  B5
05438:  MOVWF  x43
0543A:  MOVLB  0
0543C:  CALL   0880
05440:  MOVFF  01,6FE
05444:  MOVLW  01
05446:  MOVLB  6
05448:  ADDWF  01,W
0544A:  MOVWF  01
0544C:  MOVLW  00
0544E:  ADDWFC 02,W
05450:  MOVWF  03
05452:  MOVF   01,W
05454:  ADDLW  EB
05456:  MOVWF  FE9
05458:  MOVLW  01
0545A:  ADDWFC 03,W
0545C:  MOVWF  FEA
0545E:  MOVF   FEF,W
05460:  ADDWF  xFC,W
05462:  MOVWF  01
05464:  MOVLW  00
05466:  ADDWFC xFD,W
05468:  MOVWF  03
0546A:  MOVF   01,W
0546C:  ADDLW  EB
0546E:  MOVWF  FE9
05470:  MOVLW  01
05472:  ADDWFC 03,W
05474:  MOVWF  FEA
05476:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
0547A:  MOVLB  7
0547C:  CLRF   x42
0547E:  MOVFF  4C0,741
05482:  CLRF   x44
05484:  MOVLW  B5
05486:  MOVWF  x43
05488:  MOVLB  0
0548A:  CALL   0880
0548E:  MOVFF  01,6FC
05492:  MOVLW  01
05494:  MOVLB  6
05496:  ADDWF  01,W
05498:  MOVWF  01
0549A:  MOVLW  00
0549C:  ADDWFC 02,W
0549E:  MOVWF  03
054A0:  MOVF   01,W
054A2:  ADDLW  EB
054A4:  MOVWF  FE9
054A6:  MOVLW  01
054A8:  ADDWFC 03,W
054AA:  MOVWF  FEA
054AC:  MOVLW  01
054AE:  ADDWF  FEF,W
054B0:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
054B2:  MOVLB  7
054B4:  CLRF   x42
054B6:  MOVFF  4C0,741
054BA:  CLRF   x44
054BC:  MOVLW  B5
054BE:  MOVWF  x43
054C0:  MOVLB  0
054C2:  CALL   0880
054C6:  MOVFF  02,6FD
054CA:  MOVFF  01,6FC
054CE:  MOVLW  06
054D0:  MOVLB  6
054D2:  ADDWF  xFC,F
054D4:  MOVLW  00
054D6:  ADDWFC xFD,F
054D8:  MOVLB  7
054DA:  CLRF   x42
054DC:  MOVFF  4C0,741
054E0:  CLRF   x44
054E2:  MOVLW  B5
054E4:  MOVWF  x43
054E6:  MOVLB  0
054E8:  CALL   0880
054EC:  MOVFF  02,6FF
054F0:  MOVFF  01,6FE
054F4:  MOVLW  02
054F6:  ADDWF  01,W
054F8:  MOVWF  01
054FA:  MOVLW  00
054FC:  ADDWFC 02,W
054FE:  MOVWF  03
05500:  MOVF   01,W
05502:  ADDLW  EB
05504:  MOVWF  FE9
05506:  MOVLW  01
05508:  ADDWFC 03,W
0550A:  MOVWF  FEA
0550C:  MOVLB  7
0550E:  CLRF   x42
05510:  MOVFF  FEF,741
05514:  CLRF   x44
05516:  MOVLW  19
05518:  MOVWF  x43
0551A:  MOVLB  0
0551C:  CALL   0880
05520:  MOVFF  02,03
05524:  MOVF   01,W
05526:  MOVLB  6
05528:  ADDWF  xFC,F
0552A:  MOVF   02,W
0552C:  ADDWFC xFD,F
0552E:  MOVLB  7
05530:  CLRF   x42
05532:  MOVFF  4C0,741
05536:  CLRF   x44
05538:  MOVLW  B5
0553A:  MOVWF  x43
0553C:  MOVLB  0
0553E:  CALL   0880
05542:  MOVFF  01,6FE
05546:  MOVLW  01
05548:  MOVLB  6
0554A:  ADDWF  01,W
0554C:  MOVWF  01
0554E:  MOVLW  00
05550:  ADDWFC 02,W
05552:  MOVWF  03
05554:  MOVF   01,W
05556:  ADDLW  EB
05558:  MOVWF  FE9
0555A:  MOVLW  01
0555C:  ADDWFC 03,W
0555E:  MOVWF  FEA
05560:  MOVF   FEF,W
05562:  ADDWF  xFC,W
05564:  MOVWF  01
05566:  MOVLW  00
05568:  ADDWFC xFD,W
0556A:  MOVWF  03
0556C:  MOVF   01,W
0556E:  ADDLW  EB
05570:  MOVWF  FE9
05572:  MOVLW  01
05574:  ADDWFC 03,W
05576:  MOVWF  FEA
05578:  CLRF   FEF
....................          }
0557A:  BRA    5596
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
0557C:  MOVFF  4C0,701
05580:  MOVLB  0
05582:  CALL   0B64
....................             serial_out(retData);
05586:  MOVLW  04
05588:  MOVLB  7
0558A:  MOVWF  x02
0558C:  MOVLW  C1
0558E:  MOVWF  x01
05590:  MOVLB  0
05592:  RCALL  504C
05594:  MOVLB  6
....................          }
....................       }
05596:  MOVLB  0
05598:  BRA    507C
0559A:  MOVLB  1
....................    }
....................    output_low(TX_ENABLE);
0559C:  MOVLW  93
0559E:  MOVWF  F89
055A0:  BCF    F84.5
055A2:  MOVLB  0
055A4:  GOTO   A720 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00CDE:  MOVLB  6
00CE0:  CLRF   xFB
00CE2:  MOVF   xFB,W
00CE4:  SUBLW  03
00CE6:  BNC   0CF6
....................    {
....................       resetSERcmd(i);
00CE8:  MOVFF  6FB,701
00CEC:  MOVLB  0
00CEE:  RCALL  0B64
00CF0:  MOVLB  6
00CF2:  INCF   xFB,F
00CF4:  BRA    0CE2
....................    }
....................    enable_interrupts(INT_RDA);
00CF6:  MOVLB  E
00CF8:  BSF    xC0.5
00CFA:  MOVLB  0
00CFC:  GOTO   A6E4 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D00:  MOVLB  E
00D02:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D04:  MOVLW  01
00D06:  MOVWF  FD1
00D08:  MOVLW  07
00D0A:  MOVWF  FCE
00D0C:  CLRF   FCF
00D0E:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D10:  MOVLB  1
00D12:  CLRF   x75
00D14:  CLRF   x74
00D16:  CLRF   x73
00D18:  CLRF   x72
....................    timeoutReg1 = 0;
00D1A:  CLRF   x79
00D1C:  CLRF   x78
00D1E:  CLRF   x77
00D20:  CLRF   x76
....................    timeoutReg2 = 0;
00D22:  CLRF   x7D
00D24:  CLRF   x7C
00D26:  CLRF   x7B
00D28:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D2A:  MOVLB  E
00D2C:  BSF    xC1.0
00D2E:  MOVLB  0
00D30:  GOTO   A6E8 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0025C:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
0025E:  MOVLW  0B
00260:  MOVWF  FCD
00262:  MOVLW  DB
00264:  MOVWF  FCC
00266:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00268:  MOVLB  1
0026A:  MOVF   x75,F
0026C:  BNZ   027C
0026E:  MOVF   x74,F
00270:  BNZ   027C
00272:  MOVF   x73,F
00274:  BNZ   027C
00276:  MOVF   x72,W
00278:  SUBLW  0A
0027A:  BC    028A
0027C:  MOVLW  0A
0027E:  SUBWF  x72,F
00280:  MOVLW  00
00282:  SUBWFB x73,F
00284:  SUBWFB x74,F
00286:  SUBWFB x75,F
00288:  BRA    0292
0028A:  CLRF   x75
0028C:  CLRF   x74
0028E:  CLRF   x73
00290:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00292:  MOVF   x79,F
00294:  BNZ   02A4
00296:  MOVF   x78,F
00298:  BNZ   02A4
0029A:  MOVF   x77,F
0029C:  BNZ   02A4
0029E:  MOVF   x76,W
002A0:  SUBLW  0A
002A2:  BC    02B2
002A4:  MOVLW  0A
002A6:  SUBWF  x76,F
002A8:  MOVLW  00
002AA:  SUBWFB x77,F
002AC:  SUBWFB x78,F
002AE:  SUBWFB x79,F
002B0:  BRA    02BA
002B2:  CLRF   x79
002B4:  CLRF   x78
002B6:  CLRF   x77
002B8:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002BA:  MOVF   x7D,F
002BC:  BNZ   02CC
002BE:  MOVF   x7C,F
002C0:  BNZ   02CC
002C2:  MOVF   x7B,F
002C4:  BNZ   02CC
002C6:  MOVF   x7A,W
002C8:  SUBLW  0A
002CA:  BC    02DA
002CC:  MOVLW  0A
002CE:  SUBWF  x7A,F
002D0:  MOVLW  00
002D2:  SUBWFB x7B,F
002D4:  SUBWFB x7C,F
002D6:  SUBWFB x7D,F
002D8:  BRA    02E2
002DA:  CLRF   x7D
002DC:  CLRF   x7C
002DE:  CLRF   x7B
002E0:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002E2:  MOVF   x7E,F
002E4:  BNZ   02EA
002E6:  MOVF   x7F,F
002E8:  BZ    0326
....................    {
....................       timeCounter+=10;
002EA:  MOVLW  0A
002EC:  MOVLB  5
002EE:  ADDWF  x66,F
002F0:  MOVLW  00
002F2:  ADDWFC x67,F
002F4:  ADDWFC x68,F
002F6:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
002F8:  MOVF   x69,F
002FA:  BNZ   0316
002FC:  MOVF   x68,F
002FE:  BNZ   0316
00300:  MOVLB  1
00302:  MOVF   x7F,W
00304:  MOVLB  5
00306:  SUBWF  x67,W
00308:  BNC   0324
0030A:  BNZ   0316
0030C:  MOVLB  1
0030E:  MOVF   x7E,W
00310:  MOVLB  5
00312:  SUBWF  x66,W
00314:  BNC   0324
....................       {
....................          sensor_monitor_interrupt_task();
00316:  MOVLB  0
00318:  BRA    01C0
....................          timeCounter = 0;
0031A:  MOVLB  5
0031C:  CLRF   x69
0031E:  CLRF   x68
00320:  CLRF   x67
00322:  CLRF   x66
00324:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00326:  MOVLB  E
00328:  BCF    xC9.0
0032A:  MOVLB  0
0032C:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
05750:  MOVLW  04
05752:  MOVLB  7
05754:  MOVWF  x42
05756:  MOVLW  C1
05758:  MOVWF  x41
0575A:  MOVLB  0
0575C:  RCALL  5602
0575E:  MOVFF  02,03
05762:  MOVF   01,W
05764:  ADDLW  C1
05766:  MOVLB  7
05768:  MOVWF  x0B
0576A:  MOVLW  04
0576C:  ADDWFC 02,W
0576E:  MOVWF  x0C
05770:  MOVFF  FE8,565
05774:  MOVFF  70B,564
05778:  MOVLW  30
0577A:  MOVWF  FF6
0577C:  MOVLW  03
0577E:  MOVWF  FF7
05780:  MOVLB  0
05782:  RCALL  5730
05784:  MOVLW  2C
05786:  MOVLB  7
05788:  MOVWF  x50
0578A:  MOVLB  0
0578C:  RCALL  563A
....................     return SUCCESS;
0578E:  MOVLW  00
05790:  MOVWF  01
05792:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05794:  MOVLW  04
05796:  MOVLB  7
05798:  MOVWF  x42
0579A:  MOVLW  C1
0579C:  MOVWF  x41
0579E:  MOVLB  0
057A0:  RCALL  5602
057A2:  MOVFF  02,03
057A6:  MOVF   01,W
057A8:  ADDLW  C1
057AA:  MOVLB  7
057AC:  MOVWF  x0B
057AE:  MOVLW  04
057B0:  ADDWFC 02,W
057B2:  MOVWF  x0C
057B4:  MOVFF  FE8,565
057B8:  MOVFF  70B,564
057BC:  MOVLW  3A
057BE:  MOVWF  FF6
057C0:  MOVLW  03
057C2:  MOVWF  FF7
057C4:  MOVLB  0
057C6:  RCALL  5730
057C8:  MOVLW  2C
057CA:  MOVLB  7
057CC:  MOVWF  x50
057CE:  MOVLB  0
057D0:  RCALL  563A
....................     return SUCCESS;
057D2:  MOVLW  00
057D4:  MOVWF  01
057D6:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05CDC:  MOVLB  7
05CDE:  CLRF   x42
05CE0:  MOVFF  690,741
05CE4:  CLRF   x44
05CE6:  MOVLW  B5
05CE8:  MOVWF  x43
05CEA:  MOVLB  0
05CEC:  CALL   0880
05CF0:  MOVFF  02,70D
05CF4:  MOVFF  01,70C
05CF8:  MOVLW  06
05CFA:  MOVLB  7
05CFC:  ADDWF  x0C,F
05CFE:  MOVLW  00
05D00:  ADDWFC x0D,F
05D02:  MOVLW  32
05D04:  ADDWF  x0C,W
05D06:  MOVWF  01
05D08:  MOVLW  00
05D0A:  ADDWFC x0D,W
05D0C:  MOVWF  03
05D0E:  MOVF   01,W
05D10:  ADDLW  EB
05D12:  MOVWF  01
05D14:  MOVLW  01
05D16:  ADDWFC 03,F
05D18:  MOVFF  01,70C
05D1C:  MOVFF  03,70D
05D20:  MOVFF  03,734
05D24:  MOVFF  01,733
05D28:  MOVLB  0
05D2A:  RCALL  57D8
05D2C:  MOVF   01,F
05D2E:  BNZ   5D38
05D30:  MOVLW  02
05D32:  MOVWF  01
05D34:  BRA    5E7E
05D36:  BRA    5D94
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05D38:  MOVLB  7
05D3A:  CLRF   x42
05D3C:  MOVFF  690,741
05D40:  CLRF   x44
05D42:  MOVLW  B5
05D44:  MOVWF  x43
05D46:  MOVLB  0
05D48:  CALL   0880
05D4C:  MOVFF  02,70D
05D50:  MOVFF  01,70C
05D54:  MOVLW  06
05D56:  MOVLB  7
05D58:  ADDWF  x0C,F
05D5A:  MOVLW  00
05D5C:  ADDWFC x0D,F
05D5E:  MOVLW  32
05D60:  ADDWF  x0C,W
05D62:  MOVWF  01
05D64:  MOVLW  00
05D66:  ADDWFC x0D,W
05D68:  MOVWF  03
05D6A:  MOVF   01,W
05D6C:  ADDLW  EB
05D6E:  MOVWF  01
05D70:  MOVLW  01
05D72:  ADDWFC 03,F
05D74:  MOVFF  01,70C
05D78:  MOVFF  03,70D
05D7C:  MOVFF  03,734
05D80:  MOVFF  01,733
05D84:  CLRF   x36
05D86:  CLRF   x35
05D88:  MOVLW  0A
05D8A:  MOVWF  x37
05D8C:  MOVLB  0
05D8E:  RCALL  58C8
05D90:  MOVFF  01,70B
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05D94:  MOVLW  01
05D96:  MOVLB  7
05D98:  SUBWF  x0B,W
05D9A:  MOVWF  x0D
05D9C:  CLRF   x0F
05D9E:  MOVLW  70
05DA0:  MOVWF  x0E
05DA2:  MOVLB  0
05DA4:  CALL   45DE
05DA8:  BTFSC  01.0
05DAA:  BRA    5E00
05DAC:  MOVLW  04
05DAE:  MOVLB  7
05DB0:  MOVWF  x42
05DB2:  MOVLW  C1
05DB4:  MOVWF  x41
05DB6:  MOVLB  0
05DB8:  RCALL  5602
05DBA:  MOVFF  02,03
05DBE:  MOVF   01,W
05DC0:  ADDLW  C1
05DC2:  MOVLB  7
05DC4:  MOVWF  x0C
05DC6:  MOVLW  04
05DC8:  ADDWFC 02,W
05DCA:  MOVWF  x0D
05DCC:  MOVFF  FE8,565
05DD0:  MOVFF  70C,564
05DD4:  MOVFF  70B,734
05DD8:  MOVLW  18
05DDA:  MOVWF  x35
05DDC:  MOVLB  0
05DDE:  RCALL  5C1C
05DE0:  MOVLW  2C
05DE2:  MOVLB  7
05DE4:  MOVWF  x50
05DE6:  MOVLB  0
05DE8:  RCALL  563A
05DEA:  MOVLW  58
05DEC:  MOVLB  7
05DEE:  MOVWF  x50
05DF0:  MOVLB  0
05DF2:  RCALL  563A
05DF4:  MOVLW  2C
05DF6:  MOVLB  7
05DF8:  MOVWF  x50
05DFA:  MOVLB  0
05DFC:  RCALL  563A
05DFE:  BRA    5E7A
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05E00:  MOVLW  01
05E02:  MOVLB  7
05E04:  SUBWF  x0B,W
05E06:  MOVWF  x0D
05E08:  CLRF   x0F
05E0A:  MOVLW  70
05E0C:  MOVWF  x0E
05E0E:  MOVLB  0
05E10:  CALL   45DE
05E14:  BTFSS  01.0
05E16:  BRA    5E74
05E18:  MOVLW  04
05E1A:  MOVLB  7
05E1C:  MOVWF  x42
05E1E:  MOVLW  C1
05E20:  MOVWF  x41
05E22:  MOVLB  0
05E24:  CALL   5602
05E28:  MOVFF  02,03
05E2C:  MOVF   01,W
05E2E:  ADDLW  C1
05E30:  MOVLB  7
05E32:  MOVWF  x0C
05E34:  MOVLW  04
05E36:  ADDWFC 02,W
05E38:  MOVWF  x0D
05E3A:  MOVFF  FE8,565
05E3E:  MOVFF  70C,564
05E42:  MOVFF  70B,734
05E46:  MOVLW  18
05E48:  MOVWF  x35
05E4A:  MOVLB  0
05E4C:  RCALL  5C1C
05E4E:  MOVLW  2C
05E50:  MOVLB  7
05E52:  MOVWF  x50
05E54:  MOVLB  0
05E56:  CALL   563A
05E5A:  MOVLW  59
05E5C:  MOVLB  7
05E5E:  MOVWF  x50
05E60:  MOVLB  0
05E62:  CALL   563A
05E66:  MOVLW  2C
05E68:  MOVLB  7
05E6A:  MOVWF  x50
05E6C:  MOVLB  0
05E6E:  CALL   563A
05E72:  BRA    5E7A
....................     else return INV_PARAM;
05E74:  MOVLW  02
05E76:  MOVWF  01
05E78:  BRA    5E7E
....................    
....................     return SUCCESS;
05E7A:  MOVLW  00
05E7C:  MOVWF  01
05E7E:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05EC2:  MOVLB  7
05EC4:  CLRF   x42
05EC6:  MOVFF  690,741
05ECA:  CLRF   x44
05ECC:  MOVLW  B5
05ECE:  MOVWF  x43
05ED0:  MOVLB  0
05ED2:  CALL   0880
05ED6:  MOVFF  02,70E
05EDA:  MOVFF  01,70D
05EDE:  MOVLW  06
05EE0:  MOVLB  7
05EE2:  ADDWF  x0D,F
05EE4:  MOVLW  00
05EE6:  ADDWFC x0E,F
05EE8:  MOVLW  32
05EEA:  ADDWF  x0D,W
05EEC:  MOVWF  01
05EEE:  MOVLW  00
05EF0:  ADDWFC x0E,W
05EF2:  MOVWF  03
05EF4:  MOVF   01,W
05EF6:  ADDLW  EB
05EF8:  MOVWF  01
05EFA:  MOVLW  01
05EFC:  ADDWFC 03,F
05EFE:  MOVFF  01,70D
05F02:  MOVFF  03,70E
05F06:  MOVFF  03,734
05F0A:  MOVFF  01,733
05F0E:  MOVLB  0
05F10:  RCALL  57D8
05F12:  MOVF   01,F
05F14:  BNZ   5F1E
05F16:  MOVLW  02
05F18:  MOVWF  01
05F1A:  BRA    606E
05F1C:  BRA    5F7A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05F1E:  MOVLB  7
05F20:  CLRF   x42
05F22:  MOVFF  690,741
05F26:  CLRF   x44
05F28:  MOVLW  B5
05F2A:  MOVWF  x43
05F2C:  MOVLB  0
05F2E:  CALL   0880
05F32:  MOVFF  02,70E
05F36:  MOVFF  01,70D
05F3A:  MOVLW  06
05F3C:  MOVLB  7
05F3E:  ADDWF  x0D,F
05F40:  MOVLW  00
05F42:  ADDWFC x0E,F
05F44:  MOVLW  32
05F46:  ADDWF  x0D,W
05F48:  MOVWF  01
05F4A:  MOVLW  00
05F4C:  ADDWFC x0E,W
05F4E:  MOVWF  03
05F50:  MOVF   01,W
05F52:  ADDLW  EB
05F54:  MOVWF  01
05F56:  MOVLW  01
05F58:  ADDWFC 03,F
05F5A:  MOVFF  01,70D
05F5E:  MOVFF  03,70E
05F62:  MOVFF  03,734
05F66:  MOVFF  01,733
05F6A:  CLRF   x36
05F6C:  CLRF   x35
05F6E:  MOVLW  0A
05F70:  MOVWF  x37
05F72:  MOVLB  0
05F74:  RCALL  58C8
05F76:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05F7A:  MOVLB  7
05F7C:  CLRF   x42
05F7E:  MOVFF  690,741
05F82:  CLRF   x44
05F84:  MOVLW  B5
05F86:  MOVWF  x43
05F88:  MOVLB  0
05F8A:  CALL   0880
05F8E:  MOVFF  02,70E
05F92:  MOVFF  01,70D
05F96:  MOVLW  06
05F98:  MOVLB  7
05F9A:  ADDWF  x0D,F
05F9C:  MOVLW  00
05F9E:  ADDWFC x0E,F
05FA0:  MOVLW  4B
05FA2:  ADDWF  x0D,W
05FA4:  MOVWF  01
05FA6:  MOVLW  00
05FA8:  ADDWFC x0E,W
05FAA:  MOVWF  03
05FAC:  MOVF   01,W
05FAE:  ADDLW  EB
05FB0:  MOVWF  01
05FB2:  MOVLW  01
05FB4:  ADDWFC 03,F
05FB6:  MOVFF  01,70D
05FBA:  MOVFF  03,70E
05FBE:  MOVFF  03,742
05FC2:  MOVFF  01,741
05FC6:  MOVLB  0
05FC8:  CALL   5602
05FCC:  MOVFF  02,03
05FD0:  MOVF   01,W
05FD2:  SUBLW  01
05FD4:  BNZ   5FDA
05FD6:  MOVF   03,F
05FD8:  BZ    5FE2
05FDA:  MOVLW  02
05FDC:  MOVWF  01
05FDE:  BRA    606E
05FE0:  BRA    6022
....................    else arg2 = SERcmd[rec].p[3][0];
05FE2:  MOVLB  7
05FE4:  CLRF   x42
05FE6:  MOVFF  690,741
05FEA:  CLRF   x44
05FEC:  MOVLW  B5
05FEE:  MOVWF  x43
05FF0:  MOVLB  0
05FF2:  CALL   0880
05FF6:  MOVFF  02,70E
05FFA:  MOVFF  01,70D
05FFE:  MOVLW  06
06000:  MOVLB  7
06002:  ADDWF  x0D,F
06004:  MOVLW  00
06006:  ADDWFC x0E,F
06008:  MOVLW  4B
0600A:  ADDWF  x0D,F
0600C:  MOVLW  00
0600E:  ADDWFC x0E,F
06010:  MOVLW  EB
06012:  ADDWF  x0D,W
06014:  MOVWF  FE9
06016:  MOVLW  01
06018:  ADDWFC x0E,W
0601A:  MOVWF  FEA
0601C:  MOVFF  FEF,70C
06020:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
06022:  MOVLB  7
06024:  MOVF   x0C,W
06026:  SUBLW  58
06028:  BNZ   6042
0602A:  MOVLW  01
0602C:  SUBWF  x0B,W
0602E:  MOVWF  x0D
06030:  MOVWF  x22
06032:  CLRF   x23
06034:  CLRF   x25
06036:  MOVLW  70
06038:  MOVWF  x24
0603A:  MOVLB  0
0603C:  RCALL  5E80
0603E:  BRA    606A
06040:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
06042:  MOVF   x0C,W
06044:  SUBLW  59
06046:  BNZ   6062
06048:  MOVLW  01
0604A:  SUBWF  x0B,W
0604C:  MOVWF  x0D
0604E:  MOVWF  x22
06050:  MOVLW  01
06052:  MOVWF  x23
06054:  CLRF   x25
06056:  MOVLW  70
06058:  MOVWF  x24
0605A:  MOVLB  0
0605C:  RCALL  5E80
0605E:  BRA    606A
06060:  MOVLB  7
....................    else return INV_PARAM;
06062:  MOVLW  02
06064:  MOVWF  01
06066:  MOVLB  0
06068:  BRA    606E
....................    
....................    return SUCCESS;
0606A:  MOVLW  00
0606C:  MOVWF  01
0606E:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
0609A:  MOVLB  7
0609C:  CLRF   x42
0609E:  MOVFF  690,741
060A2:  CLRF   x44
060A4:  MOVLW  B5
060A6:  MOVWF  x43
060A8:  MOVLB  0
060AA:  CALL   0880
060AE:  MOVFF  02,70D
060B2:  MOVFF  01,70C
060B6:  MOVLW  06
060B8:  MOVLB  7
060BA:  ADDWF  x0C,F
060BC:  MOVLW  00
060BE:  ADDWFC x0D,F
060C0:  MOVLW  32
060C2:  ADDWF  x0C,W
060C4:  MOVWF  01
060C6:  MOVLW  00
060C8:  ADDWFC x0D,W
060CA:  MOVWF  03
060CC:  MOVF   01,W
060CE:  ADDLW  EB
060D0:  MOVWF  01
060D2:  MOVLW  01
060D4:  ADDWFC 03,F
060D6:  MOVFF  01,70C
060DA:  MOVFF  03,70D
060DE:  MOVFF  03,734
060E2:  MOVFF  01,733
060E6:  MOVLB  0
060E8:  CALL   57D8
060EC:  MOVF   01,F
060EE:  BNZ   60F8
060F0:  MOVLW  02
060F2:  MOVWF  01
060F4:  BRA    6224
060F6:  BRA    6156
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
060F8:  MOVLB  7
060FA:  CLRF   x42
060FC:  MOVFF  690,741
06100:  CLRF   x44
06102:  MOVLW  B5
06104:  MOVWF  x43
06106:  MOVLB  0
06108:  CALL   0880
0610C:  MOVFF  02,70D
06110:  MOVFF  01,70C
06114:  MOVLW  06
06116:  MOVLB  7
06118:  ADDWF  x0C,F
0611A:  MOVLW  00
0611C:  ADDWFC x0D,F
0611E:  MOVLW  32
06120:  ADDWF  x0C,W
06122:  MOVWF  01
06124:  MOVLW  00
06126:  ADDWFC x0D,W
06128:  MOVWF  03
0612A:  MOVF   01,W
0612C:  ADDLW  EB
0612E:  MOVWF  01
06130:  MOVLW  01
06132:  ADDWFC 03,F
06134:  MOVFF  01,70C
06138:  MOVFF  03,70D
0613C:  MOVFF  03,734
06140:  MOVFF  01,733
06144:  CLRF   x36
06146:  CLRF   x35
06148:  MOVLW  0A
0614A:  MOVWF  x37
0614C:  MOVLB  0
0614E:  CALL   58C8
06152:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
06156:  MOVLW  01
06158:  MOVLB  7
0615A:  SUBWF  x0B,W
0615C:  MOVWF  x0D
0615E:  CLRF   x0F
06160:  MOVLW  71
06162:  MOVWF  x0E
06164:  MOVLB  0
06166:  CALL   45DE
0616A:  BTFSC  01.0
0616C:  BRA    61B8
0616E:  MOVLW  04
06170:  MOVLB  7
06172:  MOVWF  x42
06174:  MOVLW  C1
06176:  MOVWF  x41
06178:  MOVLB  0
0617A:  CALL   5602
0617E:  MOVFF  02,03
06182:  MOVF   01,W
06184:  ADDLW  C1
06186:  MOVLB  7
06188:  MOVWF  x0C
0618A:  MOVLW  04
0618C:  ADDWFC 02,W
0618E:  MOVWF  x0D
06190:  MOVFF  FE8,565
06194:  MOVFF  70C,564
06198:  MOVFF  70B,734
0619C:  MOVLW  18
0619E:  MOVWF  x35
061A0:  MOVLB  0
061A2:  RCALL  5C1C
061A4:  MOVLW  42
061A6:  MOVWF  FF6
061A8:  MOVLW  03
061AA:  MOVWF  FF7
061AC:  MOVLW  08
061AE:  MOVLB  7
061B0:  MOVWF  x0F
061B2:  MOVLB  0
061B4:  RCALL  6070
061B6:  BRA    6220
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
061B8:  MOVLW  01
061BA:  MOVLB  7
061BC:  SUBWF  x0B,W
061BE:  MOVWF  x0D
061C0:  CLRF   x0F
061C2:  MOVLW  71
061C4:  MOVWF  x0E
061C6:  MOVLB  0
061C8:  CALL   45DE
061CC:  BTFSS  01.0
061CE:  BRA    621A
061D0:  MOVLW  04
061D2:  MOVLB  7
061D4:  MOVWF  x42
061D6:  MOVLW  C1
061D8:  MOVWF  x41
061DA:  MOVLB  0
061DC:  CALL   5602
061E0:  MOVFF  02,03
061E4:  MOVF   01,W
061E6:  ADDLW  C1
061E8:  MOVLB  7
061EA:  MOVWF  x0C
061EC:  MOVLW  04
061EE:  ADDWFC 02,W
061F0:  MOVWF  x0D
061F2:  MOVFF  FE8,565
061F6:  MOVFF  70C,564
061FA:  MOVFF  70B,734
061FE:  MOVLW  18
06200:  MOVWF  x35
06202:  MOVLB  0
06204:  RCALL  5C1C
06206:  MOVLW  4E
06208:  MOVWF  FF6
0620A:  MOVLW  03
0620C:  MOVWF  FF7
0620E:  MOVLW  08
06210:  MOVLB  7
06212:  MOVWF  x0F
06214:  MOVLB  0
06216:  RCALL  6070
06218:  BRA    6220
....................    else return INV_PARAM;
0621A:  MOVLW  02
0621C:  MOVWF  01
0621E:  BRA    6224
....................    
....................    return SUCCESS;
06220:  MOVLW  00
06222:  MOVWF  01
06224:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06226:  MOVLW  4D
06228:  MOVLB  7
0622A:  MOVWF  x10
0622C:  MOVLW  41
0622E:  MOVWF  x11
06230:  MOVLW  4E
06232:  MOVWF  x12
06234:  MOVLW  55
06236:  MOVWF  x13
06238:  MOVLW  41
0623A:  MOVWF  x14
0623C:  MOVLW  4C
0623E:  MOVWF  x15
06240:  CLRF   x16
06242:  MOVLW  07
06244:  MOVWF  x0F
06246:  MOVLW  10
06248:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
0624A:  MOVLW  4D
0624C:  MOVWF  x19
0624E:  MOVLW  41
06250:  MOVWF  x1A
06252:  MOVLW  47
06254:  MOVWF  x1B
06256:  MOVLW  53
06258:  MOVWF  x1C
0625A:  MOVLW  4E
0625C:  MOVWF  x1D
0625E:  MOVLW  53
06260:  MOVWF  x1E
06262:  CLRF   x1F
06264:  MOVLW  07
06266:  MOVWF  x18
06268:  MOVLW  19
0626A:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0626C:  CLRF   x42
0626E:  MOVFF  690,741
06272:  CLRF   x44
06274:  MOVLW  B5
06276:  MOVWF  x43
06278:  MOVLB  0
0627A:  CALL   0880
0627E:  MOVFF  02,721
06282:  MOVFF  01,720
06286:  MOVLW  06
06288:  MOVLB  7
0628A:  ADDWF  x20,F
0628C:  MOVLW  00
0628E:  ADDWFC x21,F
06290:  MOVLW  32
06292:  ADDWF  x20,W
06294:  MOVWF  01
06296:  MOVLW  00
06298:  ADDWFC x21,W
0629A:  MOVWF  03
0629C:  MOVF   01,W
0629E:  ADDLW  EB
062A0:  MOVWF  01
062A2:  MOVLW  01
062A4:  ADDWFC 03,F
062A6:  MOVFF  01,720
062AA:  MOVFF  03,721
062AE:  MOVFF  03,734
062B2:  MOVFF  01,733
062B6:  MOVLB  0
062B8:  CALL   57D8
062BC:  MOVF   01,F
062BE:  BNZ   62C8
062C0:  MOVLW  02
062C2:  MOVWF  01
062C4:  BRA    643E
062C6:  BRA    6326
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
062C8:  MOVLB  7
062CA:  CLRF   x42
062CC:  MOVFF  690,741
062D0:  CLRF   x44
062D2:  MOVLW  B5
062D4:  MOVWF  x43
062D6:  MOVLB  0
062D8:  CALL   0880
062DC:  MOVFF  02,721
062E0:  MOVFF  01,720
062E4:  MOVLW  06
062E6:  MOVLB  7
062E8:  ADDWF  x20,F
062EA:  MOVLW  00
062EC:  ADDWFC x21,F
062EE:  MOVLW  32
062F0:  ADDWF  x20,W
062F2:  MOVWF  01
062F4:  MOVLW  00
062F6:  ADDWFC x21,W
062F8:  MOVWF  03
062FA:  MOVF   01,W
062FC:  ADDLW  EB
062FE:  MOVWF  01
06300:  MOVLW  01
06302:  ADDWFC 03,F
06304:  MOVFF  01,720
06308:  MOVFF  03,721
0630C:  MOVFF  03,734
06310:  MOVFF  01,733
06314:  CLRF   x36
06316:  CLRF   x35
06318:  MOVLW  0A
0631A:  MOVWF  x37
0631C:  MOVLB  0
0631E:  CALL   58C8
06322:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06326:  MOVLB  7
06328:  CLRF   x42
0632A:  MOVFF  690,741
0632E:  CLRF   x44
06330:  MOVLW  B5
06332:  MOVWF  x43
06334:  MOVLB  0
06336:  CALL   0880
0633A:  MOVFF  02,721
0633E:  MOVFF  01,720
06342:  MOVLW  06
06344:  MOVLB  7
06346:  ADDWF  x20,F
06348:  MOVLW  00
0634A:  ADDWFC x21,F
0634C:  MOVLW  4B
0634E:  ADDWF  x20,W
06350:  MOVWF  01
06352:  MOVLW  00
06354:  ADDWFC x21,W
06356:  MOVWF  03
06358:  MOVF   01,W
0635A:  ADDLW  EB
0635C:  MOVWF  01
0635E:  MOVLW  01
06360:  ADDWFC 03,F
06362:  MOVFF  01,720
06366:  MOVFF  03,721
0636A:  MOVFF  03,742
0636E:  MOVFF  01,741
06372:  MOVLB  0
06374:  CALL   5602
06378:  MOVFF  02,03
0637C:  MOVF   01,W
0637E:  BNZ   638C
06380:  MOVF   03,F
06382:  BNZ   638C
06384:  MOVLW  02
06386:  MOVWF  01
06388:  BRA    643E
0638A:  BRA    63D2
....................    else arg2 = SERcmd[rec].p[3];
0638C:  MOVLB  7
0638E:  CLRF   x42
06390:  MOVFF  690,741
06394:  CLRF   x44
06396:  MOVLW  B5
06398:  MOVWF  x43
0639A:  MOVLB  0
0639C:  CALL   0880
063A0:  MOVFF  02,721
063A4:  MOVFF  01,720
063A8:  MOVLW  06
063AA:  MOVLB  7
063AC:  ADDWF  x20,F
063AE:  MOVLW  00
063B0:  ADDWFC x21,F
063B2:  MOVLW  4B
063B4:  ADDWF  x20,W
063B6:  MOVWF  01
063B8:  MOVLW  00
063BA:  ADDWFC x21,W
063BC:  MOVWF  03
063BE:  MOVF   01,W
063C0:  ADDLW  EB
063C2:  MOVWF  01
063C4:  MOVLW  01
063C6:  ADDWFC 03,F
063C8:  MOVFF  01,70C
063CC:  MOVFF  03,70D
063D0:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
063D2:  MOVFF  70F,742
063D6:  MOVFF  70E,741
063DA:  MOVFF  70D,744
063DE:  MOVFF  70C,743
063E2:  CALL   56B8
063E6:  MOVF   01,F
063E8:  BNZ   6402
063EA:  MOVLW  01
063EC:  MOVLB  7
063EE:  SUBWF  x0B,W
063F0:  MOVWF  x20
063F2:  MOVWF  x22
063F4:  CLRF   x23
063F6:  CLRF   x25
063F8:  MOVLW  71
063FA:  MOVWF  x24
063FC:  MOVLB  0
063FE:  RCALL  5E80
06400:  BRA    643A
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
06402:  MOVFF  718,742
06406:  MOVFF  717,741
0640A:  MOVFF  70D,744
0640E:  MOVFF  70C,743
06412:  CALL   56B8
06416:  MOVF   01,F
06418:  BNZ   6434
0641A:  MOVLW  01
0641C:  MOVLB  7
0641E:  SUBWF  x0B,W
06420:  MOVWF  x20
06422:  MOVWF  x22
06424:  MOVLW  01
06426:  MOVWF  x23
06428:  CLRF   x25
0642A:  MOVLW  71
0642C:  MOVWF  x24
0642E:  MOVLB  0
06430:  RCALL  5E80
06432:  BRA    643A
....................    else return INV_PARAM;
06434:  MOVLW  02
06436:  MOVWF  01
06438:  BRA    643E
....................    
....................    return SUCCESS;
0643A:  MOVLW  00
0643C:  MOVWF  01
0643E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
066C6:  MOVLB  7
066C8:  CLRF   x42
066CA:  MOVFF  690,741
066CE:  CLRF   x44
066D0:  MOVLW  B5
066D2:  MOVWF  x43
066D4:  MOVLB  0
066D6:  CALL   0880
066DA:  MOVFF  02,70E
066DE:  MOVFF  01,70D
066E2:  MOVLW  06
066E4:  MOVLB  7
066E6:  ADDWF  x0D,F
066E8:  MOVLW  00
066EA:  ADDWFC x0E,F
066EC:  MOVLW  32
066EE:  ADDWF  x0D,W
066F0:  MOVWF  01
066F2:  MOVLW  00
066F4:  ADDWFC x0E,W
066F6:  MOVWF  03
066F8:  MOVF   01,W
066FA:  ADDLW  EB
066FC:  MOVWF  01
066FE:  MOVLW  01
06700:  ADDWFC 03,F
06702:  MOVFF  01,70D
06706:  MOVFF  03,70E
0670A:  MOVFF  03,734
0670E:  MOVFF  01,733
06712:  MOVLB  0
06714:  CALL   57D8
06718:  MOVF   01,F
0671A:  BNZ   6724
0671C:  MOVLW  02
0671E:  MOVWF  01
06720:  BRA    6B7A
06722:  BRA    6782
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06724:  MOVLB  7
06726:  CLRF   x42
06728:  MOVFF  690,741
0672C:  CLRF   x44
0672E:  MOVLW  B5
06730:  MOVWF  x43
06732:  MOVLB  0
06734:  CALL   0880
06738:  MOVFF  02,70E
0673C:  MOVFF  01,70D
06740:  MOVLW  06
06742:  MOVLB  7
06744:  ADDWF  x0D,F
06746:  MOVLW  00
06748:  ADDWFC x0E,F
0674A:  MOVLW  32
0674C:  ADDWF  x0D,W
0674E:  MOVWF  01
06750:  MOVLW  00
06752:  ADDWFC x0E,W
06754:  MOVWF  03
06756:  MOVF   01,W
06758:  ADDLW  EB
0675A:  MOVWF  01
0675C:  MOVLW  01
0675E:  ADDWFC 03,F
06760:  MOVFF  01,70D
06764:  MOVFF  03,70E
06768:  MOVFF  03,734
0676C:  MOVFF  01,733
06770:  CLRF   x36
06772:  CLRF   x35
06774:  MOVLW  0A
06776:  MOVWF  x37
06778:  MOVLB  0
0677A:  CALL   58C8
0677E:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06782:  MOVLB  7
06784:  CLRF   x42
06786:  MOVFF  690,741
0678A:  CLRF   x44
0678C:  MOVLW  B5
0678E:  MOVWF  x43
06790:  MOVLB  0
06792:  CALL   0880
06796:  MOVFF  02,70E
0679A:  MOVFF  01,70D
0679E:  MOVLW  06
067A0:  MOVLB  7
067A2:  ADDWF  x0D,F
067A4:  MOVLW  00
067A6:  ADDWFC x0E,F
067A8:  MOVLW  4B
067AA:  ADDWF  x0D,W
067AC:  MOVWF  01
067AE:  MOVLW  00
067B0:  ADDWFC x0E,W
067B2:  MOVWF  03
067B4:  MOVF   01,W
067B6:  ADDLW  EB
067B8:  MOVWF  01
067BA:  MOVLW  01
067BC:  ADDWFC 03,F
067BE:  MOVFF  01,70D
067C2:  MOVFF  03,70E
067C6:  MOVFF  03,742
067CA:  MOVFF  01,741
067CE:  MOVLB  0
067D0:  CALL   5602
067D4:  MOVFF  02,03
067D8:  MOVF   01,W
067DA:  SUBLW  01
067DC:  BNZ   67E2
067DE:  MOVF   03,F
067E0:  BZ    67EA
067E2:  MOVLW  02
067E4:  MOVWF  01
067E6:  BRA    6B7A
067E8:  BRA    682A
....................    else arg2 = SERcmd[rec].p[3][0];
067EA:  MOVLB  7
067EC:  CLRF   x42
067EE:  MOVFF  690,741
067F2:  CLRF   x44
067F4:  MOVLW  B5
067F6:  MOVWF  x43
067F8:  MOVLB  0
067FA:  CALL   0880
067FE:  MOVFF  02,70E
06802:  MOVFF  01,70D
06806:  MOVLW  06
06808:  MOVLB  7
0680A:  ADDWF  x0D,F
0680C:  MOVLW  00
0680E:  ADDWFC x0E,F
06810:  MOVLW  4B
06812:  ADDWF  x0D,F
06814:  MOVLW  00
06816:  ADDWFC x0E,F
06818:  MOVLW  EB
0681A:  ADDWF  x0D,W
0681C:  MOVWF  FE9
0681E:  MOVLW  01
06820:  ADDWFC x0E,W
06822:  MOVWF  FEA
06824:  MOVFF  FEF,70C
06828:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
0682A:  MOVLB  7
0682C:  MOVF   x0C,W
0682E:  SUBLW  50
06830:  BNZ   68CA
06832:  MOVLW  04
06834:  MOVWF  x42
06836:  MOVLW  C1
06838:  MOVWF  x41
0683A:  MOVLB  0
0683C:  CALL   5602
06840:  MOVFF  02,03
06844:  MOVF   01,W
06846:  ADDLW  C1
06848:  MOVLB  7
0684A:  MOVWF  x0D
0684C:  MOVLW  04
0684E:  ADDWFC 02,W
06850:  MOVWF  x0E
06852:  MOVLW  01
06854:  SUBWF  x0B,W
06856:  MULLW  28
06858:  MOVF   FF3,W
0685A:  CLRF   x10
0685C:  MOVWF  x0F
0685E:  MOVLW  20
06860:  ADDWF  x0F,W
06862:  MOVWF  FE9
06864:  MOVLW  00
06866:  ADDWFC x10,W
06868:  MOVWF  FEA
0686A:  MOVFF  FEF,711
0686E:  MOVFF  FEC,712
06872:  MOVFF  FEC,713
06876:  MOVFF  FEC,714
0687A:  MOVFF  70E,565
0687E:  MOVFF  70D,564
06882:  MOVFF  70B,734
06886:  MOVLW  18
06888:  MOVWF  x35
0688A:  MOVLB  0
0688C:  CALL   5C1C
06890:  MOVLW  2C
06892:  MOVLB  7
06894:  MOVWF  x50
06896:  MOVLB  0
06898:  CALL   563A
0689C:  MOVLW  89
0689E:  MOVWF  FE9
068A0:  MOVFF  714,746
068A4:  MOVFF  713,745
068A8:  MOVFF  712,744
068AC:  MOVFF  711,743
068B0:  MOVLW  02
068B2:  MOVLB  7
068B4:  MOVWF  x47
068B6:  MOVLB  0
068B8:  RCALL  6516
068BA:  MOVLW  2C
068BC:  MOVLB  7
068BE:  MOVWF  x50
068C0:  MOVLB  0
068C2:  CALL   563A
068C6:  BRA    6B76
068C8:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
068CA:  MOVF   x0C,W
068CC:  SUBLW  49
068CE:  BNZ   6970
068D0:  MOVLW  04
068D2:  MOVWF  x42
068D4:  MOVLW  C1
068D6:  MOVWF  x41
068D8:  MOVLB  0
068DA:  CALL   5602
068DE:  MOVF   01,W
068E0:  ADDLW  C1
068E2:  MOVLB  7
068E4:  MOVWF  x0D
068E6:  MOVLW  04
068E8:  ADDWFC 02,W
068EA:  MOVWF  x0E
068EC:  MOVLW  01
068EE:  SUBWF  x0B,W
068F0:  MULLW  28
068F2:  MOVF   FF3,W
068F4:  CLRF   x10
068F6:  MOVWF  x0F
068F8:  MOVLW  04
068FA:  ADDWF  x0F,W
068FC:  MOVWF  01
068FE:  MOVLW  00
06900:  ADDWFC x10,W
06902:  MOVWF  03
06904:  MOVF   01,W
06906:  ADDLW  20
06908:  MOVWF  FE9
0690A:  MOVLW  00
0690C:  ADDWFC 03,W
0690E:  MOVWF  FEA
06910:  MOVFF  FEF,70F
06914:  MOVFF  FEC,710
06918:  MOVFF  FEC,711
0691C:  MOVFF  FEC,712
06920:  MOVFF  70E,565
06924:  MOVFF  70D,564
06928:  MOVFF  70B,734
0692C:  MOVLW  18
0692E:  MOVWF  x35
06930:  MOVLB  0
06932:  CALL   5C1C
06936:  MOVLW  2C
06938:  MOVLB  7
0693A:  MOVWF  x50
0693C:  MOVLB  0
0693E:  CALL   563A
06942:  MOVLW  89
06944:  MOVWF  FE9
06946:  MOVFF  712,746
0694A:  MOVFF  711,745
0694E:  MOVFF  710,744
06952:  MOVFF  70F,743
06956:  MOVLW  02
06958:  MOVLB  7
0695A:  MOVWF  x47
0695C:  MOVLB  0
0695E:  RCALL  6516
06960:  MOVLW  2C
06962:  MOVLB  7
06964:  MOVWF  x50
06966:  MOVLB  0
06968:  CALL   563A
0696C:  BRA    6B76
0696E:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
06970:  MOVF   x0C,W
06972:  SUBLW  44
06974:  BNZ   6A16
06976:  MOVLW  04
06978:  MOVWF  x42
0697A:  MOVLW  C1
0697C:  MOVWF  x41
0697E:  MOVLB  0
06980:  CALL   5602
06984:  MOVF   01,W
06986:  ADDLW  C1
06988:  MOVLB  7
0698A:  MOVWF  x0D
0698C:  MOVLW  04
0698E:  ADDWFC 02,W
06990:  MOVWF  x0E
06992:  MOVLW  01
06994:  SUBWF  x0B,W
06996:  MULLW  28
06998:  MOVF   FF3,W
0699A:  CLRF   x10
0699C:  MOVWF  x0F
0699E:  MOVLW  08
069A0:  ADDWF  x0F,W
069A2:  MOVWF  01
069A4:  MOVLW  00
069A6:  ADDWFC x10,W
069A8:  MOVWF  03
069AA:  MOVF   01,W
069AC:  ADDLW  20
069AE:  MOVWF  FE9
069B0:  MOVLW  00
069B2:  ADDWFC 03,W
069B4:  MOVWF  FEA
069B6:  MOVFF  FEF,70F
069BA:  MOVFF  FEC,710
069BE:  MOVFF  FEC,711
069C2:  MOVFF  FEC,712
069C6:  MOVFF  70E,565
069CA:  MOVFF  70D,564
069CE:  MOVFF  70B,734
069D2:  MOVLW  18
069D4:  MOVWF  x35
069D6:  MOVLB  0
069D8:  CALL   5C1C
069DC:  MOVLW  2C
069DE:  MOVLB  7
069E0:  MOVWF  x50
069E2:  MOVLB  0
069E4:  CALL   563A
069E8:  MOVLW  89
069EA:  MOVWF  FE9
069EC:  MOVFF  712,746
069F0:  MOVFF  711,745
069F4:  MOVFF  710,744
069F8:  MOVFF  70F,743
069FC:  MOVLW  02
069FE:  MOVLB  7
06A00:  MOVWF  x47
06A02:  MOVLB  0
06A04:  RCALL  6516
06A06:  MOVLW  2C
06A08:  MOVLB  7
06A0A:  MOVWF  x50
06A0C:  MOVLB  0
06A0E:  CALL   563A
06A12:  BRA    6B76
06A14:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06A16:  MOVF   x0C,W
06A18:  SUBLW  41
06A1A:  BTFSS  FD8.2
06A1C:  BRA    6B6E
06A1E:  MOVLW  04
06A20:  MOVWF  x42
06A22:  MOVLW  C1
06A24:  MOVWF  x41
06A26:  MOVLB  0
06A28:  CALL   5602
06A2C:  MOVF   01,W
06A2E:  ADDLW  C1
06A30:  MOVLB  7
06A32:  MOVWF  x0D
06A34:  MOVLW  04
06A36:  ADDWFC 02,W
06A38:  MOVWF  x0E
06A3A:  MOVLW  01
06A3C:  SUBWF  x0B,W
06A3E:  MULLW  28
06A40:  MOVF   FF3,W
06A42:  CLRF   x10
06A44:  MOVWF  x0F
06A46:  MOVLW  20
06A48:  ADDWF  x0F,W
06A4A:  MOVWF  FE9
06A4C:  MOVLW  00
06A4E:  ADDWFC x10,W
06A50:  MOVWF  FEA
06A52:  MOVFF  FEF,711
06A56:  MOVFF  FEC,712
06A5A:  MOVFF  FEC,713
06A5E:  MOVFF  FEC,714
06A62:  MOVLW  01
06A64:  SUBWF  x0B,W
06A66:  MULLW  28
06A68:  MOVF   FF3,W
06A6A:  CLRF   x16
06A6C:  MOVWF  x15
06A6E:  MOVLW  04
06A70:  ADDWF  x15,W
06A72:  MOVWF  01
06A74:  MOVLW  00
06A76:  ADDWFC x16,W
06A78:  MOVWF  03
06A7A:  MOVF   01,W
06A7C:  ADDLW  20
06A7E:  MOVWF  FE9
06A80:  MOVLW  00
06A82:  ADDWFC 03,W
06A84:  MOVWF  FEA
06A86:  MOVFF  FEF,715
06A8A:  MOVFF  FEC,716
06A8E:  MOVFF  FEC,717
06A92:  MOVFF  FEC,718
06A96:  MOVLW  01
06A98:  SUBWF  x0B,W
06A9A:  MULLW  28
06A9C:  MOVF   FF3,W
06A9E:  CLRF   x1A
06AA0:  MOVWF  x19
06AA2:  MOVLW  08
06AA4:  ADDWF  x19,W
06AA6:  MOVWF  01
06AA8:  MOVLW  00
06AAA:  ADDWFC x1A,W
06AAC:  MOVWF  03
06AAE:  MOVF   01,W
06AB0:  ADDLW  20
06AB2:  MOVWF  FE9
06AB4:  MOVLW  00
06AB6:  ADDWFC 03,W
06AB8:  MOVWF  FEA
06ABA:  MOVFF  FEF,719
06ABE:  MOVFF  FEC,71A
06AC2:  MOVFF  FEC,71B
06AC6:  MOVFF  FEC,71C
06ACA:  MOVFF  70E,565
06ACE:  MOVFF  70D,564
06AD2:  MOVFF  70B,734
06AD6:  MOVLW  18
06AD8:  MOVWF  x35
06ADA:  MOVLB  0
06ADC:  CALL   5C1C
06AE0:  MOVLW  2C
06AE2:  MOVLB  7
06AE4:  MOVWF  x50
06AE6:  MOVLB  0
06AE8:  CALL   563A
06AEC:  MOVLW  89
06AEE:  MOVWF  FE9
06AF0:  MOVFF  714,746
06AF4:  MOVFF  713,745
06AF8:  MOVFF  712,744
06AFC:  MOVFF  711,743
06B00:  MOVLW  02
06B02:  MOVLB  7
06B04:  MOVWF  x47
06B06:  MOVLB  0
06B08:  RCALL  6516
06B0A:  MOVLW  2C
06B0C:  MOVLB  7
06B0E:  MOVWF  x50
06B10:  MOVLB  0
06B12:  CALL   563A
06B16:  MOVLW  89
06B18:  MOVWF  FE9
06B1A:  MOVFF  718,746
06B1E:  MOVFF  717,745
06B22:  MOVFF  716,744
06B26:  MOVFF  715,743
06B2A:  MOVLW  02
06B2C:  MOVLB  7
06B2E:  MOVWF  x47
06B30:  MOVLB  0
06B32:  RCALL  6516
06B34:  MOVLW  2C
06B36:  MOVLB  7
06B38:  MOVWF  x50
06B3A:  MOVLB  0
06B3C:  CALL   563A
06B40:  MOVLW  89
06B42:  MOVWF  FE9
06B44:  MOVFF  71C,746
06B48:  MOVFF  71B,745
06B4C:  MOVFF  71A,744
06B50:  MOVFF  719,743
06B54:  MOVLW  02
06B56:  MOVLB  7
06B58:  MOVWF  x47
06B5A:  MOVLB  0
06B5C:  RCALL  6516
06B5E:  MOVLW  2C
06B60:  MOVLB  7
06B62:  MOVWF  x50
06B64:  MOVLB  0
06B66:  CALL   563A
06B6A:  BRA    6B76
06B6C:  MOVLB  7
....................    else return INV_PARAM;
06B6E:  MOVLW  02
06B70:  MOVWF  01
06B72:  MOVLB  0
06B74:  BRA    6B7A
....................    
....................    return SUCCESS;
06B76:  MOVLW  00
06B78:  MOVWF  01
06B7A:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06E98:  MOVLB  7
06E9A:  CLRF   x42
06E9C:  MOVFF  690,741
06EA0:  CLRF   x44
06EA2:  MOVLW  B5
06EA4:  MOVWF  x43
06EA6:  MOVLB  0
06EA8:  CALL   0880
06EAC:  MOVFF  02,712
06EB0:  MOVFF  01,711
06EB4:  MOVLW  06
06EB6:  MOVLB  7
06EB8:  ADDWF  x11,F
06EBA:  MOVLW  00
06EBC:  ADDWFC x12,F
06EBE:  MOVLW  32
06EC0:  ADDWF  x11,W
06EC2:  MOVWF  01
06EC4:  MOVLW  00
06EC6:  ADDWFC x12,W
06EC8:  MOVWF  03
06ECA:  MOVF   01,W
06ECC:  ADDLW  EB
06ECE:  MOVWF  01
06ED0:  MOVLW  01
06ED2:  ADDWFC 03,F
06ED4:  MOVFF  01,711
06ED8:  MOVFF  03,712
06EDC:  MOVFF  03,734
06EE0:  MOVFF  01,733
06EE4:  MOVLB  0
06EE6:  CALL   57D8
06EEA:  MOVF   01,F
06EEC:  BNZ   6EF6
06EEE:  MOVLW  02
06EF0:  MOVWF  01
06EF2:  BRA    7176
06EF4:  BRA    6F54
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06EF6:  MOVLB  7
06EF8:  CLRF   x42
06EFA:  MOVFF  690,741
06EFE:  CLRF   x44
06F00:  MOVLW  B5
06F02:  MOVWF  x43
06F04:  MOVLB  0
06F06:  CALL   0880
06F0A:  MOVFF  02,712
06F0E:  MOVFF  01,711
06F12:  MOVLW  06
06F14:  MOVLB  7
06F16:  ADDWF  x11,F
06F18:  MOVLW  00
06F1A:  ADDWFC x12,F
06F1C:  MOVLW  32
06F1E:  ADDWF  x11,W
06F20:  MOVWF  01
06F22:  MOVLW  00
06F24:  ADDWFC x12,W
06F26:  MOVWF  03
06F28:  MOVF   01,W
06F2A:  ADDLW  EB
06F2C:  MOVWF  01
06F2E:  MOVLW  01
06F30:  ADDWFC 03,F
06F32:  MOVFF  01,711
06F36:  MOVFF  03,712
06F3A:  MOVFF  03,734
06F3E:  MOVFF  01,733
06F42:  CLRF   x36
06F44:  CLRF   x35
06F46:  MOVLW  0A
06F48:  MOVWF  x37
06F4A:  MOVLB  0
06F4C:  CALL   58C8
06F50:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06F54:  MOVLB  7
06F56:  CLRF   x42
06F58:  MOVFF  690,741
06F5C:  CLRF   x44
06F5E:  MOVLW  B5
06F60:  MOVWF  x43
06F62:  MOVLB  0
06F64:  CALL   0880
06F68:  MOVFF  02,712
06F6C:  MOVFF  01,711
06F70:  MOVLW  06
06F72:  MOVLB  7
06F74:  ADDWF  x11,F
06F76:  MOVLW  00
06F78:  ADDWFC x12,F
06F7A:  MOVLW  4B
06F7C:  ADDWF  x11,W
06F7E:  MOVWF  01
06F80:  MOVLW  00
06F82:  ADDWFC x12,W
06F84:  MOVWF  03
06F86:  MOVF   01,W
06F88:  ADDLW  EB
06F8A:  MOVWF  01
06F8C:  MOVLW  01
06F8E:  ADDWFC 03,F
06F90:  MOVFF  01,711
06F94:  MOVFF  03,712
06F98:  MOVFF  03,742
06F9C:  MOVFF  01,741
06FA0:  MOVLB  0
06FA2:  CALL   5602
06FA6:  MOVFF  02,03
06FAA:  MOVF   01,W
06FAC:  SUBLW  01
06FAE:  BNZ   6FB4
06FB0:  MOVF   03,F
06FB2:  BZ    6FBC
06FB4:  MOVLW  02
06FB6:  MOVWF  01
06FB8:  BRA    7176
06FBA:  BRA    6FFC
....................    else arg2 = SERcmd[rec].p[3][0];
06FBC:  MOVLB  7
06FBE:  CLRF   x42
06FC0:  MOVFF  690,741
06FC4:  CLRF   x44
06FC6:  MOVLW  B5
06FC8:  MOVWF  x43
06FCA:  MOVLB  0
06FCC:  CALL   0880
06FD0:  MOVFF  02,712
06FD4:  MOVFF  01,711
06FD8:  MOVLW  06
06FDA:  MOVLB  7
06FDC:  ADDWF  x11,F
06FDE:  MOVLW  00
06FE0:  ADDWFC x12,F
06FE2:  MOVLW  4B
06FE4:  ADDWF  x11,F
06FE6:  MOVLW  00
06FE8:  ADDWFC x12,F
06FEA:  MOVLW  EB
06FEC:  ADDWF  x11,W
06FEE:  MOVWF  FE9
06FF0:  MOVLW  01
06FF2:  ADDWFC x12,W
06FF4:  MOVWF  FEA
06FF6:  MOVFF  FEF,70C
06FFA:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06FFC:  MOVLB  7
06FFE:  CLRF   x42
07000:  MOVFF  690,741
07004:  CLRF   x44
07006:  MOVLW  B5
07008:  MOVWF  x43
0700A:  MOVLB  0
0700C:  CALL   0880
07010:  MOVFF  02,712
07014:  MOVFF  01,711
07018:  MOVLW  06
0701A:  MOVLB  7
0701C:  ADDWF  x11,F
0701E:  MOVLW  00
07020:  ADDWFC x12,F
07022:  MOVLW  64
07024:  ADDWF  x11,W
07026:  MOVWF  01
07028:  MOVLW  00
0702A:  ADDWFC x12,W
0702C:  MOVWF  03
0702E:  MOVF   01,W
07030:  ADDLW  EB
07032:  MOVWF  01
07034:  MOVLW  01
07036:  ADDWFC 03,F
07038:  MOVFF  01,711
0703C:  MOVFF  03,712
07040:  MOVFF  03,715
07044:  MOVFF  01,714
07048:  MOVLB  0
0704A:  RCALL  6B7C
0704C:  MOVF   01,F
0704E:  BNZ   7058
07050:  MOVLW  02
07052:  MOVWF  01
07054:  BRA    7176
07056:  BRA    70BC
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07058:  MOVLB  7
0705A:  CLRF   x42
0705C:  MOVFF  690,741
07060:  CLRF   x44
07062:  MOVLW  B5
07064:  MOVWF  x43
07066:  MOVLB  0
07068:  CALL   0880
0706C:  MOVFF  02,712
07070:  MOVFF  01,711
07074:  MOVLW  06
07076:  MOVLB  7
07078:  ADDWF  x11,F
0707A:  MOVLW  00
0707C:  ADDWFC x12,F
0707E:  MOVLW  64
07080:  ADDWF  x11,W
07082:  MOVWF  01
07084:  MOVLW  00
07086:  ADDWFC x12,W
07088:  MOVWF  03
0708A:  MOVF   01,W
0708C:  ADDLW  EB
0708E:  MOVWF  01
07090:  MOVLW  01
07092:  ADDWFC 03,F
07094:  MOVFF  01,711
07098:  MOVFF  03,712
0709C:  MOVFF  03,715
070A0:  MOVFF  01,714
070A4:  CLRF   x17
070A6:  CLRF   x16
070A8:  MOVLB  0
070AA:  RCALL  6C3E
070AC:  MOVFF  03,710
070B0:  MOVFF  02,70F
070B4:  MOVFF  01,70E
070B8:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
070BC:  MOVLB  7
070BE:  MOVF   x0C,W
070C0:  SUBLW  50
070C2:  BNZ   70EE
070C4:  MOVLW  01
070C6:  SUBWF  x0B,W
070C8:  MULLW  28
070CA:  MOVF   FF3,W
070CC:  CLRF   x12
070CE:  MOVWF  x11
070D0:  MOVLW  20
070D2:  ADDWF  x11,W
070D4:  MOVWF  FE9
070D6:  MOVLW  00
070D8:  ADDWFC x12,W
070DA:  MOVWF  FEA
070DC:  MOVFF  70D,FEF
070E0:  MOVFF  70E,FEC
070E4:  MOVFF  70F,FEC
070E8:  MOVFF  710,FEC
070EC:  BRA    7170
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
070EE:  MOVF   x0C,W
070F0:  SUBLW  49
070F2:  BNZ   712A
070F4:  MOVLW  01
070F6:  SUBWF  x0B,W
070F8:  MULLW  28
070FA:  MOVF   FF3,W
070FC:  CLRF   x12
070FE:  MOVWF  x11
07100:  MOVLW  04
07102:  ADDWF  x11,W
07104:  MOVWF  01
07106:  MOVLW  00
07108:  ADDWFC x12,W
0710A:  MOVWF  03
0710C:  MOVF   01,W
0710E:  ADDLW  20
07110:  MOVWF  FE9
07112:  MOVLW  00
07114:  ADDWFC 03,W
07116:  MOVWF  FEA
07118:  MOVFF  70D,FEF
0711C:  MOVFF  70E,FEC
07120:  MOVFF  70F,FEC
07124:  MOVFF  710,FEC
07128:  BRA    7170
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
0712A:  MOVF   x0C,W
0712C:  SUBLW  44
0712E:  BNZ   7166
07130:  MOVLW  01
07132:  SUBWF  x0B,W
07134:  MULLW  28
07136:  MOVF   FF3,W
07138:  CLRF   x12
0713A:  MOVWF  x11
0713C:  MOVLW  08
0713E:  ADDWF  x11,W
07140:  MOVWF  01
07142:  MOVLW  00
07144:  ADDWFC x12,W
07146:  MOVWF  03
07148:  MOVF   01,W
0714A:  ADDLW  20
0714C:  MOVWF  FE9
0714E:  MOVLW  00
07150:  ADDWFC 03,W
07152:  MOVWF  FEA
07154:  MOVFF  70D,FEF
07158:  MOVFF  70E,FEC
0715C:  MOVFF  70F,FEC
07160:  MOVFF  710,FEC
07164:  BRA    7170
....................    else return INV_PARAM;
07166:  MOVLW  02
07168:  MOVWF  01
0716A:  MOVLB  0
0716C:  BRA    7176
0716E:  MOVLB  7
....................    
....................    return SUCCESS;
07170:  MOVLW  00
07172:  MOVWF  01
07174:  MOVLB  0
07176:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07178:  MOVLB  7
0717A:  CLRF   x42
0717C:  MOVFF  690,741
07180:  CLRF   x44
07182:  MOVLW  B5
07184:  MOVWF  x43
07186:  MOVLB  0
07188:  CALL   0880
0718C:  MOVFF  02,70D
07190:  MOVFF  01,70C
07194:  MOVLW  06
07196:  MOVLB  7
07198:  ADDWF  x0C,F
0719A:  MOVLW  00
0719C:  ADDWFC x0D,F
0719E:  MOVLW  32
071A0:  ADDWF  x0C,W
071A2:  MOVWF  01
071A4:  MOVLW  00
071A6:  ADDWFC x0D,W
071A8:  MOVWF  03
071AA:  MOVF   01,W
071AC:  ADDLW  EB
071AE:  MOVWF  01
071B0:  MOVLW  01
071B2:  ADDWFC 03,F
071B4:  MOVFF  01,70C
071B8:  MOVFF  03,70D
071BC:  MOVFF  03,734
071C0:  MOVFF  01,733
071C4:  MOVLB  0
071C6:  CALL   57D8
071CA:  MOVF   01,F
071CC:  BNZ   71D6
071CE:  MOVLW  02
071D0:  MOVWF  01
071D2:  BRA    72D8
071D4:  BRA    7234
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
071D6:  MOVLB  7
071D8:  CLRF   x42
071DA:  MOVFF  690,741
071DE:  CLRF   x44
071E0:  MOVLW  B5
071E2:  MOVWF  x43
071E4:  MOVLB  0
071E6:  CALL   0880
071EA:  MOVFF  02,70D
071EE:  MOVFF  01,70C
071F2:  MOVLW  06
071F4:  MOVLB  7
071F6:  ADDWF  x0C,F
071F8:  MOVLW  00
071FA:  ADDWFC x0D,F
071FC:  MOVLW  32
071FE:  ADDWF  x0C,W
07200:  MOVWF  01
07202:  MOVLW  00
07204:  ADDWFC x0D,W
07206:  MOVWF  03
07208:  MOVF   01,W
0720A:  ADDLW  EB
0720C:  MOVWF  01
0720E:  MOVLW  01
07210:  ADDWFC 03,F
07212:  MOVFF  01,70C
07216:  MOVFF  03,70D
0721A:  MOVFF  03,734
0721E:  MOVFF  01,733
07222:  CLRF   x36
07224:  CLRF   x35
07226:  MOVLW  0A
07228:  MOVWF  x37
0722A:  MOVLB  0
0722C:  CALL   58C8
07230:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
07234:  MOVLW  04
07236:  MOVLB  7
07238:  MOVWF  x42
0723A:  MOVLW  C1
0723C:  MOVWF  x41
0723E:  MOVLB  0
07240:  CALL   5602
07244:  MOVF   01,W
07246:  ADDLW  C1
07248:  MOVLB  7
0724A:  MOVWF  x0C
0724C:  MOVLW  04
0724E:  ADDWFC 02,W
07250:  MOVWF  x0D
07252:  MOVLW  01
07254:  SUBWF  x0B,W
07256:  MULLW  28
07258:  MOVF   FF3,W
0725A:  CLRF   x0F
0725C:  MOVWF  x0E
0725E:  MOVLW  0C
07260:  ADDWF  x0E,W
07262:  MOVWF  01
07264:  MOVLW  00
07266:  ADDWFC x0F,W
07268:  MOVWF  03
0726A:  MOVF   01,W
0726C:  ADDLW  20
0726E:  MOVWF  FE9
07270:  MOVLW  00
07272:  ADDWFC 03,W
07274:  MOVWF  FEA
07276:  MOVFF  FEF,70E
0727A:  MOVFF  FEC,70F
0727E:  MOVFF  FEC,710
07282:  MOVFF  FEC,711
07286:  MOVFF  70D,565
0728A:  MOVFF  70C,564
0728E:  MOVFF  70B,734
07292:  MOVLW  18
07294:  MOVWF  x35
07296:  MOVLB  0
07298:  CALL   5C1C
0729C:  MOVLW  2C
0729E:  MOVLB  7
072A0:  MOVWF  x50
072A2:  MOVLB  0
072A4:  CALL   563A
072A8:  MOVLW  89
072AA:  MOVWF  FE9
072AC:  MOVFF  711,746
072B0:  MOVFF  710,745
072B4:  MOVFF  70F,744
072B8:  MOVFF  70E,743
072BC:  MOVLW  02
072BE:  MOVLB  7
072C0:  MOVWF  x47
072C2:  MOVLB  0
072C4:  CALL   6516
072C8:  MOVLW  2C
072CA:  MOVLB  7
072CC:  MOVWF  x50
072CE:  MOVLB  0
072D0:  CALL   563A
....................    return SUCCESS;
072D4:  MOVLW  00
072D6:  MOVWF  01
072D8:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
072DA:  MOVLB  7
072DC:  CLRF   x42
072DE:  MOVFF  690,741
072E2:  CLRF   x44
072E4:  MOVLW  B5
072E6:  MOVWF  x43
072E8:  MOVLB  0
072EA:  CALL   0880
072EE:  MOVFF  02,711
072F2:  MOVFF  01,710
072F6:  MOVLW  06
072F8:  MOVLB  7
072FA:  ADDWF  x10,F
072FC:  MOVLW  00
072FE:  ADDWFC x11,F
07300:  MOVLW  32
07302:  ADDWF  x10,W
07304:  MOVWF  01
07306:  MOVLW  00
07308:  ADDWFC x11,W
0730A:  MOVWF  03
0730C:  MOVF   01,W
0730E:  ADDLW  EB
07310:  MOVWF  01
07312:  MOVLW  01
07314:  ADDWFC 03,F
07316:  MOVFF  01,710
0731A:  MOVFF  03,711
0731E:  MOVFF  03,734
07322:  MOVFF  01,733
07326:  MOVLB  0
07328:  CALL   57D8
0732C:  MOVF   01,F
0732E:  BNZ   7338
07330:  MOVLW  02
07332:  MOVWF  01
07334:  BRA    7496
07336:  BRA    7396
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07338:  MOVLB  7
0733A:  CLRF   x42
0733C:  MOVFF  690,741
07340:  CLRF   x44
07342:  MOVLW  B5
07344:  MOVWF  x43
07346:  MOVLB  0
07348:  CALL   0880
0734C:  MOVFF  02,711
07350:  MOVFF  01,710
07354:  MOVLW  06
07356:  MOVLB  7
07358:  ADDWF  x10,F
0735A:  MOVLW  00
0735C:  ADDWFC x11,F
0735E:  MOVLW  32
07360:  ADDWF  x10,W
07362:  MOVWF  01
07364:  MOVLW  00
07366:  ADDWFC x11,W
07368:  MOVWF  03
0736A:  MOVF   01,W
0736C:  ADDLW  EB
0736E:  MOVWF  01
07370:  MOVLW  01
07372:  ADDWFC 03,F
07374:  MOVFF  01,710
07378:  MOVFF  03,711
0737C:  MOVFF  03,734
07380:  MOVFF  01,733
07384:  CLRF   x36
07386:  CLRF   x35
07388:  MOVLW  0A
0738A:  MOVWF  x37
0738C:  MOVLB  0
0738E:  CALL   58C8
07392:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07396:  MOVLB  7
07398:  CLRF   x42
0739A:  MOVFF  690,741
0739E:  CLRF   x44
073A0:  MOVLW  B5
073A2:  MOVWF  x43
073A4:  MOVLB  0
073A6:  CALL   0880
073AA:  MOVFF  02,711
073AE:  MOVFF  01,710
073B2:  MOVLW  06
073B4:  MOVLB  7
073B6:  ADDWF  x10,F
073B8:  MOVLW  00
073BA:  ADDWFC x11,F
073BC:  MOVLW  4B
073BE:  ADDWF  x10,W
073C0:  MOVWF  01
073C2:  MOVLW  00
073C4:  ADDWFC x11,W
073C6:  MOVWF  03
073C8:  MOVF   01,W
073CA:  ADDLW  EB
073CC:  MOVWF  01
073CE:  MOVLW  01
073D0:  ADDWFC 03,F
073D2:  MOVFF  01,710
073D6:  MOVFF  03,711
073DA:  MOVFF  03,715
073DE:  MOVFF  01,714
073E2:  MOVLB  0
073E4:  CALL   6B7C
073E8:  MOVF   01,F
073EA:  BNZ   73F4
073EC:  MOVLW  02
073EE:  MOVWF  01
073F0:  BRA    7496
073F2:  BRA    745A
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
073F4:  MOVLB  7
073F6:  CLRF   x42
073F8:  MOVFF  690,741
073FC:  CLRF   x44
073FE:  MOVLW  B5
07400:  MOVWF  x43
07402:  MOVLB  0
07404:  CALL   0880
07408:  MOVFF  02,711
0740C:  MOVFF  01,710
07410:  MOVLW  06
07412:  MOVLB  7
07414:  ADDWF  x10,F
07416:  MOVLW  00
07418:  ADDWFC x11,F
0741A:  MOVLW  4B
0741C:  ADDWF  x10,W
0741E:  MOVWF  01
07420:  MOVLW  00
07422:  ADDWFC x11,W
07424:  MOVWF  03
07426:  MOVF   01,W
07428:  ADDLW  EB
0742A:  MOVWF  01
0742C:  MOVLW  01
0742E:  ADDWFC 03,F
07430:  MOVFF  01,710
07434:  MOVFF  03,711
07438:  MOVFF  03,715
0743C:  MOVFF  01,714
07440:  CLRF   x17
07442:  CLRF   x16
07444:  MOVLB  0
07446:  CALL   6C3E
0744A:  MOVFF  03,70F
0744E:  MOVFF  02,70E
07452:  MOVFF  01,70D
07456:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
0745A:  MOVLW  01
0745C:  MOVLB  7
0745E:  SUBWF  x0B,W
07460:  MULLW  28
07462:  MOVF   FF3,W
07464:  CLRF   x11
07466:  MOVWF  x10
07468:  MOVLW  0C
0746A:  ADDWF  x10,W
0746C:  MOVWF  01
0746E:  MOVLW  00
07470:  ADDWFC x11,W
07472:  MOVWF  03
07474:  MOVF   01,W
07476:  ADDLW  20
07478:  MOVWF  FE9
0747A:  MOVLW  00
0747C:  ADDWFC 03,W
0747E:  MOVWF  FEA
07480:  MOVFF  70C,FEF
07484:  MOVFF  70D,FEC
07488:  MOVFF  70E,FEC
0748C:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
07490:  MOVLW  00
07492:  MOVWF  01
07494:  MOVLB  0
07496:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07498:  MOVLB  7
0749A:  CLRF   x42
0749C:  MOVFF  690,741
074A0:  CLRF   x44
074A2:  MOVLW  B5
074A4:  MOVWF  x43
074A6:  MOVLB  0
074A8:  CALL   0880
074AC:  MOVFF  02,70D
074B0:  MOVFF  01,70C
074B4:  MOVLW  06
074B6:  MOVLB  7
074B8:  ADDWF  x0C,F
074BA:  MOVLW  00
074BC:  ADDWFC x0D,F
074BE:  MOVLW  32
074C0:  ADDWF  x0C,W
074C2:  MOVWF  01
074C4:  MOVLW  00
074C6:  ADDWFC x0D,W
074C8:  MOVWF  03
074CA:  MOVF   01,W
074CC:  ADDLW  EB
074CE:  MOVWF  01
074D0:  MOVLW  01
074D2:  ADDWFC 03,F
074D4:  MOVFF  01,70C
074D8:  MOVFF  03,70D
074DC:  MOVFF  03,734
074E0:  MOVFF  01,733
074E4:  MOVLB  0
074E6:  CALL   57D8
074EA:  MOVF   01,F
074EC:  BNZ   74F6
074EE:  MOVLW  02
074F0:  MOVWF  01
074F2:  BRA    784C
074F4:  BRA    7554
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
074F6:  MOVLB  7
074F8:  CLRF   x42
074FA:  MOVFF  690,741
074FE:  CLRF   x44
07500:  MOVLW  B5
07502:  MOVWF  x43
07504:  MOVLB  0
07506:  CALL   0880
0750A:  MOVFF  02,70D
0750E:  MOVFF  01,70C
07512:  MOVLW  06
07514:  MOVLB  7
07516:  ADDWF  x0C,F
07518:  MOVLW  00
0751A:  ADDWFC x0D,F
0751C:  MOVLW  32
0751E:  ADDWF  x0C,W
07520:  MOVWF  01
07522:  MOVLW  00
07524:  ADDWFC x0D,W
07526:  MOVWF  03
07528:  MOVF   01,W
0752A:  ADDLW  EB
0752C:  MOVWF  01
0752E:  MOVLW  01
07530:  ADDWFC 03,F
07532:  MOVFF  01,70C
07536:  MOVFF  03,70D
0753A:  MOVFF  03,734
0753E:  MOVFF  01,733
07542:  CLRF   x36
07544:  CLRF   x35
07546:  MOVLW  0A
07548:  MOVWF  x37
0754A:  MOVLB  0
0754C:  CALL   58C8
07550:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
07554:  MOVLW  04
07556:  MOVLB  7
07558:  MOVWF  x42
0755A:  MOVLW  C1
0755C:  MOVWF  x41
0755E:  MOVLB  0
07560:  CALL   5602
07564:  MOVFF  02,03
07568:  MOVF   01,W
0756A:  ADDLW  C1
0756C:  MOVLB  7
0756E:  MOVWF  x0C
07570:  MOVLW  04
07572:  ADDWFC 02,W
07574:  MOVWF  x0D
07576:  MOVFF  FE8,565
0757A:  MOVFF  70C,564
0757E:  MOVFF  70B,734
07582:  MOVLW  18
07584:  MOVWF  x35
07586:  MOVLB  0
07588:  CALL   5C1C
0758C:  MOVLW  2C
0758E:  MOVLB  7
07590:  MOVWF  x50
07592:  MOVLB  0
07594:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07598:  MOVLW  04
0759A:  MOVLB  7
0759C:  MOVWF  x42
0759E:  MOVLW  C1
075A0:  MOVWF  x41
075A2:  MOVLB  0
075A4:  CALL   5602
075A8:  MOVFF  02,03
075AC:  MOVF   01,W
075AE:  ADDLW  C1
075B0:  MOVLB  7
075B2:  MOVWF  x0C
075B4:  MOVLW  04
075B6:  ADDWFC 02,W
075B8:  MOVWF  x0D
075BA:  MOVLW  01
075BC:  SUBWF  x0B,W
075BE:  MULLW  18
075C0:  MOVF   FF3,W
075C2:  CLRF   x0F
075C4:  MOVWF  x0E
075C6:  MOVLW  92
075C8:  ADDWF  x0E,W
075CA:  MOVWF  FE9
075CC:  MOVLW  00
075CE:  ADDWFC x0F,W
075D0:  MOVWF  FEA
075D2:  MOVFF  FEF,743
075D6:  MOVFF  FEC,744
075DA:  MOVFF  FEC,745
075DE:  MOVFF  FEC,746
075E2:  MOVFF  70D,565
075E6:  MOVFF  70C,564
075EA:  MOVLW  89
075EC:  MOVWF  FE9
075EE:  MOVLW  02
075F0:  MOVWF  x47
075F2:  MOVLB  0
075F4:  CALL   6516
075F8:  MOVLW  2C
075FA:  MOVLB  7
075FC:  MOVWF  x50
075FE:  MOVLB  0
07600:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07604:  MOVLW  04
07606:  MOVLB  7
07608:  MOVWF  x42
0760A:  MOVLW  C1
0760C:  MOVWF  x41
0760E:  MOVLB  0
07610:  CALL   5602
07614:  MOVF   01,W
07616:  ADDLW  C1
07618:  MOVLB  7
0761A:  MOVWF  x0C
0761C:  MOVLW  04
0761E:  ADDWFC 02,W
07620:  MOVWF  x0D
07622:  MOVLW  01
07624:  SUBWF  x0B,W
07626:  MULLW  18
07628:  MOVF   FF3,W
0762A:  CLRF   x0F
0762C:  MOVWF  x0E
0762E:  MOVLW  04
07630:  ADDWF  x0E,W
07632:  MOVWF  01
07634:  MOVLW  00
07636:  ADDWFC x0F,W
07638:  MOVWF  03
0763A:  MOVF   01,W
0763C:  ADDLW  92
0763E:  MOVWF  FE9
07640:  MOVLW  00
07642:  ADDWFC 03,W
07644:  MOVWF  FEA
07646:  MOVFF  FEF,743
0764A:  MOVFF  FEC,744
0764E:  MOVFF  FEC,745
07652:  MOVFF  FEC,746
07656:  MOVFF  70D,565
0765A:  MOVFF  70C,564
0765E:  MOVLW  89
07660:  MOVWF  FE9
07662:  MOVLW  02
07664:  MOVWF  x47
07666:  MOVLB  0
07668:  CALL   6516
0766C:  MOVLW  2C
0766E:  MOVLB  7
07670:  MOVWF  x50
07672:  MOVLB  0
07674:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
07678:  MOVLW  04
0767A:  MOVLB  7
0767C:  MOVWF  x42
0767E:  MOVLW  C1
07680:  MOVWF  x41
07682:  MOVLB  0
07684:  CALL   5602
07688:  MOVF   01,W
0768A:  ADDLW  C1
0768C:  MOVLB  7
0768E:  MOVWF  x0C
07690:  MOVLW  04
07692:  ADDWFC 02,W
07694:  MOVWF  x0D
07696:  MOVLW  01
07698:  SUBWF  x0B,W
0769A:  MULLW  18
0769C:  MOVF   FF3,W
0769E:  CLRF   x0F
076A0:  MOVWF  x0E
076A2:  MOVLW  08
076A4:  ADDWF  x0E,W
076A6:  MOVWF  01
076A8:  MOVLW  00
076AA:  ADDWFC x0F,W
076AC:  MOVWF  03
076AE:  MOVF   01,W
076B0:  ADDLW  92
076B2:  MOVWF  FE9
076B4:  MOVLW  00
076B6:  ADDWFC 03,W
076B8:  MOVWF  FEA
076BA:  MOVFF  FEF,743
076BE:  MOVFF  FEC,744
076C2:  MOVFF  FEC,745
076C6:  MOVFF  FEC,746
076CA:  MOVFF  70D,565
076CE:  MOVFF  70C,564
076D2:  MOVLW  89
076D4:  MOVWF  FE9
076D6:  MOVLW  02
076D8:  MOVWF  x47
076DA:  MOVLB  0
076DC:  CALL   6516
076E0:  MOVLW  2C
076E2:  MOVLB  7
076E4:  MOVWF  x50
076E6:  MOVLB  0
076E8:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
076EC:  MOVLW  04
076EE:  MOVLB  7
076F0:  MOVWF  x42
076F2:  MOVLW  C1
076F4:  MOVWF  x41
076F6:  MOVLB  0
076F8:  CALL   5602
076FC:  MOVF   01,W
076FE:  ADDLW  C1
07700:  MOVLB  7
07702:  MOVWF  x0C
07704:  MOVLW  04
07706:  ADDWFC 02,W
07708:  MOVWF  x0D
0770A:  MOVLW  01
0770C:  SUBWF  x0B,W
0770E:  MULLW  18
07710:  MOVF   FF3,W
07712:  CLRF   x0F
07714:  MOVWF  x0E
07716:  MOVLW  0C
07718:  ADDWF  x0E,W
0771A:  MOVWF  01
0771C:  MOVLW  00
0771E:  ADDWFC x0F,W
07720:  MOVWF  03
07722:  MOVF   01,W
07724:  ADDLW  92
07726:  MOVWF  FE9
07728:  MOVLW  00
0772A:  ADDWFC 03,W
0772C:  MOVWF  FEA
0772E:  MOVFF  FEF,743
07732:  MOVFF  FEC,744
07736:  MOVFF  FEC,745
0773A:  MOVFF  FEC,746
0773E:  MOVFF  70D,565
07742:  MOVFF  70C,564
07746:  MOVLW  89
07748:  MOVWF  FE9
0774A:  MOVLW  02
0774C:  MOVWF  x47
0774E:  MOVLB  0
07750:  CALL   6516
07754:  MOVLW  2C
07756:  MOVLB  7
07758:  MOVWF  x50
0775A:  MOVLB  0
0775C:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
07760:  MOVLW  04
07762:  MOVLB  7
07764:  MOVWF  x42
07766:  MOVLW  C1
07768:  MOVWF  x41
0776A:  MOVLB  0
0776C:  CALL   5602
07770:  MOVF   01,W
07772:  ADDLW  C1
07774:  MOVLB  7
07776:  MOVWF  x0C
07778:  MOVLW  04
0777A:  ADDWFC 02,W
0777C:  MOVWF  x0D
0777E:  MOVLW  01
07780:  SUBWF  x0B,W
07782:  MULLW  18
07784:  MOVF   FF3,W
07786:  CLRF   x0F
07788:  MOVWF  x0E
0778A:  MOVLW  10
0778C:  ADDWF  x0E,W
0778E:  MOVWF  01
07790:  MOVLW  00
07792:  ADDWFC x0F,W
07794:  MOVWF  03
07796:  MOVF   01,W
07798:  ADDLW  92
0779A:  MOVWF  FE9
0779C:  MOVLW  00
0779E:  ADDWFC 03,W
077A0:  MOVWF  FEA
077A2:  MOVFF  FEF,743
077A6:  MOVFF  FEC,744
077AA:  MOVFF  FEC,745
077AE:  MOVFF  FEC,746
077B2:  MOVFF  70D,565
077B6:  MOVFF  70C,564
077BA:  MOVLW  89
077BC:  MOVWF  FE9
077BE:  MOVLW  02
077C0:  MOVWF  x47
077C2:  MOVLB  0
077C4:  CALL   6516
077C8:  MOVLW  2C
077CA:  MOVLB  7
077CC:  MOVWF  x50
077CE:  MOVLB  0
077D0:  CALL   563A
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
077D4:  MOVLW  04
077D6:  MOVLB  7
077D8:  MOVWF  x42
077DA:  MOVLW  C1
077DC:  MOVWF  x41
077DE:  MOVLB  0
077E0:  CALL   5602
077E4:  MOVF   01,W
077E6:  ADDLW  C1
077E8:  MOVLB  7
077EA:  MOVWF  x0C
077EC:  MOVLW  04
077EE:  ADDWFC 02,W
077F0:  MOVWF  x0D
077F2:  MOVLW  01
077F4:  SUBWF  x0B,W
077F6:  MULLW  18
077F8:  MOVF   FF3,W
077FA:  CLRF   x0F
077FC:  MOVWF  x0E
077FE:  MOVLW  14
07800:  ADDWF  x0E,W
07802:  MOVWF  01
07804:  MOVLW  00
07806:  ADDWFC x0F,W
07808:  MOVWF  03
0780A:  MOVF   01,W
0780C:  ADDLW  92
0780E:  MOVWF  FE9
07810:  MOVLW  00
07812:  ADDWFC 03,W
07814:  MOVWF  FEA
07816:  MOVFF  FEF,743
0781A:  MOVFF  FEC,744
0781E:  MOVFF  FEC,745
07822:  MOVFF  FEC,746
07826:  MOVFF  70D,565
0782A:  MOVFF  70C,564
0782E:  MOVLW  89
07830:  MOVWF  FE9
07832:  MOVLW  02
07834:  MOVWF  x47
07836:  MOVLB  0
07838:  CALL   6516
0783C:  MOVLW  2C
0783E:  MOVLB  7
07840:  MOVWF  x50
07842:  MOVLB  0
07844:  CALL   563A
....................    
....................    return SUCCESS;
07848:  MOVLW  00
0784A:  MOVWF  01
0784C:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0784E:  MOVLB  7
07850:  CLRF   x42
07852:  MOVFF  690,741
07856:  CLRF   x44
07858:  MOVLW  B5
0785A:  MOVWF  x43
0785C:  MOVLB  0
0785E:  CALL   0880
07862:  MOVFF  02,70E
07866:  MOVFF  01,70D
0786A:  MOVLW  06
0786C:  MOVLB  7
0786E:  ADDWF  x0D,F
07870:  MOVLW  00
07872:  ADDWFC x0E,F
07874:  MOVLW  32
07876:  ADDWF  x0D,W
07878:  MOVWF  01
0787A:  MOVLW  00
0787C:  ADDWFC x0E,W
0787E:  MOVWF  03
07880:  MOVF   01,W
07882:  ADDLW  EB
07884:  MOVWF  01
07886:  MOVLW  01
07888:  ADDWFC 03,F
0788A:  MOVFF  01,70D
0788E:  MOVFF  03,70E
07892:  MOVFF  03,734
07896:  MOVFF  01,733
0789A:  MOVLB  0
0789C:  CALL   57D8
078A0:  MOVF   01,F
078A2:  BNZ   78AC
078A4:  MOVLW  02
078A6:  MOVWF  01
078A8:  BRA    7DA8
078AA:  BRA    790A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
078AC:  MOVLB  7
078AE:  CLRF   x42
078B0:  MOVFF  690,741
078B4:  CLRF   x44
078B6:  MOVLW  B5
078B8:  MOVWF  x43
078BA:  MOVLB  0
078BC:  CALL   0880
078C0:  MOVFF  02,70E
078C4:  MOVFF  01,70D
078C8:  MOVLW  06
078CA:  MOVLB  7
078CC:  ADDWF  x0D,F
078CE:  MOVLW  00
078D0:  ADDWFC x0E,F
078D2:  MOVLW  32
078D4:  ADDWF  x0D,W
078D6:  MOVWF  01
078D8:  MOVLW  00
078DA:  ADDWFC x0E,W
078DC:  MOVWF  03
078DE:  MOVF   01,W
078E0:  ADDLW  EB
078E2:  MOVWF  01
078E4:  MOVLW  01
078E6:  ADDWFC 03,F
078E8:  MOVFF  01,70D
078EC:  MOVFF  03,70E
078F0:  MOVFF  03,734
078F4:  MOVFF  01,733
078F8:  CLRF   x36
078FA:  CLRF   x35
078FC:  MOVLW  0A
078FE:  MOVWF  x37
07900:  MOVLB  0
07902:  CALL   58C8
07906:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
0790A:  MOVLB  7
0790C:  CLRF   x42
0790E:  MOVFF  690,741
07912:  CLRF   x44
07914:  MOVLW  B5
07916:  MOVWF  x43
07918:  MOVLB  0
0791A:  CALL   0880
0791E:  MOVFF  02,70E
07922:  MOVFF  01,70D
07926:  MOVLW  06
07928:  MOVLB  7
0792A:  ADDWF  x0D,F
0792C:  MOVLW  00
0792E:  ADDWFC x0E,F
07930:  MOVLW  4B
07932:  ADDWF  x0D,W
07934:  MOVWF  01
07936:  MOVLW  00
07938:  ADDWFC x0E,W
0793A:  MOVWF  03
0793C:  MOVF   01,W
0793E:  ADDLW  EB
07940:  MOVWF  01
07942:  MOVLW  01
07944:  ADDWFC 03,F
07946:  MOVFF  01,70D
0794A:  MOVFF  03,70E
0794E:  MOVFF  03,742
07952:  MOVFF  01,741
07956:  MOVLB  0
07958:  CALL   5602
0795C:  MOVFF  02,03
07960:  MOVF   01,W
07962:  SUBLW  01
07964:  BNZ   796A
07966:  MOVF   03,F
07968:  BZ    7972
0796A:  MOVLW  02
0796C:  MOVWF  01
0796E:  BRA    7DA8
07970:  BRA    79B2
....................    else arg2 = SERcmd[rec].p[3][0];
07972:  MOVLB  7
07974:  CLRF   x42
07976:  MOVFF  690,741
0797A:  CLRF   x44
0797C:  MOVLW  B5
0797E:  MOVWF  x43
07980:  MOVLB  0
07982:  CALL   0880
07986:  MOVFF  02,70E
0798A:  MOVFF  01,70D
0798E:  MOVLW  06
07990:  MOVLB  7
07992:  ADDWF  x0D,F
07994:  MOVLW  00
07996:  ADDWFC x0E,F
07998:  MOVLW  4B
0799A:  ADDWF  x0D,F
0799C:  MOVLW  00
0799E:  ADDWFC x0E,F
079A0:  MOVLW  EB
079A2:  ADDWF  x0D,W
079A4:  MOVWF  FE9
079A6:  MOVLW  01
079A8:  ADDWFC x0E,W
079AA:  MOVWF  FEA
079AC:  MOVFF  FEF,70C
079B0:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
079B2:  MOVLB  7
079B4:  MOVF   x0C,W
079B6:  SUBLW  30
079B8:  BNZ   7A54
079BA:  MOVLW  04
079BC:  MOVWF  x42
079BE:  MOVLW  C1
079C0:  MOVWF  x41
079C2:  MOVLB  0
079C4:  CALL   5602
079C8:  MOVFF  02,03
079CC:  MOVF   01,W
079CE:  ADDLW  C1
079D0:  MOVLB  7
079D2:  MOVWF  x0D
079D4:  MOVLW  04
079D6:  ADDWFC 02,W
079D8:  MOVWF  x0E
079DA:  MOVLW  01
079DC:  SUBWF  x0B,W
079DE:  MULLW  18
079E0:  MOVF   FF3,W
079E2:  CLRF   x10
079E4:  MOVWF  x0F
079E6:  MOVLW  92
079E8:  ADDWF  x0F,W
079EA:  MOVWF  FE9
079EC:  MOVLW  00
079EE:  ADDWFC x10,W
079F0:  MOVWF  FEA
079F2:  MOVFF  FEF,711
079F6:  MOVFF  FEC,712
079FA:  MOVFF  FEC,713
079FE:  MOVFF  FEC,714
07A02:  MOVFF  70E,565
07A06:  MOVFF  70D,564
07A0A:  MOVFF  70B,734
07A0E:  MOVLW  18
07A10:  MOVWF  x35
07A12:  MOVLB  0
07A14:  CALL   5C1C
07A18:  MOVLW  2C
07A1A:  MOVLB  7
07A1C:  MOVWF  x50
07A1E:  MOVLB  0
07A20:  CALL   563A
07A24:  MOVLW  89
07A26:  MOVWF  FE9
07A28:  MOVFF  714,746
07A2C:  MOVFF  713,745
07A30:  MOVFF  712,744
07A34:  MOVFF  711,743
07A38:  MOVLW  02
07A3A:  MOVLB  7
07A3C:  MOVWF  x47
07A3E:  MOVLB  0
07A40:  CALL   6516
07A44:  MOVLW  2C
07A46:  MOVLB  7
07A48:  MOVWF  x50
07A4A:  MOVLB  0
07A4C:  CALL   563A
07A50:  BRA    7DA4
07A52:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07A54:  MOVF   x0C,W
07A56:  SUBLW  31
07A58:  BNZ   7AFC
07A5A:  MOVLW  04
07A5C:  MOVWF  x42
07A5E:  MOVLW  C1
07A60:  MOVWF  x41
07A62:  MOVLB  0
07A64:  CALL   5602
07A68:  MOVF   01,W
07A6A:  ADDLW  C1
07A6C:  MOVLB  7
07A6E:  MOVWF  x0D
07A70:  MOVLW  04
07A72:  ADDWFC 02,W
07A74:  MOVWF  x0E
07A76:  MOVLW  01
07A78:  SUBWF  x0B,W
07A7A:  MULLW  18
07A7C:  MOVF   FF3,W
07A7E:  CLRF   x10
07A80:  MOVWF  x0F
07A82:  MOVLW  04
07A84:  ADDWF  x0F,W
07A86:  MOVWF  01
07A88:  MOVLW  00
07A8A:  ADDWFC x10,W
07A8C:  MOVWF  03
07A8E:  MOVF   01,W
07A90:  ADDLW  92
07A92:  MOVWF  FE9
07A94:  MOVLW  00
07A96:  ADDWFC 03,W
07A98:  MOVWF  FEA
07A9A:  MOVFF  FEF,70F
07A9E:  MOVFF  FEC,710
07AA2:  MOVFF  FEC,711
07AA6:  MOVFF  FEC,712
07AAA:  MOVFF  70E,565
07AAE:  MOVFF  70D,564
07AB2:  MOVFF  70B,734
07AB6:  MOVLW  18
07AB8:  MOVWF  x35
07ABA:  MOVLB  0
07ABC:  CALL   5C1C
07AC0:  MOVLW  2C
07AC2:  MOVLB  7
07AC4:  MOVWF  x50
07AC6:  MOVLB  0
07AC8:  CALL   563A
07ACC:  MOVLW  89
07ACE:  MOVWF  FE9
07AD0:  MOVFF  712,746
07AD4:  MOVFF  711,745
07AD8:  MOVFF  710,744
07ADC:  MOVFF  70F,743
07AE0:  MOVLW  02
07AE2:  MOVLB  7
07AE4:  MOVWF  x47
07AE6:  MOVLB  0
07AE8:  CALL   6516
07AEC:  MOVLW  2C
07AEE:  MOVLB  7
07AF0:  MOVWF  x50
07AF2:  MOVLB  0
07AF4:  CALL   563A
07AF8:  BRA    7DA4
07AFA:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07AFC:  MOVF   x0C,W
07AFE:  SUBLW  32
07B00:  BNZ   7BA4
07B02:  MOVLW  04
07B04:  MOVWF  x42
07B06:  MOVLW  C1
07B08:  MOVWF  x41
07B0A:  MOVLB  0
07B0C:  CALL   5602
07B10:  MOVF   01,W
07B12:  ADDLW  C1
07B14:  MOVLB  7
07B16:  MOVWF  x0D
07B18:  MOVLW  04
07B1A:  ADDWFC 02,W
07B1C:  MOVWF  x0E
07B1E:  MOVLW  01
07B20:  SUBWF  x0B,W
07B22:  MULLW  18
07B24:  MOVF   FF3,W
07B26:  CLRF   x10
07B28:  MOVWF  x0F
07B2A:  MOVLW  08
07B2C:  ADDWF  x0F,W
07B2E:  MOVWF  01
07B30:  MOVLW  00
07B32:  ADDWFC x10,W
07B34:  MOVWF  03
07B36:  MOVF   01,W
07B38:  ADDLW  92
07B3A:  MOVWF  FE9
07B3C:  MOVLW  00
07B3E:  ADDWFC 03,W
07B40:  MOVWF  FEA
07B42:  MOVFF  FEF,70F
07B46:  MOVFF  FEC,710
07B4A:  MOVFF  FEC,711
07B4E:  MOVFF  FEC,712
07B52:  MOVFF  70E,565
07B56:  MOVFF  70D,564
07B5A:  MOVFF  70B,734
07B5E:  MOVLW  18
07B60:  MOVWF  x35
07B62:  MOVLB  0
07B64:  CALL   5C1C
07B68:  MOVLW  2C
07B6A:  MOVLB  7
07B6C:  MOVWF  x50
07B6E:  MOVLB  0
07B70:  CALL   563A
07B74:  MOVLW  89
07B76:  MOVWF  FE9
07B78:  MOVFF  712,746
07B7C:  MOVFF  711,745
07B80:  MOVFF  710,744
07B84:  MOVFF  70F,743
07B88:  MOVLW  02
07B8A:  MOVLB  7
07B8C:  MOVWF  x47
07B8E:  MOVLB  0
07B90:  CALL   6516
07B94:  MOVLW  2C
07B96:  MOVLB  7
07B98:  MOVWF  x50
07B9A:  MOVLB  0
07B9C:  CALL   563A
07BA0:  BRA    7DA4
07BA2:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07BA4:  MOVF   x0C,W
07BA6:  SUBLW  33
07BA8:  BNZ   7C4C
07BAA:  MOVLW  04
07BAC:  MOVWF  x42
07BAE:  MOVLW  C1
07BB0:  MOVWF  x41
07BB2:  MOVLB  0
07BB4:  CALL   5602
07BB8:  MOVF   01,W
07BBA:  ADDLW  C1
07BBC:  MOVLB  7
07BBE:  MOVWF  x0D
07BC0:  MOVLW  04
07BC2:  ADDWFC 02,W
07BC4:  MOVWF  x0E
07BC6:  MOVLW  01
07BC8:  SUBWF  x0B,W
07BCA:  MULLW  18
07BCC:  MOVF   FF3,W
07BCE:  CLRF   x10
07BD0:  MOVWF  x0F
07BD2:  MOVLW  0C
07BD4:  ADDWF  x0F,W
07BD6:  MOVWF  01
07BD8:  MOVLW  00
07BDA:  ADDWFC x10,W
07BDC:  MOVWF  03
07BDE:  MOVF   01,W
07BE0:  ADDLW  92
07BE2:  MOVWF  FE9
07BE4:  MOVLW  00
07BE6:  ADDWFC 03,W
07BE8:  MOVWF  FEA
07BEA:  MOVFF  FEF,70F
07BEE:  MOVFF  FEC,710
07BF2:  MOVFF  FEC,711
07BF6:  MOVFF  FEC,712
07BFA:  MOVFF  70E,565
07BFE:  MOVFF  70D,564
07C02:  MOVFF  70B,734
07C06:  MOVLW  18
07C08:  MOVWF  x35
07C0A:  MOVLB  0
07C0C:  CALL   5C1C
07C10:  MOVLW  2C
07C12:  MOVLB  7
07C14:  MOVWF  x50
07C16:  MOVLB  0
07C18:  CALL   563A
07C1C:  MOVLW  89
07C1E:  MOVWF  FE9
07C20:  MOVFF  712,746
07C24:  MOVFF  711,745
07C28:  MOVFF  710,744
07C2C:  MOVFF  70F,743
07C30:  MOVLW  02
07C32:  MOVLB  7
07C34:  MOVWF  x47
07C36:  MOVLB  0
07C38:  CALL   6516
07C3C:  MOVLW  2C
07C3E:  MOVLB  7
07C40:  MOVWF  x50
07C42:  MOVLB  0
07C44:  CALL   563A
07C48:  BRA    7DA4
07C4A:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07C4C:  MOVF   x0C,W
07C4E:  SUBLW  34
07C50:  BNZ   7CF4
07C52:  MOVLW  04
07C54:  MOVWF  x42
07C56:  MOVLW  C1
07C58:  MOVWF  x41
07C5A:  MOVLB  0
07C5C:  CALL   5602
07C60:  MOVF   01,W
07C62:  ADDLW  C1
07C64:  MOVLB  7
07C66:  MOVWF  x0D
07C68:  MOVLW  04
07C6A:  ADDWFC 02,W
07C6C:  MOVWF  x0E
07C6E:  MOVLW  01
07C70:  SUBWF  x0B,W
07C72:  MULLW  18
07C74:  MOVF   FF3,W
07C76:  CLRF   x10
07C78:  MOVWF  x0F
07C7A:  MOVLW  10
07C7C:  ADDWF  x0F,W
07C7E:  MOVWF  01
07C80:  MOVLW  00
07C82:  ADDWFC x10,W
07C84:  MOVWF  03
07C86:  MOVF   01,W
07C88:  ADDLW  92
07C8A:  MOVWF  FE9
07C8C:  MOVLW  00
07C8E:  ADDWFC 03,W
07C90:  MOVWF  FEA
07C92:  MOVFF  FEF,70F
07C96:  MOVFF  FEC,710
07C9A:  MOVFF  FEC,711
07C9E:  MOVFF  FEC,712
07CA2:  MOVFF  70E,565
07CA6:  MOVFF  70D,564
07CAA:  MOVFF  70B,734
07CAE:  MOVLW  18
07CB0:  MOVWF  x35
07CB2:  MOVLB  0
07CB4:  CALL   5C1C
07CB8:  MOVLW  2C
07CBA:  MOVLB  7
07CBC:  MOVWF  x50
07CBE:  MOVLB  0
07CC0:  CALL   563A
07CC4:  MOVLW  89
07CC6:  MOVWF  FE9
07CC8:  MOVFF  712,746
07CCC:  MOVFF  711,745
07CD0:  MOVFF  710,744
07CD4:  MOVFF  70F,743
07CD8:  MOVLW  02
07CDA:  MOVLB  7
07CDC:  MOVWF  x47
07CDE:  MOVLB  0
07CE0:  CALL   6516
07CE4:  MOVLW  2C
07CE6:  MOVLB  7
07CE8:  MOVWF  x50
07CEA:  MOVLB  0
07CEC:  CALL   563A
07CF0:  BRA    7DA4
07CF2:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07CF4:  MOVF   x0C,W
07CF6:  SUBLW  35
07CF8:  BNZ   7D9C
07CFA:  MOVLW  04
07CFC:  MOVWF  x42
07CFE:  MOVLW  C1
07D00:  MOVWF  x41
07D02:  MOVLB  0
07D04:  CALL   5602
07D08:  MOVF   01,W
07D0A:  ADDLW  C1
07D0C:  MOVLB  7
07D0E:  MOVWF  x0D
07D10:  MOVLW  04
07D12:  ADDWFC 02,W
07D14:  MOVWF  x0E
07D16:  MOVLW  01
07D18:  SUBWF  x0B,W
07D1A:  MULLW  18
07D1C:  MOVF   FF3,W
07D1E:  CLRF   x10
07D20:  MOVWF  x0F
07D22:  MOVLW  14
07D24:  ADDWF  x0F,W
07D26:  MOVWF  01
07D28:  MOVLW  00
07D2A:  ADDWFC x10,W
07D2C:  MOVWF  03
07D2E:  MOVF   01,W
07D30:  ADDLW  92
07D32:  MOVWF  FE9
07D34:  MOVLW  00
07D36:  ADDWFC 03,W
07D38:  MOVWF  FEA
07D3A:  MOVFF  FEF,70F
07D3E:  MOVFF  FEC,710
07D42:  MOVFF  FEC,711
07D46:  MOVFF  FEC,712
07D4A:  MOVFF  70E,565
07D4E:  MOVFF  70D,564
07D52:  MOVFF  70B,734
07D56:  MOVLW  18
07D58:  MOVWF  x35
07D5A:  MOVLB  0
07D5C:  CALL   5C1C
07D60:  MOVLW  2C
07D62:  MOVLB  7
07D64:  MOVWF  x50
07D66:  MOVLB  0
07D68:  CALL   563A
07D6C:  MOVLW  89
07D6E:  MOVWF  FE9
07D70:  MOVFF  712,746
07D74:  MOVFF  711,745
07D78:  MOVFF  710,744
07D7C:  MOVFF  70F,743
07D80:  MOVLW  02
07D82:  MOVLB  7
07D84:  MOVWF  x47
07D86:  MOVLB  0
07D88:  CALL   6516
07D8C:  MOVLW  2C
07D8E:  MOVLB  7
07D90:  MOVWF  x50
07D92:  MOVLB  0
07D94:  CALL   563A
07D98:  BRA    7DA4
07D9A:  MOVLB  7
....................    else return INV_PARAM;
07D9C:  MOVLW  02
07D9E:  MOVWF  01
07DA0:  MOVLB  0
07DA2:  BRA    7DA8
....................    
....................    return SUCCESS;
07DA4:  MOVLW  00
07DA6:  MOVWF  01
07DA8:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07DAA:  MOVLB  7
07DAC:  CLRF   x42
07DAE:  MOVFF  690,741
07DB2:  CLRF   x44
07DB4:  MOVLW  B5
07DB6:  MOVWF  x43
07DB8:  MOVLB  0
07DBA:  CALL   0880
07DBE:  MOVFF  02,712
07DC2:  MOVFF  01,711
07DC6:  MOVLW  06
07DC8:  MOVLB  7
07DCA:  ADDWF  x11,F
07DCC:  MOVLW  00
07DCE:  ADDWFC x12,F
07DD0:  MOVLW  32
07DD2:  ADDWF  x11,W
07DD4:  MOVWF  01
07DD6:  MOVLW  00
07DD8:  ADDWFC x12,W
07DDA:  MOVWF  03
07DDC:  MOVF   01,W
07DDE:  ADDLW  EB
07DE0:  MOVWF  01
07DE2:  MOVLW  01
07DE4:  ADDWFC 03,F
07DE6:  MOVFF  01,711
07DEA:  MOVFF  03,712
07DEE:  MOVFF  03,734
07DF2:  MOVFF  01,733
07DF6:  MOVLB  0
07DF8:  CALL   57D8
07DFC:  MOVF   01,F
07DFE:  BNZ   7E08
07E00:  MOVLW  02
07E02:  MOVWF  01
07E04:  BRA    8140
07E06:  BRA    7E66
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07E08:  MOVLB  7
07E0A:  CLRF   x42
07E0C:  MOVFF  690,741
07E10:  CLRF   x44
07E12:  MOVLW  B5
07E14:  MOVWF  x43
07E16:  MOVLB  0
07E18:  CALL   0880
07E1C:  MOVFF  02,712
07E20:  MOVFF  01,711
07E24:  MOVLW  06
07E26:  MOVLB  7
07E28:  ADDWF  x11,F
07E2A:  MOVLW  00
07E2C:  ADDWFC x12,F
07E2E:  MOVLW  32
07E30:  ADDWF  x11,W
07E32:  MOVWF  01
07E34:  MOVLW  00
07E36:  ADDWFC x12,W
07E38:  MOVWF  03
07E3A:  MOVF   01,W
07E3C:  ADDLW  EB
07E3E:  MOVWF  01
07E40:  MOVLW  01
07E42:  ADDWFC 03,F
07E44:  MOVFF  01,711
07E48:  MOVFF  03,712
07E4C:  MOVFF  03,734
07E50:  MOVFF  01,733
07E54:  CLRF   x36
07E56:  CLRF   x35
07E58:  MOVLW  0A
07E5A:  MOVWF  x37
07E5C:  MOVLB  0
07E5E:  CALL   58C8
07E62:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07E66:  MOVLB  7
07E68:  CLRF   x42
07E6A:  MOVFF  690,741
07E6E:  CLRF   x44
07E70:  MOVLW  B5
07E72:  MOVWF  x43
07E74:  MOVLB  0
07E76:  CALL   0880
07E7A:  MOVFF  02,712
07E7E:  MOVFF  01,711
07E82:  MOVLW  06
07E84:  MOVLB  7
07E86:  ADDWF  x11,F
07E88:  MOVLW  00
07E8A:  ADDWFC x12,F
07E8C:  MOVLW  4B
07E8E:  ADDWF  x11,W
07E90:  MOVWF  01
07E92:  MOVLW  00
07E94:  ADDWFC x12,W
07E96:  MOVWF  03
07E98:  MOVF   01,W
07E9A:  ADDLW  EB
07E9C:  MOVWF  01
07E9E:  MOVLW  01
07EA0:  ADDWFC 03,F
07EA2:  MOVFF  01,711
07EA6:  MOVFF  03,712
07EAA:  MOVFF  03,742
07EAE:  MOVFF  01,741
07EB2:  MOVLB  0
07EB4:  CALL   5602
07EB8:  MOVFF  02,03
07EBC:  MOVF   01,W
07EBE:  SUBLW  01
07EC0:  BNZ   7EC6
07EC2:  MOVF   03,F
07EC4:  BZ    7ECE
07EC6:  MOVLW  02
07EC8:  MOVWF  01
07ECA:  BRA    8140
07ECC:  BRA    7F0E
....................    else arg2 = SERcmd[rec].p[3][0];
07ECE:  MOVLB  7
07ED0:  CLRF   x42
07ED2:  MOVFF  690,741
07ED6:  CLRF   x44
07ED8:  MOVLW  B5
07EDA:  MOVWF  x43
07EDC:  MOVLB  0
07EDE:  CALL   0880
07EE2:  MOVFF  02,712
07EE6:  MOVFF  01,711
07EEA:  MOVLW  06
07EEC:  MOVLB  7
07EEE:  ADDWF  x11,F
07EF0:  MOVLW  00
07EF2:  ADDWFC x12,F
07EF4:  MOVLW  4B
07EF6:  ADDWF  x11,F
07EF8:  MOVLW  00
07EFA:  ADDWFC x12,F
07EFC:  MOVLW  EB
07EFE:  ADDWF  x11,W
07F00:  MOVWF  FE9
07F02:  MOVLW  01
07F04:  ADDWFC x12,W
07F06:  MOVWF  FEA
07F08:  MOVFF  FEF,70C
07F0C:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07F0E:  MOVLB  7
07F10:  CLRF   x42
07F12:  MOVFF  690,741
07F16:  CLRF   x44
07F18:  MOVLW  B5
07F1A:  MOVWF  x43
07F1C:  MOVLB  0
07F1E:  CALL   0880
07F22:  MOVFF  02,712
07F26:  MOVFF  01,711
07F2A:  MOVLW  06
07F2C:  MOVLB  7
07F2E:  ADDWF  x11,F
07F30:  MOVLW  00
07F32:  ADDWFC x12,F
07F34:  MOVLW  64
07F36:  ADDWF  x11,W
07F38:  MOVWF  01
07F3A:  MOVLW  00
07F3C:  ADDWFC x12,W
07F3E:  MOVWF  03
07F40:  MOVF   01,W
07F42:  ADDLW  EB
07F44:  MOVWF  01
07F46:  MOVLW  01
07F48:  ADDWFC 03,F
07F4A:  MOVFF  01,711
07F4E:  MOVFF  03,712
07F52:  MOVFF  03,715
07F56:  MOVFF  01,714
07F5A:  MOVLB  0
07F5C:  CALL   6B7C
07F60:  MOVF   01,F
07F62:  BNZ   7F6C
07F64:  MOVLW  02
07F66:  MOVWF  01
07F68:  BRA    8140
07F6A:  BRA    7FD2
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07F6C:  MOVLB  7
07F6E:  CLRF   x42
07F70:  MOVFF  690,741
07F74:  CLRF   x44
07F76:  MOVLW  B5
07F78:  MOVWF  x43
07F7A:  MOVLB  0
07F7C:  CALL   0880
07F80:  MOVFF  02,712
07F84:  MOVFF  01,711
07F88:  MOVLW  06
07F8A:  MOVLB  7
07F8C:  ADDWF  x11,F
07F8E:  MOVLW  00
07F90:  ADDWFC x12,F
07F92:  MOVLW  64
07F94:  ADDWF  x11,W
07F96:  MOVWF  01
07F98:  MOVLW  00
07F9A:  ADDWFC x12,W
07F9C:  MOVWF  03
07F9E:  MOVF   01,W
07FA0:  ADDLW  EB
07FA2:  MOVWF  01
07FA4:  MOVLW  01
07FA6:  ADDWFC 03,F
07FA8:  MOVFF  01,711
07FAC:  MOVFF  03,712
07FB0:  MOVFF  03,715
07FB4:  MOVFF  01,714
07FB8:  CLRF   x17
07FBA:  CLRF   x16
07FBC:  MOVLB  0
07FBE:  CALL   6C3E
07FC2:  MOVFF  03,710
07FC6:  MOVFF  02,70F
07FCA:  MOVFF  01,70E
07FCE:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07FD2:  MOVLB  7
07FD4:  MOVF   x0C,W
07FD6:  SUBLW  30
07FD8:  BNZ   8004
07FDA:  MOVLW  01
07FDC:  SUBWF  x0B,W
07FDE:  MULLW  18
07FE0:  MOVF   FF3,W
07FE2:  CLRF   x12
07FE4:  MOVWF  x11
07FE6:  MOVLW  92
07FE8:  ADDWF  x11,W
07FEA:  MOVWF  FE9
07FEC:  MOVLW  00
07FEE:  ADDWFC x12,W
07FF0:  MOVWF  FEA
07FF2:  MOVFF  70D,FEF
07FF6:  MOVFF  70E,FEC
07FFA:  MOVFF  70F,FEC
07FFE:  MOVFF  710,FEC
08002:  BRA    813A
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08004:  MOVF   x0C,W
08006:  SUBLW  31
08008:  BNZ   8040
0800A:  MOVLW  01
0800C:  SUBWF  x0B,W
0800E:  MULLW  18
08010:  MOVF   FF3,W
08012:  CLRF   x12
08014:  MOVWF  x11
08016:  MOVLW  04
08018:  ADDWF  x11,W
0801A:  MOVWF  01
0801C:  MOVLW  00
0801E:  ADDWFC x12,W
08020:  MOVWF  03
08022:  MOVF   01,W
08024:  ADDLW  92
08026:  MOVWF  FE9
08028:  MOVLW  00
0802A:  ADDWFC 03,W
0802C:  MOVWF  FEA
0802E:  MOVFF  70D,FEF
08032:  MOVFF  70E,FEC
08036:  MOVFF  70F,FEC
0803A:  MOVFF  710,FEC
0803E:  BRA    813A
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
08040:  MOVF   x0C,W
08042:  SUBLW  32
08044:  BNZ   807C
08046:  MOVLW  01
08048:  SUBWF  x0B,W
0804A:  MULLW  18
0804C:  MOVF   FF3,W
0804E:  CLRF   x12
08050:  MOVWF  x11
08052:  MOVLW  08
08054:  ADDWF  x11,W
08056:  MOVWF  01
08058:  MOVLW  00
0805A:  ADDWFC x12,W
0805C:  MOVWF  03
0805E:  MOVF   01,W
08060:  ADDLW  92
08062:  MOVWF  FE9
08064:  MOVLW  00
08066:  ADDWFC 03,W
08068:  MOVWF  FEA
0806A:  MOVFF  70D,FEF
0806E:  MOVFF  70E,FEC
08072:  MOVFF  70F,FEC
08076:  MOVFF  710,FEC
0807A:  BRA    813A
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
0807C:  MOVF   x0C,W
0807E:  SUBLW  33
08080:  BNZ   80B8
08082:  MOVLW  01
08084:  SUBWF  x0B,W
08086:  MULLW  18
08088:  MOVF   FF3,W
0808A:  CLRF   x12
0808C:  MOVWF  x11
0808E:  MOVLW  0C
08090:  ADDWF  x11,W
08092:  MOVWF  01
08094:  MOVLW  00
08096:  ADDWFC x12,W
08098:  MOVWF  03
0809A:  MOVF   01,W
0809C:  ADDLW  92
0809E:  MOVWF  FE9
080A0:  MOVLW  00
080A2:  ADDWFC 03,W
080A4:  MOVWF  FEA
080A6:  MOVFF  70D,FEF
080AA:  MOVFF  70E,FEC
080AE:  MOVFF  70F,FEC
080B2:  MOVFF  710,FEC
080B6:  BRA    813A
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
080B8:  MOVF   x0C,W
080BA:  SUBLW  34
080BC:  BNZ   80F4
080BE:  MOVLW  01
080C0:  SUBWF  x0B,W
080C2:  MULLW  18
080C4:  MOVF   FF3,W
080C6:  CLRF   x12
080C8:  MOVWF  x11
080CA:  MOVLW  10
080CC:  ADDWF  x11,W
080CE:  MOVWF  01
080D0:  MOVLW  00
080D2:  ADDWFC x12,W
080D4:  MOVWF  03
080D6:  MOVF   01,W
080D8:  ADDLW  92
080DA:  MOVWF  FE9
080DC:  MOVLW  00
080DE:  ADDWFC 03,W
080E0:  MOVWF  FEA
080E2:  MOVFF  70D,FEF
080E6:  MOVFF  70E,FEC
080EA:  MOVFF  70F,FEC
080EE:  MOVFF  710,FEC
080F2:  BRA    813A
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
080F4:  MOVF   x0C,W
080F6:  SUBLW  35
080F8:  BNZ   8130
080FA:  MOVLW  01
080FC:  SUBWF  x0B,W
080FE:  MULLW  18
08100:  MOVF   FF3,W
08102:  CLRF   x12
08104:  MOVWF  x11
08106:  MOVLW  14
08108:  ADDWF  x11,W
0810A:  MOVWF  01
0810C:  MOVLW  00
0810E:  ADDWFC x12,W
08110:  MOVWF  03
08112:  MOVF   01,W
08114:  ADDLW  92
08116:  MOVWF  FE9
08118:  MOVLW  00
0811A:  ADDWFC 03,W
0811C:  MOVWF  FEA
0811E:  MOVFF  70D,FEF
08122:  MOVFF  70E,FEC
08126:  MOVFF  70F,FEC
0812A:  MOVFF  710,FEC
0812E:  BRA    813A
....................    else return INV_PARAM;
08130:  MOVLW  02
08132:  MOVWF  01
08134:  MOVLB  0
08136:  BRA    8140
08138:  MOVLB  7
....................    
....................    return SUCCESS;
0813A:  MOVLW  00
0813C:  MOVWF  01
0813E:  MOVLB  0
08140:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08142:  MOVLW  4E
08144:  MOVLB  7
08146:  MOVWF  x0F
08148:  MOVLW  31
0814A:  MOVWF  x10
0814C:  MOVLW  35
0814E:  MOVWF  x11
08150:  CLRF   x12
08152:  MOVLW  07
08154:  MOVWF  x0E
08156:  MOVLW  0F
08158:  MOVWF  x0D
....................    char *s_200 = "200";
0815A:  MOVLW  32
0815C:  MOVWF  x15
0815E:  MOVLW  30
08160:  MOVWF  x16
08162:  MOVWF  x17
08164:  CLRF   x18
08166:  MOVLW  07
08168:  MOVWF  x14
0816A:  MOVLW  15
0816C:  MOVWF  x13
....................    char *s_5V6 = "5V6";
0816E:  MOVLW  35
08170:  MOVWF  x1B
08172:  MOVLW  56
08174:  MOVWF  x1C
08176:  MOVLW  36
08178:  MOVWF  x1D
0817A:  CLRF   x1E
0817C:  MOVLW  07
0817E:  MOVWF  x1A
08180:  MOVLW  1B
08182:  MOVWF  x19
....................    char *s_5VA = "5VA";
08184:  MOVLW  35
08186:  MOVWF  x21
08188:  MOVLW  56
0818A:  MOVWF  x22
0818C:  MOVLW  41
0818E:  MOVWF  x23
08190:  CLRF   x24
08192:  MOVLW  07
08194:  MOVWF  x20
08196:  MOVLW  21
08198:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
0819A:  MOVLW  33
0819C:  MOVWF  x27
0819E:  MOVLW  56
081A0:  MOVWF  x28
081A2:  MOVLW  36
081A4:  MOVWF  x29
081A6:  MOVLW  58
081A8:  MOVWF  x2A
081AA:  CLRF   x2B
081AC:  MOVLW  07
081AE:  MOVWF  x26
081B0:  MOVLW  27
081B2:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
081B4:  MOVLW  33
081B6:  MOVWF  x2E
081B8:  MOVLW  56
081BA:  MOVWF  x2F
081BC:  MOVLW  33
081BE:  MOVWF  x30
081C0:  MOVLW  41
081C2:  MOVWF  x31
081C4:  CLRF   x32
081C6:  MOVLW  07
081C8:  MOVWF  x2D
081CA:  MOVLW  2E
081CC:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
081CE:  MOVLW  33
081D0:  MOVWF  x35
081D2:  MOVLW  56
081D4:  MOVWF  x36
081D6:  MOVLW  33
081D8:  MOVWF  x37
081DA:  MOVLW  44
081DC:  MOVWF  x38
081DE:  CLRF   x39
081E0:  MOVLW  07
081E2:  MOVWF  x34
081E4:  MOVLW  35
081E6:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
081E8:  CLRF   x42
081EA:  MOVFF  690,741
081EE:  CLRF   x44
081F0:  MOVLW  B5
081F2:  MOVWF  x43
081F4:  MOVLB  0
081F6:  CALL   0880
081FA:  MOVFF  02,73B
081FE:  MOVFF  01,73A
08202:  MOVLW  06
08204:  MOVLB  7
08206:  ADDWF  x3A,F
08208:  MOVLW  00
0820A:  ADDWFC x3B,F
0820C:  MOVLW  32
0820E:  ADDWF  x3A,W
08210:  MOVWF  01
08212:  MOVLW  00
08214:  ADDWFC x3B,W
08216:  MOVWF  03
08218:  MOVF   01,W
0821A:  ADDLW  EB
0821C:  MOVWF  01
0821E:  MOVLW  01
08220:  ADDWFC 03,F
08222:  MOVFF  01,70B
08226:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
0822A:  MOVFF  70E,742
0822E:  MOVFF  70D,741
08232:  MOVFF  70C,744
08236:  MOVFF  70B,743
0823A:  MOVLB  0
0823C:  CALL   56B8
08240:  MOVF   01,F
08242:  BNZ   82C6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
08244:  MOVLW  04
08246:  MOVLB  7
08248:  MOVWF  x42
0824A:  MOVLW  C1
0824C:  MOVWF  x41
0824E:  MOVLB  0
08250:  CALL   5602
08254:  MOVFF  02,03
08258:  MOVF   01,W
0825A:  ADDLW  C1
0825C:  MOVLB  7
0825E:  MOVWF  x3A
08260:  MOVLW  04
08262:  ADDWFC 02,W
08264:  MOVWF  x3B
08266:  MOVFF  FE8,565
0826A:  MOVFF  73A,564
0826E:  MOVLW  89
08270:  MOVWF  FE9
08272:  MOVFF  C5,746
08276:  MOVFF  C4,745
0827A:  MOVFF  C3,744
0827E:  MOVFF  C2,743
08282:  MOVLW  02
08284:  MOVWF  x47
08286:  MOVLB  0
08288:  CALL   6516
0828C:  MOVLW  2C
0828E:  MOVLB  7
08290:  MOVWF  x50
08292:  MOVLB  0
08294:  CALL   563A
08298:  MOVLW  89
0829A:  MOVWF  FE9
0829C:  MOVFF  C9,746
082A0:  MOVFF  C8,745
082A4:  MOVFF  C7,744
082A8:  MOVFF  C6,743
082AC:  MOVLW  02
082AE:  MOVLB  7
082B0:  MOVWF  x47
082B2:  MOVLB  0
082B4:  CALL   6516
082B8:  MOVLW  2C
082BA:  MOVLB  7
082BC:  MOVWF  x50
082BE:  MOVLB  0
082C0:  CALL   563A
....................    }
082C4:  BRA    8668
....................    else if (0 == strcmp(s_200, arg1)) {
082C6:  MOVFF  714,742
082CA:  MOVFF  713,741
082CE:  MOVFF  70C,744
082D2:  MOVFF  70B,743
082D6:  CALL   56B8
082DA:  MOVF   01,F
082DC:  BNZ   8360
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
082DE:  MOVLW  04
082E0:  MOVLB  7
082E2:  MOVWF  x42
082E4:  MOVLW  C1
082E6:  MOVWF  x41
082E8:  MOVLB  0
082EA:  CALL   5602
082EE:  MOVFF  02,03
082F2:  MOVF   01,W
082F4:  ADDLW  C1
082F6:  MOVLB  7
082F8:  MOVWF  x3A
082FA:  MOVLW  04
082FC:  ADDWFC 02,W
082FE:  MOVWF  x3B
08300:  MOVFF  FE8,565
08304:  MOVFF  73A,564
08308:  MOVLW  89
0830A:  MOVWF  FE9
0830C:  MOVFF  CD,746
08310:  MOVFF  CC,745
08314:  MOVFF  CB,744
08318:  MOVFF  CA,743
0831C:  MOVLW  02
0831E:  MOVWF  x47
08320:  MOVLB  0
08322:  CALL   6516
08326:  MOVLW  2C
08328:  MOVLB  7
0832A:  MOVWF  x50
0832C:  MOVLB  0
0832E:  CALL   563A
08332:  MOVLW  89
08334:  MOVWF  FE9
08336:  MOVFF  D1,746
0833A:  MOVFF  D0,745
0833E:  MOVFF  CF,744
08342:  MOVFF  CE,743
08346:  MOVLW  02
08348:  MOVLB  7
0834A:  MOVWF  x47
0834C:  MOVLB  0
0834E:  CALL   6516
08352:  MOVLW  2C
08354:  MOVLB  7
08356:  MOVWF  x50
08358:  MOVLB  0
0835A:  CALL   563A
....................    }
0835E:  BRA    8668
....................    else if (0 == strcmp(s_5V6, arg1)) {
08360:  MOVFF  71A,742
08364:  MOVFF  719,741
08368:  MOVFF  70C,744
0836C:  MOVFF  70B,743
08370:  CALL   56B8
08374:  MOVF   01,F
08376:  BNZ   83FA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
08378:  MOVLW  04
0837A:  MOVLB  7
0837C:  MOVWF  x42
0837E:  MOVLW  C1
08380:  MOVWF  x41
08382:  MOVLB  0
08384:  CALL   5602
08388:  MOVFF  02,03
0838C:  MOVF   01,W
0838E:  ADDLW  C1
08390:  MOVLB  7
08392:  MOVWF  x3A
08394:  MOVLW  04
08396:  ADDWFC 02,W
08398:  MOVWF  x3B
0839A:  MOVFF  FE8,565
0839E:  MOVFF  73A,564
083A2:  MOVLW  89
083A4:  MOVWF  FE9
083A6:  MOVFF  D5,746
083AA:  MOVFF  D4,745
083AE:  MOVFF  D3,744
083B2:  MOVFF  D2,743
083B6:  MOVLW  02
083B8:  MOVWF  x47
083BA:  MOVLB  0
083BC:  CALL   6516
083C0:  MOVLW  2C
083C2:  MOVLB  7
083C4:  MOVWF  x50
083C6:  MOVLB  0
083C8:  CALL   563A
083CC:  MOVLW  89
083CE:  MOVWF  FE9
083D0:  MOVFF  D9,746
083D4:  MOVFF  D8,745
083D8:  MOVFF  D7,744
083DC:  MOVFF  D6,743
083E0:  MOVLW  02
083E2:  MOVLB  7
083E4:  MOVWF  x47
083E6:  MOVLB  0
083E8:  CALL   6516
083EC:  MOVLW  2C
083EE:  MOVLB  7
083F0:  MOVWF  x50
083F2:  MOVLB  0
083F4:  CALL   563A
....................    }
083F8:  BRA    8668
....................    else if (0 == strcmp(s_5VA, arg1)) {
083FA:  MOVFF  720,742
083FE:  MOVFF  71F,741
08402:  MOVFF  70C,744
08406:  MOVFF  70B,743
0840A:  CALL   56B8
0840E:  MOVF   01,F
08410:  BNZ   8494
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
08412:  MOVLW  04
08414:  MOVLB  7
08416:  MOVWF  x42
08418:  MOVLW  C1
0841A:  MOVWF  x41
0841C:  MOVLB  0
0841E:  CALL   5602
08422:  MOVFF  02,03
08426:  MOVF   01,W
08428:  ADDLW  C1
0842A:  MOVLB  7
0842C:  MOVWF  x3A
0842E:  MOVLW  04
08430:  ADDWFC 02,W
08432:  MOVWF  x3B
08434:  MOVFF  FE8,565
08438:  MOVFF  73A,564
0843C:  MOVLW  89
0843E:  MOVWF  FE9
08440:  MOVFF  DD,746
08444:  MOVFF  DC,745
08448:  MOVFF  DB,744
0844C:  MOVFF  DA,743
08450:  MOVLW  02
08452:  MOVWF  x47
08454:  MOVLB  0
08456:  CALL   6516
0845A:  MOVLW  2C
0845C:  MOVLB  7
0845E:  MOVWF  x50
08460:  MOVLB  0
08462:  CALL   563A
08466:  MOVLW  89
08468:  MOVWF  FE9
0846A:  MOVFF  E1,746
0846E:  MOVFF  E0,745
08472:  MOVFF  DF,744
08476:  MOVFF  DE,743
0847A:  MOVLW  02
0847C:  MOVLB  7
0847E:  MOVWF  x47
08480:  MOVLB  0
08482:  CALL   6516
08486:  MOVLW  2C
08488:  MOVLB  7
0848A:  MOVWF  x50
0848C:  MOVLB  0
0848E:  CALL   563A
....................    }
08492:  BRA    8668
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08494:  MOVFF  726,742
08498:  MOVFF  725,741
0849C:  MOVFF  70C,744
084A0:  MOVFF  70B,743
084A4:  CALL   56B8
084A8:  MOVF   01,F
084AA:  BNZ   852E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
084AC:  MOVLW  04
084AE:  MOVLB  7
084B0:  MOVWF  x42
084B2:  MOVLW  C1
084B4:  MOVWF  x41
084B6:  MOVLB  0
084B8:  CALL   5602
084BC:  MOVFF  02,03
084C0:  MOVF   01,W
084C2:  ADDLW  C1
084C4:  MOVLB  7
084C6:  MOVWF  x3A
084C8:  MOVLW  04
084CA:  ADDWFC 02,W
084CC:  MOVWF  x3B
084CE:  MOVFF  FE8,565
084D2:  MOVFF  73A,564
084D6:  MOVLW  89
084D8:  MOVWF  FE9
084DA:  MOVFF  E5,746
084DE:  MOVFF  E4,745
084E2:  MOVFF  E3,744
084E6:  MOVFF  E2,743
084EA:  MOVLW  02
084EC:  MOVWF  x47
084EE:  MOVLB  0
084F0:  CALL   6516
084F4:  MOVLW  2C
084F6:  MOVLB  7
084F8:  MOVWF  x50
084FA:  MOVLB  0
084FC:  CALL   563A
08500:  MOVLW  89
08502:  MOVWF  FE9
08504:  MOVFF  E9,746
08508:  MOVFF  E8,745
0850C:  MOVFF  E7,744
08510:  MOVFF  E6,743
08514:  MOVLW  02
08516:  MOVLB  7
08518:  MOVWF  x47
0851A:  MOVLB  0
0851C:  CALL   6516
08520:  MOVLW  2C
08522:  MOVLB  7
08524:  MOVWF  x50
08526:  MOVLB  0
08528:  CALL   563A
....................    }
0852C:  BRA    8668
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0852E:  MOVFF  72D,742
08532:  MOVFF  72C,741
08536:  MOVFF  70C,744
0853A:  MOVFF  70B,743
0853E:  CALL   56B8
08542:  MOVF   01,F
08544:  BNZ   85C8
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08546:  MOVLW  04
08548:  MOVLB  7
0854A:  MOVWF  x42
0854C:  MOVLW  C1
0854E:  MOVWF  x41
08550:  MOVLB  0
08552:  CALL   5602
08556:  MOVFF  02,03
0855A:  MOVF   01,W
0855C:  ADDLW  C1
0855E:  MOVLB  7
08560:  MOVWF  x3A
08562:  MOVLW  04
08564:  ADDWFC 02,W
08566:  MOVWF  x3B
08568:  MOVFF  FE8,565
0856C:  MOVFF  73A,564
08570:  MOVLW  89
08572:  MOVWF  FE9
08574:  MOVFF  ED,746
08578:  MOVFF  EC,745
0857C:  MOVFF  EB,744
08580:  MOVFF  EA,743
08584:  MOVLW  02
08586:  MOVWF  x47
08588:  MOVLB  0
0858A:  CALL   6516
0858E:  MOVLW  2C
08590:  MOVLB  7
08592:  MOVWF  x50
08594:  MOVLB  0
08596:  CALL   563A
0859A:  MOVLW  89
0859C:  MOVWF  FE9
0859E:  MOVFF  F1,746
085A2:  MOVFF  F0,745
085A6:  MOVFF  EF,744
085AA:  MOVFF  EE,743
085AE:  MOVLW  02
085B0:  MOVLB  7
085B2:  MOVWF  x47
085B4:  MOVLB  0
085B6:  CALL   6516
085BA:  MOVLW  2C
085BC:  MOVLB  7
085BE:  MOVWF  x50
085C0:  MOVLB  0
085C2:  CALL   563A
....................    }
085C6:  BRA    8668
....................    else if (0 == strcmp(s_3V3D, arg1)) {
085C8:  MOVFF  734,742
085CC:  MOVFF  733,741
085D0:  MOVFF  70C,744
085D4:  MOVFF  70B,743
085D8:  CALL   56B8
085DC:  MOVF   01,F
085DE:  BNZ   8662
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
085E0:  MOVLW  04
085E2:  MOVLB  7
085E4:  MOVWF  x42
085E6:  MOVLW  C1
085E8:  MOVWF  x41
085EA:  MOVLB  0
085EC:  CALL   5602
085F0:  MOVFF  02,03
085F4:  MOVF   01,W
085F6:  ADDLW  C1
085F8:  MOVLB  7
085FA:  MOVWF  x3A
085FC:  MOVLW  04
085FE:  ADDWFC 02,W
08600:  MOVWF  x3B
08602:  MOVFF  FE8,565
08606:  MOVFF  73A,564
0860A:  MOVLW  89
0860C:  MOVWF  FE9
0860E:  MOVFF  F5,746
08612:  MOVFF  F4,745
08616:  MOVFF  F3,744
0861A:  MOVFF  F2,743
0861E:  MOVLW  02
08620:  MOVWF  x47
08622:  MOVLB  0
08624:  CALL   6516
08628:  MOVLW  2C
0862A:  MOVLB  7
0862C:  MOVWF  x50
0862E:  MOVLB  0
08630:  CALL   563A
08634:  MOVLW  89
08636:  MOVWF  FE9
08638:  MOVFF  F9,746
0863C:  MOVFF  F8,745
08640:  MOVFF  F7,744
08644:  MOVFF  F6,743
08648:  MOVLW  02
0864A:  MOVLB  7
0864C:  MOVWF  x47
0864E:  MOVLB  0
08650:  CALL   6516
08654:  MOVLW  2C
08656:  MOVLB  7
08658:  MOVWF  x50
0865A:  MOVLB  0
0865C:  CALL   563A
....................    }
08660:  BRA    8668
....................    else return INV_PARAM;
08662:  MOVLW  02
08664:  MOVWF  01
08666:  BRA    866C
....................    
....................    return SUCCESS;
08668:  MOVLW  00
0866A:  MOVWF  01
0866C:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
0866E:  MOVLW  00
08670:  MOVWF  01
08672:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08674:  MOVLW  4E
08676:  MOVLB  7
08678:  MOVWF  x0F
0867A:  MOVLW  31
0867C:  MOVWF  x10
0867E:  MOVLW  35
08680:  MOVWF  x11
08682:  CLRF   x12
08684:  MOVLW  07
08686:  MOVWF  x0E
08688:  MOVLW  0F
0868A:  MOVWF  x0D
....................    char *s_200 = "200";
0868C:  MOVLW  32
0868E:  MOVWF  x15
08690:  MOVLW  30
08692:  MOVWF  x16
08694:  MOVWF  x17
08696:  CLRF   x18
08698:  MOVLW  07
0869A:  MOVWF  x14
0869C:  MOVLW  15
0869E:  MOVWF  x13
....................    char *s_5V6 = "5V6";
086A0:  MOVLW  35
086A2:  MOVWF  x1B
086A4:  MOVLW  56
086A6:  MOVWF  x1C
086A8:  MOVLW  36
086AA:  MOVWF  x1D
086AC:  CLRF   x1E
086AE:  MOVLW  07
086B0:  MOVWF  x1A
086B2:  MOVLW  1B
086B4:  MOVWF  x19
....................    char *s_5VA = "5VA";
086B6:  MOVLW  35
086B8:  MOVWF  x21
086BA:  MOVLW  56
086BC:  MOVWF  x22
086BE:  MOVLW  41
086C0:  MOVWF  x23
086C2:  CLRF   x24
086C4:  MOVLW  07
086C6:  MOVWF  x20
086C8:  MOVLW  21
086CA:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
086CC:  MOVLW  33
086CE:  MOVWF  x27
086D0:  MOVLW  56
086D2:  MOVWF  x28
086D4:  MOVLW  36
086D6:  MOVWF  x29
086D8:  MOVLW  58
086DA:  MOVWF  x2A
086DC:  CLRF   x2B
086DE:  MOVLW  07
086E0:  MOVWF  x26
086E2:  MOVLW  27
086E4:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
086E6:  MOVLW  33
086E8:  MOVWF  x2E
086EA:  MOVLW  56
086EC:  MOVWF  x2F
086EE:  MOVLW  33
086F0:  MOVWF  x30
086F2:  MOVLW  41
086F4:  MOVWF  x31
086F6:  CLRF   x32
086F8:  MOVLW  07
086FA:  MOVWF  x2D
086FC:  MOVLW  2E
086FE:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
08700:  MOVLW  33
08702:  MOVWF  x35
08704:  MOVLW  56
08706:  MOVWF  x36
08708:  MOVLW  33
0870A:  MOVWF  x37
0870C:  MOVLW  44
0870E:  MOVWF  x38
08710:  CLRF   x39
08712:  MOVLW  07
08714:  MOVWF  x34
08716:  MOVLW  35
08718:  MOVWF  x33
....................    char *s_all = "all";
0871A:  MOVLW  61
0871C:  MOVWF  x3C
0871E:  MOVLW  6C
08720:  MOVWF  x3D
08722:  MOVWF  x3E
08724:  CLRF   x3F
08726:  MOVLW  07
08728:  MOVWF  x3B
0872A:  MOVLW  3C
0872C:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
0872E:  CLRF   x42
08730:  MOVFF  690,741
08734:  CLRF   x44
08736:  MOVLW  B5
08738:  MOVWF  x43
0873A:  MOVLB  0
0873C:  CALL   0880
08740:  MOVFF  02,741
08744:  MOVFF  01,740
08748:  MOVLW  06
0874A:  MOVLB  7
0874C:  ADDWF  x40,F
0874E:  MOVLW  00
08750:  ADDWFC x41,F
08752:  MOVLW  32
08754:  ADDWF  x40,W
08756:  MOVWF  01
08758:  MOVLW  00
0875A:  ADDWFC x41,W
0875C:  MOVWF  03
0875E:  MOVF   01,W
08760:  ADDLW  EB
08762:  MOVWF  01
08764:  MOVLW  01
08766:  ADDWFC 03,F
08768:  MOVFF  01,70B
0876C:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08770:  MOVFF  70E,742
08774:  MOVFF  70D,741
08778:  MOVFF  70C,744
0877C:  MOVFF  70B,743
08780:  MOVLB  0
08782:  CALL   56B8
08786:  MOVF   01,F
08788:  BNZ   87E0
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0878A:  MOVLW  04
0878C:  MOVLB  7
0878E:  MOVWF  x42
08790:  MOVLW  C1
08792:  MOVWF  x41
08794:  MOVLB  0
08796:  CALL   5602
0879A:  MOVFF  02,03
0879E:  MOVF   01,W
087A0:  ADDLW  C1
087A2:  MOVLB  7
087A4:  MOVWF  x40
087A6:  MOVLW  04
087A8:  ADDWFC 02,W
087AA:  MOVWF  x41
087AC:  MOVFF  FE8,565
087B0:  MOVFF  740,564
087B4:  MOVLW  89
087B6:  MOVWF  FE9
087B8:  MOVFF  FE,746
087BC:  MOVFF  FD,745
087C0:  MOVFF  FC,744
087C4:  MOVFF  FB,743
087C8:  MOVLW  02
087CA:  MOVWF  x47
087CC:  MOVLB  0
087CE:  CALL   6516
087D2:  MOVLW  2C
087D4:  MOVLB  7
087D6:  MOVWF  x50
087D8:  MOVLB  0
087DA:  CALL   563A
....................    }
087DE:  BRA    8CE2
....................    else if (0 == strcmp(s_200, arg1)) {
087E0:  MOVFF  714,742
087E4:  MOVFF  713,741
087E8:  MOVFF  70C,744
087EC:  MOVFF  70B,743
087F0:  CALL   56B8
087F4:  MOVF   01,F
087F6:  BNZ   884E
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
087F8:  MOVLW  04
087FA:  MOVLB  7
087FC:  MOVWF  x42
087FE:  MOVLW  C1
08800:  MOVWF  x41
08802:  MOVLB  0
08804:  CALL   5602
08808:  MOVFF  02,03
0880C:  MOVF   01,W
0880E:  ADDLW  C1
08810:  MOVLB  7
08812:  MOVWF  x40
08814:  MOVLW  04
08816:  ADDWFC 02,W
08818:  MOVWF  x41
0881A:  MOVFF  FE8,565
0881E:  MOVFF  740,564
08822:  MOVLW  89
08824:  MOVWF  FE9
08826:  MOVFF  102,746
0882A:  MOVFF  101,745
0882E:  MOVFF  100,744
08832:  MOVFF  FF,743
08836:  MOVLW  01
08838:  MOVWF  x47
0883A:  MOVLB  0
0883C:  CALL   6516
08840:  MOVLW  2C
08842:  MOVLB  7
08844:  MOVWF  x50
08846:  MOVLB  0
08848:  CALL   563A
....................    }
0884C:  BRA    8CE2
....................    else if (0 == strcmp(s_5V6, arg1)) {
0884E:  MOVFF  71A,742
08852:  MOVFF  719,741
08856:  MOVFF  70C,744
0885A:  MOVFF  70B,743
0885E:  CALL   56B8
08862:  MOVF   01,F
08864:  BNZ   88BC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08866:  MOVLW  04
08868:  MOVLB  7
0886A:  MOVWF  x42
0886C:  MOVLW  C1
0886E:  MOVWF  x41
08870:  MOVLB  0
08872:  CALL   5602
08876:  MOVFF  02,03
0887A:  MOVF   01,W
0887C:  ADDLW  C1
0887E:  MOVLB  7
08880:  MOVWF  x40
08882:  MOVLW  04
08884:  ADDWFC 02,W
08886:  MOVWF  x41
08888:  MOVFF  FE8,565
0888C:  MOVFF  740,564
08890:  MOVLW  89
08892:  MOVWF  FE9
08894:  MOVFF  106,746
08898:  MOVFF  105,745
0889C:  MOVFF  104,744
088A0:  MOVFF  103,743
088A4:  MOVLW  03
088A6:  MOVWF  x47
088A8:  MOVLB  0
088AA:  CALL   6516
088AE:  MOVLW  2C
088B0:  MOVLB  7
088B2:  MOVWF  x50
088B4:  MOVLB  0
088B6:  CALL   563A
....................    }
088BA:  BRA    8CE2
....................    else if (0 == strcmp(s_5VA, arg1)) {
088BC:  MOVFF  720,742
088C0:  MOVFF  71F,741
088C4:  MOVFF  70C,744
088C8:  MOVFF  70B,743
088CC:  CALL   56B8
088D0:  MOVF   01,F
088D2:  BNZ   892A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
088D4:  MOVLW  04
088D6:  MOVLB  7
088D8:  MOVWF  x42
088DA:  MOVLW  C1
088DC:  MOVWF  x41
088DE:  MOVLB  0
088E0:  CALL   5602
088E4:  MOVFF  02,03
088E8:  MOVF   01,W
088EA:  ADDLW  C1
088EC:  MOVLB  7
088EE:  MOVWF  x40
088F0:  MOVLW  04
088F2:  ADDWFC 02,W
088F4:  MOVWF  x41
088F6:  MOVFF  FE8,565
088FA:  MOVFF  740,564
088FE:  MOVLW  89
08900:  MOVWF  FE9
08902:  MOVFF  10A,746
08906:  MOVFF  109,745
0890A:  MOVFF  108,744
0890E:  MOVFF  107,743
08912:  MOVLW  03
08914:  MOVWF  x47
08916:  MOVLB  0
08918:  CALL   6516
0891C:  MOVLW  2C
0891E:  MOVLB  7
08920:  MOVWF  x50
08922:  MOVLB  0
08924:  CALL   563A
....................    }
08928:  BRA    8CE2
....................    else if (0 == strcmp(s_3V6X, arg1)) {
0892A:  MOVFF  726,742
0892E:  MOVFF  725,741
08932:  MOVFF  70C,744
08936:  MOVFF  70B,743
0893A:  CALL   56B8
0893E:  MOVF   01,F
08940:  BNZ   8998
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08942:  MOVLW  04
08944:  MOVLB  7
08946:  MOVWF  x42
08948:  MOVLW  C1
0894A:  MOVWF  x41
0894C:  MOVLB  0
0894E:  CALL   5602
08952:  MOVFF  02,03
08956:  MOVF   01,W
08958:  ADDLW  C1
0895A:  MOVLB  7
0895C:  MOVWF  x40
0895E:  MOVLW  04
08960:  ADDWFC 02,W
08962:  MOVWF  x41
08964:  MOVFF  FE8,565
08968:  MOVFF  740,564
0896C:  MOVLW  89
0896E:  MOVWF  FE9
08970:  MOVFF  10E,746
08974:  MOVFF  10D,745
08978:  MOVFF  10C,744
0897C:  MOVFF  10B,743
08980:  MOVLW  03
08982:  MOVWF  x47
08984:  MOVLB  0
08986:  CALL   6516
0898A:  MOVLW  2C
0898C:  MOVLB  7
0898E:  MOVWF  x50
08990:  MOVLB  0
08992:  CALL   563A
....................    }
08996:  BRA    8CE2
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08998:  MOVFF  72D,742
0899C:  MOVFF  72C,741
089A0:  MOVFF  70C,744
089A4:  MOVFF  70B,743
089A8:  CALL   56B8
089AC:  MOVF   01,F
089AE:  BNZ   8A06
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
089B0:  MOVLW  04
089B2:  MOVLB  7
089B4:  MOVWF  x42
089B6:  MOVLW  C1
089B8:  MOVWF  x41
089BA:  MOVLB  0
089BC:  CALL   5602
089C0:  MOVFF  02,03
089C4:  MOVF   01,W
089C6:  ADDLW  C1
089C8:  MOVLB  7
089CA:  MOVWF  x40
089CC:  MOVLW  04
089CE:  ADDWFC 02,W
089D0:  MOVWF  x41
089D2:  MOVFF  FE8,565
089D6:  MOVFF  740,564
089DA:  MOVLW  89
089DC:  MOVWF  FE9
089DE:  MOVFF  112,746
089E2:  MOVFF  111,745
089E6:  MOVFF  110,744
089EA:  MOVFF  10F,743
089EE:  MOVLW  03
089F0:  MOVWF  x47
089F2:  MOVLB  0
089F4:  CALL   6516
089F8:  MOVLW  2C
089FA:  MOVLB  7
089FC:  MOVWF  x50
089FE:  MOVLB  0
08A00:  CALL   563A
....................    }
08A04:  BRA    8CE2
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08A06:  MOVFF  734,742
08A0A:  MOVFF  733,741
08A0E:  MOVFF  70C,744
08A12:  MOVFF  70B,743
08A16:  CALL   56B8
08A1A:  MOVF   01,F
08A1C:  BNZ   8A74
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08A1E:  MOVLW  04
08A20:  MOVLB  7
08A22:  MOVWF  x42
08A24:  MOVLW  C1
08A26:  MOVWF  x41
08A28:  MOVLB  0
08A2A:  CALL   5602
08A2E:  MOVFF  02,03
08A32:  MOVF   01,W
08A34:  ADDLW  C1
08A36:  MOVLB  7
08A38:  MOVWF  x40
08A3A:  MOVLW  04
08A3C:  ADDWFC 02,W
08A3E:  MOVWF  x41
08A40:  MOVFF  FE8,565
08A44:  MOVFF  740,564
08A48:  MOVLW  89
08A4A:  MOVWF  FE9
08A4C:  MOVFF  116,746
08A50:  MOVFF  115,745
08A54:  MOVFF  114,744
08A58:  MOVFF  113,743
08A5C:  MOVLW  03
08A5E:  MOVWF  x47
08A60:  MOVLB  0
08A62:  CALL   6516
08A66:  MOVLW  2C
08A68:  MOVLB  7
08A6A:  MOVWF  x50
08A6C:  MOVLB  0
08A6E:  CALL   563A
....................    }
08A72:  BRA    8CE2
....................    else if (0 == strcmp(s_all, arg1)) {
08A74:  MOVFF  73B,742
08A78:  MOVFF  73A,741
08A7C:  MOVFF  70C,744
08A80:  MOVFF  70B,743
08A84:  CALL   56B8
08A88:  MOVF   01,F
08A8A:  BTFSS  FD8.2
08A8C:  BRA    8CDC
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08A8E:  MOVLW  04
08A90:  MOVLB  7
08A92:  MOVWF  x42
08A94:  MOVLW  C1
08A96:  MOVWF  x41
08A98:  MOVLB  0
08A9A:  CALL   5602
08A9E:  MOVFF  02,03
08AA2:  MOVF   01,W
08AA4:  ADDLW  C1
08AA6:  MOVLB  7
08AA8:  MOVWF  x40
08AAA:  MOVLW  04
08AAC:  ADDWFC 02,W
08AAE:  MOVWF  x41
08AB0:  MOVFF  FE8,565
08AB4:  MOVFF  740,564
08AB8:  MOVLW  89
08ABA:  MOVWF  FE9
08ABC:  MOVFF  FE,746
08AC0:  MOVFF  FD,745
08AC4:  MOVFF  FC,744
08AC8:  MOVFF  FB,743
08ACC:  MOVLW  02
08ACE:  MOVWF  x47
08AD0:  MOVLB  0
08AD2:  CALL   6516
08AD6:  MOVLW  2C
08AD8:  MOVLB  7
08ADA:  MOVWF  x50
08ADC:  MOVLB  0
08ADE:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08AE2:  MOVLW  04
08AE4:  MOVLB  7
08AE6:  MOVWF  x42
08AE8:  MOVLW  C1
08AEA:  MOVWF  x41
08AEC:  MOVLB  0
08AEE:  CALL   5602
08AF2:  MOVFF  02,03
08AF6:  MOVF   01,W
08AF8:  ADDLW  C1
08AFA:  MOVLB  7
08AFC:  MOVWF  x40
08AFE:  MOVLW  04
08B00:  ADDWFC 02,W
08B02:  MOVWF  x41
08B04:  MOVFF  FE8,565
08B08:  MOVFF  740,564
08B0C:  MOVLW  89
08B0E:  MOVWF  FE9
08B10:  MOVFF  102,746
08B14:  MOVFF  101,745
08B18:  MOVFF  100,744
08B1C:  MOVFF  FF,743
08B20:  MOVLW  01
08B22:  MOVWF  x47
08B24:  MOVLB  0
08B26:  CALL   6516
08B2A:  MOVLW  2C
08B2C:  MOVLB  7
08B2E:  MOVWF  x50
08B30:  MOVLB  0
08B32:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08B36:  MOVLW  04
08B38:  MOVLB  7
08B3A:  MOVWF  x42
08B3C:  MOVLW  C1
08B3E:  MOVWF  x41
08B40:  MOVLB  0
08B42:  CALL   5602
08B46:  MOVFF  02,03
08B4A:  MOVF   01,W
08B4C:  ADDLW  C1
08B4E:  MOVLB  7
08B50:  MOVWF  x40
08B52:  MOVLW  04
08B54:  ADDWFC 02,W
08B56:  MOVWF  x41
08B58:  MOVFF  FE8,565
08B5C:  MOVFF  740,564
08B60:  MOVLW  89
08B62:  MOVWF  FE9
08B64:  MOVFF  106,746
08B68:  MOVFF  105,745
08B6C:  MOVFF  104,744
08B70:  MOVFF  103,743
08B74:  MOVLW  03
08B76:  MOVWF  x47
08B78:  MOVLB  0
08B7A:  CALL   6516
08B7E:  MOVLW  2C
08B80:  MOVLB  7
08B82:  MOVWF  x50
08B84:  MOVLB  0
08B86:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08B8A:  MOVLW  04
08B8C:  MOVLB  7
08B8E:  MOVWF  x42
08B90:  MOVLW  C1
08B92:  MOVWF  x41
08B94:  MOVLB  0
08B96:  CALL   5602
08B9A:  MOVFF  02,03
08B9E:  MOVF   01,W
08BA0:  ADDLW  C1
08BA2:  MOVLB  7
08BA4:  MOVWF  x40
08BA6:  MOVLW  04
08BA8:  ADDWFC 02,W
08BAA:  MOVWF  x41
08BAC:  MOVFF  FE8,565
08BB0:  MOVFF  740,564
08BB4:  MOVLW  89
08BB6:  MOVWF  FE9
08BB8:  MOVFF  10A,746
08BBC:  MOVFF  109,745
08BC0:  MOVFF  108,744
08BC4:  MOVFF  107,743
08BC8:  MOVLW  03
08BCA:  MOVWF  x47
08BCC:  MOVLB  0
08BCE:  CALL   6516
08BD2:  MOVLW  2C
08BD4:  MOVLB  7
08BD6:  MOVWF  x50
08BD8:  MOVLB  0
08BDA:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08BDE:  MOVLW  04
08BE0:  MOVLB  7
08BE2:  MOVWF  x42
08BE4:  MOVLW  C1
08BE6:  MOVWF  x41
08BE8:  MOVLB  0
08BEA:  CALL   5602
08BEE:  MOVFF  02,03
08BF2:  MOVF   01,W
08BF4:  ADDLW  C1
08BF6:  MOVLB  7
08BF8:  MOVWF  x40
08BFA:  MOVLW  04
08BFC:  ADDWFC 02,W
08BFE:  MOVWF  x41
08C00:  MOVFF  FE8,565
08C04:  MOVFF  740,564
08C08:  MOVLW  89
08C0A:  MOVWF  FE9
08C0C:  MOVFF  10E,746
08C10:  MOVFF  10D,745
08C14:  MOVFF  10C,744
08C18:  MOVFF  10B,743
08C1C:  MOVLW  03
08C1E:  MOVWF  x47
08C20:  MOVLB  0
08C22:  CALL   6516
08C26:  MOVLW  2C
08C28:  MOVLB  7
08C2A:  MOVWF  x50
08C2C:  MOVLB  0
08C2E:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08C32:  MOVLW  04
08C34:  MOVLB  7
08C36:  MOVWF  x42
08C38:  MOVLW  C1
08C3A:  MOVWF  x41
08C3C:  MOVLB  0
08C3E:  CALL   5602
08C42:  MOVFF  02,03
08C46:  MOVF   01,W
08C48:  ADDLW  C1
08C4A:  MOVLB  7
08C4C:  MOVWF  x40
08C4E:  MOVLW  04
08C50:  ADDWFC 02,W
08C52:  MOVWF  x41
08C54:  MOVFF  FE8,565
08C58:  MOVFF  740,564
08C5C:  MOVLW  89
08C5E:  MOVWF  FE9
08C60:  MOVFF  112,746
08C64:  MOVFF  111,745
08C68:  MOVFF  110,744
08C6C:  MOVFF  10F,743
08C70:  MOVLW  03
08C72:  MOVWF  x47
08C74:  MOVLB  0
08C76:  CALL   6516
08C7A:  MOVLW  2C
08C7C:  MOVLB  7
08C7E:  MOVWF  x50
08C80:  MOVLB  0
08C82:  CALL   563A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08C86:  MOVLW  04
08C88:  MOVLB  7
08C8A:  MOVWF  x42
08C8C:  MOVLW  C1
08C8E:  MOVWF  x41
08C90:  MOVLB  0
08C92:  CALL   5602
08C96:  MOVFF  02,03
08C9A:  MOVF   01,W
08C9C:  ADDLW  C1
08C9E:  MOVLB  7
08CA0:  MOVWF  x40
08CA2:  MOVLW  04
08CA4:  ADDWFC 02,W
08CA6:  MOVWF  x41
08CA8:  MOVFF  FE8,565
08CAC:  MOVFF  740,564
08CB0:  MOVLW  89
08CB2:  MOVWF  FE9
08CB4:  MOVFF  116,746
08CB8:  MOVFF  115,745
08CBC:  MOVFF  114,744
08CC0:  MOVFF  113,743
08CC4:  MOVLW  03
08CC6:  MOVWF  x47
08CC8:  MOVLB  0
08CCA:  CALL   6516
08CCE:  MOVLW  2C
08CD0:  MOVLB  7
08CD2:  MOVWF  x50
08CD4:  MOVLB  0
08CD6:  CALL   563A
....................    }
08CDA:  BRA    8CE2
....................    else return INV_PARAM;
08CDC:  MOVLW  02
08CDE:  MOVWF  01
08CE0:  BRA    8CE6
....................    
....................    return SUCCESS;
08CE2:  MOVLW  00
08CE4:  MOVWF  01
08CE6:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08CE8:  MOVLW  50
08CEA:  MOVLB  7
08CEC:  MOVWF  x10
08CEE:  MOVLW  56
08CF0:  MOVWF  x11
08CF2:  CLRF   x12
08CF4:  MOVLW  07
08CF6:  MOVWF  x0F
08CF8:  MOVLW  10
08CFA:  MOVWF  x0E
....................    char *s_CV = "CV";
08CFC:  MOVLW  43
08CFE:  MOVWF  x15
08D00:  MOVLW  56
08D02:  MOVWF  x16
08D04:  CLRF   x17
08D06:  MOVLW  07
08D08:  MOVWF  x14
08D0A:  MOVLW  15
08D0C:  MOVWF  x13
....................    char *s_PVold = "PVold";
08D0E:  MOVLW  50
08D10:  MOVWF  x1A
08D12:  MOVLW  56
08D14:  MOVWF  x1B
08D16:  MOVLW  6F
08D18:  MOVWF  x1C
08D1A:  MOVLW  6C
08D1C:  MOVWF  x1D
08D1E:  MOVLW  64
08D20:  MOVWF  x1E
08D22:  CLRF   x1F
08D24:  MOVLW  07
08D26:  MOVWF  x19
08D28:  MOVLW  1A
08D2A:  MOVWF  x18
....................    char *s_I = "I";
08D2C:  MOVLW  49
08D2E:  MOVWF  x22
08D30:  CLRF   x23
08D32:  MOVLW  07
08D34:  MOVWF  x21
08D36:  MOVLW  22
08D38:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08D3A:  CLRF   x42
08D3C:  MOVFF  690,741
08D40:  CLRF   x44
08D42:  MOVLW  B5
08D44:  MOVWF  x43
08D46:  MOVLB  0
08D48:  CALL   0880
08D4C:  MOVFF  02,725
08D50:  MOVFF  01,724
08D54:  MOVLW  06
08D56:  MOVLB  7
08D58:  ADDWF  x24,F
08D5A:  MOVLW  00
08D5C:  ADDWFC x25,F
08D5E:  MOVLW  32
08D60:  ADDWF  x24,W
08D62:  MOVWF  01
08D64:  MOVLW  00
08D66:  ADDWFC x25,W
08D68:  MOVWF  03
08D6A:  MOVF   01,W
08D6C:  ADDLW  EB
08D6E:  MOVWF  01
08D70:  MOVLW  01
08D72:  ADDWFC 03,F
08D74:  MOVFF  01,724
08D78:  MOVFF  03,725
08D7C:  MOVFF  03,734
08D80:  MOVFF  01,733
08D84:  MOVLB  0
08D86:  CALL   57D8
08D8A:  MOVF   01,F
08D8C:  BNZ   8D96
08D8E:  MOVLW  02
08D90:  MOVWF  01
08D92:  BRA    912C
08D94:  BRA    8DF4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08D96:  MOVLB  7
08D98:  CLRF   x42
08D9A:  MOVFF  690,741
08D9E:  CLRF   x44
08DA0:  MOVLW  B5
08DA2:  MOVWF  x43
08DA4:  MOVLB  0
08DA6:  CALL   0880
08DAA:  MOVFF  02,725
08DAE:  MOVFF  01,724
08DB2:  MOVLW  06
08DB4:  MOVLB  7
08DB6:  ADDWF  x24,F
08DB8:  MOVLW  00
08DBA:  ADDWFC x25,F
08DBC:  MOVLW  32
08DBE:  ADDWF  x24,W
08DC0:  MOVWF  01
08DC2:  MOVLW  00
08DC4:  ADDWFC x25,W
08DC6:  MOVWF  03
08DC8:  MOVF   01,W
08DCA:  ADDLW  EB
08DCC:  MOVWF  01
08DCE:  MOVLW  01
08DD0:  ADDWFC 03,F
08DD2:  MOVFF  01,724
08DD6:  MOVFF  03,725
08DDA:  MOVFF  03,734
08DDE:  MOVFF  01,733
08DE2:  CLRF   x36
08DE4:  CLRF   x35
08DE6:  MOVLW  0A
08DE8:  MOVWF  x37
08DEA:  MOVLB  0
08DEC:  CALL   58C8
08DF0:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08DF4:  MOVLB  7
08DF6:  CLRF   x42
08DF8:  MOVFF  690,741
08DFC:  CLRF   x44
08DFE:  MOVLW  B5
08E00:  MOVWF  x43
08E02:  MOVLB  0
08E04:  CALL   0880
08E08:  MOVFF  02,725
08E0C:  MOVFF  01,724
08E10:  MOVLW  06
08E12:  MOVLB  7
08E14:  ADDWF  x24,F
08E16:  MOVLW  00
08E18:  ADDWFC x25,F
08E1A:  MOVLW  4B
08E1C:  ADDWF  x24,W
08E1E:  MOVWF  01
08E20:  MOVLW  00
08E22:  ADDWFC x25,W
08E24:  MOVWF  03
08E26:  MOVF   01,W
08E28:  ADDLW  EB
08E2A:  MOVWF  01
08E2C:  MOVLW  01
08E2E:  ADDWFC 03,F
08E30:  MOVFF  01,70C
08E34:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08E38:  MOVFF  70F,742
08E3C:  MOVFF  70E,741
08E40:  MOVFF  70D,744
08E44:  MOVFF  70C,743
08E48:  MOVLB  0
08E4A:  CALL   56B8
08E4E:  MOVF   01,F
08E50:  BNZ   8EF4
08E52:  MOVLW  04
08E54:  MOVLB  7
08E56:  MOVWF  x42
08E58:  MOVLW  C1
08E5A:  MOVWF  x41
08E5C:  MOVLB  0
08E5E:  CALL   5602
08E62:  MOVF   01,W
08E64:  ADDLW  C1
08E66:  MOVLB  7
08E68:  MOVWF  x24
08E6A:  MOVLW  04
08E6C:  ADDWFC 02,W
08E6E:  MOVWF  x25
08E70:  MOVLW  01
08E72:  SUBWF  x0B,W
08E74:  MULLW  28
08E76:  MOVF   FF3,W
08E78:  CLRF   x27
08E7A:  MOVWF  x26
08E7C:  MOVLW  10
08E7E:  ADDWF  x26,W
08E80:  MOVWF  01
08E82:  MOVLW  00
08E84:  ADDWFC x27,W
08E86:  MOVWF  03
08E88:  MOVF   01,W
08E8A:  ADDLW  20
08E8C:  MOVWF  FE9
08E8E:  MOVLW  00
08E90:  ADDWFC 03,W
08E92:  MOVWF  FEA
08E94:  MOVFF  FEF,726
08E98:  MOVFF  FEC,727
08E9C:  MOVFF  FEC,728
08EA0:  MOVFF  FEC,729
08EA4:  MOVFF  725,565
08EA8:  MOVFF  724,564
08EAC:  MOVFF  70B,734
08EB0:  MOVLW  18
08EB2:  MOVWF  x35
08EB4:  MOVLB  0
08EB6:  CALL   5C1C
08EBA:  MOVLW  2C
08EBC:  MOVLB  7
08EBE:  MOVWF  x50
08EC0:  MOVLB  0
08EC2:  CALL   563A
08EC6:  MOVLW  89
08EC8:  MOVWF  FE9
08ECA:  MOVFF  729,746
08ECE:  MOVFF  728,745
08ED2:  MOVFF  727,744
08ED6:  MOVFF  726,743
08EDA:  MOVLW  02
08EDC:  MOVLB  7
08EDE:  MOVWF  x47
08EE0:  MOVLB  0
08EE2:  CALL   6516
08EE6:  MOVLW  2C
08EE8:  MOVLB  7
08EEA:  MOVWF  x50
08EEC:  MOVLB  0
08EEE:  CALL   563A
08EF2:  BRA    9128
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
08EF4:  MOVFF  714,742
08EF8:  MOVFF  713,741
08EFC:  MOVFF  70D,744
08F00:  MOVFF  70C,743
08F04:  CALL   56B8
08F08:  MOVF   01,F
08F0A:  BNZ   8FAE
08F0C:  MOVLW  04
08F0E:  MOVLB  7
08F10:  MOVWF  x42
08F12:  MOVLW  C1
08F14:  MOVWF  x41
08F16:  MOVLB  0
08F18:  CALL   5602
08F1C:  MOVF   01,W
08F1E:  ADDLW  C1
08F20:  MOVLB  7
08F22:  MOVWF  x24
08F24:  MOVLW  04
08F26:  ADDWFC 02,W
08F28:  MOVWF  x25
08F2A:  MOVLW  01
08F2C:  SUBWF  x0B,W
08F2E:  MULLW  28
08F30:  MOVF   FF3,W
08F32:  CLRF   x27
08F34:  MOVWF  x26
08F36:  MOVLW  18
08F38:  ADDWF  x26,W
08F3A:  MOVWF  01
08F3C:  MOVLW  00
08F3E:  ADDWFC x27,W
08F40:  MOVWF  03
08F42:  MOVF   01,W
08F44:  ADDLW  20
08F46:  MOVWF  FE9
08F48:  MOVLW  00
08F4A:  ADDWFC 03,W
08F4C:  MOVWF  FEA
08F4E:  MOVFF  FEF,726
08F52:  MOVFF  FEC,727
08F56:  MOVFF  FEC,728
08F5A:  MOVFF  FEC,729
08F5E:  MOVFF  725,565
08F62:  MOVFF  724,564
08F66:  MOVFF  70B,734
08F6A:  MOVLW  18
08F6C:  MOVWF  x35
08F6E:  MOVLB  0
08F70:  CALL   5C1C
08F74:  MOVLW  2C
08F76:  MOVLB  7
08F78:  MOVWF  x50
08F7A:  MOVLB  0
08F7C:  CALL   563A
08F80:  MOVLW  89
08F82:  MOVWF  FE9
08F84:  MOVFF  729,746
08F88:  MOVFF  728,745
08F8C:  MOVFF  727,744
08F90:  MOVFF  726,743
08F94:  MOVLW  02
08F96:  MOVLB  7
08F98:  MOVWF  x47
08F9A:  MOVLB  0
08F9C:  CALL   6516
08FA0:  MOVLW  2C
08FA2:  MOVLB  7
08FA4:  MOVWF  x50
08FA6:  MOVLB  0
08FA8:  CALL   563A
08FAC:  BRA    9128
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08FAE:  MOVFF  719,742
08FB2:  MOVFF  718,741
08FB6:  MOVFF  70D,744
08FBA:  MOVFF  70C,743
08FBE:  CALL   56B8
08FC2:  MOVF   01,F
08FC4:  BNZ   9068
08FC6:  MOVLW  04
08FC8:  MOVLB  7
08FCA:  MOVWF  x42
08FCC:  MOVLW  C1
08FCE:  MOVWF  x41
08FD0:  MOVLB  0
08FD2:  CALL   5602
08FD6:  MOVF   01,W
08FD8:  ADDLW  C1
08FDA:  MOVLB  7
08FDC:  MOVWF  x24
08FDE:  MOVLW  04
08FE0:  ADDWFC 02,W
08FE2:  MOVWF  x25
08FE4:  MOVLW  01
08FE6:  SUBWF  x0B,W
08FE8:  MULLW  28
08FEA:  MOVF   FF3,W
08FEC:  CLRF   x27
08FEE:  MOVWF  x26
08FF0:  MOVLW  14
08FF2:  ADDWF  x26,W
08FF4:  MOVWF  01
08FF6:  MOVLW  00
08FF8:  ADDWFC x27,W
08FFA:  MOVWF  03
08FFC:  MOVF   01,W
08FFE:  ADDLW  20
09000:  MOVWF  FE9
09002:  MOVLW  00
09004:  ADDWFC 03,W
09006:  MOVWF  FEA
09008:  MOVFF  FEF,726
0900C:  MOVFF  FEC,727
09010:  MOVFF  FEC,728
09014:  MOVFF  FEC,729
09018:  MOVFF  725,565
0901C:  MOVFF  724,564
09020:  MOVFF  70B,734
09024:  MOVLW  18
09026:  MOVWF  x35
09028:  MOVLB  0
0902A:  CALL   5C1C
0902E:  MOVLW  2C
09030:  MOVLB  7
09032:  MOVWF  x50
09034:  MOVLB  0
09036:  CALL   563A
0903A:  MOVLW  89
0903C:  MOVWF  FE9
0903E:  MOVFF  729,746
09042:  MOVFF  728,745
09046:  MOVFF  727,744
0904A:  MOVFF  726,743
0904E:  MOVLW  02
09050:  MOVLB  7
09052:  MOVWF  x47
09054:  MOVLB  0
09056:  CALL   6516
0905A:  MOVLW  2C
0905C:  MOVLB  7
0905E:  MOVWF  x50
09060:  MOVLB  0
09062:  CALL   563A
09066:  BRA    9128
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
09068:  MOVFF  721,742
0906C:  MOVFF  720,741
09070:  MOVFF  70D,744
09074:  MOVFF  70C,743
09078:  CALL   56B8
0907C:  MOVF   01,F
0907E:  BNZ   9122
09080:  MOVLW  04
09082:  MOVLB  7
09084:  MOVWF  x42
09086:  MOVLW  C1
09088:  MOVWF  x41
0908A:  MOVLB  0
0908C:  CALL   5602
09090:  MOVF   01,W
09092:  ADDLW  C1
09094:  MOVLB  7
09096:  MOVWF  x24
09098:  MOVLW  04
0909A:  ADDWFC 02,W
0909C:  MOVWF  x25
0909E:  MOVLW  01
090A0:  SUBWF  x0B,W
090A2:  MULLW  28
090A4:  MOVF   FF3,W
090A6:  CLRF   x27
090A8:  MOVWF  x26
090AA:  MOVLW  1C
090AC:  ADDWF  x26,W
090AE:  MOVWF  01
090B0:  MOVLW  00
090B2:  ADDWFC x27,W
090B4:  MOVWF  03
090B6:  MOVF   01,W
090B8:  ADDLW  20
090BA:  MOVWF  FE9
090BC:  MOVLW  00
090BE:  ADDWFC 03,W
090C0:  MOVWF  FEA
090C2:  MOVFF  FEF,726
090C6:  MOVFF  FEC,727
090CA:  MOVFF  FEC,728
090CE:  MOVFF  FEC,729
090D2:  MOVFF  725,565
090D6:  MOVFF  724,564
090DA:  MOVFF  70B,734
090DE:  MOVLW  18
090E0:  MOVWF  x35
090E2:  MOVLB  0
090E4:  CALL   5C1C
090E8:  MOVLW  2C
090EA:  MOVLB  7
090EC:  MOVWF  x50
090EE:  MOVLB  0
090F0:  CALL   563A
090F4:  MOVLW  89
090F6:  MOVWF  FE9
090F8:  MOVFF  729,746
090FC:  MOVFF  728,745
09100:  MOVFF  727,744
09104:  MOVFF  726,743
09108:  MOVLW  02
0910A:  MOVLB  7
0910C:  MOVWF  x47
0910E:  MOVLB  0
09110:  CALL   6516
09114:  MOVLW  2C
09116:  MOVLB  7
09118:  MOVWF  x50
0911A:  MOVLB  0
0911C:  CALL   563A
09120:  BRA    9128
....................    else return INV_PARAM;
09122:  MOVLW  02
09124:  MOVWF  01
09126:  BRA    912C
....................    
....................    return SUCCESS;
09128:  MOVLW  00
0912A:  MOVWF  01
0912C:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
0924C:  MOVLW  72
0924E:  MOVLB  7
09250:  MOVWF  x10
09252:  MOVLW  61
09254:  MOVWF  x11
09256:  MOVLW  77
09258:  MOVWF  x12
0925A:  CLRF   x13
0925C:  MOVLW  07
0925E:  MOVWF  x0F
09260:  MOVLW  10
09262:  MOVWF  x0E
....................    char *s_calibrated = "calib";
09264:  MOVLW  63
09266:  MOVWF  x16
09268:  MOVLW  61
0926A:  MOVWF  x17
0926C:  MOVLW  6C
0926E:  MOVWF  x18
09270:  MOVLW  69
09272:  MOVWF  x19
09274:  MOVLW  62
09276:  MOVWF  x1A
09278:  CLRF   x1B
0927A:  MOVLW  07
0927C:  MOVWF  x15
0927E:  MOVLW  16
09280:  MOVWF  x14
....................    char *s_p0 = "p0";
09282:  MOVLW  70
09284:  MOVWF  x1E
09286:  MOVLW  30
09288:  MOVWF  x1F
0928A:  CLRF   x20
0928C:  MOVLW  07
0928E:  MOVWF  x1D
09290:  MOVLW  1E
09292:  MOVWF  x1C
....................    char *s_poles = "poles";
09294:  MOVLW  70
09296:  MOVWF  x23
09298:  MOVLW  6F
0929A:  MOVWF  x24
0929C:  MOVLW  6C
0929E:  MOVWF  x25
092A0:  MOVLW  65
092A2:  MOVWF  x26
092A4:  MOVLW  73
092A6:  MOVWF  x27
092A8:  CLRF   x28
092AA:  MOVLW  07
092AC:  MOVWF  x22
092AE:  MOVLW  23
092B0:  MOVWF  x21
....................    char *s_real = "real";
092B2:  MOVLW  72
092B4:  MOVWF  x2B
092B6:  MOVLW  65
092B8:  MOVWF  x2C
092BA:  MOVLW  61
092BC:  MOVWF  x2D
092BE:  MOVLW  6C
092C0:  MOVWF  x2E
092C2:  CLRF   x2F
092C4:  MOVLW  07
092C6:  MOVWF  x2A
092C8:  MOVLW  2B
092CA:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
092CC:  CLRF   x42
092CE:  MOVFF  690,741
092D2:  CLRF   x44
092D4:  MOVLW  B5
092D6:  MOVWF  x43
092D8:  MOVLB  0
092DA:  CALL   0880
092DE:  MOVFF  02,731
092E2:  MOVFF  01,730
092E6:  MOVLW  06
092E8:  MOVLB  7
092EA:  ADDWF  x30,F
092EC:  MOVLW  00
092EE:  ADDWFC x31,F
092F0:  MOVLW  32
092F2:  ADDWF  x30,W
092F4:  MOVWF  01
092F6:  MOVLW  00
092F8:  ADDWFC x31,W
092FA:  MOVWF  03
092FC:  MOVF   01,W
092FE:  ADDLW  EB
09300:  MOVWF  01
09302:  MOVLW  01
09304:  ADDWFC 03,F
09306:  MOVFF  01,730
0930A:  MOVFF  03,731
0930E:  MOVFF  03,734
09312:  MOVFF  01,733
09316:  MOVLB  0
09318:  CALL   57D8
0931C:  MOVF   01,F
0931E:  BNZ   9328
09320:  MOVLW  02
09322:  MOVWF  01
09324:  BRA    996C
09326:  BRA    9386
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09328:  MOVLB  7
0932A:  CLRF   x42
0932C:  MOVFF  690,741
09330:  CLRF   x44
09332:  MOVLW  B5
09334:  MOVWF  x43
09336:  MOVLB  0
09338:  CALL   0880
0933C:  MOVFF  02,731
09340:  MOVFF  01,730
09344:  MOVLW  06
09346:  MOVLB  7
09348:  ADDWF  x30,F
0934A:  MOVLW  00
0934C:  ADDWFC x31,F
0934E:  MOVLW  32
09350:  ADDWF  x30,W
09352:  MOVWF  01
09354:  MOVLW  00
09356:  ADDWFC x31,W
09358:  MOVWF  03
0935A:  MOVF   01,W
0935C:  ADDLW  EB
0935E:  MOVWF  01
09360:  MOVLW  01
09362:  ADDWFC 03,F
09364:  MOVFF  01,730
09368:  MOVFF  03,731
0936C:  MOVFF  03,734
09370:  MOVFF  01,733
09374:  CLRF   x36
09376:  CLRF   x35
09378:  MOVLW  0A
0937A:  MOVWF  x37
0937C:  MOVLB  0
0937E:  CALL   58C8
09382:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
09386:  MOVLB  7
09388:  CLRF   x42
0938A:  MOVFF  690,741
0938E:  CLRF   x44
09390:  MOVLW  B5
09392:  MOVWF  x43
09394:  MOVLB  0
09396:  CALL   0880
0939A:  MOVFF  02,731
0939E:  MOVFF  01,730
093A2:  MOVLW  06
093A4:  MOVLB  7
093A6:  ADDWF  x30,F
093A8:  MOVLW  00
093AA:  ADDWFC x31,F
093AC:  MOVLW  4B
093AE:  ADDWF  x30,W
093B0:  MOVWF  01
093B2:  MOVLW  00
093B4:  ADDWFC x31,W
093B6:  MOVWF  03
093B8:  MOVF   01,W
093BA:  ADDLW  EB
093BC:  MOVWF  01
093BE:  MOVLW  01
093C0:  ADDWFC 03,F
093C2:  MOVFF  01,70C
093C6:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
093CA:  MOVFF  70F,742
093CE:  MOVFF  70E,741
093D2:  MOVFF  70D,744
093D6:  MOVFF  70C,743
093DA:  MOVLB  0
093DC:  CALL   56B8
093E0:  MOVF   01,F
093E2:  BTFSS  FD8.2
093E4:  BRA    9560
....................       sprintf(retData+strlen(retData), "%d,", arg1);
093E6:  MOVLW  04
093E8:  MOVLB  7
093EA:  MOVWF  x42
093EC:  MOVLW  C1
093EE:  MOVWF  x41
093F0:  MOVLB  0
093F2:  CALL   5602
093F6:  MOVFF  02,03
093FA:  MOVF   01,W
093FC:  ADDLW  C1
093FE:  MOVLB  7
09400:  MOVWF  x30
09402:  MOVLW  04
09404:  ADDWFC 02,W
09406:  MOVWF  x31
09408:  MOVFF  FE8,565
0940C:  MOVFF  730,564
09410:  MOVFF  70B,734
09414:  MOVLW  18
09416:  MOVWF  x35
09418:  MOVLB  0
0941A:  CALL   5C1C
0941E:  MOVLW  2C
09420:  MOVLB  7
09422:  MOVWF  x50
09424:  MOVLB  0
09426:  CALL   563A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
0942A:  MOVLW  04
0942C:  MOVLB  7
0942E:  MOVWF  x42
09430:  MOVLW  C1
09432:  MOVWF  x41
09434:  MOVLB  0
09436:  CALL   5602
0943A:  MOVFF  02,03
0943E:  MOVF   01,W
09440:  ADDLW  C1
09442:  MOVLB  7
09444:  MOVWF  x30
09446:  MOVLW  04
09448:  ADDWFC 02,W
0944A:  MOVWF  x31
0944C:  MOVLW  01
0944E:  SUBWF  x0B,W
09450:  MULLW  26
09452:  MOVF   FF3,W
09454:  CLRF   x33
09456:  MOVWF  x32
09458:  MOVLW  17
0945A:  ADDWF  x32,W
0945C:  MOVWF  FE9
0945E:  MOVLW  01
09460:  ADDWFC x33,W
09462:  MOVWF  FEA
09464:  MOVFF  FEF,750
09468:  MOVFF  FEC,01
0946C:  MOVFF  FEC,02
09470:  MOVFF  FEC,03
09474:  MOVFF  03,753
09478:  MOVFF  02,752
0947C:  MOVFF  01,751
09480:  MOVLB  0
09482:  CALL   6440
09486:  MOVFF  03,737
0948A:  MOVFF  02,736
0948E:  MOVFF  01,735
09492:  MOVFF  00,734
09496:  MOVFF  731,565
0949A:  MOVFF  730,564
0949E:  MOVLW  41
094A0:  MOVWF  FE9
094A2:  MOVFF  03,73C
094A6:  MOVFF  02,73B
094AA:  MOVFF  01,73A
094AE:  MOVFF  00,739
094B2:  RCALL  912E
094B4:  MOVLW  2C
094B6:  MOVLB  7
094B8:  MOVWF  x50
094BA:  MOVLB  0
094BC:  CALL   563A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
094C0:  MOVLW  04
094C2:  MOVLB  7
094C4:  MOVWF  x42
094C6:  MOVLW  C1
094C8:  MOVWF  x41
094CA:  MOVLB  0
094CC:  CALL   5602
094D0:  MOVF   01,W
094D2:  ADDLW  C1
094D4:  MOVLB  7
094D6:  MOVWF  x30
094D8:  MOVLW  04
094DA:  ADDWFC 02,W
094DC:  MOVWF  x31
094DE:  MOVLW  01
094E0:  SUBWF  x0B,W
094E2:  MULLW  26
094E4:  MOVF   FF3,W
094E6:  CLRF   x33
094E8:  MOVWF  x32
094EA:  MOVLW  04
094EC:  ADDWF  x32,W
094EE:  MOVWF  01
094F0:  MOVLW  00
094F2:  ADDWFC x33,W
094F4:  MOVWF  03
094F6:  MOVF   01,W
094F8:  ADDLW  17
094FA:  MOVWF  FE9
094FC:  MOVLW  01
094FE:  ADDWFC 03,W
09500:  MOVWF  FEA
09502:  MOVFF  FEF,750
09506:  MOVFF  FEC,01
0950A:  MOVFF  FEC,02
0950E:  MOVFF  FEC,03
09512:  MOVFF  03,753
09516:  MOVFF  02,752
0951A:  MOVFF  01,751
0951E:  MOVLB  0
09520:  CALL   6440
09524:  MOVFF  03,735
09528:  MOVFF  02,734
0952C:  MOVFF  01,733
09530:  MOVFF  00,732
09534:  MOVFF  731,565
09538:  MOVFF  730,564
0953C:  MOVLW  41
0953E:  MOVWF  FE9
09540:  MOVFF  03,73C
09544:  MOVFF  02,73B
09548:  MOVFF  01,73A
0954C:  MOVFF  00,739
09550:  RCALL  912E
09552:  MOVLW  2C
09554:  MOVLB  7
09556:  MOVWF  x50
09558:  MOVLB  0
0955A:  CALL   563A
....................    }
0955E:  BRA    9968
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09560:  MOVFF  715,742
09564:  MOVFF  714,741
09568:  MOVFF  70D,744
0956C:  MOVFF  70C,743
09570:  CALL   56B8
09574:  MOVF   01,F
09576:  BTFSS  FD8.2
09578:  BRA    96FC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0957A:  MOVLW  04
0957C:  MOVLB  7
0957E:  MOVWF  x42
09580:  MOVLW  C1
09582:  MOVWF  x41
09584:  MOVLB  0
09586:  CALL   5602
0958A:  MOVFF  02,03
0958E:  MOVF   01,W
09590:  ADDLW  C1
09592:  MOVLB  7
09594:  MOVWF  x30
09596:  MOVLW  04
09598:  ADDWFC 02,W
0959A:  MOVWF  x31
0959C:  MOVFF  FE8,565
095A0:  MOVFF  730,564
095A4:  MOVFF  70B,734
095A8:  MOVLW  18
095AA:  MOVWF  x35
095AC:  MOVLB  0
095AE:  CALL   5C1C
095B2:  MOVLW  2C
095B4:  MOVLB  7
095B6:  MOVWF  x50
095B8:  MOVLB  0
095BA:  CALL   563A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
095BE:  MOVLW  04
095C0:  MOVLB  7
095C2:  MOVWF  x42
095C4:  MOVLW  C1
095C6:  MOVWF  x41
095C8:  MOVLB  0
095CA:  CALL   5602
095CE:  MOVF   01,W
095D0:  ADDLW  C1
095D2:  MOVLB  7
095D4:  MOVWF  x30
095D6:  MOVLW  04
095D8:  ADDWFC 02,W
095DA:  MOVWF  x31
095DC:  MOVLW  01
095DE:  SUBWF  x0B,W
095E0:  MULLW  26
095E2:  MOVF   FF3,W
095E4:  CLRF   x33
095E6:  MOVWF  x32
095E8:  MOVLW  08
095EA:  ADDWF  x32,W
095EC:  MOVWF  01
095EE:  MOVLW  00
095F0:  ADDWFC x33,W
095F2:  MOVWF  03
095F4:  MOVF   01,W
095F6:  ADDLW  17
095F8:  MOVWF  FE9
095FA:  MOVLW  01
095FC:  ADDWFC 03,W
095FE:  MOVWF  FEA
09600:  MOVFF  FEF,750
09604:  MOVFF  FEC,01
09608:  MOVFF  FEC,02
0960C:  MOVFF  FEC,03
09610:  MOVFF  03,753
09614:  MOVFF  02,752
09618:  MOVFF  01,751
0961C:  MOVLB  0
0961E:  CALL   6440
09622:  MOVFF  03,735
09626:  MOVFF  02,734
0962A:  MOVFF  01,733
0962E:  MOVFF  00,732
09632:  MOVFF  731,565
09636:  MOVFF  730,564
0963A:  MOVLW  41
0963C:  MOVWF  FE9
0963E:  MOVFF  03,73C
09642:  MOVFF  02,73B
09646:  MOVFF  01,73A
0964A:  MOVFF  00,739
0964E:  RCALL  912E
09650:  MOVLW  2C
09652:  MOVLB  7
09654:  MOVWF  x50
09656:  MOVLB  0
09658:  CALL   563A
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
0965C:  MOVLW  04
0965E:  MOVLB  7
09660:  MOVWF  x42
09662:  MOVLW  C1
09664:  MOVWF  x41
09666:  MOVLB  0
09668:  CALL   5602
0966C:  MOVF   01,W
0966E:  ADDLW  C1
09670:  MOVLB  7
09672:  MOVWF  x30
09674:  MOVLW  04
09676:  ADDWFC 02,W
09678:  MOVWF  x31
0967A:  MOVLW  01
0967C:  SUBWF  x0B,W
0967E:  MULLW  26
09680:  MOVF   FF3,W
09682:  CLRF   x33
09684:  MOVWF  x32
09686:  MOVLW  0C
09688:  ADDWF  x32,W
0968A:  MOVWF  01
0968C:  MOVLW  00
0968E:  ADDWFC x33,W
09690:  MOVWF  03
09692:  MOVF   01,W
09694:  ADDLW  17
09696:  MOVWF  FE9
09698:  MOVLW  01
0969A:  ADDWFC 03,W
0969C:  MOVWF  FEA
0969E:  MOVFF  FEF,750
096A2:  MOVFF  FEC,01
096A6:  MOVFF  FEC,02
096AA:  MOVFF  FEC,03
096AE:  MOVFF  03,753
096B2:  MOVFF  02,752
096B6:  MOVFF  01,751
096BA:  MOVLB  0
096BC:  CALL   6440
096C0:  MOVFF  03,735
096C4:  MOVFF  02,734
096C8:  MOVFF  01,733
096CC:  MOVFF  00,732
096D0:  MOVFF  731,565
096D4:  MOVFF  730,564
096D8:  MOVLW  41
096DA:  MOVWF  FE9
096DC:  MOVFF  03,73C
096E0:  MOVFF  02,73B
096E4:  MOVFF  01,73A
096E8:  MOVFF  00,739
096EC:  RCALL  912E
096EE:  MOVLW  2C
096F0:  MOVLB  7
096F2:  MOVWF  x50
096F4:  MOVLB  0
096F6:  CALL   563A
....................    }
096FA:  BRA    9968
....................    else if (0 == strcmp(s_p0, arg2)) {
096FC:  MOVFF  71D,742
09700:  MOVFF  71C,741
09704:  MOVFF  70D,744
09708:  MOVFF  70C,743
0970C:  CALL   56B8
09710:  MOVF   01,F
09712:  BNZ   97CE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09714:  MOVLW  04
09716:  MOVLB  7
09718:  MOVWF  x42
0971A:  MOVLW  C1
0971C:  MOVWF  x41
0971E:  MOVLB  0
09720:  CALL   5602
09724:  MOVFF  02,03
09728:  MOVF   01,W
0972A:  ADDLW  C1
0972C:  MOVLB  7
0972E:  MOVWF  x30
09730:  MOVLW  04
09732:  ADDWFC 02,W
09734:  MOVWF  x31
09736:  MOVFF  FE8,565
0973A:  MOVFF  730,564
0973E:  MOVFF  70B,734
09742:  MOVLW  18
09744:  MOVWF  x35
09746:  MOVLB  0
09748:  CALL   5C1C
0974C:  MOVLW  2C
0974E:  MOVLB  7
09750:  MOVWF  x50
09752:  MOVLB  0
09754:  CALL   563A
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09758:  MOVLW  04
0975A:  MOVLB  7
0975C:  MOVWF  x42
0975E:  MOVLW  C1
09760:  MOVWF  x41
09762:  MOVLB  0
09764:  CALL   5602
09768:  MOVF   01,W
0976A:  ADDLW  C1
0976C:  MOVLB  7
0976E:  MOVWF  x30
09770:  MOVLW  04
09772:  ADDWFC 02,W
09774:  MOVWF  x31
09776:  MOVLW  01
09778:  SUBWF  x0B,W
0977A:  MULLW  26
0977C:  MOVF   FF3,W
0977E:  CLRF   x33
09780:  MOVWF  x32
09782:  MOVLW  18
09784:  ADDWF  x32,W
09786:  MOVWF  01
09788:  MOVLW  00
0978A:  ADDWFC x33,W
0978C:  MOVWF  03
0978E:  MOVF   01,W
09790:  ADDLW  17
09792:  MOVWF  FE9
09794:  MOVLW  01
09796:  ADDWFC 03,W
09798:  MOVWF  FEA
0979A:  MOVFF  FEF,743
0979E:  MOVFF  FEC,744
097A2:  MOVFF  FEC,745
097A6:  MOVFF  FEC,746
097AA:  MOVFF  731,565
097AE:  MOVFF  730,564
097B2:  MOVLW  89
097B4:  MOVWF  FE9
097B6:  MOVLW  02
097B8:  MOVWF  x47
097BA:  MOVLB  0
097BC:  CALL   6516
097C0:  MOVLW  2C
097C2:  MOVLB  7
097C4:  MOVWF  x50
097C6:  MOVLB  0
097C8:  CALL   563A
....................    }
097CC:  BRA    9968
....................    else if (0 == strcmp(s_poles, arg2)) {
097CE:  MOVFF  722,742
097D2:  MOVFF  721,741
097D6:  MOVFF  70D,744
097DA:  MOVFF  70C,743
097DE:  CALL   56B8
097E2:  MOVF   01,F
097E4:  BNZ   9890
....................       sprintf(retData+strlen(retData), "%d,", arg1);
097E6:  MOVLW  04
097E8:  MOVLB  7
097EA:  MOVWF  x42
097EC:  MOVLW  C1
097EE:  MOVWF  x41
097F0:  MOVLB  0
097F2:  CALL   5602
097F6:  MOVFF  02,03
097FA:  MOVF   01,W
097FC:  ADDLW  C1
097FE:  MOVLB  7
09800:  MOVWF  x30
09802:  MOVLW  04
09804:  ADDWFC 02,W
09806:  MOVWF  x31
09808:  MOVFF  FE8,565
0980C:  MOVFF  730,564
09810:  MOVFF  70B,734
09814:  MOVLW  18
09816:  MOVWF  x35
09818:  MOVLB  0
0981A:  CALL   5C1C
0981E:  MOVLW  2C
09820:  MOVLB  7
09822:  MOVWF  x50
09824:  MOVLB  0
09826:  CALL   563A
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
0982A:  MOVLW  04
0982C:  MOVLB  7
0982E:  MOVWF  x42
09830:  MOVLW  C1
09832:  MOVWF  x41
09834:  MOVLB  0
09836:  CALL   5602
0983A:  MOVF   01,W
0983C:  ADDLW  C1
0983E:  MOVLB  7
09840:  MOVWF  x30
09842:  MOVLW  04
09844:  ADDWFC 02,W
09846:  MOVWF  x31
09848:  MOVLW  01
0984A:  SUBWF  x0B,W
0984C:  MULLW  26
0984E:  MOVF   FF3,W
09850:  CLRF   x33
09852:  MOVWF  x32
09854:  MOVLW  1C
09856:  ADDWF  x32,W
09858:  MOVWF  01
0985A:  MOVLW  00
0985C:  ADDWFC x33,W
0985E:  MOVWF  03
09860:  MOVF   01,W
09862:  ADDLW  17
09864:  MOVWF  FE9
09866:  MOVLW  01
09868:  ADDWFC 03,W
0986A:  MOVWF  FEA
0986C:  MOVFF  FEF,734
09870:  MOVFF  731,565
09874:  MOVFF  730,564
09878:  MOVLW  18
0987A:  MOVWF  x35
0987C:  MOVLB  0
0987E:  CALL   5C1C
09882:  MOVLW  2C
09884:  MOVLB  7
09886:  MOVWF  x50
09888:  MOVLB  0
0988A:  CALL   563A
....................    }
0988E:  BRA    9968
....................    else if (0 == strcmp(s_real, arg2)) {
09890:  MOVFF  72A,742
09894:  MOVFF  729,741
09898:  MOVFF  70D,744
0989C:  MOVFF  70C,743
098A0:  CALL   56B8
098A4:  MOVF   01,F
098A6:  BNZ   9962
....................       sprintf(retData+strlen(retData), "%d,", arg1);
098A8:  MOVLW  04
098AA:  MOVLB  7
098AC:  MOVWF  x42
098AE:  MOVLW  C1
098B0:  MOVWF  x41
098B2:  MOVLB  0
098B4:  CALL   5602
098B8:  MOVFF  02,03
098BC:  MOVF   01,W
098BE:  ADDLW  C1
098C0:  MOVLB  7
098C2:  MOVWF  x30
098C4:  MOVLW  04
098C6:  ADDWFC 02,W
098C8:  MOVWF  x31
098CA:  MOVFF  FE8,565
098CE:  MOVFF  730,564
098D2:  MOVFF  70B,734
098D6:  MOVLW  18
098D8:  MOVWF  x35
098DA:  MOVLB  0
098DC:  CALL   5C1C
098E0:  MOVLW  2C
098E2:  MOVLB  7
098E4:  MOVWF  x50
098E6:  MOVLB  0
098E8:  CALL   563A
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
098EC:  MOVLW  04
098EE:  MOVLB  7
098F0:  MOVWF  x42
098F2:  MOVLW  C1
098F4:  MOVWF  x41
098F6:  MOVLB  0
098F8:  CALL   5602
098FC:  MOVF   01,W
098FE:  ADDLW  C1
09900:  MOVLB  7
09902:  MOVWF  x30
09904:  MOVLW  04
09906:  ADDWFC 02,W
09908:  MOVWF  x31
0990A:  MOVLW  01
0990C:  SUBWF  x0B,W
0990E:  MULLW  26
09910:  MOVF   FF3,W
09912:  CLRF   x33
09914:  MOVWF  x32
09916:  MOVLW  1D
09918:  ADDWF  x32,W
0991A:  MOVWF  01
0991C:  MOVLW  00
0991E:  ADDWFC x33,W
09920:  MOVWF  03
09922:  MOVF   01,W
09924:  ADDLW  17
09926:  MOVWF  FE9
09928:  MOVLW  01
0992A:  ADDWFC 03,W
0992C:  MOVWF  FEA
0992E:  MOVFF  FEF,743
09932:  MOVFF  FEC,744
09936:  MOVFF  FEC,745
0993A:  MOVFF  FEC,746
0993E:  MOVFF  731,565
09942:  MOVFF  730,564
09946:  MOVLW  89
09948:  MOVWF  FE9
0994A:  MOVLW  02
0994C:  MOVWF  x47
0994E:  MOVLB  0
09950:  CALL   6516
09954:  MOVLW  2C
09956:  MOVLB  7
09958:  MOVWF  x50
0995A:  MOVLB  0
0995C:  CALL   563A
....................    }
09960:  BRA    9968
....................    else return INV_PARAM;
09962:  MOVLW  02
09964:  MOVWF  01
09966:  BRA    996C
....................    
....................    return SUCCESS;
09968:  MOVLW  00
0996A:  MOVWF  01
0996C:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0996E:  MOVLB  7
09970:  CLRF   x42
09972:  MOVFF  690,741
09976:  CLRF   x44
09978:  MOVLW  B5
0997A:  MOVWF  x43
0997C:  MOVLB  0
0997E:  CALL   0880
09982:  MOVFF  02,70D
09986:  MOVFF  01,70C
0998A:  MOVLW  06
0998C:  MOVLB  7
0998E:  ADDWF  x0C,F
09990:  MOVLW  00
09992:  ADDWFC x0D,F
09994:  MOVLW  32
09996:  ADDWF  x0C,W
09998:  MOVWF  01
0999A:  MOVLW  00
0999C:  ADDWFC x0D,W
0999E:  MOVWF  03
099A0:  MOVF   01,W
099A2:  ADDLW  EB
099A4:  MOVWF  01
099A6:  MOVLW  01
099A8:  ADDWFC 03,F
099AA:  MOVFF  01,70C
099AE:  MOVFF  03,70D
099B2:  MOVFF  03,734
099B6:  MOVFF  01,733
099BA:  MOVLB  0
099BC:  CALL   57D8
099C0:  MOVF   01,F
099C2:  BNZ   99CC
099C4:  MOVLW  02
099C6:  MOVWF  01
099C8:  BRA    9ACE
099CA:  BRA    9A2A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
099CC:  MOVLB  7
099CE:  CLRF   x42
099D0:  MOVFF  690,741
099D4:  CLRF   x44
099D6:  MOVLW  B5
099D8:  MOVWF  x43
099DA:  MOVLB  0
099DC:  CALL   0880
099E0:  MOVFF  02,70D
099E4:  MOVFF  01,70C
099E8:  MOVLW  06
099EA:  MOVLB  7
099EC:  ADDWF  x0C,F
099EE:  MOVLW  00
099F0:  ADDWFC x0D,F
099F2:  MOVLW  32
099F4:  ADDWF  x0C,W
099F6:  MOVWF  01
099F8:  MOVLW  00
099FA:  ADDWFC x0D,W
099FC:  MOVWF  03
099FE:  MOVF   01,W
09A00:  ADDLW  EB
09A02:  MOVWF  01
09A04:  MOVLW  01
09A06:  ADDWFC 03,F
09A08:  MOVFF  01,70C
09A0C:  MOVFF  03,70D
09A10:  MOVFF  03,734
09A14:  MOVFF  01,733
09A18:  CLRF   x36
09A1A:  CLRF   x35
09A1C:  MOVLW  0A
09A1E:  MOVWF  x37
09A20:  MOVLB  0
09A22:  CALL   58C8
09A26:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09A2A:  MOVLW  04
09A2C:  MOVLB  7
09A2E:  MOVWF  x42
09A30:  MOVLW  C1
09A32:  MOVWF  x41
09A34:  MOVLB  0
09A36:  CALL   5602
09A3A:  MOVF   01,W
09A3C:  ADDLW  C1
09A3E:  MOVLB  7
09A40:  MOVWF  x0C
09A42:  MOVLW  04
09A44:  ADDWFC 02,W
09A46:  MOVWF  x0D
09A48:  MOVLW  01
09A4A:  SUBWF  x0B,W
09A4C:  MULLW  07
09A4E:  MOVF   FF3,W
09A50:  CLRF   x0F
09A52:  MOVWF  x0E
09A54:  MOVLW  03
09A56:  ADDWF  x0E,W
09A58:  MOVWF  01
09A5A:  MOVLW  00
09A5C:  ADDWFC x0F,W
09A5E:  MOVWF  03
09A60:  MOVF   01,W
09A62:  ADDLW  64
09A64:  MOVWF  FE9
09A66:  MOVLW  01
09A68:  ADDWFC 03,W
09A6A:  MOVWF  FEA
09A6C:  MOVFF  FEF,70E
09A70:  MOVFF  FEC,70F
09A74:  MOVFF  FEC,710
09A78:  MOVFF  FEC,711
09A7C:  MOVFF  70D,565
09A80:  MOVFF  70C,564
09A84:  MOVFF  70B,734
09A88:  MOVLW  18
09A8A:  MOVWF  x35
09A8C:  MOVLB  0
09A8E:  CALL   5C1C
09A92:  MOVLW  2C
09A94:  MOVLB  7
09A96:  MOVWF  x50
09A98:  MOVLB  0
09A9A:  CALL   563A
09A9E:  MOVLW  89
09AA0:  MOVWF  FE9
09AA2:  MOVFF  711,746
09AA6:  MOVFF  710,745
09AAA:  MOVFF  70F,744
09AAE:  MOVFF  70E,743
09AB2:  MOVLW  02
09AB4:  MOVLB  7
09AB6:  MOVWF  x47
09AB8:  MOVLB  0
09ABA:  CALL   6516
09ABE:  MOVLW  2C
09AC0:  MOVLB  7
09AC2:  MOVWF  x50
09AC4:  MOVLB  0
09AC6:  CALL   563A
....................    
....................    return SUCCESS;
09ACA:  MOVLW  00
09ACC:  MOVWF  01
09ACE:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09AD0:  MOVLB  7
09AD2:  CLRF   x42
09AD4:  MOVFF  690,741
09AD8:  CLRF   x44
09ADA:  MOVLW  B5
09ADC:  MOVWF  x43
09ADE:  MOVLB  0
09AE0:  CALL   0880
09AE4:  MOVFF  02,711
09AE8:  MOVFF  01,710
09AEC:  MOVLW  06
09AEE:  MOVLB  7
09AF0:  ADDWF  x10,F
09AF2:  MOVLW  00
09AF4:  ADDWFC x11,F
09AF6:  MOVLW  32
09AF8:  ADDWF  x10,W
09AFA:  MOVWF  01
09AFC:  MOVLW  00
09AFE:  ADDWFC x11,W
09B00:  MOVWF  03
09B02:  MOVF   01,W
09B04:  ADDLW  EB
09B06:  MOVWF  01
09B08:  MOVLW  01
09B0A:  ADDWFC 03,F
09B0C:  MOVFF  01,710
09B10:  MOVFF  03,711
09B14:  MOVFF  03,734
09B18:  MOVFF  01,733
09B1C:  MOVLB  0
09B1E:  CALL   57D8
09B22:  MOVF   01,F
09B24:  BNZ   9B2E
09B26:  MOVLW  02
09B28:  MOVWF  01
09B2A:  BRA    9D40
09B2C:  BRA    9B8C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B2E:  MOVLB  7
09B30:  CLRF   x42
09B32:  MOVFF  690,741
09B36:  CLRF   x44
09B38:  MOVLW  B5
09B3A:  MOVWF  x43
09B3C:  MOVLB  0
09B3E:  CALL   0880
09B42:  MOVFF  02,711
09B46:  MOVFF  01,710
09B4A:  MOVLW  06
09B4C:  MOVLB  7
09B4E:  ADDWF  x10,F
09B50:  MOVLW  00
09B52:  ADDWFC x11,F
09B54:  MOVLW  32
09B56:  ADDWF  x10,W
09B58:  MOVWF  01
09B5A:  MOVLW  00
09B5C:  ADDWFC x11,W
09B5E:  MOVWF  03
09B60:  MOVF   01,W
09B62:  ADDLW  EB
09B64:  MOVWF  01
09B66:  MOVLW  01
09B68:  ADDWFC 03,F
09B6A:  MOVFF  01,710
09B6E:  MOVFF  03,711
09B72:  MOVFF  03,734
09B76:  MOVFF  01,733
09B7A:  CLRF   x36
09B7C:  CLRF   x35
09B7E:  MOVLW  0A
09B80:  MOVWF  x37
09B82:  MOVLB  0
09B84:  CALL   58C8
09B88:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09B8C:  MOVLB  7
09B8E:  CLRF   x42
09B90:  MOVFF  690,741
09B94:  CLRF   x44
09B96:  MOVLW  B5
09B98:  MOVWF  x43
09B9A:  MOVLB  0
09B9C:  CALL   0880
09BA0:  MOVFF  02,711
09BA4:  MOVFF  01,710
09BA8:  MOVLW  06
09BAA:  MOVLB  7
09BAC:  ADDWF  x10,F
09BAE:  MOVLW  00
09BB0:  ADDWFC x11,F
09BB2:  MOVLW  4B
09BB4:  ADDWF  x10,W
09BB6:  MOVWF  01
09BB8:  MOVLW  00
09BBA:  ADDWFC x11,W
09BBC:  MOVWF  03
09BBE:  MOVF   01,W
09BC0:  ADDLW  EB
09BC2:  MOVWF  01
09BC4:  MOVLW  01
09BC6:  ADDWFC 03,F
09BC8:  MOVFF  01,710
09BCC:  MOVFF  03,711
09BD0:  MOVFF  03,715
09BD4:  MOVFF  01,714
09BD8:  MOVLB  0
09BDA:  CALL   6B7C
09BDE:  MOVF   01,F
09BE0:  BNZ   9BEA
09BE2:  MOVLW  02
09BE4:  MOVWF  01
09BE6:  BRA    9D40
09BE8:  BRA    9C50
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09BEA:  MOVLB  7
09BEC:  CLRF   x42
09BEE:  MOVFF  690,741
09BF2:  CLRF   x44
09BF4:  MOVLW  B5
09BF6:  MOVWF  x43
09BF8:  MOVLB  0
09BFA:  CALL   0880
09BFE:  MOVFF  02,711
09C02:  MOVFF  01,710
09C06:  MOVLW  06
09C08:  MOVLB  7
09C0A:  ADDWF  x10,F
09C0C:  MOVLW  00
09C0E:  ADDWFC x11,F
09C10:  MOVLW  4B
09C12:  ADDWF  x10,W
09C14:  MOVWF  01
09C16:  MOVLW  00
09C18:  ADDWFC x11,W
09C1A:  MOVWF  03
09C1C:  MOVF   01,W
09C1E:  ADDLW  EB
09C20:  MOVWF  01
09C22:  MOVLW  01
09C24:  ADDWFC 03,F
09C26:  MOVFF  01,710
09C2A:  MOVFF  03,711
09C2E:  MOVFF  03,715
09C32:  MOVFF  01,714
09C36:  CLRF   x17
09C38:  CLRF   x16
09C3A:  MOVLB  0
09C3C:  CALL   6C3E
09C40:  MOVFF  03,70F
09C44:  MOVFF  02,70E
09C48:  MOVFF  01,70D
09C4C:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09C50:  MOVLB  7
09C52:  CLRF   x49
09C54:  CLRF   x48
09C56:  MOVLW  7C
09C58:  MOVWF  x47
09C5A:  MOVLW  84
09C5C:  MOVWF  x46
09C5E:  MOVFF  70F,74D
09C62:  MOVFF  70E,74C
09C66:  MOVFF  70D,74B
09C6A:  MOVFF  70C,74A
09C6E:  MOVLB  0
09C70:  CALL   1CF6
09C74:  BNC   9CAA
09C76:  MOVLW  01
09C78:  MOVLB  7
09C7A:  SUBWF  x0B,W
09C7C:  MULLW  07
09C7E:  MOVF   FF3,W
09C80:  CLRF   x11
09C82:  MOVWF  x10
09C84:  MOVLW  03
09C86:  ADDWF  x10,W
09C88:  MOVWF  01
09C8A:  MOVLW  00
09C8C:  ADDWFC x11,W
09C8E:  MOVWF  03
09C90:  MOVF   01,W
09C92:  ADDLW  64
09C94:  MOVWF  FE9
09C96:  MOVLW  01
09C98:  ADDWFC 03,W
09C9A:  MOVWF  FEA
09C9C:  MOVLW  84
09C9E:  MOVWF  FEF
09CA0:  MOVLW  7C
09CA2:  MOVWF  FEC
09CA4:  CLRF   FEC
09CA6:  CLRF   FEC
09CA8:  BRA    9D3A
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09CAA:  MOVFF  70F,749
09CAE:  MOVFF  70E,748
09CB2:  MOVFF  70D,747
09CB6:  MOVFF  70C,746
09CBA:  MOVLB  7
09CBC:  CLRF   x4D
09CBE:  CLRF   x4C
09CC0:  MOVLW  C0
09CC2:  MOVWF  x4B
09CC4:  MOVLW  82
09CC6:  MOVWF  x4A
09CC8:  MOVLB  0
09CCA:  CALL   1CF6
09CCE:  BNC   9D04
09CD0:  MOVLW  01
09CD2:  MOVLB  7
09CD4:  SUBWF  x0B,W
09CD6:  MULLW  07
09CD8:  MOVF   FF3,W
09CDA:  CLRF   x11
09CDC:  MOVWF  x10
09CDE:  MOVLW  03
09CE0:  ADDWF  x10,W
09CE2:  MOVWF  01
09CE4:  MOVLW  00
09CE6:  ADDWFC x11,W
09CE8:  MOVWF  03
09CEA:  MOVF   01,W
09CEC:  ADDLW  64
09CEE:  MOVWF  FE9
09CF0:  MOVLW  01
09CF2:  ADDWFC 03,W
09CF4:  MOVWF  FEA
09CF6:  MOVLW  82
09CF8:  MOVWF  FEF
09CFA:  MOVLW  C0
09CFC:  MOVWF  FEC
09CFE:  CLRF   FEC
09D00:  CLRF   FEC
09D02:  BRA    9D3A
....................    else dacVals[arg1-1].opPcnt = arg2;
09D04:  MOVLW  01
09D06:  MOVLB  7
09D08:  SUBWF  x0B,W
09D0A:  MULLW  07
09D0C:  MOVF   FF3,W
09D0E:  CLRF   x11
09D10:  MOVWF  x10
09D12:  MOVLW  03
09D14:  ADDWF  x10,W
09D16:  MOVWF  01
09D18:  MOVLW  00
09D1A:  ADDWFC x11,W
09D1C:  MOVWF  03
09D1E:  MOVF   01,W
09D20:  ADDLW  64
09D22:  MOVWF  FE9
09D24:  MOVLW  01
09D26:  ADDWFC 03,W
09D28:  MOVWF  FEA
09D2A:  MOVFF  70C,FEF
09D2E:  MOVFF  70D,FEC
09D32:  MOVFF  70E,FEC
09D36:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09D3A:  MOVLW  00
09D3C:  MOVWF  01
09D3E:  MOVLB  0
09D40:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09D42:  MOVLB  1
09D44:  BSF    x63.0
....................    return SUCCESS;
09D46:  MOVLW  00
09D48:  MOVWF  01
09D4A:  MOVLB  0
09D4C:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09D4E:  MOVLB  1
09D50:  BCF    x63.0
....................    return SUCCESS;
09D52:  MOVLW  00
09D54:  MOVWF  01
09D56:  MOVLB  0
09D58:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09D5A:  MOVLB  7
09D5C:  CLRF   x42
09D5E:  MOVFF  690,741
09D62:  CLRF   x44
09D64:  MOVLW  B5
09D66:  MOVWF  x43
09D68:  MOVLB  0
09D6A:  CALL   0880
09D6E:  MOVFF  02,70D
09D72:  MOVFF  01,70C
09D76:  MOVLW  06
09D78:  MOVLB  7
09D7A:  ADDWF  x0C,F
09D7C:  MOVLW  00
09D7E:  ADDWFC x0D,F
09D80:  MOVLW  32
09D82:  ADDWF  x0C,W
09D84:  MOVWF  01
09D86:  MOVLW  00
09D88:  ADDWFC x0D,W
09D8A:  MOVWF  03
09D8C:  MOVF   01,W
09D8E:  ADDLW  EB
09D90:  MOVWF  01
09D92:  MOVLW  01
09D94:  ADDWFC 03,F
09D96:  MOVFF  01,70C
09D9A:  MOVFF  03,70D
09D9E:  MOVFF  03,734
09DA2:  MOVFF  01,733
09DA6:  MOVLB  0
09DA8:  CALL   57D8
09DAC:  MOVF   01,F
09DAE:  BNZ   9DB8
09DB0:  MOVLW  02
09DB2:  MOVWF  01
09DB4:  BRA    9E44
09DB6:  BRA    9E16
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09DB8:  MOVLB  7
09DBA:  CLRF   x42
09DBC:  MOVFF  690,741
09DC0:  CLRF   x44
09DC2:  MOVLW  B5
09DC4:  MOVWF  x43
09DC6:  MOVLB  0
09DC8:  CALL   0880
09DCC:  MOVFF  02,70D
09DD0:  MOVFF  01,70C
09DD4:  MOVLW  06
09DD6:  MOVLB  7
09DD8:  ADDWF  x0C,F
09DDA:  MOVLW  00
09DDC:  ADDWFC x0D,F
09DDE:  MOVLW  32
09DE0:  ADDWF  x0C,W
09DE2:  MOVWF  01
09DE4:  MOVLW  00
09DE6:  ADDWFC x0D,W
09DE8:  MOVWF  03
09DEA:  MOVF   01,W
09DEC:  ADDLW  EB
09DEE:  MOVWF  01
09DF0:  MOVLW  01
09DF2:  ADDWFC 03,F
09DF4:  MOVFF  01,70C
09DF8:  MOVFF  03,70D
09DFC:  MOVFF  03,734
09E00:  MOVFF  01,733
09E04:  CLRF   x36
09E06:  CLRF   x35
09E08:  MOVLW  0A
09E0A:  MOVWF  x37
09E0C:  MOVLB  0
09E0E:  CALL   58C8
09E12:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09E16:  MOVLW  01
09E18:  MOVLB  7
09E1A:  SUBWF  x0B,W
09E1C:  MULLW  26
09E1E:  MOVF   FF3,W
09E20:  CLRF   x0D
09E22:  MOVWF  x0C
09E24:  MOVLW  25
09E26:  ADDWF  x0C,W
09E28:  MOVWF  01
09E2A:  MOVLW  00
09E2C:  ADDWFC x0D,W
09E2E:  MOVWF  03
09E30:  MOVF   01,W
09E32:  ADDLW  17
09E34:  MOVWF  FE9
09E36:  MOVLW  01
09E38:  ADDWFC 03,W
09E3A:  MOVWF  FEA
09E3C:  BSF    FEF.0
....................     
....................     return SUCCESS;
09E3E:  MOVLW  00
09E40:  MOVWF  01
09E42:  MOVLB  0
09E44:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09E46:  MOVLW  01
09E48:  MOVWF  01
09E4A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06B7C:  MOVLB  7
06B7E:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06B80:  CLRF   x17
06B82:  MOVFF  715,742
06B86:  MOVFF  714,741
06B8A:  MOVLB  0
06B8C:  CALL   5602
06B90:  MOVFF  02,03
06B94:  MOVF   01,W
06B96:  MOVF   03,F
06B98:  BNZ   6BA4
06B9A:  MOVF   01,W
06B9C:  MOVLB  7
06B9E:  SUBWF  x17,W
06BA0:  BC    6C36
06BA2:  MOVLB  0
....................       if (!isdigit(arg[i])){
06BA4:  MOVLB  7
06BA6:  MOVF   x17,W
06BA8:  ADDWF  x14,W
06BAA:  MOVWF  FE9
06BAC:  MOVLW  00
06BAE:  ADDWFC x15,W
06BB0:  MOVWF  FEA
06BB2:  MOVFF  FEF,718
06BB6:  MOVF   x18,W
06BB8:  SUBLW  2F
06BBA:  BC    6BC2
06BBC:  MOVF   x18,W
06BBE:  SUBLW  39
06BC0:  BC    6C2E
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06BC2:  MOVF   x17,W
06BC4:  ADDWF  x14,W
06BC6:  MOVWF  FE9
06BC8:  MOVLW  00
06BCA:  ADDWFC x15,W
06BCC:  MOVWF  FEA
06BCE:  MOVF   FEF,W
06BD0:  SUBLW  2D
06BD2:  BZ    6BFE
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06BD4:  MOVF   x17,W
06BD6:  ADDWF  x14,W
06BD8:  MOVWF  FE9
06BDA:  MOVLW  00
06BDC:  ADDWFC x15,W
06BDE:  MOVWF  FEA
06BE0:  MOVF   FEF,W
06BE2:  SUBLW  2E
06BE4:  BZ    6BEE
06BE6:  MOVLW  00
06BE8:  MOVWF  01
06BEA:  BRA    6C3A
06BEC:  BRA    6BFC
....................             else if  (decimal) return FALSE;
06BEE:  BTFSS  x16.0
06BF0:  BRA    6BFA
06BF2:  MOVLW  00
06BF4:  MOVWF  01
06BF6:  BRA    6C3A
06BF8:  BRA    6BFC
....................             else decimal = TRUE;
06BFA:  BSF    x16.0
....................          }
06BFC:  BRA    6C2E
....................          else if (0 != i) return FALSE;
06BFE:  MOVF   x17,F
06C00:  BZ    6C0A
06C02:  MOVLW  00
06C04:  MOVWF  01
06C06:  BRA    6C3A
06C08:  BRA    6C2E
....................          else if (1 == strlen(arg)) return FALSE;
06C0A:  MOVFF  715,742
06C0E:  MOVFF  714,741
06C12:  MOVLB  0
06C14:  CALL   5602
06C18:  MOVFF  02,03
06C1C:  MOVF   01,W
06C1E:  SUBLW  01
06C20:  BNZ   6C30
06C22:  MOVF   03,F
06C24:  BNZ   6C30
06C26:  MOVLW  00
06C28:  MOVWF  01
06C2A:  MOVLB  7
06C2C:  BRA    6C3A
06C2E:  MOVLB  0
....................       }
06C30:  MOVLB  7
06C32:  INCF   x17,F
06C34:  BRA    6B82
....................    }
....................    return TRUE;
06C36:  MOVLW  01
06C38:  MOVWF  01
06C3A:  MOVLB  0
06C3C:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
057D8:  MOVFF  734,742
057DC:  MOVFF  733,741
057E0:  RCALL  5602
057E2:  MOVFF  02,03
057E6:  MOVF   01,W
057E8:  SUBLW  01
057EA:  BNZ   57F0
057EC:  MOVF   03,F
057EE:  BZ    57F8
057F0:  MOVLW  00
057F2:  MOVWF  01
057F4:  BRA    5826
057F6:  BRA    581E
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
057F8:  MOVLB  7
057FA:  MOVFF  733,FE9
057FE:  MOVFF  734,FEA
05802:  MOVF   FEF,W
05804:  SUBLW  31
05806:  BZ    5820
05808:  MOVFF  733,FE9
0580C:  MOVFF  734,FEA
05810:  MOVF   FEF,W
05812:  SUBLW  32
05814:  BZ    5820
05816:  MOVLW  00
05818:  MOVWF  01
0581A:  MOVLB  0
0581C:  BRA    5826
0581E:  MOVLB  7
....................     return TRUE;
05820:  MOVLW  01
05822:  MOVWF  01
05824:  MOVLB  0
05826:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
0567E:  MOVLB  7
05680:  MOVF   x0A,W
05682:  SUBLW  2F
05684:  BC    5696
05686:  MOVF   x0A,W
05688:  SUBLW  39
0568A:  BNC   5696
0568C:  MOVLW  30
0568E:  SUBWF  x0A,W
05690:  MOVWF  01
05692:  BRA    56B2
05694:  BRA    56B2
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05696:  MOVF   x0A,W
05698:  SUBLW  40
0569A:  BC    56AE
0569C:  MOVF   x0A,W
0569E:  SUBLW  46
056A0:  BNC   56AE
056A2:  MOVLW  41
056A4:  SUBWF  x0A,W
056A6:  ADDLW  0A
056A8:  MOVWF  01
056AA:  BRA    56B2
056AC:  BRA    56B2
....................    else return 0xFF;
056AE:  MOVLW  FF
056B0:  MOVWF  01
056B2:  MOVLB  0
056B4:  GOTO   9EF0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    /* NEEDS FIXING
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
....................    */
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09E4C:  MOVLB  7
09E4E:  CLRF   x42
09E50:  MOVFF  701,741
09E54:  CLRF   x44
09E56:  MOVLW  B5
09E58:  MOVWF  x43
09E5A:  MOVLB  0
09E5C:  CALL   0880
09E60:  MOVFF  02,70A
09E64:  MOVFF  01,709
09E68:  MOVLW  06
09E6A:  MOVLB  7
09E6C:  ADDWF  x09,F
09E6E:  MOVLW  00
09E70:  ADDWFC x0A,F
09E72:  MOVLW  EB
09E74:  ADDWF  x09,W
09E76:  MOVWF  01
09E78:  MOVLW  01
09E7A:  ADDWFC x0A,W
09E7C:  MOVWF  03
09E7E:  MOVFF  01,702
09E82:  MOVWF  x03
09E84:  CLRF   x42
09E86:  MOVFF  701,741
09E8A:  CLRF   x44
09E8C:  MOVLW  B5
09E8E:  MOVWF  x43
09E90:  MOVLB  0
09E92:  CALL   0880
09E96:  MOVFF  02,70C
09E9A:  MOVFF  01,70B
09E9E:  MOVLW  06
09EA0:  MOVLB  7
09EA2:  ADDWF  x0B,F
09EA4:  MOVLW  00
09EA6:  ADDWFC x0C,F
09EA8:  MOVLW  19
09EAA:  ADDWF  x0B,W
09EAC:  MOVWF  01
09EAE:  MOVLW  00
09EB0:  ADDWFC x0C,W
09EB2:  MOVWF  03
09EB4:  MOVF   01,W
09EB6:  ADDLW  EB
09EB8:  MOVWF  01
09EBA:  MOVLW  01
09EBC:  ADDWFC 03,F
09EBE:  MOVFF  01,704
09EC2:  MOVFF  03,705
09EC6:  CLRF   x06
09EC8:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09ECA:  MOVFF  702,FE9
09ECE:  MOVFF  703,FEA
09ED2:  MOVF   FEF,W
09ED4:  SUBLW  44
09ED6:  BTFSS  FD8.2
09ED8:  BRA    9FC8
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
09EDA:  MOVLW  01
09EDC:  ADDWF  x02,W
09EDE:  MOVWF  FE9
09EE0:  MOVLW  00
09EE2:  ADDWFC x03,W
09EE4:  MOVWF  FEA
09EE6:  MOVFF  FEF,70A
09EEA:  MOVLB  0
09EEC:  GOTO   567E
09EF0:  MOVFF  01,709
09EF4:  MOVLB  7
09EF6:  MOVF   x06,W
09EF8:  ANDLW  0F
09EFA:  SUBWF  01,W
09EFC:  BNZ   9FC0
....................          while (0 != strlen(cmd_list[i].cmd_name)){
09EFE:  MOVF   x07,W
09F00:  MULLW  04
09F02:  MOVF   FF3,W
09F04:  CLRF   x0A
09F06:  MOVWF  x09
09F08:  MOVLW  6A
09F0A:  ADDWF  x09,W
09F0C:  MOVWF  FE9
09F0E:  MOVLW  05
09F10:  ADDWFC x0A,W
09F12:  MOVWF  FEA
09F14:  MOVFF  FEC,742
09F18:  MOVF   FED,F
09F1A:  MOVFF  FEF,741
09F1E:  MOVLB  0
09F20:  CALL   5602
09F24:  MOVFF  02,03
09F28:  MOVF   01,W
09F2A:  BNZ   9F30
09F2C:  MOVF   03,F
09F2E:  BZ    9FB6
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
09F30:  MOVLB  7
09F32:  MOVF   x07,W
09F34:  MULLW  04
09F36:  MOVF   FF3,W
09F38:  CLRF   x0A
09F3A:  MOVWF  x09
09F3C:  MOVLW  6A
09F3E:  ADDWF  x09,W
09F40:  MOVWF  FE9
09F42:  MOVLW  05
09F44:  ADDWFC x0A,W
09F46:  MOVWF  FEA
09F48:  MOVFF  FEC,744
09F4C:  MOVF   FED,F
09F4E:  MOVFF  FEF,743
09F52:  MOVFF  705,742
09F56:  MOVFF  704,741
09F5A:  MOVLB  0
09F5C:  CALL   56B8
09F60:  MOVF   01,F
09F62:  BNZ   9FAE
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09F64:  MOVLB  7
09F66:  MOVF   x07,W
09F68:  MULLW  04
09F6A:  MOVF   FF3,W
09F6C:  CLRF   x0A
09F6E:  MOVWF  x09
09F70:  MOVLW  02
09F72:  ADDWF  x09,W
09F74:  MOVWF  01
09F76:  MOVLW  00
09F78:  ADDWFC x0A,W
09F7A:  MOVWF  03
09F7C:  MOVF   01,W
09F7E:  ADDLW  6A
09F80:  MOVWF  01
09F82:  MOVLW  05
09F84:  ADDWFC 03,F
09F86:  MOVFF  01,709
09F8A:  MOVFF  03,70A
09F8E:  MOVFF  03,FEA
09F92:  MOVFF  01,FE9
09F96:  MOVFF  701,690
09F9A:  MOVLB  0
09F9C:  CALL   00BC
09FA0:  MOVFF  01,708
....................                return return_code;
09FA4:  MOVLB  7
09FA6:  MOVFF  708,01
09FAA:  BRA    9FCC
09FAC:  MOVLB  0
....................             }
....................             i++;
09FAE:  MOVLB  7
09FB0:  INCF   x07,F
09FB2:  BRA    9EFE
09FB4:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
09FB6:  MOVLW  01
09FB8:  MOVWF  01
09FBA:  MOVLB  7
09FBC:  BRA    9FCC
....................       } else return 254; // NOT THIS ADDRESS
09FBE:  BRA    9FC6
09FC0:  MOVLW  FE
09FC2:  MOVWF  01
09FC4:  BRA    9FCC
....................    } else return 255; // NOT THIS DEVICE TYPE
09FC6:  BRA    9FCC
09FC8:  MOVLW  FF
09FCA:  MOVWF  01
09FCC:  MOVLB  0
09FCE:  GOTO   A06E (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
09FD2:  GOTO   55A8
09FD6:  MOVF   01,F
09FD8:  BTFSC  FD8.2
09FDA:  BRA    A0FA
....................    {
....................       int8 return_code;
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
09FDC:  MOVLW  04
09FDE:  MOVLB  7
09FE0:  MOVWF  x42
09FE2:  MOVLW  C1
09FE4:  MOVWF  x41
09FE6:  MOVLB  0
09FE8:  CALL   5602
09FEC:  MOVFF  02,03
09FF0:  MOVF   01,W
09FF2:  ADDLW  C1
09FF4:  MOVLB  7
09FF6:  MOVWF  x00
09FF8:  MOVLW  04
09FFA:  ADDWFC 02,W
09FFC:  MOVWF  x01
09FFE:  CLRF   x42
0A000:  MOVFF  4BF,741
0A004:  CLRF   x44
0A006:  MOVLW  B5
0A008:  MOVWF  x43
0A00A:  MOVLB  0
0A00C:  CALL   0880
0A010:  MOVFF  02,703
0A014:  MOVFF  01,702
0A018:  MOVLW  06
0A01A:  MOVLB  7
0A01C:  ADDWF  x02,F
0A01E:  MOVLW  00
0A020:  ADDWFC x03,F
0A022:  MOVLW  EB
0A024:  ADDWF  x02,W
0A026:  MOVWF  01
0A028:  MOVLW  01
0A02A:  ADDWFC x03,W
0A02C:  MOVWF  03
0A02E:  MOVFF  01,704
0A032:  MOVWF  x05
0A034:  MOVFF  701,565
0A038:  MOVFF  700,564
0A03C:  MOVLW  24
0A03E:  MOVWF  x50
0A040:  MOVLB  0
0A042:  CALL   563A
0A046:  MOVFF  565,FEA
0A04A:  MOVFF  564,FE9
0A04E:  CLRF   FEF
0A050:  MOVFF  705,FEA
0A054:  MOVFF  704,FE9
0A058:  CALL   565A
0A05C:  MOVLW  2C
0A05E:  MOVLB  7
0A060:  MOVWF  x50
0A062:  MOVLB  0
0A064:  CALL   563A
....................       
....................       return_code = command_parser(SRI);
0A068:  MOVFF  4BF,701
0A06C:  BRA    9E4C
0A06E:  MOVFF  01,6FB
....................       
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A072:  MOVLW  04
0A074:  MOVLB  7
0A076:  MOVWF  x42
0A078:  MOVLW  C1
0A07A:  MOVWF  x41
0A07C:  MOVLB  0
0A07E:  CALL   5602
0A082:  MOVF   01,W
0A084:  ADDLW  C1
0A086:  MOVLB  7
0A088:  MOVWF  x00
0A08A:  MOVLW  04
0A08C:  ADDWFC 02,W
0A08E:  MOVWF  x01
0A090:  MOVLB  6
0A092:  MOVF   xFB,W
0A094:  MULLW  03
0A096:  MOVF   FF3,W
0A098:  MOVLB  7
0A09A:  CLRF   x03
0A09C:  MOVWF  x02
0A09E:  MOVLW  01
0A0A0:  ADDWF  x02,W
0A0A2:  MOVWF  01
0A0A4:  MOVLW  00
0A0A6:  ADDWFC x03,W
0A0A8:  MOVWF  03
0A0AA:  MOVF   01,W
0A0AC:  ADDLW  5C
0A0AE:  MOVWF  FE9
0A0B0:  MOVLW  06
0A0B2:  ADDWFC 03,W
0A0B4:  MOVWF  FEA
0A0B6:  MOVFF  FEC,703
0A0BA:  MOVF   FED,F
0A0BC:  MOVFF  FEF,702
0A0C0:  MOVFF  701,565
0A0C4:  MOVFF  700,564
0A0C8:  MOVFF  565,FEA
0A0CC:  MOVFF  564,FE9
0A0D0:  CLRF   FEF
0A0D2:  MOVFF  703,FEA
0A0D6:  MOVFF  702,FE9
0A0DA:  MOVLB  0
0A0DC:  CALL   565A
....................       serial_out(retData);
0A0E0:  MOVLW  04
0A0E2:  MOVLB  7
0A0E4:  MOVWF  x02
0A0E6:  MOVLW  C1
0A0E8:  MOVWF  x01
0A0EA:  MOVLB  0
0A0EC:  CALL   504C
....................       resetSERcmd(SRI);
0A0F0:  MOVFF  4BF,701
0A0F4:  CALL   0B64
0A0F8:  BRA    9FD2
....................    }
0A0FA:  GOTO   A722 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
*
0A2C4:  CLRF   FF8
0A2C6:  BCF    FF2.5
0A2C8:  BSF    07.7
0A2CA:  MOVLB  E
0A2CC:  MOVLW  55
0A2CE:  MOVWF  x9B
0A2D0:  MOVLW  AA
0A2D2:  MOVWF  x9B
0A2D4:  BCF    x9B.0
0A2D6:  MOVLW  17
0A2D8:  MOVWF  xB0
0A2DA:  MOVLW  13
0A2DC:  MOVWF  xB2
0A2DE:  MOVLW  09
0A2E0:  MOVWF  x8A
0A2E2:  MOVLW  0A
0A2E4:  MOVWF  x8B
0A2E6:  MOVLW  11
0A2E8:  MOVWF  xEB
0A2EA:  MOVLW  12
0A2EC:  MOVWF  xED
0A2EE:  MOVLW  10
0A2F0:  MOVWF  xF4
0A2F2:  MOVLW  0F
0A2F4:  MOVWF  xF5
0A2F6:  MOVLW  09
0A2F8:  MOVWF  xF8
0A2FA:  MOVLW  55
0A2FC:  MOVWF  x9B
0A2FE:  MOVLW  AA
0A300:  MOVWF  x9B
0A302:  BSF    x9B.0
0A304:  CLRF   xD8
0A306:  CLRF   xD5
0A308:  CLRF   xD7
0A30A:  MOVLW  08
0A30C:  MOVWF  xD9
0A30E:  MOVLW  60
0A310:  MOVWF  xD3
0A312:  MOVLW  AA
0A314:  MOVLB  0
0A316:  MOVWF  xFA
0A318:  MOVLB  1
0A31A:  BCF    x63.0
0A31C:  CLRF   x75
0A31E:  CLRF   x74
0A320:  CLRF   x73
0A322:  CLRF   x72
0A324:  CLRF   x79
0A326:  CLRF   x78
0A328:  CLRF   x77
0A32A:  CLRF   x76
0A32C:  CLRF   x7D
0A32E:  CLRF   x7C
0A330:  CLRF   x7B
0A332:  CLRF   x7A
0A334:  CLRF   x7F
0A336:  CLRF   x7E
0A338:  MOVLB  E
0A33A:  BCF    x91.5
0A33C:  MOVLW  00
0A33E:  MOVWF  x90
0A340:  MOVLW  03
0A342:  MOVWF  x8E
0A344:  MOVLW  2A
0A346:  MOVWF  x91
0A348:  MOVLW  04
0A34A:  MOVWF  F88
0A34C:  MOVWF  F88
0A34E:  MOVWF  F88
0A350:  MOVLB  1
0A352:  CLRF   xD0
0A354:  CLRF   xD1
0A356:  CLRF   xD2
0A358:  CLRF   xD3
0A35A:  BCF    F95.5
0A35C:  MOVLW  40
0A35E:  MOVWF  F94
0A360:  MOVLW  9F
0A362:  MOVWF  F92
0A364:  MOVLW  3A
0A366:  MOVWF  F95
0A368:  MOVLW  93
0A36A:  MOVWF  F89
0A36C:  MOVWF  F89
0A36E:  MOVLB  4
0A370:  CLRF   xBF
0A372:  CLRF   xC0
0A374:  MOVLB  5
0A376:  CLRF   x61
0A378:  CLRF   x62
0A37A:  MOVLB  1
0A37C:  BCF    x63.1
0A37E:  MOVLW  04
0A380:  MOVWF  F88
0A382:  BSF    F83.7
0A384:  MOVLW  12
0A386:  MOVWF  03
0A388:  MOVLW  FA
0A38A:  MOVLB  7
0A38C:  MOVWF  x01
0A38E:  MOVLB  0
0A390:  CALL   0394
0A394:  DECFSZ 03,F
0A396:  BRA    A39A
0A398:  BRA    A39E
0A39A:  MOVLB  1
0A39C:  BRA    A388
0A39E:  MOVLB  5
0A3A0:  CLRF   x63
0A3A2:  BSF    F9E.3
0A3A4:  MOVLW  7C
0A3A6:  MOVWF  F9A
0A3A8:  MOVLW  00
0A3AA:  MOVWF  F9B
0A3AC:  MOVLW  A6
0A3AE:  MOVWF  F9D
0A3B0:  MOVLW  90
0A3B2:  MOVWF  F9C
0A3B4:  CLRF   x65
0A3B6:  CLRF   x64
0A3B8:  CLRF   x69
0A3BA:  CLRF   x68
0A3BC:  CLRF   x67
0A3BE:  CLRF   x66
0A3C0:  MOVLB  F
0A3C2:  CLRF   x0C
0A3C4:  CLRF   x14
0A3C6:  CLRF   x1C
0A3C8:  CLRF   x21
0A3CA:  CLRF   x29
0A3CC:  CLRF   x35
0A3CE:  CLRF   x36
0A3D0:  CLRF   x37
0A3D2:  CLRF   x34
0A3D4:  CLRF   x31
0A3D6:  CLRF   x32
0A3D8:  CLRF   x33
0A3DA:  CLRF   x30
0A3DC:  MOVLW  57
0A3DE:  MOVLB  5
0A3E0:  MOVWF  x6D
0A3E2:  MOVLW  50
0A3E4:  MOVWF  x6C
0A3E6:  MOVLW  57
0A3E8:  MOVWF  x71
0A3EA:  MOVLW  94
0A3EC:  MOVWF  x70
0A3EE:  MOVLW  5C
0A3F0:  MOVWF  x75
0A3F2:  MOVLW  DC
0A3F4:  MOVWF  x74
0A3F6:  MOVLW  5E
0A3F8:  MOVWF  x79
0A3FA:  MOVLW  C2
0A3FC:  MOVWF  x78
0A3FE:  MOVLW  60
0A400:  MOVWF  x7D
0A402:  MOVLW  9A
0A404:  MOVWF  x7C
0A406:  MOVLW  62
0A408:  MOVWF  x81
0A40A:  MOVLW  26
0A40C:  MOVWF  x80
0A40E:  MOVLW  66
0A410:  MOVWF  x85
0A412:  MOVLW  C6
0A414:  MOVWF  x84
0A416:  MOVLW  6E
0A418:  MOVWF  x89
0A41A:  MOVLW  98
0A41C:  MOVWF  x88
0A41E:  MOVLW  71
0A420:  MOVWF  x8D
0A422:  MOVLW  78
0A424:  MOVWF  x8C
0A426:  MOVLW  72
0A428:  MOVWF  x91
0A42A:  MOVLW  DA
0A42C:  MOVWF  x90
0A42E:  MOVLW  74
0A430:  MOVWF  x95
0A432:  MOVLW  98
0A434:  MOVWF  x94
0A436:  MOVLW  78
0A438:  MOVWF  x99
0A43A:  MOVLW  4E
0A43C:  MOVWF  x98
0A43E:  MOVLW  7D
0A440:  MOVWF  x9D
0A442:  MOVLW  AA
0A444:  MOVWF  x9C
0A446:  MOVLW  81
0A448:  MOVWF  xA1
0A44A:  MOVLW  42
0A44C:  MOVWF  xA0
0A44E:  MOVLW  86
0A450:  MOVWF  xA5
0A452:  MOVLW  6E
0A454:  MOVWF  xA4
0A456:  MOVLW  86
0A458:  MOVWF  xA9
0A45A:  MOVLW  74
0A45C:  MOVWF  xA8
0A45E:  MOVLW  8C
0A460:  MOVWF  xAD
0A462:  MOVLW  E8
0A464:  MOVWF  xAC
0A466:  MOVLW  92
0A468:  MOVWF  xB1
0A46A:  MOVLW  4C
0A46C:  MOVWF  xB0
0A46E:  MOVLW  99
0A470:  MOVWF  xB5
0A472:  MOVLW  6E
0A474:  MOVWF  xB4
0A476:  MOVLW  9A
0A478:  MOVWF  xB9
0A47A:  MOVLW  D0
0A47C:  MOVWF  xB8
0A47E:  MOVLW  9D
0A480:  MOVWF  xBD
0A482:  MOVLW  42
0A484:  MOVWF  xBC
0A486:  MOVLW  9D
0A488:  MOVWF  xC1
0A48A:  MOVLW  4E
0A48C:  MOVWF  xC0
0A48E:  MOVLW  9D
0A490:  MOVWF  xC5
0A492:  MOVLW  5A
0A494:  MOVWF  xC4
0A496:  MOVLW  9E
0A498:  MOVWF  xC9
0A49A:  MOVLW  46
0A49C:  MOVWF  xC8
0A49E:  BRA    A67E
0A4A0:  DATA 02,00
0A4A2:  DATA 1A,00
0A4A4:  DATA 00,0C
0A4A6:  DATA 00,20
0A4A8:  DATA 78,23
0A4AA:  DATA D7,0A
0A4AC:  DATA 7D,19
0A4AE:  DATA 99,9A
0A4B0:  DATA 7B,4C
0A4B2:  DATA CC,CD
0A4B4:  DATA 1C,C0
0A4B6:  DATA 00,0C
0A4B8:  DATA 80,78
0A4BA:  DATA 23,D7
0A4BC:  DATA 0A,7D
0A4BE:  DATA 19,99
0A4C0:  DATA 9A,7B
0A4C2:  DATA 4C,CC
0A4C4:  DATA CD,1C
0A4C6:  DATA C0,00
0A4C8:  DATA 01,80
0A4CA:  DATA 02,09
0A4CC:  DATA C0,00
0A4CE:  DATA 05,80
0A4D0:  DATA 7F,00
0A4D2:  DATA 00,00
0A4D4:  DATA 7F,0B
0A4D6:  DATA C0,00
0A4D8:  DATA 05,80
0A4DA:  DATA 7F,00
0A4DC:  DATA 00,00
0A4DE:  DATA 7F,07
0A4E0:  DATA C0,00
0A4E2:  DATA 01,80
0A4E4:  DATA 7F,17
0A4E6:  DATA C0,00
0A4E8:  DATA 01,80
0A4EA:  DATA 7F,17
0A4EC:  DATA C0,00
0A4EE:  DATA 04,80
0A4F0:  DATA 79,B7
0A4F2:  DATA F3,BD
0A4F4:  DATA 04,C0
0A4F6:  DATA 00,04
0A4F8:  DATA 80,7C
0A4FA:  DATA 59,DF
0A4FC:  DATA 4E,04
0A4FE:  DATA C0,00
0A500:  DATA 04,80
0A502:  DATA 78,0A
0A504:  DATA 28,88
0A506:  DATA 04,C0
0A508:  DATA 00,04
0A50A:  DATA 80,78
0A50C:  DATA 05,EA
0A50E:  DATA 16,04
0A510:  DATA C0,00
0A512:  DATA 04,80
0A514:  DATA 78,1E
0A516:  DATA 33,D7
0A518:  DATA 04,C0
0A51A:  DATA 00,04
0A51C:  DATA 80,77
0A51E:  DATA 68,7B
0A520:  DATA BB,04
0A522:  DATA C0,00
0A524:  DATA 04,80
0A526:  DATA 77,68
0A528:  DATA 0D,C6
0A52A:  DATA 68,40
0A52C:  DATA FB,00
0A52E:  DATA 0E,41
0A530:  DATA 64,00
0A532:  DATA 17,41
0A534:  DATA D4,00
0A536:  DATA 3C,45
0A538:  DATA 25,00
0A53A:  DATA 02,05
0A53C:  DATA 6A,CA
0A53E:  DATA 05,02
0A540:  DATA 05,6E
0A542:  DATA CD,05
0A544:  DATA 02,05
0A546:  DATA 72,D0
0A548:  DATA 05,02
0A54A:  DATA 05,76
0A54C:  DATA D7,05
0A54E:  DATA 02,05
0A550:  DATA 7A,DE
0A552:  DATA 05,02
0A554:  DATA 05,7E
0A556:  DATA E6,05
0A558:  DATA 02,05
0A55A:  DATA 82,EE
0A55C:  DATA 05,02
0A55E:  DATA 05,86
0A560:  DATA F3,05
0A562:  DATA 02,05
0A564:  DATA 8A,F8
0A566:  DATA 05,02
0A568:  DATA 05,8E
0A56A:  DATA FC,05
0A56C:  DATA 02,05
0A56E:  DATA 92,00
0A570:  DATA 06,02
0A572:  DATA 05,96
0A574:  DATA 07,06
0A576:  DATA 02,05
0A578:  DATA 9A,0D
0A57A:  DATA 06,02
0A57C:  DATA 05,9E
0A57E:  DATA 13,06
0A580:  DATA 02,05
0A582:  DATA A2,19
0A584:  DATA 06,02
0A586:  DATA 05,A6
0A588:  DATA 1F,06
0A58A:  DATA 02,05
0A58C:  DATA AA,24
0A58E:  DATA 06,02
0A590:  DATA 05,AE
0A592:  DATA 2D,06
0A594:  DATA 02,05
0A596:  DATA B2,35
0A598:  DATA 06,02
0A59A:  DATA 05,B6
0A59C:  DATA 3C,06
0A59E:  DATA 02,05
0A5A0:  DATA BA,43
0A5A2:  DATA 06,02
0A5A4:  DATA 05,BE
0A5A6:  DATA 4B,06
0A5A8:  DATA 02,05
0A5AA:  DATA C2,54
0A5AC:  DATA 06,02
0A5AE:  DATA 05,C6
0A5B0:  DATA 5A,06
0A5B2:  DATA 8F,05
0A5B4:  DATA CA,67
0A5B6:  DATA 72,00
0A5B8:  DATA 67,73
0A5BA:  DATA 00,67
0A5BC:  DATA 43,68
0A5BE:  DATA 4D,61
0A5C0:  DATA 70,00
0A5C2:  DATA 73,43
0A5C4:  DATA 68,4D
0A5C6:  DATA 61,70
0A5C8:  DATA 00,67
0A5CA:  DATA 43,68
0A5CC:  DATA 4D,6F
0A5CE:  DATA 64,65
0A5D0:  DATA 00,73
0A5D2:  DATA 43,68
0A5D4:  DATA 4D,6F
0A5D6:  DATA 64,65
0A5D8:  DATA 00,67
0A5DA:  DATA 50,49
0A5DC:  DATA 44,00
0A5DE:  DATA 73,50
0A5E0:  DATA 49,44
0A5E2:  DATA 00,67
0A5E4:  DATA 53,50
0A5E6:  DATA 00,73
0A5E8:  DATA 53,50
0A5EA:  DATA 00,67
0A5EC:  DATA 53,43
0A5EE:  DATA 61,6C
0A5F0:  DATA 73,00
0A5F2:  DATA 67,53
0A5F4:  DATA 43,61
0A5F6:  DATA 6C,00
0A5F8:  DATA 73,53
0A5FA:  DATA 43,61
0A5FC:  DATA 6C,00
0A5FE:  DATA 67,4D
0A600:  DATA 43,61
0A602:  DATA 6C,00
0A604:  DATA 73,4D
0A606:  DATA 43,61
0A608:  DATA 6C,00
0A60A:  DATA 67,4D
0A60C:  DATA 6F,6E
0A60E:  DATA 00,67
0A610:  DATA 50,49
0A612:  DATA 44,64
0A614:  DATA 61,74
0A616:  DATA 61,00
0A618:  DATA 67,49
0A61A:  DATA 50,64
0A61C:  DATA 61,74
0A61E:  DATA 61,00
0A620:  DATA 67,4D
0A622:  DATA 61,6E
0A624:  DATA 4F,50
0A626:  DATA 00,73
0A628:  DATA 4D,61
0A62A:  DATA 6E,4F
0A62C:  DATA 50,00
0A62E:  DATA 73,46
0A630:  DATA 69,6C
0A632:  DATA 74,4F
0A634:  DATA 6E,00
0A636:  DATA 73,46
0A638:  DATA 69,6C
0A63A:  DATA 74,4F
0A63C:  DATA 66,66
0A63E:  DATA 00,73
0A640:  DATA 48,6F
0A642:  DATA 6D,65
0A644:  DATA 04,C0
0A646:  DATA 00,33
0A648:  DATA 80,65
0A64A:  DATA 06,01
0A64C:  DATA 6D,06
0A64E:  DATA 02,7D
0A650:  DATA 06,53
0A652:  DATA 55,43
0A654:  DATA 43,45
0A656:  DATA 53,53
0A658:  DATA 00,49
0A65A:  DATA 4E,56
0A65C:  DATA 41,4C
0A65E:  DATA 49,44
0A660:  DATA 20,43
0A662:  DATA 4F,4D
0A664:  DATA 4D,41
0A666:  DATA 4E,44
0A668:  DATA 00,49
0A66A:  DATA 4E,56
0A66C:  DATA 41,4C
0A66E:  DATA 49,44
0A670:  DATA 20,50
0A672:  DATA 41,52
0A674:  DATA 41,4D
0A676:  DATA 45,54
0A678:  DATA 45,52
0A67A:  DATA 00,00
0A67C:  DATA 00,00
0A67E:  MOVLW  00
0A680:  MOVWF  FF8
0A682:  MOVLW  A4
0A684:  MOVWF  FF7
0A686:  MOVLW  A0
0A688:  MOVWF  FF6
0A68A:  TBLRD*+
0A68C:  MOVF   FF5,W
0A68E:  MOVWF  00
0A690:  XORLW  00
0A692:  BZ    A6BA
0A694:  TBLRD*+
0A696:  MOVF   FF5,W
0A698:  MOVWF  01
0A69A:  BTFSC  FE8.7
0A69C:  BRA    A6A8
0A69E:  ANDLW  3F
0A6A0:  MOVWF  FEA
0A6A2:  TBLRD*+
0A6A4:  MOVFF  FF5,FE9
0A6A8:  BTFSC  01.6
0A6AA:  TBLRD*+
0A6AC:  BTFSS  01.6
0A6AE:  TBLRD*+
0A6B0:  MOVFF  FF5,FEE
0A6B4:  DCFSNZ 00,F
0A6B6:  BRA    A68A
0A6B8:  BRA    A6AC
0A6BA:  CLRF   FF8
0A6BC:  MOVLW  03
0A6BE:  MOVLB  6
0A6C0:  MOVWF  x92
0A6C2:  MOVLW  E8
0A6C4:  MOVWF  x91
0A6C6:  CLRF   x94
0A6C8:  CLRF   x93
0A6CA:  CLRF   x96
0A6CC:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A6CE:  MOVLB  0
0A6D0:  GOTO   03BE
....................     params_init();                // load parameters
0A6D4:  GOTO   065A
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A6D8:  GOTO   0AA6
....................     control_init();               // initialize the output control DACs
0A6DC:  GOTO   0B3E
....................     serial_init();                // setup the serial port
0A6E0:  GOTO   0CDE
....................     event_timer_init();
0A6E4:  GOTO   0D00
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A6E8:  MOVLW  C0
0A6EA:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A6EC:  MOVLB  6
0A6EE:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A6F0:  MOVLB  0
0A6F2:  GOTO   10D8
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A6F6:  GOTO   4428
....................       
....................         if (controlCounter >= 2){
0A6FA:  MOVLB  6
0A6FC:  MOVF   x94,F
0A6FE:  BNZ   A706
0A700:  MOVF   x93,W
0A702:  SUBLW  01
0A704:  BC    A714
....................             control_task();
0A706:  MOVLB  0
0A708:  GOTO   4FA0
....................             controlCounter = 0;
0A70C:  MOVLB  6
0A70E:  CLRF   x94
0A710:  CLRF   x93
....................         }else controlCounter++;
0A712:  BRA    A71A
0A714:  INCF   x93,F
0A716:  BTFSC  FD8.2
0A718:  INCF   x94,F
....................       
....................         serial_task();             
0A71A:  MOVLB  0
0A71C:  GOTO   507C
....................         command_handler_task();    //execute commands
0A720:  BRA    9FD2
....................         
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A722:  MOVLW  06
0A724:  MOVLB  7
0A726:  MOVWF  x42
0A728:  MOVLW  97
0A72A:  MOVWF  x41
0A72C:  MOVLB  0
0A72E:  CALL   5602
0A732:  MOVF   01,W
0A734:  ADDLW  97
0A736:  MOVLB  6
0A738:  MOVWF  xFB
0A73A:  MOVLW  06
0A73C:  ADDWFC 02,W
0A73E:  MOVWF  xFC
0A740:  MOVLW  01
0A742:  ADDWF  x8F,W
0A744:  MOVWF  xFD
0A746:  MOVF   x8F,W
0A748:  MULLW  26
0A74A:  MOVF   FF3,W
0A74C:  CLRF   xFF
0A74E:  MOVWF  xFE
0A750:  MOVLW  08
0A752:  ADDWF  xFE,W
0A754:  MOVWF  01
0A756:  MOVLW  00
0A758:  ADDWFC xFF,W
0A75A:  MOVWF  03
0A75C:  MOVF   01,W
0A75E:  ADDLW  17
0A760:  MOVWF  FE9
0A762:  MOVLW  01
0A764:  ADDWFC 03,W
0A766:  MOVWF  FEA
0A768:  MOVFF  FEF,6FE
0A76C:  MOVFF  FEC,6FF
0A770:  MOVFF  FEC,700
0A774:  MOVFF  FEC,701
0A778:  MOVF   x8F,W
0A77A:  MULLW  26
0A77C:  MOVF   FF3,W
0A77E:  MOVLB  7
0A780:  CLRF   x03
0A782:  MOVWF  x02
0A784:  MOVLW  0C
0A786:  ADDWF  x02,W
0A788:  MOVWF  01
0A78A:  MOVLW  00
0A78C:  ADDWFC x03,W
0A78E:  MOVWF  03
0A790:  MOVF   01,W
0A792:  ADDLW  17
0A794:  MOVWF  FE9
0A796:  MOVLW  01
0A798:  ADDWFC 03,W
0A79A:  MOVWF  FEA
0A79C:  MOVFF  FEF,702
0A7A0:  MOVFF  FEC,703
0A7A4:  MOVFF  FEC,704
0A7A8:  MOVFF  FEC,705
0A7AC:  MOVFF  6FC,565
0A7B0:  MOVFF  6FB,564
0A7B4:  MOVLW  58
0A7B6:  MOVWF  FF6
0A7B8:  MOVLW  03
0A7BA:  MOVWF  FF7
0A7BC:  MOVLW  04
0A7BE:  MOVWF  x0F
0A7C0:  MOVLB  0
0A7C2:  CALL   6070
0A7C6:  MOVFF  6FD,706
0A7CA:  MOVLW  1B
0A7CC:  MOVLB  7
0A7CE:  MOVWF  x07
0A7D0:  MOVLB  0
0A7D2:  RCALL  A0FE
0A7D4:  MOVLW  2C
0A7D6:  MOVLB  7
0A7D8:  MOVWF  x50
0A7DA:  MOVLB  0
0A7DC:  CALL   563A
0A7E0:  MOVLW  89
0A7E2:  MOVWF  FE9
0A7E4:  MOVFF  701,746
0A7E8:  MOVFF  700,745
0A7EC:  MOVFF  6FF,744
0A7F0:  MOVFF  6FE,743
0A7F4:  MOVLB  7
0A7F6:  CLRF   x47
0A7F8:  MOVLB  0
0A7FA:  CALL   6516
0A7FE:  MOVLW  2C
0A800:  MOVLB  7
0A802:  MOVWF  x50
0A804:  MOVLB  0
0A806:  CALL   563A
0A80A:  MOVLW  89
0A80C:  MOVWF  FE9
0A80E:  MOVFF  705,746
0A812:  MOVFF  704,745
0A816:  MOVFF  703,744
0A81A:  MOVFF  702,743
0A81E:  MOVLB  7
0A820:  CLRF   x47
0A822:  MOVLB  0
0A824:  CALL   6516
0A828:  MOVLW  3B
0A82A:  MOVLB  7
0A82C:  MOVWF  x50
0A82E:  MOVLB  0
0A830:  CALL   563A
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A834:  MOVLW  06
0A836:  MOVLB  7
0A838:  MOVWF  x42
0A83A:  MOVLW  97
0A83C:  MOVWF  x41
0A83E:  MOVLB  0
0A840:  CALL   5602
0A844:  MOVF   01,W
0A846:  ADDLW  97
0A848:  MOVLB  6
0A84A:  MOVWF  xFB
0A84C:  MOVLW  06
0A84E:  ADDWFC 02,W
0A850:  MOVWF  xFC
0A852:  MOVLW  01
0A854:  ADDWF  x8F,W
0A856:  MOVWF  xFD
0A858:  MOVF   x8F,W
0A85A:  MULLW  26
0A85C:  MOVF   FF3,W
0A85E:  CLRF   xFF
0A860:  MOVWF  xFE
0A862:  MOVLW  1D
0A864:  ADDWF  xFE,W
0A866:  MOVWF  01
0A868:  MOVLW  00
0A86A:  ADDWFC xFF,W
0A86C:  MOVWF  03
0A86E:  MOVF   01,W
0A870:  ADDLW  17
0A872:  MOVWF  FE9
0A874:  MOVLW  01
0A876:  ADDWFC 03,W
0A878:  MOVWF  FEA
0A87A:  MOVFF  FEF,6FE
0A87E:  MOVFF  FEC,6FF
0A882:  MOVFF  FEC,700
0A886:  MOVFF  FEC,701
0A88A:  MOVFF  6FC,565
0A88E:  MOVFF  6FB,564
0A892:  MOVLW  6A
0A894:  MOVWF  FF6
0A896:  MOVLW  03
0A898:  MOVWF  FF7
0A89A:  MOVLW  04
0A89C:  MOVLB  7
0A89E:  MOVWF  x0F
0A8A0:  MOVLB  0
0A8A2:  CALL   6070
0A8A6:  MOVFF  6FD,706
0A8AA:  MOVLW  1B
0A8AC:  MOVLB  7
0A8AE:  MOVWF  x07
0A8B0:  MOVLB  0
0A8B2:  RCALL  A0FE
0A8B4:  MOVLW  2C
0A8B6:  MOVLB  7
0A8B8:  MOVWF  x50
0A8BA:  MOVLB  0
0A8BC:  CALL   563A
0A8C0:  MOVLW  89
0A8C2:  MOVWF  FE9
0A8C4:  MOVFF  701,746
0A8C8:  MOVFF  700,745
0A8CC:  MOVFF  6FF,744
0A8D0:  MOVFF  6FE,743
0A8D4:  MOVLW  03
0A8D6:  MOVLB  7
0A8D8:  MOVWF  x47
0A8DA:  MOVLB  0
0A8DC:  CALL   6516
0A8E0:  MOVLW  3B
0A8E2:  MOVLB  7
0A8E4:  MOVWF  x50
0A8E6:  MOVLB  0
0A8E8:  CALL   563A
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A8EC:  MOVLB  6
0A8EE:  MOVF   x8F,W
0A8F0:  MULLW  07
0A8F2:  MOVF   FF3,W
0A8F4:  CLRF   xFC
0A8F6:  MOVWF  xFB
0A8F8:  MOVLW  64
0A8FA:  ADDWF  xFB,W
0A8FC:  MOVWF  FE9
0A8FE:  MOVLW  01
0A900:  ADDWFC xFC,W
0A902:  MOVWF  FEA
0A904:  BTFSS  FEF.0
0A906:  BRA    A9B6
0A908:  MOVLW  06
0A90A:  MOVLB  7
0A90C:  MOVWF  x42
0A90E:  MOVLW  97
0A910:  MOVWF  x41
0A912:  MOVLB  0
0A914:  CALL   5602
0A918:  MOVF   01,W
0A91A:  ADDLW  97
0A91C:  MOVLB  6
0A91E:  MOVWF  xFB
0A920:  MOVLW  06
0A922:  ADDWFC 02,W
0A924:  MOVWF  xFC
0A926:  MOVLW  01
0A928:  ADDWF  x8F,W
0A92A:  MOVWF  xFD
0A92C:  MOVF   x8F,W
0A92E:  MULLW  07
0A930:  MOVF   FF3,W
0A932:  CLRF   xFF
0A934:  MOVWF  xFE
0A936:  MOVLW  01
0A938:  ADDWF  xFE,W
0A93A:  MOVWF  01
0A93C:  MOVLW  00
0A93E:  ADDWFC xFF,W
0A940:  MOVWF  03
0A942:  MOVF   01,W
0A944:  ADDLW  64
0A946:  MOVWF  FE9
0A948:  MOVLW  01
0A94A:  ADDWFC 03,W
0A94C:  MOVWF  FEA
0A94E:  MOVFF  FEC,6FF
0A952:  MOVF   FED,F
0A954:  MOVFF  FEF,6FE
0A958:  MOVFF  6FC,565
0A95C:  MOVFF  6FB,564
0A960:  MOVLW  78
0A962:  MOVWF  FF6
0A964:  MOVLW  03
0A966:  MOVWF  FF7
0A968:  MOVLW  04
0A96A:  MOVLB  7
0A96C:  MOVWF  x0F
0A96E:  MOVLB  0
0A970:  CALL   6070
0A974:  MOVFF  6FD,706
0A978:  MOVLW  1B
0A97A:  MOVLB  7
0A97C:  MOVWF  x07
0A97E:  MOVLB  0
0A980:  CALL   A0FE
0A984:  MOVLW  7E
0A986:  MOVWF  FF6
0A988:  MOVLW  03
0A98A:  MOVWF  FF7
0A98C:  MOVLW  03
0A98E:  MOVLB  7
0A990:  MOVWF  x0F
0A992:  MOVLB  0
0A994:  CALL   6070
0A998:  MOVLW  10
0A99A:  MOVWF  FE9
0A99C:  MOVFF  6FF,701
0A9A0:  MOVFF  6FE,700
0A9A4:  CALL   A184
0A9A8:  MOVLW  3B
0A9AA:  MOVLB  7
0A9AC:  MOVWF  x50
0A9AE:  MOVLB  0
0A9B0:  CALL   563A
0A9B4:  BRA    AA62
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0A9B6:  MOVLW  06
0A9B8:  MOVLB  7
0A9BA:  MOVWF  x42
0A9BC:  MOVLW  97
0A9BE:  MOVWF  x41
0A9C0:  MOVLB  0
0A9C2:  CALL   5602
0A9C6:  MOVF   01,W
0A9C8:  ADDLW  97
0A9CA:  MOVLB  6
0A9CC:  MOVWF  xFB
0A9CE:  MOVLW  06
0A9D0:  ADDWFC 02,W
0A9D2:  MOVWF  xFC
0A9D4:  MOVLW  01
0A9D6:  ADDWF  x8F,W
0A9D8:  MOVWF  xFD
0A9DA:  MOVF   x8F,W
0A9DC:  MULLW  07
0A9DE:  MOVF   FF3,W
0A9E0:  CLRF   xFF
0A9E2:  MOVWF  xFE
0A9E4:  MOVLW  01
0A9E6:  ADDWF  xFE,W
0A9E8:  MOVWF  01
0A9EA:  MOVLW  00
0A9EC:  ADDWFC xFF,W
0A9EE:  MOVWF  03
0A9F0:  MOVF   01,W
0A9F2:  ADDLW  64
0A9F4:  MOVWF  FE9
0A9F6:  MOVLW  01
0A9F8:  ADDWFC 03,W
0A9FA:  MOVWF  FEA
0A9FC:  MOVFF  FEC,6FF
0AA00:  MOVF   FED,F
0AA02:  MOVFF  FEF,6FE
0AA06:  MOVFF  6FC,565
0AA0A:  MOVFF  6FB,564
0AA0E:  MOVLW  86
0AA10:  MOVWF  FF6
0AA12:  MOVLW  03
0AA14:  MOVWF  FF7
0AA16:  MOVLW  04
0AA18:  MOVLB  7
0AA1A:  MOVWF  x0F
0AA1C:  MOVLB  0
0AA1E:  CALL   6070
0AA22:  MOVFF  6FD,706
0AA26:  MOVLW  1B
0AA28:  MOVLB  7
0AA2A:  MOVWF  x07
0AA2C:  MOVLB  0
0AA2E:  CALL   A0FE
0AA32:  MOVLW  8C
0AA34:  MOVWF  FF6
0AA36:  MOVLW  03
0AA38:  MOVWF  FF7
0AA3A:  MOVLW  03
0AA3C:  MOVLB  7
0AA3E:  MOVWF  x0F
0AA40:  MOVLB  0
0AA42:  CALL   6070
0AA46:  MOVLW  10
0AA48:  MOVWF  FE9
0AA4A:  MOVFF  6FF,701
0AA4E:  MOVFF  6FE,700
0AA52:  CALL   A184
0AA56:  MOVLW  3B
0AA58:  MOVLB  7
0AA5A:  MOVWF  x50
0AA5C:  MOVLB  0
0AA5E:  CALL   563A
....................             ch = !ch;
0AA62:  MOVLB  6
0AA64:  MOVF   x8F,F
0AA66:  BTFSC  FD8.2
0AA68:  BRA    AA6E
0AA6A:  MOVLW  00
0AA6C:  BRA    AA70
0AA6E:  MOVLW  01
0AA70:  MOVWF  x8F
....................             debugCounter = 0;
0AA72:  CLRF   x96
0AA74:  CLRF   x95
....................         }else debugCounter++;
....................         fprintf(ICD_STREAM, "%s\n", pBuff);
0AA76:  MOVLW  06
0AA78:  MOVWF  FEA
0AA7A:  MOVLW  97
0AA7C:  MOVWF  FE9
0AA7E:  MOVLB  0
0AA80:  BRA    A29E
0AA82:  MOVLW  0A
0AA84:  MOVLB  6
0AA86:  MOVWF  xFD
0AA88:  MOVLB  0
0AA8A:  CALL   A24C
....................         #endif
....................       
....................         delay_ms(loopDelay);
0AA8E:  MOVFF  692,6FB
0AA92:  MOVLB  6
0AA94:  INCF   xFB,F
0AA96:  DECF   xFB,F
0AA98:  BTFSC  FD8.2
0AA9A:  BRA    AAAA
0AA9C:  MOVLB  7
0AA9E:  SETF   x01
0AAA0:  MOVLB  0
0AAA2:  CALL   0394
0AAA6:  MOVLB  6
0AAA8:  BRA    AA96
0AAAA:  MOVFF  691,701
0AAAE:  MOVLB  0
0AAB0:  CALL   0394
0AAB4:  BRA    A6EC
....................     }
.................... }
0AAB6:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
