CCS PCH C Compiler, Version 5.109, 62303               16-Dec-25 14:36

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   43680 bytes (67%)
                           Largest free fragment is 21854
               RAM used:   1798 (50%) at main() level
                           1911 (53%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   A2B8
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   0122
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0294
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
00368:  DATA 32,30
0036A:  DATA 32,35
0036C:  DATA 31,32
0036E:  DATA 30,38
00370:  DATA 00,00
00372:  DATA 30,30
00374:  DATA 30,30
00376:  DATA 00,00
00378:  DATA 25,64
0037A:  DATA 2C,4D
0037C:  DATA 41,4E
0037E:  DATA 55,41
00380:  DATA 4C,2C
00382:  DATA 00,00
00384:  DATA 25,64
00386:  DATA 2C,4D
00388:  DATA 41,47
0038A:  DATA 53,4E
0038C:  DATA 53,2C
0038E:  DATA 00,00
00390:  DATA 43,4E
00392:  DATA 54,2C
00394:  DATA 25,75
00396:  DATA 2C,25
00398:  DATA 2E,30
0039A:  DATA 66,2C
0039C:  DATA 25,2E
0039E:  DATA 30,66
003A0:  DATA 3B,00
003A2:  DATA 50,4F
003A4:  DATA 53,2C
003A6:  DATA 25,75
003A8:  DATA 2C,25
003AA:  DATA 33,2E
003AC:  DATA 33,66
003AE:  DATA 3B,00
003B0:  DATA 4F,55
003B2:  DATA 54,2C
003B4:  DATA 25,75
003B6:  DATA 2C,2D
003B8:  DATA 2C,25
003BA:  DATA 4C,75
003BC:  DATA 3B,00
003BE:  DATA 4F,55
003C0:  DATA 54,2C
003C2:  DATA 25,75
003C4:  DATA 2C,2B
003C6:  DATA 2C,25
003C8:  DATA 4C,75
003CA:  DATA 3B,00
*
00710:  ADDWF  FE8,W
00712:  CLRF   FF7
00714:  RLCF   FF7,F
00716:  ADDLW  2B
00718:  MOVWF  FF6
0071A:  MOVLW  07
0071C:  ADDWFC FF7,F
0071E:  TBLRD*-
00720:  MOVF   FF5,W
00722:  MOVWF  FFA
00724:  TBLRD*
00726:  MOVF   FF5,W
00728:  MOVWF  FF9
0072A:  DATA DA,06
0072C:  DATA E4,06
0072E:  DATA EE,06
00730:  DATA F8,06
*
008BA:  MOVLB  7
008BC:  MOVF   x41,W
008BE:  MULWF  x43
008C0:  MOVFF  FF3,01
008C4:  MOVFF  FF4,00
008C8:  MULWF  x44
008CA:  MOVF   FF3,W
008CC:  ADDWF  00,F
008CE:  MOVF   x42,W
008D0:  MULWF  x43
008D2:  MOVF   FF3,W
008D4:  ADDWFC 00,W
008D6:  MOVWF  02
008D8:  MOVLB  0
008DA:  RETURN 0
008DC:  MOVLB  7
008DE:  MOVF   x3B,W
008E0:  CLRF   01
008E2:  SUBWF  x3A,W
008E4:  BC    08EC
008E6:  MOVFF  73A,00
008EA:  BRA    0904
008EC:  CLRF   00
008EE:  MOVLW  08
008F0:  MOVWF  x3C
008F2:  RLCF   x3A,F
008F4:  RLCF   00,F
008F6:  MOVF   x3B,W
008F8:  SUBWF  00,W
008FA:  BTFSC  FD8.0
008FC:  MOVWF  00
008FE:  RLCF   01,F
00900:  DECFSZ x3C,F
00902:  BRA    08F2
00904:  MOVLB  0
00906:  RETURN 0
*
00D6E:  MOVLW  8E
00D70:  MOVWF  00
00D72:  MOVFF  74B,01
00D76:  MOVFF  74A,02
00D7A:  CLRF   03
00D7C:  MOVF   01,F
00D7E:  BNZ   0D92
00D80:  MOVFF  02,01
00D84:  CLRF   02
00D86:  MOVLW  08
00D88:  SUBWF  00,F
00D8A:  MOVF   01,F
00D8C:  BNZ   0D92
00D8E:  CLRF   00
00D90:  BRA    0DA2
00D92:  BCF    FD8.0
00D94:  BTFSC  01.7
00D96:  BRA    0DA0
00D98:  RLCF   02,F
00D9A:  RLCF   01,F
00D9C:  DECF   00,F
00D9E:  BRA    0D92
00DA0:  BCF    01.7
00DA2:  RETURN 0
00DA4:  MOVLB  7
00DA6:  MOVF   x50,W
00DA8:  BTFSC  FD8.2
00DAA:  BRA    0E8E
00DAC:  MOVWF  00
00DAE:  MOVF   x54,W
00DB0:  BTFSC  FD8.2
00DB2:  BRA    0E8E
00DB4:  ADDWF  00,F
00DB6:  BNC   0DC0
00DB8:  MOVLW  81
00DBA:  ADDWF  00,F
00DBC:  BC    0E8E
00DBE:  BRA    0DC8
00DC0:  MOVLW  7F
00DC2:  SUBWF  00,F
00DC4:  BNC   0E8E
00DC6:  BZ    0E8E
00DC8:  MOVFF  751,758
00DCC:  MOVF   x55,W
00DCE:  XORWF  x58,F
00DD0:  BSF    x51.7
00DD2:  BSF    x55.7
00DD4:  MOVF   x53,W
00DD6:  MULWF  x57
00DD8:  MOVFF  FF4,75A
00DDC:  MOVF   x52,W
00DDE:  MULWF  x56
00DE0:  MOVFF  FF4,03
00DE4:  MOVFF  FF3,759
00DE8:  MULWF  x57
00DEA:  MOVF   FF3,W
00DEC:  ADDWF  x5A,F
00DEE:  MOVF   FF4,W
00DF0:  ADDWFC x59,F
00DF2:  MOVLW  00
00DF4:  ADDWFC 03,F
00DF6:  MOVF   x53,W
00DF8:  MULWF  x56
00DFA:  MOVF   FF3,W
00DFC:  ADDWF  x5A,F
00DFE:  MOVF   FF4,W
00E00:  ADDWFC x59,F
00E02:  MOVLW  00
00E04:  CLRF   02
00E06:  ADDWFC 03,F
00E08:  ADDWFC 02,F
00E0A:  MOVF   x51,W
00E0C:  MULWF  x57
00E0E:  MOVF   FF3,W
00E10:  ADDWF  x59,F
00E12:  MOVF   FF4,W
00E14:  ADDWFC 03,F
00E16:  MOVLW  00
00E18:  ADDWFC 02,F
00E1A:  MOVF   x51,W
00E1C:  MULWF  x56
00E1E:  MOVF   FF3,W
00E20:  ADDWF  03,F
00E22:  MOVF   FF4,W
00E24:  ADDWFC 02,F
00E26:  MOVLW  00
00E28:  CLRF   01
00E2A:  ADDWFC 01,F
00E2C:  MOVF   x53,W
00E2E:  MULWF  x55
00E30:  MOVF   FF3,W
00E32:  ADDWF  x59,F
00E34:  MOVF   FF4,W
00E36:  ADDWFC 03,F
00E38:  MOVLW  00
00E3A:  ADDWFC 02,F
00E3C:  ADDWFC 01,F
00E3E:  MOVF   x52,W
00E40:  MULWF  x55
00E42:  MOVF   FF3,W
00E44:  ADDWF  03,F
00E46:  MOVF   FF4,W
00E48:  ADDWFC 02,F
00E4A:  MOVLW  00
00E4C:  ADDWFC 01,F
00E4E:  MOVF   x51,W
00E50:  MULWF  x55
00E52:  MOVF   FF3,W
00E54:  ADDWF  02,F
00E56:  MOVF   FF4,W
00E58:  ADDWFC 01,F
00E5A:  INCF   00,F
00E5C:  BTFSC  01.7
00E5E:  BRA    0E6A
00E60:  RLCF   x59,F
00E62:  RLCF   03,F
00E64:  RLCF   02,F
00E66:  RLCF   01,F
00E68:  DECF   00,F
00E6A:  MOVLW  00
00E6C:  BTFSS  x59.7
00E6E:  BRA    0E84
00E70:  INCF   03,F
00E72:  ADDWFC 02,F
00E74:  ADDWFC 01,F
00E76:  MOVF   01,W
00E78:  BNZ   0E84
00E7A:  MOVF   02,W
00E7C:  BNZ   0E84
00E7E:  MOVF   03,W
00E80:  BNZ   0E84
00E82:  INCF   00,F
00E84:  BTFSC  x58.7
00E86:  BSF    01.7
00E88:  BTFSS  x58.7
00E8A:  BCF    01.7
00E8C:  BRA    0E96
00E8E:  CLRF   00
00E90:  CLRF   01
00E92:  CLRF   02
00E94:  CLRF   03
00E96:  MOVLB  0
00E98:  RETURN 0
00E9A:  MOVLW  80
00E9C:  BTFSS  FD8.1
00E9E:  BRA    0EA4
00EA0:  MOVLB  7
00EA2:  XORWF  x4F,F
00EA4:  MOVLB  7
00EA6:  CLRF   x54
00EA8:  CLRF   x55
00EAA:  MOVFF  74B,753
00EAE:  MOVF   x4F,W
00EB0:  XORWF  x53,F
00EB2:  MOVF   x4A,W
00EB4:  BTFSC  FD8.2
00EB6:  BRA    1076
00EB8:  MOVWF  x52
00EBA:  MOVWF  00
00EBC:  MOVF   x4E,W
00EBE:  BTFSC  FD8.2
00EC0:  BRA    1088
00EC2:  SUBWF  x52,F
00EC4:  BTFSC  FD8.2
00EC6:  BRA    0FCE
00EC8:  BNC   0F46
00ECA:  MOVFF  74F,758
00ECE:  BSF    x58.7
00ED0:  MOVFF  750,757
00ED4:  MOVFF  751,756
00ED8:  CLRF   x55
00EDA:  BCF    FD8.0
00EDC:  RRCF   x58,F
00EDE:  RRCF   x57,F
00EE0:  RRCF   x56,F
00EE2:  RRCF   x55,F
00EE4:  DECFSZ x52,F
00EE6:  BRA    0ED8
00EE8:  BTFSS  x53.7
00EEA:  BRA    0EF2
00EEC:  BSF    x54.0
00EEE:  BRA    10B0
00EF0:  BCF    x54.0
00EF2:  BCF    x52.0
00EF4:  BSF    x54.4
00EF6:  MOVLW  07
00EF8:  MOVWF  FEA
00EFA:  MOVLW  4D
00EFC:  MOVWF  FE9
00EFE:  BRA    10D6
00F00:  BCF    x54.4
00F02:  BTFSC  x53.7
00F04:  BRA    0F1A
00F06:  BTFSS  x52.0
00F08:  BRA    0F30
00F0A:  RRCF   x58,F
00F0C:  RRCF   x57,F
00F0E:  RRCF   x56,F
00F10:  RRCF   x55,F
00F12:  INCF   00,F
00F14:  BTFSC  FD8.2
00F16:  BRA    10A6
00F18:  BRA    0F30
00F1A:  BTFSC  x58.7
00F1C:  BRA    0F36
00F1E:  BCF    FD8.0
00F20:  RLCF   x55,F
00F22:  RLCF   x56,F
00F24:  RLCF   x57,F
00F26:  RLCF   x58,F
00F28:  DECF   00,F
00F2A:  BTFSC  FD8.2
00F2C:  BRA    10A6
00F2E:  BRA    0F1A
00F30:  BSF    x54.6
00F32:  BRA    100E
00F34:  BCF    x54.6
00F36:  MOVFF  74B,753
00F3A:  BTFSS  x4B.7
00F3C:  BRA    0F42
00F3E:  BSF    x58.7
00F40:  BRA    1098
00F42:  BCF    x58.7
00F44:  BRA    1098
00F46:  MOVFF  74E,752
00F4A:  MOVFF  74E,00
00F4E:  MOVF   x4A,W
00F50:  SUBWF  x52,F
00F52:  MOVFF  74B,758
00F56:  BSF    x58.7
00F58:  MOVFF  74C,757
00F5C:  MOVFF  74D,756
00F60:  CLRF   x55
00F62:  BCF    FD8.0
00F64:  RRCF   x58,F
00F66:  RRCF   x57,F
00F68:  RRCF   x56,F
00F6A:  RRCF   x55,F
00F6C:  DECFSZ x52,F
00F6E:  BRA    0F60
00F70:  BTFSS  x53.7
00F72:  BRA    0F7A
00F74:  BSF    x54.1
00F76:  BRA    10B0
00F78:  BCF    x54.1
00F7A:  BCF    x52.0
00F7C:  BSF    x54.5
00F7E:  MOVLW  07
00F80:  MOVWF  FEA
00F82:  MOVLW  51
00F84:  MOVWF  FE9
00F86:  BRA    10D6
00F88:  BCF    x54.5
00F8A:  BTFSC  x53.7
00F8C:  BRA    0FA2
00F8E:  BTFSS  x52.0
00F90:  BRA    0FB8
00F92:  RRCF   x58,F
00F94:  RRCF   x57,F
00F96:  RRCF   x56,F
00F98:  RRCF   x55,F
00F9A:  INCF   00,F
00F9C:  BTFSC  FD8.2
00F9E:  BRA    10A6
00FA0:  BRA    0FB8
00FA2:  BTFSC  x58.7
00FA4:  BRA    0FBE
00FA6:  BCF    FD8.0
00FA8:  RLCF   x55,F
00FAA:  RLCF   x56,F
00FAC:  RLCF   x57,F
00FAE:  RLCF   x58,F
00FB0:  DECF   00,F
00FB2:  BTFSC  FD8.2
00FB4:  BRA    10A6
00FB6:  BRA    0FA2
00FB8:  BSF    x54.7
00FBA:  BRA    100E
00FBC:  BCF    x54.7
00FBE:  MOVFF  74F,753
00FC2:  BTFSS  x4F.7
00FC4:  BRA    0FCA
00FC6:  BSF    x58.7
00FC8:  BRA    1098
00FCA:  BCF    x58.7
00FCC:  BRA    1098
00FCE:  MOVFF  74F,758
00FD2:  BSF    x58.7
00FD4:  MOVFF  750,757
00FD8:  MOVFF  751,756
00FDC:  BTFSS  x53.7
00FDE:  BRA    0FE8
00FE0:  BCF    x58.7
00FE2:  BSF    x54.2
00FE4:  BRA    10B0
00FE6:  BCF    x54.2
00FE8:  CLRF   x55
00FEA:  BCF    x52.0
00FEC:  MOVLW  07
00FEE:  MOVWF  FEA
00FF0:  MOVLW  4D
00FF2:  MOVWF  FE9
00FF4:  BRA    10D6
00FF6:  BTFSC  x53.7
00FF8:  BRA    1032
00FFA:  MOVFF  74B,753
00FFE:  BTFSS  x52.0
01000:  BRA    100E
01002:  RRCF   x58,F
01004:  RRCF   x57,F
01006:  RRCF   x56,F
01008:  RRCF   x55,F
0100A:  INCF   00,F
0100C:  BZ    10A6
0100E:  BTFSS  x55.7
01010:  BRA    1028
01012:  INCF   x56,F
01014:  BNZ   1028
01016:  INCF   x57,F
01018:  BNZ   1028
0101A:  INCF   x58,F
0101C:  BNZ   1028
0101E:  RRCF   x58,F
01020:  RRCF   x57,F
01022:  RRCF   x56,F
01024:  INCF   00,F
01026:  BZ    10A6
01028:  BTFSC  x54.6
0102A:  BRA    0F34
0102C:  BTFSC  x54.7
0102E:  BRA    0FBC
01030:  BRA    106A
01032:  MOVLW  80
01034:  XORWF  x58,F
01036:  BTFSS  x58.7
01038:  BRA    1042
0103A:  BRA    10B0
0103C:  MOVFF  74F,753
01040:  BRA    1056
01042:  MOVFF  74B,753
01046:  MOVF   x58,F
01048:  BNZ   1056
0104A:  MOVF   x57,F
0104C:  BNZ   1056
0104E:  MOVF   x56,F
01050:  BNZ   1056
01052:  CLRF   00
01054:  BRA    1098
01056:  BTFSC  x58.7
01058:  BRA    106A
0105A:  BCF    FD8.0
0105C:  RLCF   x55,F
0105E:  RLCF   x56,F
01060:  RLCF   x57,F
01062:  RLCF   x58,F
01064:  DECFSZ 00,F
01066:  BRA    1056
01068:  BRA    10A6
0106A:  BTFSS  x53.7
0106C:  BRA    1072
0106E:  BSF    x58.7
01070:  BRA    1098
01072:  BCF    x58.7
01074:  BRA    1098
01076:  MOVFF  74E,00
0107A:  MOVFF  74F,758
0107E:  MOVFF  750,757
01082:  MOVFF  751,756
01086:  BRA    1098
01088:  MOVFF  74A,00
0108C:  MOVFF  74B,758
01090:  MOVFF  74C,757
01094:  MOVFF  74D,756
01098:  MOVFF  758,01
0109C:  MOVFF  757,02
010A0:  MOVFF  756,03
010A4:  BRA    110E
010A6:  CLRF   00
010A8:  CLRF   01
010AA:  CLRF   02
010AC:  CLRF   03
010AE:  BRA    110E
010B0:  CLRF   x55
010B2:  COMF   x56,F
010B4:  COMF   x57,F
010B6:  COMF   x58,F
010B8:  COMF   x55,F
010BA:  INCF   x55,F
010BC:  BNZ   10C8
010BE:  INCF   x56,F
010C0:  BNZ   10C8
010C2:  INCF   x57,F
010C4:  BNZ   10C8
010C6:  INCF   x58,F
010C8:  BTFSC  x54.0
010CA:  BRA    0EF0
010CC:  BTFSC  x54.1
010CE:  BRA    0F78
010D0:  BTFSC  x54.2
010D2:  BRA    0FE6
010D4:  BRA    103C
010D6:  MOVF   FEF,W
010D8:  ADDWF  x56,F
010DA:  BNC   10E6
010DC:  INCF   x57,F
010DE:  BNZ   10E6
010E0:  INCF   x58,F
010E2:  BTFSC  FD8.2
010E4:  BSF    x52.0
010E6:  MOVF   FED,F
010E8:  MOVF   FEF,W
010EA:  ADDWF  x57,F
010EC:  BNC   10F4
010EE:  INCF   x58,F
010F0:  BTFSC  FD8.2
010F2:  BSF    x52.0
010F4:  MOVF   FED,F
010F6:  MOVF   FEF,W
010F8:  BTFSC  FEF.7
010FA:  BRA    10FE
010FC:  XORLW  80
010FE:  ADDWF  x58,F
01100:  BTFSC  FD8.0
01102:  BSF    x52.0
01104:  BTFSC  x54.4
01106:  BRA    0F00
01108:  BTFSC  x54.5
0110A:  BRA    0F88
0110C:  BRA    0FF6
0110E:  MOVLB  0
01110:  RETURN 0
*
01668:  ADDWF  FE8,W
0166A:  CLRF   FF7
0166C:  RLCF   FF7,F
0166E:  ADDLW  83
01670:  MOVWF  FF6
01672:  MOVLW  16
01674:  ADDWFC FF7,F
01676:  TBLRD*-
01678:  MOVF   FF5,W
0167A:  MOVWF  FFA
0167C:  TBLRD*
0167E:  MOVF   FF5,W
01680:  MOVWF  FF9
01682:  DATA 2A,11
01684:  DATA EA,11
01686:  DATA AA,12
01688:  DATA 6A,13
0168A:  DATA 2A,14
0168C:  DATA EA,14
0168E:  DATA AA,15
01690:  BTFSC  FD8.1
01692:  BRA    169C
01694:  MOVLW  07
01696:  MOVWF  FEA
01698:  MOVLW  39
0169A:  MOVWF  FE9
0169C:  MOVLB  7
0169E:  MOVF   x34,W
016A0:  XORWF  x38,W
016A2:  ANDLW  80
016A4:  MOVWF  x3E
016A6:  BTFSS  x34.7
016A8:  BRA    16C0
016AA:  COMF   x31,F
016AC:  COMF   x32,F
016AE:  COMF   x33,F
016B0:  COMF   x34,F
016B2:  INCF   x31,F
016B4:  BTFSC  FD8.2
016B6:  INCF   x32,F
016B8:  BTFSC  FD8.2
016BA:  INCF   x33,F
016BC:  BTFSC  FD8.2
016BE:  INCF   x34,F
016C0:  BTFSS  x38.7
016C2:  BRA    16DA
016C4:  COMF   x35,F
016C6:  COMF   x36,F
016C8:  COMF   x37,F
016CA:  COMF   x38,F
016CC:  INCF   x35,F
016CE:  BTFSC  FD8.2
016D0:  INCF   x36,F
016D2:  BTFSC  FD8.2
016D4:  INCF   x37,F
016D6:  BTFSC  FD8.2
016D8:  INCF   x38,F
016DA:  CLRF   00
016DC:  CLRF   01
016DE:  CLRF   02
016E0:  CLRF   03
016E2:  CLRF   x39
016E4:  CLRF   x3A
016E6:  CLRF   x3B
016E8:  CLRF   x3C
016EA:  MOVF   x38,W
016EC:  IORWF  x37,W
016EE:  IORWF  x36,W
016F0:  IORWF  x35,W
016F2:  BZ    174C
016F4:  MOVLW  20
016F6:  MOVWF  x3D
016F8:  BCF    FD8.0
016FA:  RLCF   x31,F
016FC:  RLCF   x32,F
016FE:  RLCF   x33,F
01700:  RLCF   x34,F
01702:  RLCF   x39,F
01704:  RLCF   x3A,F
01706:  RLCF   x3B,F
01708:  RLCF   x3C,F
0170A:  MOVF   x38,W
0170C:  SUBWF  x3C,W
0170E:  BNZ   1720
01710:  MOVF   x37,W
01712:  SUBWF  x3B,W
01714:  BNZ   1720
01716:  MOVF   x36,W
01718:  SUBWF  x3A,W
0171A:  BNZ   1720
0171C:  MOVF   x35,W
0171E:  SUBWF  x39,W
01720:  BNC   1740
01722:  MOVF   x35,W
01724:  SUBWF  x39,F
01726:  MOVF   x36,W
01728:  BTFSS  FD8.0
0172A:  INCFSZ x36,W
0172C:  SUBWF  x3A,F
0172E:  MOVF   x37,W
01730:  BTFSS  FD8.0
01732:  INCFSZ x37,W
01734:  SUBWF  x3B,F
01736:  MOVF   x38,W
01738:  BTFSS  FD8.0
0173A:  INCFSZ x38,W
0173C:  SUBWF  x3C,F
0173E:  BSF    FD8.0
01740:  RLCF   00,F
01742:  RLCF   01,F
01744:  RLCF   02,F
01746:  RLCF   03,F
01748:  DECFSZ x3D,F
0174A:  BRA    16F8
0174C:  BTFSS  x3E.7
0174E:  BRA    1766
01750:  COMF   00,F
01752:  COMF   01,F
01754:  COMF   02,F
01756:  COMF   03,F
01758:  INCF   00,F
0175A:  BTFSC  FD8.2
0175C:  INCF   01,F
0175E:  BTFSC  FD8.2
01760:  INCF   02,F
01762:  BTFSC  FD8.2
01764:  INCF   03,F
01766:  MOVFF  739,FEF
0176A:  MOVFF  73A,FEC
0176E:  MOVFF  73B,FEC
01772:  MOVFF  73C,FEC
01776:  MOVLB  0
01778:  RETURN 0
*
01CD6:  MOVLW  B6
01CD8:  MOVWF  00
01CDA:  CLRF   03
01CDC:  CLRF   02
01CDE:  CLRF   01
01CE0:  MOVLB  7
01CE2:  BCF    x14.0
01CE4:  BTFSS  x13.7
01CE6:  BRA    1D00
01CE8:  BSF    x14.0
01CEA:  COMF   x10,F
01CEC:  COMF   x11,F
01CEE:  COMF   x12,F
01CF0:  COMF   x13,F
01CF2:  INCF   x10,F
01CF4:  BNZ   1D00
01CF6:  INCF   x11,F
01CF8:  BNZ   1D00
01CFA:  INCF   x12,F
01CFC:  BTFSC  FD8.2
01CFE:  INCF   x13,F
01D00:  MOVF   x10,W
01D02:  IORWF  x11,W
01D04:  IORWF  x12,W
01D06:  IORWF  x13,W
01D08:  BNZ   1D0E
01D0A:  CLRF   00
01D0C:  BRA    1D2C
01D0E:  BCF    FD8.0
01D10:  BTFSC  01.7
01D12:  BRA    1D26
01D14:  RLCF   x10,F
01D16:  RLCF   x11,F
01D18:  RLCF   x12,F
01D1A:  RLCF   x13,F
01D1C:  RLCF   03,F
01D1E:  RLCF   02,F
01D20:  RLCF   01,F
01D22:  DECFSZ 00,F
01D24:  BRA    1D0E
01D26:  BCF    01.7
01D28:  BTFSC  x14.0
01D2A:  BSF    01.7
01D2C:  MOVLB  0
01D2E:  RETURN 0
01D30:  MOVFF  747,74E
01D34:  MOVLB  7
01D36:  MOVF   x4B,W
01D38:  XORWF  x4E,F
01D3A:  BTFSS  x4E.7
01D3C:  BRA    1D48
01D3E:  BCF    FD8.2
01D40:  BCF    FD8.0
01D42:  BTFSC  x47.7
01D44:  BSF    FD8.0
01D46:  BRA    1DA6
01D48:  MOVFF  747,74E
01D4C:  MOVFF  74A,74F
01D50:  MOVF   x46,W
01D52:  SUBWF  x4F,F
01D54:  BZ    1D62
01D56:  BTFSS  x4E.7
01D58:  BRA    1DA6
01D5A:  MOVF   FD8,W
01D5C:  XORLW  01
01D5E:  MOVWF  FD8
01D60:  BRA    1DA6
01D62:  MOVFF  74B,74F
01D66:  MOVF   x47,W
01D68:  SUBWF  x4F,F
01D6A:  BZ    1D78
01D6C:  BTFSS  x4E.7
01D6E:  BRA    1DA6
01D70:  MOVF   FD8,W
01D72:  XORLW  01
01D74:  MOVWF  FD8
01D76:  BRA    1DA6
01D78:  MOVFF  74C,74F
01D7C:  MOVF   x48,W
01D7E:  SUBWF  x4F,F
01D80:  BZ    1D8E
01D82:  BTFSS  x4E.7
01D84:  BRA    1DA6
01D86:  MOVF   FD8,W
01D88:  XORLW  01
01D8A:  MOVWF  FD8
01D8C:  BRA    1DA6
01D8E:  MOVFF  74D,74F
01D92:  MOVF   x49,W
01D94:  SUBWF  x4F,F
01D96:  BZ    1DA4
01D98:  BTFSS  x4E.7
01D9A:  BRA    1DA6
01D9C:  MOVF   FD8,W
01D9E:  XORLW  01
01DA0:  MOVWF  FD8
01DA2:  BRA    1DA6
01DA4:  BCF    FD8.0
01DA6:  MOVLB  0
01DA8:  RETURN 0
01DAA:  MOVLB  7
01DAC:  MOVF   x3F,W
01DAE:  BTFSC  FD8.2
01DB0:  BRA    1EFC
01DB2:  MOVWF  x4B
01DB4:  MOVF   x43,W
01DB6:  BTFSC  FD8.2
01DB8:  BRA    1EFC
01DBA:  SUBWF  x4B,F
01DBC:  BNC   1DC8
01DBE:  MOVLW  7F
01DC0:  ADDWF  x4B,F
01DC2:  BTFSC  FD8.0
01DC4:  BRA    1EFC
01DC6:  BRA    1DD4
01DC8:  MOVLW  81
01DCA:  SUBWF  x4B,F
01DCC:  BTFSS  FD8.0
01DCE:  BRA    1EFC
01DD0:  BTFSC  FD8.2
01DD2:  BRA    1EFC
01DD4:  MOVFF  74B,00
01DD8:  CLRF   01
01DDA:  CLRF   02
01DDC:  CLRF   03
01DDE:  CLRF   x4A
01DE0:  MOVFF  740,749
01DE4:  BSF    x49.7
01DE6:  MOVFF  741,748
01DEA:  MOVFF  742,747
01DEE:  MOVLW  19
01DF0:  MOVWF  x4B
01DF2:  MOVF   x46,W
01DF4:  SUBWF  x47,F
01DF6:  BC    1E12
01DF8:  MOVLW  01
01DFA:  SUBWF  x48,F
01DFC:  BC    1E12
01DFE:  SUBWF  x49,F
01E00:  BC    1E12
01E02:  SUBWF  x4A,F
01E04:  BC    1E12
01E06:  INCF   x4A,F
01E08:  INCF   x49,F
01E0A:  INCF   x48,F
01E0C:  MOVF   x46,W
01E0E:  ADDWF  x47,F
01E10:  BRA    1E62
01E12:  MOVF   x45,W
01E14:  SUBWF  x48,F
01E16:  BC    1E3C
01E18:  MOVLW  01
01E1A:  SUBWF  x49,F
01E1C:  BC    1E3C
01E1E:  SUBWF  x4A,F
01E20:  BC    1E3C
01E22:  INCF   x4A,F
01E24:  INCF   x49,F
01E26:  MOVF   x45,W
01E28:  ADDWF  x48,F
01E2A:  MOVF   x46,W
01E2C:  ADDWF  x47,F
01E2E:  BNC   1E62
01E30:  INCF   x48,F
01E32:  BNZ   1E62
01E34:  INCF   x49,F
01E36:  BNZ   1E62
01E38:  INCF   x4A,F
01E3A:  BRA    1E62
01E3C:  MOVF   x44,W
01E3E:  IORLW  80
01E40:  SUBWF  x49,F
01E42:  BC    1E60
01E44:  MOVLW  01
01E46:  SUBWF  x4A,F
01E48:  BC    1E60
01E4A:  INCF   x4A,F
01E4C:  MOVF   x44,W
01E4E:  IORLW  80
01E50:  ADDWF  x49,F
01E52:  MOVF   x45,W
01E54:  ADDWF  x48,F
01E56:  BNC   1E2A
01E58:  INCF   x49,F
01E5A:  BNZ   1E2A
01E5C:  INCF   x4A,F
01E5E:  BRA    1E2A
01E60:  BSF    03.0
01E62:  DECFSZ x4B,F
01E64:  BRA    1E68
01E66:  BRA    1E7E
01E68:  BCF    FD8.0
01E6A:  RLCF   x47,F
01E6C:  RLCF   x48,F
01E6E:  RLCF   x49,F
01E70:  RLCF   x4A,F
01E72:  BCF    FD8.0
01E74:  RLCF   03,F
01E76:  RLCF   02,F
01E78:  RLCF   01,F
01E7A:  RLCF   x4C,F
01E7C:  BRA    1DF2
01E7E:  BTFSS  x4C.0
01E80:  BRA    1E8E
01E82:  BCF    FD8.0
01E84:  RRCF   01,F
01E86:  RRCF   02,F
01E88:  RRCF   03,F
01E8A:  RRCF   x4C,F
01E8C:  BRA    1E92
01E8E:  DECF   00,F
01E90:  BZ    1EFC
01E92:  BTFSC  x4C.7
01E94:  BRA    1ED2
01E96:  BCF    FD8.0
01E98:  RLCF   x47,F
01E9A:  RLCF   x48,F
01E9C:  RLCF   x49,F
01E9E:  RLCF   x4A,F
01EA0:  MOVF   x46,W
01EA2:  SUBWF  x47,F
01EA4:  BC    1EB4
01EA6:  MOVLW  01
01EA8:  SUBWF  x48,F
01EAA:  BC    1EB4
01EAC:  SUBWF  x49,F
01EAE:  BC    1EB4
01EB0:  SUBWF  x4A,F
01EB2:  BNC   1EE8
01EB4:  MOVF   x45,W
01EB6:  SUBWF  x48,F
01EB8:  BC    1EC4
01EBA:  MOVLW  01
01EBC:  SUBWF  x49,F
01EBE:  BC    1EC4
01EC0:  SUBWF  x4A,F
01EC2:  BNC   1EE8
01EC4:  MOVF   x44,W
01EC6:  IORLW  80
01EC8:  SUBWF  x49,F
01ECA:  BC    1ED2
01ECC:  MOVLW  01
01ECE:  SUBWF  x4A,F
01ED0:  BNC   1EE8
01ED2:  INCF   03,F
01ED4:  BNZ   1EE8
01ED6:  INCF   02,F
01ED8:  BNZ   1EE8
01EDA:  INCF   01,F
01EDC:  BNZ   1EE8
01EDE:  INCF   00,F
01EE0:  BZ    1EFC
01EE2:  RRCF   01,F
01EE4:  RRCF   02,F
01EE6:  RRCF   03,F
01EE8:  MOVFF  740,74B
01EEC:  MOVF   x44,W
01EEE:  XORWF  x4B,F
01EF0:  BTFSS  x4B.7
01EF2:  BRA    1EF8
01EF4:  BSF    01.7
01EF6:  BRA    1F04
01EF8:  BCF    01.7
01EFA:  BRA    1F04
01EFC:  CLRF   00
01EFE:  CLRF   01
01F00:  CLRF   02
01F02:  CLRF   03
01F04:  MOVLB  0
01F06:  RETURN 0
*
026B2:  ADDWF  FE8,W
026B4:  CLRF   FF7
026B6:  RLCF   FF7,F
026B8:  ADDLW  CD
026BA:  MOVWF  FF6
026BC:  MOVLW  26
026BE:  ADDWFC FF7,F
026C0:  TBLRD*-
026C2:  MOVF   FF5,W
026C4:  MOVWF  FFA
026C6:  TBLRD*
026C8:  MOVF   FF5,W
026CA:  MOVWF  FF9
026CC:  DATA BA,25
026CE:  DATA D4,25
026D0:  DATA 28,26
026D2:  DATA 8C,26
026D4:  MOVLW  8E
026D6:  MOVWF  00
026D8:  MOVFF  73D,01
026DC:  MOVFF  73C,02
026E0:  CLRF   03
026E2:  BTFSS  01.7
026E4:  BRA    26F0
026E6:  COMF   01,F
026E8:  COMF   02,F
026EA:  INCF   02,F
026EC:  BNZ   26F0
026EE:  INCF   01,F
026F0:  MOVF   01,F
026F2:  BNZ   2706
026F4:  MOVFF  02,01
026F8:  CLRF   02
026FA:  MOVLW  08
026FC:  SUBWF  00,F
026FE:  MOVF   01,F
02700:  BNZ   2706
02702:  CLRF   00
02704:  BRA    2722
02706:  BCF    FD8.0
02708:  BTFSC  01.7
0270A:  BRA    2714
0270C:  RLCF   02,F
0270E:  RLCF   01,F
02710:  DECF   00,F
02712:  BRA    2706
02714:  MOVLB  7
02716:  BTFSS  x3D.7
02718:  BRA    271E
0271A:  MOVLB  0
0271C:  BRA    2722
0271E:  BCF    01.7
02720:  MOVLB  0
02722:  RETURN 0
02724:  MOVLW  8E
02726:  MOVWF  00
02728:  MOVLB  7
0272A:  MOVF   x46,W
0272C:  SUBWF  00,F
0272E:  MOVFF  747,02
02732:  MOVFF  748,01
02736:  BSF    02.7
02738:  MOVF   00,F
0273A:  BZ    274E
0273C:  BCF    FD8.0
0273E:  MOVF   02,F
02740:  BNZ   2746
02742:  MOVF   01,F
02744:  BZ    274E
02746:  RRCF   02,F
02748:  RRCF   01,F
0274A:  DECFSZ 00,F
0274C:  BRA    273C
0274E:  BTFSS  x47.7
02750:  BRA    275C
02752:  COMF   01,F
02754:  COMF   02,F
02756:  INCF   01,F
02758:  BTFSC  FD8.2
0275A:  INCF   02,F
0275C:  MOVLB  0
0275E:  RETURN 0
*
04618:  MOVLB  7
0461A:  MOVF   x0D,W
0461C:  ANDLW  07
0461E:  MOVWF  00
04620:  RRCF   x0D,W
04622:  MOVWF  01
04624:  RRCF   01,F
04626:  RRCF   01,F
04628:  MOVLW  1F
0462A:  ANDWF  01,F
0462C:  MOVF   01,W
0462E:  ADDWF  x0E,W
04630:  MOVWF  FE9
04632:  MOVLW  00
04634:  ADDWFC x0F,W
04636:  MOVWF  FEA
04638:  MOVFF  FEF,01
0463C:  INCF   00,F
0463E:  BRA    4642
04640:  RRCF   01,F
04642:  DECFSZ 00,F
04644:  BRA    4640
04646:  MOVLW  01
04648:  ANDWF  01,F
0464A:  MOVLB  0
0464C:  RETURN 0
*
050AC:  MOVF   FEF,F
050AE:  BZ    50CE
050B0:  MOVFF  FEA,704
050B4:  MOVFF  FE9,703
050B8:  MOVFF  FEF,705
050BC:  RCALL  505A
050BE:  MOVFF  704,FEA
050C2:  MOVFF  703,FE9
050C6:  INCF   FE9,F
050C8:  BTFSC  FD8.2
050CA:  INCF   FEA,F
050CC:  BRA    50AC
050CE:  GOTO   50DC (RETURN)
*
056A6:  MOVFF  565,FEA
056AA:  MOVFF  564,FE9
056AE:  MOVFF  750,FEF
056B2:  INCF   FE9,F
056B4:  BTFSC  FD8.2
056B6:  INCF   FEA,F
056B8:  CLRF   FEF
056BA:  MOVLB  5
056BC:  INCF   x64,F
056BE:  BTFSC  FD8.2
056C0:  INCF   x65,F
056C2:  MOVLB  0
056C4:  RETURN 0
056C6:  MOVF   FEF,F
056C8:  BZ    56E8
056CA:  MOVFF  FEA,708
056CE:  MOVFF  FE9,707
056D2:  MOVFF  FEF,750
056D6:  RCALL  56A6
056D8:  MOVFF  708,FEA
056DC:  MOVFF  707,FE9
056E0:  INCF   FE9,F
056E2:  BTFSC  FD8.2
056E4:  INCF   FEA,F
056E6:  BRA    56C6
056E8:  RETURN 0
*
0579C:  TBLRD*+
0579E:  MOVF   FF5,F
057A0:  BZ    57BA
057A2:  MOVFF  FF6,70E
057A6:  MOVFF  FF7,70F
057AA:  MOVFF  FF5,750
057AE:  RCALL  56A6
057B0:  MOVFF  70E,FF6
057B4:  MOVFF  70F,FF7
057B8:  BRA    579C
057BA:  RETURN 0
*
058DE:  MOVLB  7
058E0:  MOVF   x68,W
058E2:  XORWF  x6A,W
058E4:  ANDLW  80
058E6:  MOVWF  x6C
058E8:  BTFSS  x68.7
058EA:  BRA    58F6
058EC:  COMF   x67,F
058EE:  COMF   x68,F
058F0:  INCF   x67,F
058F2:  BTFSC  FD8.2
058F4:  INCF   x68,F
058F6:  BTFSS  x6A.7
058F8:  BRA    5904
058FA:  COMF   x69,F
058FC:  COMF   x6A,F
058FE:  INCF   x69,F
05900:  BTFSC  FD8.2
05902:  INCF   x6A,F
05904:  MOVF   x67,W
05906:  MULWF  x69
05908:  MOVFF  FF3,01
0590C:  MOVFF  FF4,00
05910:  MULWF  x6A
05912:  MOVF   FF3,W
05914:  ADDWF  00,F
05916:  MOVF   x68,W
05918:  MULWF  x69
0591A:  MOVF   FF3,W
0591C:  ADDWFC 00,W
0591E:  MOVWF  02
05920:  BTFSS  x6C.7
05922:  BRA    592E
05924:  COMF   01,F
05926:  COMF   02,F
05928:  INCF   01,F
0592A:  BTFSC  FD8.2
0592C:  INCF   02,F
0592E:  MOVLB  0
05930:  GOTO   5BC4 (RETURN)
*
05C88:  MOVLW  20
05C8A:  MOVLB  7
05C8C:  BTFSS  x35.4
05C8E:  MOVLW  30
05C90:  MOVWF  x36
05C92:  MOVFF  734,00
05C96:  BTFSS  00.7
05C98:  BRA    5CAA
05C9A:  COMF   00,F
05C9C:  INCF   00,F
05C9E:  MOVFF  00,734
05CA2:  MOVLW  2D
05CA4:  MOVWF  x36
05CA6:  BSF    x35.7
05CA8:  BSF    x35.0
05CAA:  MOVF   01,W
05CAC:  MOVFF  734,73A
05CB0:  MOVLW  64
05CB2:  MOVWF  x3B
05CB4:  MOVLB  0
05CB6:  CALL   08DC
05CBA:  MOVFF  00,734
05CBE:  MOVLW  30
05CC0:  ADDWF  01,W
05CC2:  MOVLB  7
05CC4:  MOVWF  x37
05CC6:  MOVFF  734,73A
05CCA:  MOVLW  0A
05CCC:  MOVWF  x3B
05CCE:  MOVLB  0
05CD0:  CALL   08DC
05CD4:  MOVLW  30
05CD6:  ADDWF  00,W
05CD8:  MOVLB  7
05CDA:  MOVWF  x39
05CDC:  MOVLW  30
05CDE:  ADDWF  01,W
05CE0:  MOVWF  x38
05CE2:  MOVFF  736,00
05CE6:  MOVLW  30
05CE8:  SUBWF  x37,W
05CEA:  BZ    5CF4
05CEC:  BSF    x35.1
05CEE:  BTFSC  x35.7
05CF0:  BSF    x35.2
05CF2:  BRA    5D18
05CF4:  MOVFF  736,737
05CF8:  MOVLW  20
05CFA:  MOVWF  x36
05CFC:  MOVLW  30
05CFE:  SUBWF  x38,W
05D00:  BZ    5D0A
05D02:  BSF    x35.0
05D04:  BTFSC  x35.7
05D06:  BSF    x35.1
05D08:  BRA    5D18
05D0A:  BTFSS  FD8.2
05D0C:  BSF    x35.0
05D0E:  BNZ   5D18
05D10:  MOVFF  737,738
05D14:  MOVLW  20
05D16:  MOVWF  x37
05D18:  BTFSC  x35.2
05D1A:  BRA    5D26
05D1C:  BTFSC  x35.1
05D1E:  BRA    5D2E
05D20:  BTFSC  x35.0
05D22:  BRA    5D36
05D24:  BRA    5D3E
05D26:  MOVFF  736,750
05D2A:  MOVLB  0
05D2C:  RCALL  56A6
05D2E:  MOVFF  737,750
05D32:  MOVLB  0
05D34:  RCALL  56A6
05D36:  MOVFF  738,750
05D3A:  MOVLB  0
05D3C:  RCALL  56A6
05D3E:  MOVFF  739,750
05D42:  MOVLB  0
05D44:  RCALL  56A6
05D46:  RETURN 0
*
05EEC:  MOVLB  7
05EEE:  MOVF   x22,W
05EF0:  ANDLW  07
05EF2:  MOVWF  00
05EF4:  RRCF   x22,W
05EF6:  MOVWF  01
05EF8:  RRCF   01,F
05EFA:  RRCF   01,F
05EFC:  MOVLW  1F
05EFE:  ANDWF  01,F
05F00:  MOVF   01,W
05F02:  ADDWF  x24,W
05F04:  MOVWF  FE9
05F06:  MOVLW  00
05F08:  ADDWFC x25,W
05F0A:  MOVWF  FEA
05F0C:  CLRF   01
05F0E:  INCF   01,F
05F10:  INCF   00,F
05F12:  BRA    5F16
05F14:  RLCF   01,F
05F16:  DECFSZ 00,F
05F18:  BRA    5F14
05F1A:  MOVF   x23,F
05F1C:  BZ    5F24
05F1E:  MOVF   01,W
05F20:  IORWF  FEF,F
05F22:  BRA    5F2A
05F24:  COMF   01,F
05F26:  MOVF   01,W
05F28:  ANDWF  FEF,F
05F2A:  MOVLB  0
05F2C:  RETURN 0
*
060DC:  TBLRD*+
060DE:  MOVFF  FF6,710
060E2:  MOVFF  FF7,711
060E6:  MOVFF  FF5,750
060EA:  CALL   56A6
060EE:  MOVFF  710,FF6
060F2:  MOVFF  711,FF7
060F6:  MOVLB  7
060F8:  DECFSZ x0F,F
060FA:  BRA    60FE
060FC:  BRA    6102
060FE:  MOVLB  0
06100:  BRA    60DC
06102:  MOVLB  0
06104:  RETURN 0
*
064AC:  MOVLB  7
064AE:  MOVF   x50,W
064B0:  SUBLW  B6
064B2:  MOVWF  x50
064B4:  CLRF   03
064B6:  MOVFF  751,754
064BA:  BSF    x51.7
064BC:  BCF    FD8.0
064BE:  RRCF   x51,F
064C0:  RRCF   x52,F
064C2:  RRCF   x53,F
064C4:  RRCF   03,F
064C6:  RRCF   02,F
064C8:  RRCF   01,F
064CA:  RRCF   00,F
064CC:  DECFSZ x50,F
064CE:  BRA    64BC
064D0:  BTFSS  x54.7
064D2:  BRA    64EA
064D4:  COMF   00,F
064D6:  COMF   01,F
064D8:  COMF   02,F
064DA:  COMF   03,F
064DC:  INCF   00,F
064DE:  BTFSC  FD8.2
064E0:  INCF   01,F
064E2:  BTFSC  FD8.2
064E4:  INCF   02,F
064E6:  BTFSC  FD8.2
064E8:  INCF   03,F
064EA:  MOVLB  0
064EC:  RETURN 0
064EE:  BTFSC  FD8.1
064F0:  BRA    64FA
064F2:  MOVLW  07
064F4:  MOVWF  FEA
064F6:  MOVLW  58
064F8:  MOVWF  FE9
064FA:  CLRF   00
064FC:  CLRF   01
064FE:  CLRF   02
06500:  CLRF   03
06502:  MOVLB  7
06504:  CLRF   x58
06506:  CLRF   x59
06508:  CLRF   x5A
0650A:  CLRF   x5B
0650C:  MOVF   x57,W
0650E:  IORWF  x56,W
06510:  IORWF  x55,W
06512:  IORWF  x54,W
06514:  BZ    656E
06516:  MOVLW  20
06518:  MOVWF  x5C
0651A:  BCF    FD8.0
0651C:  RLCF   x50,F
0651E:  RLCF   x51,F
06520:  RLCF   x52,F
06522:  RLCF   x53,F
06524:  RLCF   x58,F
06526:  RLCF   x59,F
06528:  RLCF   x5A,F
0652A:  RLCF   x5B,F
0652C:  MOVF   x57,W
0652E:  SUBWF  x5B,W
06530:  BNZ   6542
06532:  MOVF   x56,W
06534:  SUBWF  x5A,W
06536:  BNZ   6542
06538:  MOVF   x55,W
0653A:  SUBWF  x59,W
0653C:  BNZ   6542
0653E:  MOVF   x54,W
06540:  SUBWF  x58,W
06542:  BNC   6562
06544:  MOVF   x54,W
06546:  SUBWF  x58,F
06548:  MOVF   x55,W
0654A:  BTFSS  FD8.0
0654C:  INCFSZ x55,W
0654E:  SUBWF  x59,F
06550:  MOVF   x56,W
06552:  BTFSS  FD8.0
06554:  INCFSZ x56,W
06556:  SUBWF  x5A,F
06558:  MOVF   x57,W
0655A:  BTFSS  FD8.0
0655C:  INCFSZ x57,W
0655E:  SUBWF  x5B,F
06560:  BSF    FD8.0
06562:  RLCF   00,F
06564:  RLCF   01,F
06566:  RLCF   02,F
06568:  RLCF   03,F
0656A:  DECFSZ x5C,F
0656C:  BRA    651A
0656E:  MOVFF  758,FEF
06572:  MOVFF  759,FEC
06576:  MOVFF  75A,FEC
0657A:  MOVFF  75B,FEC
0657E:  MOVLB  0
06580:  RETURN 0
06582:  MOVF   FE9,W
06584:  MOVLB  7
06586:  MOVWF  x48
06588:  MOVF   x47,W
0658A:  MOVWF  x4A
0658C:  BZ    65C6
0658E:  MOVFF  746,753
06592:  MOVFF  745,752
06596:  MOVFF  744,751
0659A:  MOVFF  743,750
0659E:  CLRF   x57
065A0:  CLRF   x56
065A2:  MOVLW  20
065A4:  MOVWF  x55
065A6:  MOVLW  82
065A8:  MOVWF  x54
065AA:  MOVLB  0
065AC:  CALL   0DA4
065B0:  MOVFF  03,746
065B4:  MOVFF  02,745
065B8:  MOVFF  01,744
065BC:  MOVFF  00,743
065C0:  MOVLB  7
065C2:  DECFSZ x4A,F
065C4:  BRA    658E
065C6:  MOVFF  746,753
065CA:  MOVFF  745,752
065CE:  MOVFF  744,751
065D2:  MOVFF  743,750
065D6:  MOVLB  0
065D8:  RCALL  64AC
065DA:  MOVFF  03,746
065DE:  MOVFF  02,745
065E2:  MOVFF  01,744
065E6:  MOVFF  00,743
065EA:  MOVLB  7
065EC:  BTFSS  x46.7
065EE:  BRA    660A
065F0:  DECF   x48,F
065F2:  BSF    x48.5
065F4:  COMF   x43,F
065F6:  COMF   x44,F
065F8:  COMF   x45,F
065FA:  COMF   x46,F
065FC:  INCF   x43,F
065FE:  BTFSC  FD8.2
06600:  INCF   x44,F
06602:  BTFSC  FD8.2
06604:  INCF   x45,F
06606:  BTFSC  FD8.2
06608:  INCF   x46,F
0660A:  MOVLW  3B
0660C:  MOVWF  x4F
0660E:  MOVLW  9A
06610:  MOVWF  x4E
06612:  MOVLW  CA
06614:  MOVWF  x4D
06616:  CLRF   x4C
06618:  MOVLW  0A
0661A:  MOVWF  x4A
0661C:  MOVF   x47,W
0661E:  BTFSC  FD8.2
06620:  INCF   x48,F
06622:  BSF    FD8.1
06624:  MOVLW  07
06626:  MOVWF  FEA
06628:  MOVLW  43
0662A:  MOVWF  FE9
0662C:  MOVFF  746,753
06630:  MOVFF  745,752
06634:  MOVFF  744,751
06638:  MOVFF  743,750
0663C:  MOVFF  74F,757
06640:  MOVFF  74E,756
06644:  MOVFF  74D,755
06648:  MOVFF  74C,754
0664C:  MOVLB  0
0664E:  RCALL  64EE
06650:  MOVF   01,W
06652:  MOVF   00,F
06654:  BNZ   667C
06656:  MOVLB  7
06658:  INCF   x47,W
0665A:  SUBWF  x4A,W
0665C:  BTFSS  FD8.2
0665E:  BRA    6664
06660:  MOVLB  0
06662:  BRA    667C
06664:  MOVF   x48,W
06666:  BZ    6682
06668:  ANDLW  0F
0666A:  SUBWF  x4A,W
0666C:  BZ    6670
0666E:  BC    66F8
06670:  BTFSC  x48.7
06672:  BRA    66F8
06674:  BTFSC  x48.6
06676:  BRA    6682
06678:  MOVLW  20
0667A:  BRA    66EA
0667C:  MOVLW  20
0667E:  MOVLB  7
06680:  ANDWF  x48,F
06682:  BTFSS  x48.5
06684:  BRA    66A4
06686:  BCF    x48.5
06688:  MOVF   x47,W
0668A:  BTFSS  FD8.2
0668C:  DECF   x48,F
0668E:  MOVF   00,W
06690:  MOVWF  x48
06692:  MOVLW  2D
06694:  MOVWF  x50
06696:  MOVLB  0
06698:  CALL   56A6
0669C:  MOVLB  7
0669E:  MOVF   x48,W
066A0:  MOVWF  00
066A2:  CLRF   x48
066A4:  MOVF   x47,W
066A6:  SUBWF  x4A,W
066A8:  BNZ   66C4
066AA:  MOVF   00,W
066AC:  MOVWF  x48
066AE:  MOVLW  2E
066B0:  MOVWF  x50
066B2:  MOVLB  0
066B4:  CALL   56A6
066B8:  MOVLB  7
066BA:  MOVF   x48,W
066BC:  MOVWF  00
066BE:  MOVLW  20
066C0:  ANDWF  x48,F
066C2:  MOVLW  00
066C4:  MOVLW  30
066C6:  BTFSS  x48.5
066C8:  BRA    66EA
066CA:  BCF    x48.5
066CC:  MOVF   x47,W
066CE:  BTFSS  FD8.2
066D0:  DECF   x48,F
066D2:  MOVF   00,W
066D4:  MOVWF  x48
066D6:  MOVLW  2D
066D8:  MOVWF  x50
066DA:  MOVLB  0
066DC:  CALL   56A6
066E0:  MOVLB  7
066E2:  MOVF   x48,W
066E4:  MOVWF  00
066E6:  CLRF   x48
066E8:  MOVLW  30
066EA:  ADDWF  00,F
066EC:  MOVFF  00,750
066F0:  MOVLB  0
066F2:  CALL   56A6
066F6:  MOVLB  7
066F8:  BCF    FD8.1
066FA:  MOVFF  74F,753
066FE:  MOVFF  74E,752
06702:  MOVFF  74D,751
06706:  MOVFF  74C,750
0670A:  CLRF   x57
0670C:  CLRF   x56
0670E:  CLRF   x55
06710:  MOVLW  0A
06712:  MOVWF  x54
06714:  MOVLB  0
06716:  RCALL  64EE
06718:  MOVFF  03,74F
0671C:  MOVFF  02,74E
06720:  MOVFF  01,74D
06724:  MOVFF  00,74C
06728:  MOVLB  7
0672A:  DECFSZ x4A,F
0672C:  BRA    6622
0672E:  MOVLB  0
06730:  RETURN 0
*
0919A:  MOVF   FE9,W
0919C:  MOVLB  7
0919E:  MOVWF  x3D
091A0:  BTFSS  x3C.7
091A2:  BRA    91BE
091A4:  DECF   x3D,F
091A6:  BSF    x3D.5
091A8:  COMF   x39,F
091AA:  COMF   x3A,F
091AC:  COMF   x3B,F
091AE:  COMF   x3C,F
091B0:  INCF   x39,F
091B2:  BTFSC  FD8.2
091B4:  INCF   x3A,F
091B6:  BTFSC  FD8.2
091B8:  INCF   x3B,F
091BA:  BTFSC  FD8.2
091BC:  INCF   x3C,F
091BE:  MOVLW  3B
091C0:  MOVWF  x44
091C2:  MOVLW  9A
091C4:  MOVWF  x43
091C6:  MOVLW  CA
091C8:  MOVWF  x42
091CA:  CLRF   x41
091CC:  MOVLW  0A
091CE:  MOVWF  x3F
091D0:  BSF    FD8.1
091D2:  MOVLW  07
091D4:  MOVWF  FEA
091D6:  MOVLW  39
091D8:  MOVWF  FE9
091DA:  MOVFF  73C,753
091DE:  MOVFF  73B,752
091E2:  MOVFF  73A,751
091E6:  MOVFF  739,750
091EA:  MOVFF  744,757
091EE:  MOVFF  743,756
091F2:  MOVFF  742,755
091F6:  MOVFF  741,754
091FA:  MOVLB  0
091FC:  CALL   64EE
09200:  MOVF   01,W
09202:  MOVF   00,F
09204:  BNZ   922C
09206:  MOVLB  7
09208:  MOVF   x3F,W
0920A:  XORLW  01
0920C:  BTFSS  FD8.2
0920E:  BRA    9214
09210:  MOVLB  0
09212:  BRA    922C
09214:  MOVF   x3D,W
09216:  BZ    9232
09218:  ANDLW  0F
0921A:  SUBWF  x3F,W
0921C:  BZ    9220
0921E:  BC    927C
09220:  BTFSC  x3D.7
09222:  BRA    927C
09224:  BTFSC  x3D.6
09226:  BRA    9232
09228:  MOVLW  20
0922A:  BRA    926E
0922C:  MOVLW  20
0922E:  MOVLB  7
09230:  ANDWF  x3D,F
09232:  BTFSS  x3D.5
09234:  BRA    924E
09236:  BCF    x3D.5
09238:  MOVFF  00,73D
0923C:  MOVLW  2D
0923E:  MOVWF  x50
09240:  MOVLB  0
09242:  CALL   56A6
09246:  MOVLB  7
09248:  MOVFF  73D,00
0924C:  CLRF   x3D
0924E:  MOVLW  30
09250:  BTFSS  x3D.5
09252:  BRA    926E
09254:  BCF    x3D.5
09256:  MOVFF  00,73D
0925A:  MOVLW  2D
0925C:  MOVWF  x50
0925E:  MOVLB  0
09260:  CALL   56A6
09264:  MOVLB  7
09266:  MOVFF  73D,00
0926A:  CLRF   x3D
0926C:  MOVLW  30
0926E:  ADDWF  00,F
09270:  MOVFF  00,750
09274:  MOVLB  0
09276:  CALL   56A6
0927A:  MOVLB  7
0927C:  BCF    FD8.1
0927E:  MOVFF  744,753
09282:  MOVFF  743,752
09286:  MOVFF  742,751
0928A:  MOVFF  741,750
0928E:  CLRF   x57
09290:  CLRF   x56
09292:  CLRF   x55
09294:  MOVLW  0A
09296:  MOVWF  x54
09298:  MOVLB  0
0929A:  CALL   64EE
0929E:  MOVFF  03,744
092A2:  MOVFF  02,743
092A6:  MOVFF  01,742
092AA:  MOVFF  00,741
092AE:  MOVLB  7
092B0:  DECFSZ x3F,F
092B2:  BRA    91D0
092B4:  MOVLB  0
092B6:  RETURN 0
*
0A16A:  MOVF   01,W
0A16C:  MOVFF  706,73A
0A170:  MOVLW  64
0A172:  MOVLB  7
0A174:  MOVWF  x3B
0A176:  MOVLB  0
0A178:  CALL   08DC
0A17C:  MOVFF  00,706
0A180:  MOVF   01,W
0A182:  MOVLW  30
0A184:  BNZ   A196
0A186:  MOVLB  7
0A188:  BTFSS  x07.1
0A18A:  BRA    A1AC
0A18C:  BTFSC  x07.3
0A18E:  BRA    A1AC
0A190:  BTFSC  x07.4
0A192:  MOVLW  20
0A194:  BRA    A19E
0A196:  MOVLB  7
0A198:  BCF    x07.3
0A19A:  BCF    x07.4
0A19C:  BSF    x07.0
0A19E:  ADDWF  01,F
0A1A0:  MOVFF  01,750
0A1A4:  MOVLB  0
0A1A6:  CALL   56A6
0A1AA:  MOVLB  7
0A1AC:  MOVFF  706,73A
0A1B0:  MOVLW  0A
0A1B2:  MOVWF  x3B
0A1B4:  MOVLB  0
0A1B6:  CALL   08DC
0A1BA:  MOVFF  00,706
0A1BE:  MOVF   01,W
0A1C0:  MOVLW  30
0A1C2:  BNZ   A1D4
0A1C4:  MOVLB  7
0A1C6:  BTFSC  x07.3
0A1C8:  BRA    A1E0
0A1CA:  BTFSS  x07.0
0A1CC:  BRA    A1E0
0A1CE:  BTFSC  x07.4
0A1D0:  MOVLW  20
0A1D2:  MOVLB  0
0A1D4:  ADDWF  01,F
0A1D6:  MOVFF  01,750
0A1DA:  CALL   56A6
0A1DE:  MOVLB  7
0A1E0:  MOVLW  30
0A1E2:  ADDWF  x06,F
0A1E4:  MOVFF  706,750
0A1E8:  MOVLB  0
0A1EA:  CALL   56A6
0A1EE:  RETURN 0
0A1F0:  MOVFF  FEA,708
0A1F4:  MOVFF  FE9,707
0A1F8:  MOVLB  7
0A1FA:  SWAPF  x01,W
0A1FC:  IORLW  F0
0A1FE:  MOVWF  x03
0A200:  ADDWF  x03,F
0A202:  ADDLW  E2
0A204:  MOVWF  x04
0A206:  ADDLW  32
0A208:  MOVWF  x06
0A20A:  MOVF   x01,W
0A20C:  ANDLW  0F
0A20E:  ADDWF  x04,F
0A210:  ADDWF  x04,F
0A212:  ADDWF  x06,F
0A214:  ADDLW  E9
0A216:  MOVWF  x05
0A218:  ADDWF  x05,F
0A21A:  ADDWF  x05,F
0A21C:  SWAPF  x00,W
0A21E:  ANDLW  0F
0A220:  ADDWF  x05,F
0A222:  ADDWF  x06,F
0A224:  RLCF   x05,F
0A226:  RLCF   x06,F
0A228:  COMF   x06,F
0A22A:  RLCF   x06,F
0A22C:  MOVF   x00,W
0A22E:  ANDLW  0F
0A230:  ADDWF  x06,F
0A232:  RLCF   x03,F
0A234:  MOVLW  07
0A236:  MOVWF  x02
0A238:  MOVLW  0A
0A23A:  DECF   x05,F
0A23C:  ADDWF  x06,F
0A23E:  BNC   A23A
0A240:  DECF   x04,F
0A242:  ADDWF  x05,F
0A244:  BNC   A240
0A246:  DECF   x03,F
0A248:  ADDWF  x04,F
0A24A:  BNC   A246
0A24C:  DECF   x02,F
0A24E:  ADDWF  x03,F
0A250:  BNC   A24C
0A252:  MOVLW  07
0A254:  MOVWF  FEA
0A256:  MOVLW  02
0A258:  MOVWF  FE9
0A25A:  MOVLW  07
0A25C:  ANDWF  x07,W
0A25E:  BCF    x07.6
0A260:  ADDWF  FE9,F
0A262:  MOVLW  00
0A264:  ADDWFC FEA,F
0A266:  MOVF   FE9,W
0A268:  SUBLW  06
0A26A:  BNZ   A274
0A26C:  MOVF   FEA,W
0A26E:  SUBLW  07
0A270:  BNZ   A274
0A272:  BSF    x07.6
0A274:  MOVF   FEF,W
0A276:  MOVWF  00
0A278:  BNZ   A28A
0A27A:  BTFSC  x07.6
0A27C:  BRA    A28A
0A27E:  BTFSC  x07.4
0A280:  BRA    A2AE
0A282:  BTFSC  x07.3
0A284:  BRA    A28A
0A286:  MOVLW  20
0A288:  BRA    A290
0A28A:  BSF    x07.3
0A28C:  BCF    x07.4
0A28E:  MOVLW  30
0A290:  ADDWF  00,F
0A292:  MOVFF  FEA,701
0A296:  MOVFF  FE9,700
0A29A:  MOVFF  00,750
0A29E:  MOVLB  0
0A2A0:  CALL   56A6
0A2A4:  MOVFF  701,FEA
0A2A8:  MOVFF  700,FE9
0A2AC:  MOVLB  7
0A2AE:  MOVF   FEE,W
0A2B0:  BTFSS  x07.6
0A2B2:  BRA    A266
0A2B4:  MOVLB  0
0A2B6:  RETURN 0
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003CC:  MOVLW  07
003CE:  MOVWF  FEA
003D0:  MOVLW  01
003D2:  MOVWF  FE9
003D4:  MOVF   FEF,W
003D6:  BZ    03F4
003D8:  MOVLW  14
003DA:  MOVWF  01
003DC:  CLRF   00
003DE:  DECFSZ 00,F
003E0:  BRA    03DE
003E2:  DECFSZ 01,F
003E4:  BRA    03DC
003E6:  MOVLW  BF
003E8:  MOVWF  00
003EA:  DECFSZ 00,F
003EC:  BRA    03EA
003EE:  BRA    03F0
003F0:  DECFSZ FEF,F
003F2:  BRA    03D8
003F4:  RETURN 0
*
00748:  MOVLW  01
0074A:  MOVLB  7
0074C:  SUBWF  x07,F
0074E:  BNC   0766
00750:  MOVLW  07
00752:  MOVWF  FEA
00754:  MOVWF  FE9
00756:  MOVF   FEF,W
00758:  BZ    0766
0075A:  MOVLW  04
0075C:  MOVWF  00
0075E:  DECFSZ 00,F
00760:  BRA    075E
00762:  DECFSZ FEF,F
00764:  BRA    075A
00766:  MOVLB  0
00768:  GOTO   07AE (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251208" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
003F6:  MOVLW  CF
003F8:  MOVWF  F87
003FA:  CLRF   F82
....................    output_b(portB_reset);
003FC:  MOVLW  04
003FE:  MOVWF  F88
00400:  CLRF   F83
....................    output_c(portC_reset);
00402:  MOVLW  93
00404:  MOVWF  F89
00406:  CLRF   F84
....................    output_d(portD_reset);
00408:  MOVLW  1F
0040A:  MOVWF  F8A
0040C:  CLRF   F85
....................    output_e(portE_reset);
0040E:  BCF    F8B.0
00410:  BCF    F8B.1
00412:  BCF    F8B.2
00414:  BCF    F8B.3
00416:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00418:  MOVLB  F
0041A:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0041C:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0041E:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00420:  SETF   x20
....................    port_e_pullups(portE_pullups);
00422:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00424:  MOVLW  40
00426:  MOVWF  x0C
00428:  CLRF   x14
0042A:  MOVLW  03
0042C:  MOVWF  x1C
0042E:  MOVLW  0F
00430:  MOVWF  x21
00432:  CLRF   x29
00434:  MOVLB  0
00436:  GOTO   A6C8 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05724:  MOVFF  742,FEA
05728:  MOVLB  7
0572A:  MOVFF  741,FE9
0572E:  MOVFF  FEF,745
05732:  MOVFF  744,FEA
05736:  MOVFF  743,FE9
0573A:  MOVF   FEF,W
0573C:  SUBWF  x45,W
0573E:  BNZ   576E
....................       if (*s1 == '\0')
05740:  MOVFF  742,03
05744:  MOVFF  741,FE9
05748:  MOVFF  03,FEA
0574C:  MOVF   FEF,F
0574E:  BNZ   5756
....................          return(0);
05750:  MOVLW  00
05752:  MOVWF  01
05754:  BRA    5798
05756:  MOVFF  742,03
0575A:  MOVF   x41,W
0575C:  INCF   x41,F
0575E:  BTFSC  FD8.2
05760:  INCF   x42,F
05762:  INCF   x43,F
05764:  BTFSC  FD8.2
05766:  INCF   x44,F
05768:  MOVLB  0
0576A:  BRA    5724
0576C:  MOVLB  7
....................    return((*s1 < *s2) ? -1: 1);
0576E:  MOVFF  742,03
05772:  MOVFF  741,FE9
05776:  MOVFF  03,FEA
0577A:  MOVFF  FEF,745
0577E:  MOVFF  744,03
05782:  MOVFF  743,FE9
05786:  MOVFF  03,FEA
0578A:  MOVF   FEF,W
0578C:  SUBWF  x45,W
0578E:  BC    5794
05790:  MOVLW  FF
05792:  BRA    5796
05794:  MOVLW  01
05796:  MOVWF  01
05798:  MOVLB  0
0579A:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05894:  MOVFF  768,76B
....................    for(su=s;0<n;++su,--n)
05898:  MOVFF  767,76D
0589C:  MOVFF  766,76C
058A0:  MOVLB  7
058A2:  MOVF   x6A,F
058A4:  BNZ   58AC
058A6:  MOVF   x69,W
058A8:  SUBLW  00
058AA:  BC    58D4
....................       if(*su==uc)
058AC:  MOVFF  76D,FEA
058B0:  MOVFF  76C,FE9
058B4:  MOVF   x6B,W
058B6:  SUBWF  FEF,W
058B8:  BNZ   58C4
....................       return su;
058BA:  MOVFF  76C,01
058BE:  MOVFF  76D,02
058C2:  BRA    58DA
058C4:  INCF   x6C,F
058C6:  BTFSC  FD8.2
058C8:  INCF   x6D,F
058CA:  MOVF   x69,W
058CC:  BTFSC  FD8.2
058CE:  DECF   x6A,F
058D0:  DECF   x69,F
058D2:  BRA    58A2
....................    return NULL;
058D4:  MOVLW  00
058D6:  MOVWF  01
058D8:  MOVWF  02
058DA:  MOVLB  0
058DC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0566E:  MOVFF  742,744
05672:  MOVFF  741,743
05676:  MOVFF  744,FEA
0567A:  MOVLB  7
0567C:  MOVFF  743,FE9
05680:  MOVF   FEF,F
05682:  BZ    5690
05684:  INCF   x43,F
05686:  BTFSC  FD8.2
05688:  INCF   x44,F
0568A:  MOVLB  0
0568C:  BRA    5676
0568E:  MOVLB  7
....................    return(sc - s);
05690:  MOVF   x41,W
05692:  SUBWF  x43,W
05694:  MOVWF  00
05696:  MOVF   x42,W
05698:  SUBWFB x44,W
0569A:  MOVWF  03
0569C:  MOVFF  00,01
056A0:  MOVWF  02
056A2:  MOVLB  0
056A4:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
06CAA:  MOVLB  7
06CAC:  CLRF   x1B
06CAE:  CLRF   x1A
06CB0:  CLRF   x19
06CB2:  MOVLW  7F
06CB4:  MOVWF  x18
06CB6:  CLRF   x1F
06CB8:  CLRF   x1E
06CBA:  CLRF   x1D
06CBC:  CLRF   x1C
06CBE:  BSF    x20.0
06CC0:  BCF    x20.1
06CC2:  BCF    x20.2
06CC4:  CLRF   x22
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
06CC6:  MOVF   x14,W
06CC8:  IORWF  x15,W
06CCA:  BNZ   6CD6
....................       return 0;
06CCC:  CLRF   00
06CCE:  CLRF   01
06CD0:  CLRF   02
06CD2:  CLRF   03
06CD4:  BRA    6F00
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
06CD6:  MOVF   x22,W
06CD8:  INCF   x22,F
06CDA:  ADDWF  x14,W
06CDC:  MOVWF  FE9
06CDE:  MOVLW  00
06CE0:  ADDWFC x15,W
06CE2:  MOVWF  FEA
06CE4:  MOVFF  FEF,721
06CE8:  MOVF   x21,F
06CEA:  BTFSC  FD8.2
06CEC:  BRA    6E84
....................    {
....................       if (skip && !isspace(c))
06CEE:  BTFSS  x20.0
06CF0:  BRA    6D10
06CF2:  MOVF   x21,W
06CF4:  SUBLW  20
06CF6:  BZ    6D10
....................       {
....................          skip = 0;
06CF8:  BCF    x20.0
....................          if (c == '+')
06CFA:  MOVF   x21,W
06CFC:  SUBLW  2B
06CFE:  BNZ   6D06
....................          {
....................             sign = 0;
06D00:  BCF    x20.1
....................             continue;
06D02:  BRA    6E6C
....................          }            
06D04:  BRA    6D10
....................          else if (c == '-')
06D06:  MOVF   x21,W
06D08:  SUBLW  2D
06D0A:  BNZ   6D10
....................          {
....................             sign = 1;
06D0C:  BSF    x20.1
....................             continue;
06D0E:  BRA    6E6C
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06D10:  BTFSC  x20.0
06D12:  BRA    6D22
06D14:  MOVF   x21,W
06D16:  SUBLW  2E
06D18:  BNZ   6D22
06D1A:  BTFSC  x20.2
06D1C:  BRA    6D22
....................          point = 1;
06D1E:  BSF    x20.2
06D20:  BRA    6E6C
....................       else if (!skip && isdigit(c))
06D22:  BTFSC  x20.0
06D24:  BRA    6E66
06D26:  MOVF   x21,W
06D28:  SUBLW  2F
06D2A:  BTFSC  FD8.0
06D2C:  BRA    6E66
06D2E:  MOVF   x21,W
06D30:  SUBLW  39
06D32:  BTFSS  FD8.0
06D34:  BRA    6E66
....................       {
....................          c -= '0';
06D36:  MOVLW  30
06D38:  SUBWF  x21,F
....................          if (point)
06D3A:  BTFSS  x20.2
06D3C:  BRA    6DEC
....................          {
....................             pow10 = pow10 * 10.0;
06D3E:  MOVFF  71B,753
06D42:  MOVFF  71A,752
06D46:  MOVFF  719,751
06D4A:  MOVFF  718,750
06D4E:  CLRF   x57
06D50:  CLRF   x56
06D52:  MOVLW  20
06D54:  MOVWF  x55
06D56:  MOVLW  82
06D58:  MOVWF  x54
06D5A:  MOVLB  0
06D5C:  CALL   0DA4
06D60:  MOVFF  03,71B
06D64:  MOVFF  02,71A
06D68:  MOVFF  01,719
06D6C:  MOVFF  00,718
....................             result += (float)c / pow10;   
06D70:  MOVLB  7
06D72:  CLRF   x4B
06D74:  MOVFF  721,74A
06D78:  MOVLB  0
06D7A:  CALL   0D6E
06D7E:  MOVFF  03,726
06D82:  MOVFF  02,725
06D86:  MOVFF  01,724
06D8A:  MOVFF  00,723
06D8E:  MOVFF  03,742
06D92:  MOVFF  02,741
06D96:  MOVFF  01,740
06D9A:  MOVFF  00,73F
06D9E:  MOVFF  71B,746
06DA2:  MOVFF  71A,745
06DA6:  MOVFF  719,744
06DAA:  MOVFF  718,743
06DAE:  CALL   1DAA
06DB2:  BCF    FD8.1
06DB4:  MOVFF  71F,74D
06DB8:  MOVFF  71E,74C
06DBC:  MOVFF  71D,74B
06DC0:  MOVFF  71C,74A
06DC4:  MOVFF  03,751
06DC8:  MOVFF  02,750
06DCC:  MOVFF  01,74F
06DD0:  MOVFF  00,74E
06DD4:  CALL   0E9A
06DD8:  MOVFF  03,71F
06DDC:  MOVFF  02,71E
06DE0:  MOVFF  01,71D
06DE4:  MOVFF  00,71C
....................          }
06DE8:  BRA    6E62
06DEA:  MOVLB  7
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
06DEC:  CLRF   x53
06DEE:  CLRF   x52
06DF0:  MOVLW  20
06DF2:  MOVWF  x51
06DF4:  MOVLW  82
06DF6:  MOVWF  x50
06DF8:  MOVFF  71F,757
06DFC:  MOVFF  71E,756
06E00:  MOVFF  71D,755
06E04:  MOVFF  71C,754
06E08:  MOVLB  0
06E0A:  CALL   0DA4
06E0E:  MOVFF  03,726
06E12:  MOVFF  02,725
06E16:  MOVFF  01,724
06E1A:  MOVFF  00,723
06E1E:  MOVLB  7
06E20:  CLRF   x4B
06E22:  MOVFF  721,74A
06E26:  MOVLB  0
06E28:  CALL   0D6E
06E2C:  BCF    FD8.1
06E2E:  MOVFF  726,74D
06E32:  MOVFF  725,74C
06E36:  MOVFF  724,74B
06E3A:  MOVFF  723,74A
06E3E:  MOVFF  03,751
06E42:  MOVFF  02,750
06E46:  MOVFF  01,74F
06E4A:  MOVFF  00,74E
06E4E:  CALL   0E9A
06E52:  MOVFF  03,71F
06E56:  MOVFF  02,71E
06E5A:  MOVFF  01,71D
06E5E:  MOVFF  00,71C
....................          }
....................       }
06E62:  BRA    6E6E
06E64:  MOVLB  7
....................       else if (!skip)
06E66:  BTFSC  x20.0
06E68:  BRA    6E6C
....................          break;
06E6A:  BRA    6E84
06E6C:  MOVLB  0
06E6E:  MOVLB  7
06E70:  MOVF   x22,W
06E72:  INCF   x22,F
06E74:  ADDWF  x14,W
06E76:  MOVWF  FE9
06E78:  MOVLW  00
06E7A:  ADDWFC x15,W
06E7C:  MOVWF  FEA
06E7E:  MOVFF  FEF,721
06E82:  BRA    6CE8
....................    }
.................... 
....................    if (sign)
06E84:  BTFSS  x20.1
06E86:  BRA    6EBC
....................       result = -1*result;
06E88:  CLRF   x53
06E8A:  CLRF   x52
06E8C:  MOVLW  80
06E8E:  MOVWF  x51
06E90:  MOVLW  7F
06E92:  MOVWF  x50
06E94:  MOVFF  71F,757
06E98:  MOVFF  71E,756
06E9C:  MOVFF  71D,755
06EA0:  MOVFF  71C,754
06EA4:  MOVLB  0
06EA6:  CALL   0DA4
06EAA:  MOVFF  03,71F
06EAE:  MOVFF  02,71E
06EB2:  MOVFF  01,71D
06EB6:  MOVFF  00,71C
06EBA:  MOVLB  7
....................       
....................    if(endptr)
06EBC:  MOVF   x16,W
06EBE:  IORWF  x17,W
06EC0:  BZ    6EF0
....................    {
....................       if (ptr) {
06EC2:  MOVF   x22,F
06EC4:  BZ    6EDE
....................          ptr--;
06EC6:  DECF   x22,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
06EC8:  MOVFF  717,FEA
06ECC:  MOVFF  716,FE9
06ED0:  MOVF   x22,W
06ED2:  ADDWF  x14,W
06ED4:  MOVWF  FEF
06ED6:  MOVLW  00
06ED8:  ADDWFC x15,W
06EDA:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
06EDC:  BRA    6EF0
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
06EDE:  MOVFF  717,FEA
06EE2:  MOVFF  716,FE9
06EE6:  MOVFF  715,FEC
06EEA:  MOVF   FED,F
06EEC:  MOVFF  714,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
06EF0:  MOVFF  71C,00
06EF4:  MOVFF  71D,01
06EF8:  MOVFF  71E,02
06EFC:  MOVFF  71F,03
06F00:  MOVLB  0
06F02:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
05934:  MOVLB  7
05936:  CLRF   x3F
05938:  CLRF   x3E
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
0593A:  MOVLW  30
0593C:  MOVWF  x41
0593E:  MOVLW  31
05940:  MOVWF  x42
05942:  MOVLW  32
05944:  MOVWF  x43
05946:  MOVLW  33
05948:  MOVWF  x44
0594A:  MOVLW  34
0594C:  MOVWF  x45
0594E:  MOVLW  35
05950:  MOVWF  x46
05952:  MOVLW  36
05954:  MOVWF  x47
05956:  MOVLW  37
05958:  MOVWF  x48
0595A:  MOVLW  38
0595C:  MOVWF  x49
0595E:  MOVLW  39
05960:  MOVWF  x4A
05962:  MOVLW  61
05964:  MOVWF  x4B
05966:  MOVLW  62
05968:  MOVWF  x4C
0596A:  MOVLW  63
0596C:  MOVWF  x4D
0596E:  MOVLW  64
05970:  MOVWF  x4E
05972:  MOVLW  65
05974:  MOVWF  x4F
05976:  MOVLW  66
05978:  MOVWF  x50
0597A:  MOVLW  67
0597C:  MOVWF  x51
0597E:  MOVLW  68
05980:  MOVWF  x52
05982:  MOVLW  69
05984:  MOVWF  x53
05986:  MOVLW  6A
05988:  MOVWF  x54
0598A:  MOVLW  6B
0598C:  MOVWF  x55
0598E:  MOVLW  6C
05990:  MOVWF  x56
05992:  MOVLW  6D
05994:  MOVWF  x57
05996:  MOVLW  6E
05998:  MOVWF  x58
0599A:  MOVLW  6F
0599C:  MOVWF  x59
0599E:  MOVLW  70
059A0:  MOVWF  x5A
059A2:  MOVLW  71
059A4:  MOVWF  x5B
059A6:  MOVLW  73
059A8:  MOVWF  x5C
059AA:  MOVLW  74
059AC:  MOVWF  x5D
059AE:  MOVLW  75
059B0:  MOVWF  x5E
059B2:  MOVLW  76
059B4:  MOVWF  x5F
059B6:  MOVLW  77
059B8:  MOVWF  x60
059BA:  MOVLW  78
059BC:  MOVWF  x61
059BE:  MOVLW  79
059C0:  MOVWF  x62
059C2:  MOVLW  7A
059C4:  MOVWF  x63
059C6:  CLRF   x64
....................    for(sc=s;isspace(*sc);++sc);
059C8:  MOVFF  734,739
059CC:  MOVFF  733,738
059D0:  MOVFF  739,FEA
059D4:  MOVFF  738,FE9
059D8:  MOVF   FEF,W
059DA:  SUBLW  20
059DC:  BNZ   59E6
059DE:  INCF   x38,F
059E0:  BTFSC  FD8.2
059E2:  INCF   x39,F
059E4:  BRA    59D0
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
059E6:  MOVFF  739,03
059EA:  MOVFF  738,FE9
059EE:  MOVFF  03,FEA
059F2:  MOVF   FEF,W
059F4:  SUBLW  2D
059F6:  BZ    5A06
059F8:  MOVFF  739,FEA
059FC:  MOVFF  738,FE9
05A00:  MOVF   FEF,W
05A02:  SUBLW  2B
05A04:  BNZ   5A18
05A06:  MOVFF  739,FEA
05A0A:  MOVF   x38,W
05A0C:  INCF   x38,F
05A0E:  BTFSC  FD8.2
05A10:  INCF   x39,F
05A12:  MOVWF  FE9
05A14:  MOVF   FEF,W
05A16:  BRA    5A1A
05A18:  MOVLW  2B
05A1A:  MOVWF  x40
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
05A1C:  MOVF   x40,W
05A1E:  SUBLW  2D
05A20:  BZ    5A36
05A22:  BTFSC  x37.7
05A24:  BRA    5A36
05A26:  DECFSZ x37,W
05A28:  BRA    5A2C
05A2A:  BRA    5A36
05A2C:  BTFSC  x37.7
05A2E:  BRA    5A3A
05A30:  MOVF   x37,W
05A32:  SUBLW  24
05A34:  BC    5A3A
....................    goto StrtoulGO;
05A36:  BRA    5C42
05A38:  BRA    5B32
.................... 
....................    else if (base)
05A3A:  MOVF   x37,F
05A3C:  BZ    5ACA
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
05A3E:  MOVF   x37,W
05A40:  SUBLW  10
05A42:  BNZ   5A7E
05A44:  MOVFF  739,FEA
05A48:  MOVFF  738,FE9
05A4C:  MOVF   FEF,W
05A4E:  SUBLW  30
05A50:  BNZ   5A7E
05A52:  MOVLW  01
05A54:  ADDWF  x38,W
05A56:  MOVWF  FE9
05A58:  MOVLW  00
05A5A:  ADDWFC x39,W
05A5C:  MOVWF  FEA
05A5E:  MOVF   FEF,W
05A60:  SUBLW  78
05A62:  BZ    5A76
05A64:  MOVLW  01
05A66:  ADDWF  x38,W
05A68:  MOVWF  FE9
05A6A:  MOVLW  00
05A6C:  ADDWFC x39,W
05A6E:  MOVWF  FEA
05A70:  MOVF   FEF,W
05A72:  SUBLW  58
05A74:  BNZ   5A7E
....................          sc+=2;
05A76:  MOVLW  02
05A78:  ADDWF  x38,F
05A7A:  MOVLW  00
05A7C:  ADDWFC x39,F
....................       if(base==8 && *sc =='0')
05A7E:  MOVF   x37,W
05A80:  SUBLW  08
05A82:  BNZ   5A9A
05A84:  MOVFF  739,FEA
05A88:  MOVFF  738,FE9
05A8C:  MOVF   FEF,W
05A8E:  SUBLW  30
05A90:  BNZ   5A9A
....................          sc+=1;
05A92:  MOVLW  01
05A94:  ADDWF  x38,F
05A96:  MOVLW  00
05A98:  ADDWFC x39,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
05A9A:  MOVF   x37,W
05A9C:  SUBLW  02
05A9E:  BNZ   5AC8
05AA0:  MOVFF  739,FEA
05AA4:  MOVFF  738,FE9
05AA8:  MOVF   FEF,W
05AAA:  SUBLW  30
05AAC:  BNZ   5AC8
05AAE:  MOVLW  01
05AB0:  ADDWF  x38,W
05AB2:  MOVWF  FE9
05AB4:  MOVLW  00
05AB6:  ADDWFC x39,W
05AB8:  MOVWF  FEA
05ABA:  MOVF   FEF,W
05ABC:  SUBLW  62
05ABE:  BNZ   5AC8
....................          sc+=2;
05AC0:  MOVLW  02
05AC2:  ADDWF  x38,F
05AC4:  MOVLW  00
05AC6:  ADDWFC x39,F
.................... 
....................    }
05AC8:  BRA    5B32
....................    else if(*sc!='0') // base is 0, find base
05ACA:  MOVFF  739,FEA
05ACE:  MOVFF  738,FE9
05AD2:  MOVF   FEF,W
05AD4:  SUBLW  30
05AD6:  BZ    5ADE
....................       base=10;
05AD8:  MOVLW  0A
05ADA:  MOVWF  x37
05ADC:  BRA    5B32
....................    else if (sc[1]=='x' || sc[1]=='X')
05ADE:  MOVLW  01
05AE0:  ADDWF  x38,W
05AE2:  MOVWF  FE9
05AE4:  MOVLW  00
05AE6:  ADDWFC x39,W
05AE8:  MOVWF  FEA
05AEA:  MOVF   FEF,W
05AEC:  SUBLW  78
05AEE:  BZ    5B02
05AF0:  MOVLW  01
05AF2:  ADDWF  x38,W
05AF4:  MOVWF  FE9
05AF6:  MOVLW  00
05AF8:  ADDWFC x39,W
05AFA:  MOVWF  FEA
05AFC:  MOVF   FEF,W
05AFE:  SUBLW  58
05B00:  BNZ   5B10
....................       base =16,sc+=2;
05B02:  MOVLW  10
05B04:  MOVWF  x37
05B06:  MOVLW  02
05B08:  ADDWF  x38,F
05B0A:  MOVLW  00
05B0C:  ADDWFC x39,F
05B0E:  BRA    5B32
....................    else if(sc[1]=='b')
05B10:  MOVLW  01
05B12:  ADDWF  x38,W
05B14:  MOVWF  FE9
05B16:  MOVLW  00
05B18:  ADDWFC x39,W
05B1A:  MOVWF  FEA
05B1C:  MOVF   FEF,W
05B1E:  SUBLW  62
05B20:  BNZ   5B2E
....................       base=2,sc+=2;
05B22:  MOVLW  02
05B24:  MOVWF  x37
05B26:  ADDWF  x38,F
05B28:  MOVLW  00
05B2A:  ADDWFC x39,F
05B2C:  BRA    5B32
....................    else
....................       base=8;
05B2E:  MOVLW  08
05B30:  MOVWF  x37
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
05B32:  MOVFF  739,73B
05B36:  MOVFF  738,73A
05B3A:  MOVFF  739,FEA
05B3E:  MOVFF  738,FE9
05B42:  MOVF   FEF,W
05B44:  SUBLW  30
05B46:  BNZ   5B50
05B48:  INCF   x38,F
05B4A:  BTFSC  FD8.2
05B4C:  INCF   x39,F
05B4E:  BRA    5B3A
....................    sd=memchr(digits,tolower(*sc),base);
05B50:  MOVFF  739,03
05B54:  MOVFF  738,FE9
05B58:  MOVFF  03,FEA
05B5C:  MOVFF  FEF,765
05B60:  MOVF   x65,W
05B62:  SUBLW  40
05B64:  BC    5B72
05B66:  MOVF   x65,W
05B68:  SUBLW  5A
05B6A:  BNC   5B72
05B6C:  MOVF   x65,W
05B6E:  IORLW  20
05B70:  BRA    5B74
05B72:  MOVF   x65,W
05B74:  MOVWF  x65
05B76:  MOVLW  07
05B78:  MOVWF  x67
05B7A:  MOVLW  41
05B7C:  MOVWF  x66
05B7E:  MOVFF  765,768
05B82:  CLRF   x6A
05B84:  MOVFF  737,769
05B88:  BTFSC  x69.7
05B8A:  DECF   x6A,F
05B8C:  MOVLB  0
05B8E:  RCALL  5894
05B90:  MOVFF  02,73D
05B94:  MOVFF  01,73C
....................    for(; sd!=0; )
05B98:  MOVLB  7
05B9A:  MOVF   x3C,F
05B9C:  BNZ   5BA2
05B9E:  MOVF   x3D,F
05BA0:  BZ    5C36
....................    {
....................       x=x*base+(int16)(sd-digits);
05BA2:  CLRF   03
05BA4:  MOVF   x37,W
05BA6:  MOVWF  00
05BA8:  BTFSC  FE8.7
05BAA:  DECF   03,F
05BAC:  MOVWF  x65
05BAE:  MOVFF  03,766
05BB2:  MOVFF  73F,768
05BB6:  MOVFF  73E,767
05BBA:  MOVFF  03,76A
05BBE:  MOVWF  x69
05BC0:  MOVLB  0
05BC2:  BRA    58DE
05BC4:  MOVFF  01,765
05BC8:  MOVLW  41
05BCA:  MOVLB  7
05BCC:  SUBWF  x3C,W
05BCE:  MOVWF  00
05BD0:  MOVLW  07
05BD2:  SUBWFB x3D,W
05BD4:  MOVWF  03
05BD6:  MOVF   00,W
05BD8:  ADDWF  01,W
05BDA:  MOVWF  01
05BDC:  MOVF   02,W
05BDE:  ADDWFC 03,F
05BE0:  MOVFF  01,73E
05BE4:  MOVFF  03,73F
....................       ++sc;
05BE8:  INCF   x38,F
05BEA:  BTFSC  FD8.2
05BEC:  INCF   x39,F
....................       sd=memchr(digits,tolower(*sc),base);
05BEE:  MOVFF  739,FEA
05BF2:  MOVFF  738,FE9
05BF6:  MOVFF  FEF,765
05BFA:  MOVF   x65,W
05BFC:  SUBLW  40
05BFE:  BC    5C0C
05C00:  MOVF   x65,W
05C02:  SUBLW  5A
05C04:  BNC   5C0C
05C06:  MOVF   x65,W
05C08:  IORLW  20
05C0A:  BRA    5C0E
05C0C:  MOVF   x65,W
05C0E:  MOVWF  x65
05C10:  MOVLW  07
05C12:  MOVWF  x67
05C14:  MOVLW  41
05C16:  MOVWF  x66
05C18:  MOVFF  765,768
05C1C:  CLRF   x6A
05C1E:  MOVFF  737,769
05C22:  BTFSC  x69.7
05C24:  DECF   x6A,F
05C26:  MOVLB  0
05C28:  RCALL  5894
05C2A:  MOVFF  02,73D
05C2E:  MOVFF  01,73C
05C32:  BRA    5B98
05C34:  MOVLB  7
....................    }
....................    if(s1==sc)
05C36:  MOVF   x38,W
05C38:  SUBWF  x3A,W
05C3A:  BNZ   5C64
05C3C:  MOVF   x39,W
05C3E:  SUBWF  x3B,W
05C40:  BNZ   5C64
....................    {
....................    StrtoulGO:
....................       if (endptr)
05C42:  MOVLB  7
05C44:  MOVF   x35,W
05C46:  IORWF  x36,W
05C48:  BZ    5C5C
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
05C4A:  MOVFF  736,FEA
05C4E:  MOVFF  735,FE9
05C52:  MOVFF  734,FEC
05C56:  MOVF   FED,F
05C58:  MOVFF  733,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
05C5C:  MOVLW  00
05C5E:  MOVWF  01
05C60:  MOVWF  02
05C62:  BRA    5C84
....................    }
....................    if (endptr)
05C64:  MOVF   x35,W
05C66:  IORWF  x36,W
05C68:  BZ    5C7C
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
05C6A:  MOVFF  736,FEA
05C6E:  MOVFF  735,FE9
05C72:  MOVFF  739,FEC
05C76:  MOVF   FED,F
05C78:  MOVFF  738,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
05C7C:  MOVFF  73E,01
05C80:  MOVFF  73F,02
05C84:  MOVLB  0
05C86:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0049C:  MOVLB  7
0049E:  CLRF   x00
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
004A0:  CLRF   x00
004A2:  MOVLB  6
004A4:  MOVF   xFF,W
004A6:  MOVLB  7
004A8:  SUBWF  x00,W
004AA:  BC    050C
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
004AC:  MOVF   x00,W
004AE:  MOVLB  6
004B0:  ADDWF  xFD,W
004B2:  MOVLB  7
004B4:  MOVWF  x01
004B6:  MOVLW  00
004B8:  MOVLB  6
004BA:  ADDWFC xFE,W
004BC:  MOVLB  7
004BE:  MOVWF  x02
004C0:  MOVF   x00,W
004C2:  MOVLB  6
004C4:  ADDWF  xFB,W
004C6:  MOVWF  01
004C8:  MOVLW  00
004CA:  ADDWFC xFC,W
004CC:  MOVWF  03
004CE:  MOVF   01,W
004D0:  MOVWF  FE9
004D2:  MOVFF  03,FEA
004D6:  MOVFF  FEF,703
004DA:  BSF    F7F.7
004DC:  MOVF   FF2,W
004DE:  MOVWF  00
004E0:  BCF    FF2.7
004E2:  MOVFF  702,F7A
004E6:  MOVFF  701,F79
004EA:  MOVLW  31
004EC:  MOVWF  F7B
004EE:  MOVFF  703,F7C
004F2:  MOVLB  F
004F4:  MOVLW  55
004F6:  MOVWF  F81
004F8:  MOVLW  AA
004FA:  MOVWF  F81
004FC:  BSF    F80.4
004FE:  BTFSC  F80.4
00500:  BRA    04FE
00502:  MOVF   00,W
00504:  IORWF  FF2,F
00506:  MOVLB  7
00508:  INCF   x00,F
0050A:  BRA    04A2
....................    }
0050C:  MOVLB  0
0050E:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0043A:  MOVLB  7
0043C:  CLRF   x00
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0043E:  CLRF   x00
00440:  MOVLB  6
00442:  MOVF   xFF,W
00444:  MOVLB  7
00446:  SUBWF  x00,W
00448:  BC    0498
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
0044A:  MOVF   x00,W
0044C:  MOVLB  6
0044E:  ADDWF  xFB,W
00450:  MOVWF  01
00452:  MOVLW  00
00454:  ADDWFC xFC,W
00456:  MOVWF  03
00458:  MOVF   01,W
0045A:  MOVWF  FE9
0045C:  MOVFF  03,FEA
00460:  MOVLB  7
00462:  MOVF   x00,W
00464:  MOVLB  6
00466:  ADDWF  xFD,W
00468:  MOVLB  7
0046A:  MOVWF  x03
0046C:  MOVLW  00
0046E:  MOVLB  6
00470:  ADDWFC xFE,W
00472:  MOVLB  7
00474:  MOVWF  x04
00476:  BSF    F7F.7
00478:  MOVFF  FF2,705
0047C:  BCF    FF2.7
0047E:  MOVFF  704,F7A
00482:  MOVFF  703,F79
00486:  MOVLW  31
00488:  MOVWF  F7B
0048A:  BSF    F80.0
0048C:  MOVF   F7C,W
0048E:  BTFSC  x05.7
00490:  BSF    FF2.7
00492:  MOVWF  FEF
00494:  INCF   x00,F
00496:  BRA    0440
....................    }
00498:  MOVLB  0
0049A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
00510:  MOVLB  6
00512:  CLRF   xFC
00514:  MOVLW  20
00516:  MOVWF  xFB
00518:  CLRF   xFE
0051A:  CLRF   xFD
0051C:  MOVLW  80
0051E:  MOVWF  xFF
00520:  MOVLB  0
00522:  RCALL  049C
....................    delay_ms(1);
00524:  MOVLW  01
00526:  MOVLB  7
00528:  MOVWF  x01
0052A:  MOVLB  0
0052C:  RCALL  03CC
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0052E:  MOVLB  6
00530:  CLRF   xFC
00532:  MOVLW  70
00534:  MOVWF  xFB
00536:  CLRF   xFE
00538:  MOVLW  80
0053A:  MOVWF  xFD
0053C:  MOVLW  02
0053E:  MOVWF  xFF
00540:  MOVLB  0
00542:  RCALL  049C
....................    delay_ms(1);
00544:  MOVLW  01
00546:  MOVLB  7
00548:  MOVWF  x01
0054A:  MOVLB  0
0054C:  RCALL  03CC
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0054E:  MOVLB  6
00550:  CLRF   xFC
00552:  MOVLW  71
00554:  MOVWF  xFB
00556:  CLRF   xFE
00558:  MOVLW  90
0055A:  MOVWF  xFD
0055C:  MOVLW  02
0055E:  MOVWF  xFF
00560:  MOVLB  0
00562:  RCALL  049C
....................    delay_ms(1);
00564:  MOVLW  01
00566:  MOVLB  7
00568:  MOVWF  x01
0056A:  MOVLB  0
0056C:  RCALL  03CC
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0056E:  MOVLB  6
00570:  CLRF   xFC
00572:  MOVLW  72
00574:  MOVWF  xFB
00576:  CLRF   xFE
00578:  MOVLW  A0
0057A:  MOVWF  xFD
0057C:  MOVLW  20
0057E:  MOVWF  xFF
00580:  MOVLB  0
00582:  RCALL  049C
....................    delay_ms(1);
00584:  MOVLW  01
00586:  MOVLB  7
00588:  MOVWF  x01
0058A:  MOVLB  0
0058C:  RCALL  03CC
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0058E:  MOVLB  6
00590:  CLRF   xFC
00592:  MOVLW  92
00594:  MOVWF  xFB
00596:  CLRF   xFE
00598:  MOVLW  C0
0059A:  MOVWF  xFD
0059C:  MOVLW  30
0059E:  MOVWF  xFF
005A0:  MOVLB  0
005A2:  RCALL  049C
....................    delay_ms(1);
005A4:  MOVLW  01
005A6:  MOVLB  7
005A8:  MOVWF  x01
005AA:  MOVLB  0
005AC:  RCALL  03CC
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
005AE:  MOVLB  6
005B0:  CLRF   xFC
005B2:  MOVLW  C2
005B4:  MOVWF  xFB
005B6:  CLRF   xFE
005B8:  MOVLW  F0
005BA:  MOVWF  xFD
005BC:  MOVLW  38
005BE:  MOVWF  xFF
005C0:  MOVLB  0
005C2:  RCALL  049C
....................    delay_ms(1);
005C4:  MOVLW  01
005C6:  MOVLB  7
005C8:  MOVWF  x01
005CA:  MOVLB  0
005CC:  RCALL  03CC
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005CE:  MOVLB  6
005D0:  CLRF   xFC
005D2:  MOVLW  FA
005D4:  MOVWF  xFB
005D6:  MOVLW  01
005D8:  MOVWF  xFE
005DA:  MOVLW  40
005DC:  MOVWF  xFD
005DE:  MOVLW  01
005E0:  MOVWF  xFF
005E2:  MOVLB  0
005E4:  RCALL  049C
....................    delay_ms(1);
005E6:  MOVLW  01
005E8:  MOVLB  7
005EA:  MOVWF  x01
005EC:  MOVLB  0
005EE:  RCALL  03CC
005F0:  GOTO   06C0 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
005F4:  MOVLB  6
005F6:  CLRF   xFC
005F8:  MOVLW  20
005FA:  MOVWF  xFB
005FC:  CLRF   xFE
005FE:  CLRF   xFD
00600:  MOVLW  80
00602:  MOVWF  xFF
00604:  MOVLB  0
00606:  RCALL  043A
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00608:  MOVLB  6
0060A:  CLRF   xFC
0060C:  MOVLW  70
0060E:  MOVWF  xFB
00610:  CLRF   xFE
00612:  MOVLW  80
00614:  MOVWF  xFD
00616:  MOVLW  02
00618:  MOVWF  xFF
0061A:  MOVLB  0
0061C:  RCALL  043A
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0061E:  MOVLB  6
00620:  CLRF   xFC
00622:  MOVLW  71
00624:  MOVWF  xFB
00626:  CLRF   xFE
00628:  MOVLW  90
0062A:  MOVWF  xFD
0062C:  MOVLW  02
0062E:  MOVWF  xFF
00630:  MOVLB  0
00632:  RCALL  043A
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00634:  MOVLB  6
00636:  CLRF   xFC
00638:  MOVLW  72
0063A:  MOVWF  xFB
0063C:  CLRF   xFE
0063E:  MOVLW  A0
00640:  MOVWF  xFD
00642:  MOVLW  20
00644:  MOVWF  xFF
00646:  MOVLB  0
00648:  RCALL  043A
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
0064A:  MOVLB  6
0064C:  CLRF   xFC
0064E:  MOVLW  92
00650:  MOVWF  xFB
00652:  CLRF   xFE
00654:  MOVLW  C0
00656:  MOVWF  xFD
00658:  MOVLW  30
0065A:  MOVWF  xFF
0065C:  MOVLB  0
0065E:  RCALL  043A
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00660:  MOVLB  6
00662:  CLRF   xFC
00664:  MOVLW  C2
00666:  MOVWF  xFB
00668:  CLRF   xFE
0066A:  MOVLW  F0
0066C:  MOVWF  xFD
0066E:  MOVLW  38
00670:  MOVWF  xFF
00672:  MOVLB  0
00674:  RCALL  043A
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00676:  MOVLB  6
00678:  CLRF   xFC
0067A:  MOVLW  FA
0067C:  MOVWF  xFB
0067E:  MOVLW  01
00680:  MOVWF  xFE
00682:  MOVLW  40
00684:  MOVWF  xFD
00686:  MOVLW  01
00688:  MOVWF  xFF
0068A:  MOVLB  0
0068C:  RCALL  043A
0068E:  GOTO   06C4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00692:  MOVLB  6
00694:  CLRF   xFC
00696:  MOVLW  FA
00698:  MOVWF  xFB
0069A:  MOVLW  01
0069C:  MOVWF  xFE
0069E:  MOVLW  40
006A0:  MOVWF  xFD
006A2:  MOVLW  01
006A4:  MOVWF  xFF
006A6:  MOVLB  0
006A8:  RCALL  043A
....................    delay_ms(1);
006AA:  MOVLW  01
006AC:  MOVLB  7
006AE:  MOVWF  x01
006B0:  MOVLB  0
006B2:  RCALL  03CC
....................    if (paramsValid != isValid)
006B4:  MOVF   xFA,W
006B6:  SUBLW  AA
006B8:  BZ    06C2
....................    {
....................       paramsValid = isValid;
006BA:  MOVLW  AA
006BC:  MOVWF  xFA
....................       params_save_to_ee(); // saves the base parameters on first boot
006BE:  BRA    0510
....................    }
006C0:  BRA    06C4
....................    else
....................    {
....................       params_load_from_ee();
006C2:  BRA    05F4
....................    }
006C4:  GOTO   A6CC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=4096000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIRoff|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00170:  MOVLW  1F
00172:  MOVWF  F8A
00174:  BSF    F85.5
....................    output_high(_CS1);
00176:  MOVWF  F8A
00178:  BSF    F85.6
....................    output_high(_CS2);
0017A:  MOVWF  F8A
0017C:  BSF    F85.7
....................    output_high(_CS3); 
0017E:  MOVLW  04
00180:  MOVWF  F88
00182:  BSF    F83.0
....................    delay_us(10);
00184:  MOVLW  35
00186:  MOVWF  00
00188:  DECFSZ 00,F
0018A:  BRA    0188
0018C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
006C8:  RCALL  0170
....................    switch(ch)
006CA:  MOVLB  7
006CC:  MOVF   x0C,W
006CE:  ADDLW  FC
006D0:  BC    0704
006D2:  ADDLW  04
006D4:  MOVLB  0
006D6:  GOTO   0710
....................    {
....................       case 0:
....................          output_low(_CS0);
006DA:  MOVLW  1F
006DC:  MOVWF  F8A
006DE:  BCF    F85.5
....................       break; 
006E0:  MOVLB  7
006E2:  BRA    0704
....................       case 1:
....................          output_low(_CS1);
006E4:  MOVLW  1F
006E6:  MOVWF  F8A
006E8:  BCF    F85.6
....................       break;   
006EA:  MOVLB  7
006EC:  BRA    0704
....................       case 2:
....................          output_low(_CS2);
006EE:  MOVLW  1F
006F0:  MOVWF  F8A
006F2:  BCF    F85.7
....................       break;
006F4:  MOVLB  7
006F6:  BRA    0704
....................       case 3:
....................          output_low(_CS3);
006F8:  MOVLW  04
006FA:  MOVWF  F88
006FC:  BCF    F83.0
....................       break;              
006FE:  MOVLB  7
00700:  BRA    0704
00702:  MOVLB  7
....................    }
....................    delay_us(10);
00704:  MOVLW  35
00706:  MOVWF  00
00708:  DECFSZ 00,F
0070A:  BRA    0708
0070C:  MOVLB  0
0070E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0018E:  RCALL  0170
....................    switch(block)
00190:  MOVLB  7
00192:  MOVF   x74,W
00194:  XORLW  00
00196:  MOVLB  0
00198:  BZ    01A0
0019A:  XORLW  01
0019C:  BZ    01AC
0019E:  BRA    01B8
....................    {
....................       case 0:
....................          output_low(_CS0);
001A0:  MOVLW  1F
001A2:  MOVWF  F8A
001A4:  BCF    F85.5
....................          output_low(_CS1);
001A6:  MOVWF  F8A
001A8:  BCF    F85.6
....................       break; 
001AA:  BRA    01B8
....................       case 1:         
....................          output_low(_CS2);
001AC:  MOVLW  1F
001AE:  MOVWF  F8A
001B0:  BCF    F85.7
....................          output_low(_CS3);
001B2:  MOVLW  04
001B4:  MOVWF  F88
001B6:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
001B8:  MOVLW  35
001BA:  MOVWF  00
001BC:  DECFSZ 00,F
001BE:  BRA    01BC
001C0:  GOTO   01CA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ALL ADCs                                                           */
.................... /*****************************************************************************/
.................... void ads_select_all()
.................... {
....................    output_low(_CS0);
*
007FC:  MOVLW  1F
007FE:  MOVWF  F8A
00800:  BCF    F85.5
....................    output_low(_CS1);
00802:  MOVWF  F8A
00804:  BCF    F85.6
....................    output_low(_CS2);
00806:  MOVWF  F8A
00808:  BCF    F85.7
....................    output_low(_CS3);
0080A:  MOVLW  04
0080C:  MOVWF  F88
0080E:  BCF    F83.0
....................    delay_us(10);
00810:  MOVLW  35
00812:  MOVWF  00
00814:  DECFSZ 00,F
00816:  BRA    0814
00818:  GOTO   081E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00732:  MOVFF  70A,70C
00736:  RCALL  06C8
....................    spi_write2(command);
00738:  MOVLB  E
0073A:  MOVF   x8D,W
0073C:  MOVFF  70B,E8D
00740:  RRCF   x90,W
00742:  BNC   0740
00744:  MOVLB  0
00746:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C4:  MOVFF  772,774
001C8:  BRA    018E
....................    spi_write2(command);
001CA:  MOVLB  E
001CC:  MOVF   x8D,W
001CE:  MOVFF  773,E8D
001D2:  RRCF   x90,W
001D4:  BNC   01D2
001D6:  MOVLB  0
001D8:  GOTO   01EA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO ALL ADCs                                        */
.................... /*****************************************************************************/
.................... void ads_write_command_all(unsigned int8 command)
.................... {
....................    ads_select_all();
*
0081C:  BRA    07FC
....................    spi_write2(command);
0081E:  MOVLB  E
00820:  MOVF   x8D,W
00822:  MOVFF  701,E8D
00826:  RRCF   x90,W
00828:  BNC   0826
0082A:  MOVLB  0
0082C:  GOTO   083A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
00848:  MOVFF  709,70C
0084C:  RCALL  06C8
....................    spi_read2(command);
0084E:  MOVLB  E
00850:  MOVF   x8D,W
00852:  MOVFF  70A,E8D
00856:  RRCF   x90,W
00858:  BNC   0856
0085A:  MOVLB  0
0085C:  GOTO   086E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
0076C:  MOVLB  7
0076E:  MOVF   x07,W
00770:  IORLW  40
00772:  MOVWF  x09
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
00774:  MOVFF  706,70A
00778:  MOVFF  709,70B
0077C:  MOVLB  0
0077E:  RCALL  0732
....................    spi_write2(data);
00780:  MOVLB  E
00782:  MOVF   x8D,W
00784:  MOVFF  708,E8D
00788:  RRCF   x90,W
0078A:  BNC   0788
....................    ads_deselect_all();
0078C:  MOVLB  0
0078E:  RCALL  0170
00790:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001DC:  MOVFF  771,772
001E0:  MOVLW  08
001E2:  MOVLB  7
001E4:  MOVWF  x73
001E6:  MOVLB  0
001E8:  BRA    01C4
....................    delay_us(10);
001EA:  MOVLW  35
001EC:  MOVWF  00
001EE:  DECFSZ 00,F
001F0:  BRA    01EE
....................    ads_deselect_all();
001F2:  RCALL  0170
001F4:  GOTO   023A (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* START ALL CONVERSION                                                      */
.................... /*****************************************************************************/
.................... void ads_start_conv_all()
.................... {
....................    ads_write_command_all(ADSstart);
*
00830:  MOVLW  08
00832:  MOVLB  7
00834:  MOVWF  x01
00836:  MOVLB  0
00838:  BRA    081C
....................    delay_us(10);
0083A:  MOVLW  35
0083C:  MOVWF  00
0083E:  DECFSZ 00,F
00840:  BRA    083E
....................    ads_deselect_all();
00842:  RCALL  0170
00844:  GOTO   09CA (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
00860:  MOVFF  704,709
00864:  MOVLW  10
00866:  MOVLB  7
00868:  MOVWF  x0A
0086A:  MOVLB  0
0086C:  BRA    0848
....................    data.dBytes[3] = 0;
0086E:  MOVLB  7
00870:  CLRF   x08
....................    data.dBytes[2] = spi_read2(0);
00872:  MOVLB  E
00874:  MOVF   x8D,W
00876:  CLRF   x8D
00878:  RRCF   x90,W
0087A:  BNC   0878
0087C:  MOVFF  E8D,707
....................    data.dBytes[1] = spi_read2(0);
00880:  MOVF   x8D,W
00882:  CLRF   x8D
00884:  RRCF   x90,W
00886:  BNC   0884
00888:  MOVFF  E8D,706
....................    data.dBytes[0] = spi_read2(0);
0088C:  MOVF   x8D,W
0088E:  CLRF   x8D
00890:  RRCF   x90,W
00892:  BNC   0890
00894:  MOVFF  E8D,705
....................    
....................    //convert 24-bit 2's complement to 32-bit 2's complement
....................    if (0x80 & data.dBytes[2]) data.dBytes[3] |= 0xFF;
00898:  MOVLB  7
0089A:  MOVF   x07,W
0089C:  ANDLW  80
0089E:  BZ    08A4
008A0:  MOVLW  FF
008A2:  IORWF  x08,F
....................    
....................    ads_deselect_all();
008A4:  MOVLB  0
008A6:  RCALL  0170
....................    return data.dWord;
008A8:  MOVFF  705,00
008AC:  MOVFF  706,01
008B0:  MOVFF  707,02
008B4:  MOVFF  708,03
008B8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00792:  MOVFF  701,70A
00796:  MOVLW  06
00798:  MOVLB  7
0079A:  MOVWF  x0B
0079C:  MOVLB  0
0079E:  RCALL  0732
....................    delay_us(300);                    
007A0:  MOVLW  02
007A2:  MOVLB  7
007A4:  MOVWF  x06
007A6:  MOVLW  96
007A8:  MOVWF  x07
007AA:  MOVLB  0
007AC:  BRA    0748
007AE:  MOVLB  7
007B0:  DECFSZ x06,F
007B2:  BRA    07A6
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
007B4:  MOVFF  701,706
007B8:  CLRF   x07
007BA:  MOVFF  702,708
007BE:  MOVLB  0
007C0:  RCALL  076C
....................    ads_write_reg(ch, reg1, rc1);
007C2:  MOVFF  701,706
007C6:  MOVLW  04
007C8:  MOVLB  7
007CA:  MOVWF  x07
007CC:  MOVFF  703,708
007D0:  MOVLB  0
007D2:  RCALL  076C
....................    ads_write_reg(ch, reg2, rc2);
007D4:  MOVFF  701,706
007D8:  MOVLW  08
007DA:  MOVLB  7
007DC:  MOVWF  x07
007DE:  MOVFF  704,708
007E2:  MOVLB  0
007E4:  RCALL  076C
....................    ads_write_reg(ch, reg3, rc3);  
007E6:  MOVFF  701,706
007EA:  MOVLW  0C
007EC:  MOVLB  7
007EE:  MOVWF  x07
007F0:  MOVFF  705,708
007F4:  MOVLB  0
007F6:  RCALL  076C
007F8:  GOTO   09A4 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
02760:  MOVLB  7
02762:  BCF    x45.0
....................    y = x;
02764:  MOVFF  739,73E
02768:  MOVFF  738,73D
0276C:  MOVFF  737,73C
02770:  MOVFF  736,73B
.................... 
....................    if (x < 0)
02774:  MOVFF  739,749
02778:  MOVFF  738,748
0277C:  MOVFF  737,747
02780:  MOVFF  736,746
02784:  CLRF   x4D
02786:  CLRF   x4C
02788:  CLRF   x4B
0278A:  CLRF   x4A
0278C:  MOVLB  0
0278E:  CALL   1D30
02792:  BNC   27A0
....................    {
....................       s = 1;
02794:  MOVLB  7
02796:  BSF    x45.0
....................       y = -y;
02798:  MOVF   x3C,W
0279A:  XORLW  80
0279C:  MOVWF  x3C
0279E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
027A0:  MOVFF  73E,749
027A4:  MOVFF  73D,748
027A8:  MOVFF  73C,747
027AC:  MOVFF  73B,746
027B0:  MOVLB  7
027B2:  CLRF   x4D
027B4:  CLRF   x4C
027B6:  CLRF   x4B
027B8:  MOVLW  8E
027BA:  MOVWF  x4A
027BC:  MOVLB  0
027BE:  CALL   1D30
027C2:  BC    27C6
027C4:  BNZ   27F6
....................       res = (float32)(unsigned int16)y;
027C6:  MOVFF  73E,749
027CA:  MOVFF  73D,748
027CE:  MOVFF  73C,747
027D2:  MOVFF  73B,746
027D6:  RCALL  2724
027D8:  MOVFF  02,74B
027DC:  MOVFF  01,74A
027E0:  CALL   0D6E
027E4:  MOVFF  03,742
027E8:  MOVFF  02,741
027EC:  MOVFF  01,740
027F0:  MOVFF  00,73F
027F4:  BRA    2998
.................... 
....................  else if (y < 10000000.0)
027F6:  MOVFF  73E,749
027FA:  MOVFF  73D,748
027FE:  MOVFF  73C,747
02802:  MOVFF  73B,746
02806:  MOVLW  80
02808:  MOVLB  7
0280A:  MOVWF  x4D
0280C:  MOVLW  96
0280E:  MOVWF  x4C
02810:  MOVLW  18
02812:  MOVWF  x4B
02814:  MOVLW  96
02816:  MOVWF  x4A
02818:  MOVLB  0
0281A:  CALL   1D30
0281E:  BTFSS  FD8.0
02820:  BRA    2988
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
02822:  MOVFF  73E,753
02826:  MOVFF  73D,752
0282A:  MOVFF  73C,751
0282E:  MOVFF  73B,750
02832:  MOVLB  7
02834:  CLRF   x57
02836:  CLRF   x56
02838:  CLRF   x55
0283A:  MOVLW  70
0283C:  MOVWF  x54
0283E:  MOVLB  0
02840:  CALL   0DA4
02844:  MOVFF  03,749
02848:  MOVFF  02,748
0284C:  MOVFF  01,747
02850:  MOVFF  00,746
02854:  RCALL  2724
02856:  MOVFF  02,744
0285A:  MOVFF  01,743
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
0285E:  MOVFF  73E,753
02862:  MOVFF  73D,752
02866:  MOVFF  73C,751
0286A:  MOVFF  73B,750
0286E:  MOVLB  7
02870:  CLRF   x57
02872:  CLRF   x56
02874:  CLRF   x55
02876:  MOVLW  70
02878:  MOVWF  x54
0287A:  MOVLB  0
0287C:  CALL   0DA4
02880:  MOVFF  03,749
02884:  MOVFF  02,748
02888:  MOVFF  01,747
0288C:  MOVFF  00,746
02890:  MOVFF  744,74B
02894:  MOVFF  743,74A
02898:  CALL   0D6E
0289C:  BSF    FD8.1
0289E:  MOVFF  749,74D
028A2:  MOVFF  748,74C
028A6:  MOVFF  747,74B
028AA:  MOVFF  746,74A
028AE:  MOVFF  03,751
028B2:  MOVFF  02,750
028B6:  MOVFF  01,74F
028BA:  MOVFF  00,74E
028BE:  CALL   0E9A
028C2:  MOVLB  7
028C4:  CLRF   x53
028C6:  CLRF   x52
028C8:  CLRF   x51
028CA:  MOVLW  8E
028CC:  MOVWF  x50
028CE:  MOVFF  03,757
028D2:  MOVFF  02,756
028D6:  MOVFF  01,755
028DA:  MOVFF  00,754
028DE:  MOVLB  0
028E0:  CALL   0DA4
028E4:  MOVFF  03,73E
028E8:  MOVFF  02,73D
028EC:  MOVFF  01,73C
028F0:  MOVFF  00,73B
....................       res = 32768.0*(float32)l;
028F4:  MOVFF  744,74B
028F8:  MOVFF  743,74A
028FC:  CALL   0D6E
02900:  MOVLB  7
02902:  CLRF   x53
02904:  CLRF   x52
02906:  CLRF   x51
02908:  MOVLW  8E
0290A:  MOVWF  x50
0290C:  MOVFF  03,757
02910:  MOVFF  02,756
02914:  MOVFF  01,755
02918:  MOVFF  00,754
0291C:  MOVLB  0
0291E:  CALL   0DA4
02922:  MOVFF  03,742
02926:  MOVFF  02,741
0292A:  MOVFF  01,740
0292E:  MOVFF  00,73F
....................       res += (float32)(unsigned int16)y;
02932:  MOVFF  73E,749
02936:  MOVFF  73D,748
0293A:  MOVFF  73C,747
0293E:  MOVFF  73B,746
02942:  RCALL  2724
02944:  MOVFF  02,74B
02948:  MOVFF  01,74A
0294C:  CALL   0D6E
02950:  BCF    FD8.1
02952:  MOVFF  742,74D
02956:  MOVFF  741,74C
0295A:  MOVFF  740,74B
0295E:  MOVFF  73F,74A
02962:  MOVFF  03,751
02966:  MOVFF  02,750
0296A:  MOVFF  01,74F
0296E:  MOVFF  00,74E
02972:  CALL   0E9A
02976:  MOVFF  03,742
0297A:  MOVFF  02,741
0297E:  MOVFF  01,740
02982:  MOVFF  00,73F
....................    }
02986:  BRA    2998
.................... 
....................  else
....................   res = y;
02988:  MOVFF  73E,742
0298C:  MOVFF  73D,741
02990:  MOVFF  73C,740
02994:  MOVFF  73B,73F
.................... 
....................  y = y - (float32)(unsigned int16)y;
02998:  MOVFF  73E,749
0299C:  MOVFF  73D,748
029A0:  MOVFF  73C,747
029A4:  MOVFF  73B,746
029A8:  RCALL  2724
029AA:  MOVFF  02,74B
029AE:  MOVFF  01,74A
029B2:  CALL   0D6E
029B6:  BSF    FD8.1
029B8:  MOVFF  73E,74D
029BC:  MOVFF  73D,74C
029C0:  MOVFF  73C,74B
029C4:  MOVFF  73B,74A
029C8:  MOVFF  03,751
029CC:  MOVFF  02,750
029D0:  MOVFF  01,74F
029D4:  MOVFF  00,74E
029D8:  CALL   0E9A
029DC:  MOVFF  03,73E
029E0:  MOVFF  02,73D
029E4:  MOVFF  01,73C
029E8:  MOVFF  00,73B
.................... 
....................  if (s)
029EC:  MOVLB  7
029EE:  BTFSS  x45.0
029F0:  BRA    29F8
....................   res = -res;
029F2:  MOVF   x40,W
029F4:  XORLW  80
029F6:  MOVWF  x40
.................... 
....................  if (y != 0)
029F8:  MOVFF  73E,749
029FC:  MOVFF  73D,748
02A00:  MOVFF  73C,747
02A04:  MOVFF  73B,746
02A08:  CLRF   x4D
02A0A:  CLRF   x4C
02A0C:  CLRF   x4B
02A0E:  CLRF   x4A
02A10:  MOVLB  0
02A12:  CALL   1D30
02A16:  BZ    2A90
....................  {
....................   if (s == 1 && n == 0)
02A18:  MOVLB  7
02A1A:  BTFSS  x45.0
02A1C:  BRA    2A56
02A1E:  MOVF   x3A,F
02A20:  BNZ   2A56
....................    res -= 1.0;
02A22:  BSF    FD8.1
02A24:  MOVFF  742,74D
02A28:  MOVFF  741,74C
02A2C:  MOVFF  740,74B
02A30:  MOVFF  73F,74A
02A34:  CLRF   x51
02A36:  CLRF   x50
02A38:  CLRF   x4F
02A3A:  MOVLW  7F
02A3C:  MOVWF  x4E
02A3E:  MOVLB  0
02A40:  CALL   0E9A
02A44:  MOVFF  03,742
02A48:  MOVFF  02,741
02A4C:  MOVFF  01,740
02A50:  MOVFF  00,73F
02A54:  MOVLB  7
.................... 
....................   if (s == 0 && n == 1)
02A56:  BTFSC  x45.0
02A58:  BRA    2A92
02A5A:  DECFSZ x3A,W
02A5C:  BRA    2A92
....................    res += 1.0;
02A5E:  BCF    FD8.1
02A60:  MOVFF  742,74D
02A64:  MOVFF  741,74C
02A68:  MOVFF  740,74B
02A6C:  MOVFF  73F,74A
02A70:  CLRF   x51
02A72:  CLRF   x50
02A74:  CLRF   x4F
02A76:  MOVLW  7F
02A78:  MOVWF  x4E
02A7A:  MOVLB  0
02A7C:  CALL   0E9A
02A80:  MOVFF  03,742
02A84:  MOVFF  02,741
02A88:  MOVFF  01,740
02A8C:  MOVFF  00,73F
02A90:  MOVLB  7
....................  }
....................  if (x == 0)
02A92:  MOVFF  739,749
02A96:  MOVFF  738,748
02A9A:  MOVFF  737,747
02A9E:  MOVFF  736,746
02AA2:  CLRF   x4D
02AA4:  CLRF   x4C
02AA6:  CLRF   x4B
02AA8:  CLRF   x4A
02AAA:  MOVLB  0
02AAC:  CALL   1D30
02AB0:  BNZ   2ABE
....................     res = 0;
02AB2:  MOVLB  7
02AB4:  CLRF   x42
02AB6:  CLRF   x41
02AB8:  CLRF   x40
02ABA:  CLRF   x3F
02ABC:  MOVLB  0
.................... 
....................  return (res);
02ABE:  MOVFF  73F,00
02AC2:  MOVFF  740,01
02AC6:  MOVFF  741,02
02ACA:  MOVFF  742,03
02ACE:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02AEE:  MOVFF  735,739
02AF2:  MOVFF  734,738
02AF6:  MOVFF  733,737
02AFA:  MOVFF  732,736
02AFE:  MOVLB  7
02B00:  CLRF   x3A
02B02:  MOVLB  0
02B04:  RCALL  2760
02B06:  GOTO   2C12 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
02AD0:  MOVFF  735,739
02AD4:  MOVFF  734,738
02AD8:  MOVFF  733,737
02ADC:  MOVFF  732,736
02AE0:  MOVLW  01
02AE2:  MOVLB  7
02AE4:  MOVWF  x3A
02AE6:  MOVLB  0
02AE8:  RCALL  2760
02AEA:  GOTO   2BCA (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02B0A:  MOVFF  729,749
02B0E:  MOVFF  728,748
02B12:  MOVFF  727,747
02B16:  MOVFF  726,746
02B1A:  MOVLB  7
02B1C:  CLRF   x4D
02B1E:  CLRF   x4C
02B20:  CLRF   x4B
02B22:  CLRF   x4A
02B24:  MOVLB  0
02B26:  CALL   1D30
02B2A:  BTFSC  FD8.2
02B2C:  BRA    2C6E
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02B2E:  MOVFF  725,742
02B32:  MOVFF  724,741
02B36:  MOVFF  723,740
02B3A:  MOVFF  722,73F
02B3E:  MOVFF  729,746
02B42:  MOVFF  728,745
02B46:  MOVFF  727,744
02B4A:  MOVFF  726,743
02B4E:  CALL   1DAA
02B52:  MOVFF  03,731
02B56:  MOVFF  02,730
02B5A:  MOVFF  01,72F
02B5E:  MOVFF  00,72E
02B62:  MOVFF  03,749
02B66:  MOVFF  02,748
02B6A:  MOVFF  01,747
02B6E:  MOVFF  00,746
02B72:  MOVLB  7
02B74:  CLRF   x4D
02B76:  CLRF   x4C
02B78:  CLRF   x4B
02B7A:  CLRF   x4A
02B7C:  MOVLB  0
02B7E:  CALL   1D30
02B82:  BNC   2BCC
02B84:  MOVFF  725,742
02B88:  MOVFF  724,741
02B8C:  MOVFF  723,740
02B90:  MOVFF  722,73F
02B94:  MOVFF  729,746
02B98:  MOVFF  728,745
02B9C:  MOVFF  727,744
02BA0:  MOVFF  726,743
02BA4:  CALL   1DAA
02BA8:  MOVFF  03,731
02BAC:  MOVFF  02,730
02BB0:  MOVFF  01,72F
02BB4:  MOVFF  00,72E
02BB8:  MOVFF  03,735
02BBC:  MOVFF  02,734
02BC0:  MOVFF  01,733
02BC4:  MOVFF  00,732
02BC8:  BRA    2AD0
02BCA:  BRA    2C12
02BCC:  MOVFF  725,742
02BD0:  MOVFF  724,741
02BD4:  MOVFF  723,740
02BD8:  MOVFF  722,73F
02BDC:  MOVFF  729,746
02BE0:  MOVFF  728,745
02BE4:  MOVFF  727,744
02BE8:  MOVFF  726,743
02BEC:  CALL   1DAA
02BF0:  MOVFF  03,731
02BF4:  MOVFF  02,730
02BF8:  MOVFF  01,72F
02BFC:  MOVFF  00,72E
02C00:  MOVFF  03,735
02C04:  MOVFF  02,734
02C08:  MOVFF  01,733
02C0C:  MOVFF  00,732
02C10:  BRA    2AEE
02C12:  MOVFF  03,72D
02C16:  MOVFF  02,72C
02C1A:  MOVFF  01,72B
02C1E:  MOVFF  00,72A
....................       return(x-(i*y));
02C22:  MOVFF  72D,753
02C26:  MOVFF  72C,752
02C2A:  MOVFF  72B,751
02C2E:  MOVFF  72A,750
02C32:  MOVFF  729,757
02C36:  MOVFF  728,756
02C3A:  MOVFF  727,755
02C3E:  MOVFF  726,754
02C42:  CALL   0DA4
02C46:  BSF    FD8.1
02C48:  MOVFF  725,74D
02C4C:  MOVFF  724,74C
02C50:  MOVFF  723,74B
02C54:  MOVFF  722,74A
02C58:  MOVFF  03,751
02C5C:  MOVFF  02,750
02C60:  MOVFF  01,74F
02C64:  MOVFF  00,74E
02C68:  CALL   0E9A
02C6C:  BRA    2C6E
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
02C6E:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
03004:  MOVFF  729,753
03008:  MOVFF  728,752
0300C:  MOVFF  727,751
03010:  MOVFF  726,750
03014:  MOVLW  3B
03016:  MOVLB  7
03018:  MOVWF  x57
0301A:  MOVLW  AA
0301C:  MOVWF  x56
0301E:  MOVLW  38
03020:  MOVWF  x55
03022:  MOVLW  7F
03024:  MOVWF  x54
03026:  MOVLB  0
03028:  CALL   0DA4
0302C:  MOVFF  03,749
03030:  MOVFF  02,748
03034:  MOVFF  01,747
03038:  MOVFF  00,746
0303C:  CALL   2724
03040:  MOVFF  01,736
....................    s = 0;
03044:  MOVLB  7
03046:  BCF    x37.0
....................    y = x;
03048:  MOVFF  729,72D
0304C:  MOVFF  728,72C
03050:  MOVFF  727,72B
03054:  MOVFF  726,72A
.................... 
....................    if (x < 0)
03058:  MOVFF  729,749
0305C:  MOVFF  728,748
03060:  MOVFF  727,747
03064:  MOVFF  726,746
03068:  CLRF   x4D
0306A:  CLRF   x4C
0306C:  CLRF   x4B
0306E:  CLRF   x4A
03070:  MOVLB  0
03072:  CALL   1D30
03076:  BNC   3086
....................    {
....................       s = 1;
03078:  MOVLB  7
0307A:  BSF    x37.0
....................       n = -n;
0307C:  NEGF   x36
....................       y = -y;
0307E:  MOVF   x2B,W
03080:  XORLW  80
03082:  MOVWF  x2B
03084:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
03086:  MOVLB  7
03088:  CLRF   x31
0308A:  CLRF   x30
0308C:  CLRF   x2F
0308E:  CLRF   x2E
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
03090:  MOVLW  07
03092:  MOVWF  x39
03094:  MOVLW  2E
03096:  MOVFF  739,FEA
0309A:  MOVWF  FE9
0309C:  MOVLW  7F
0309E:  ADDWF  x36,W
030A0:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
030A2:  MOVFF  72D,753
030A6:  MOVFF  72C,752
030AA:  MOVFF  72B,751
030AE:  MOVFF  72A,750
030B2:  MOVLW  3B
030B4:  MOVWF  x57
030B6:  MOVLW  AA
030B8:  MOVWF  x56
030BA:  MOVLW  38
030BC:  MOVWF  x55
030BE:  MOVLW  7F
030C0:  MOVWF  x54
030C2:  MOVLB  0
030C4:  CALL   0DA4
030C8:  MOVFF  03,73B
030CC:  MOVFF  02,73A
030D0:  MOVFF  01,739
030D4:  MOVFF  00,738
030D8:  MOVLB  7
030DA:  CLRF   x3D
030DC:  MOVFF  736,73C
030E0:  BTFSC  x3C.7
030E2:  DECF   x3D,F
030E4:  MOVLB  0
030E6:  CALL   26D4
030EA:  BSF    FD8.1
030EC:  MOVFF  73B,74D
030F0:  MOVFF  73A,74C
030F4:  MOVFF  739,74B
030F8:  MOVFF  738,74A
030FC:  MOVFF  03,751
03100:  MOVFF  02,750
03104:  MOVFF  01,74F
03108:  MOVFF  00,74E
0310C:  CALL   0E9A
03110:  MOVFF  03,72D
03114:  MOVFF  02,72C
03118:  MOVFF  01,72B
0311C:  MOVFF  00,72A
.................... 
....................    r = pe[0]*y + pe[1];
03120:  MOVLW  7C
03122:  MOVLB  7
03124:  MOVWF  x53
03126:  MOVLW  88
03128:  MOVWF  x52
0312A:  MOVLW  59
0312C:  MOVWF  x51
0312E:  MOVLW  72
03130:  MOVWF  x50
03132:  MOVFF  72D,757
03136:  MOVFF  72C,756
0313A:  MOVFF  72B,755
0313E:  MOVFF  72A,754
03142:  MOVLB  0
03144:  CALL   0DA4
03148:  MOVFF  03,73B
0314C:  MOVFF  02,73A
03150:  MOVFF  01,739
03154:  MOVFF  00,738
03158:  BCF    FD8.1
0315A:  MOVFF  03,74D
0315E:  MOVFF  02,74C
03162:  MOVFF  01,74B
03166:  MOVFF  00,74A
0316A:  MOVLW  E0
0316C:  MOVLB  7
0316E:  MOVWF  x51
03170:  MOVLW  97
03172:  MOVWF  x50
03174:  MOVLW  26
03176:  MOVWF  x4F
03178:  MOVLW  75
0317A:  MOVWF  x4E
0317C:  MOVLB  0
0317E:  CALL   0E9A
03182:  MOVFF  03,735
03186:  MOVFF  02,734
0318A:  MOVFF  01,733
0318E:  MOVFF  00,732
....................    r = r*y + pe[2];
03192:  MOVFF  735,753
03196:  MOVFF  734,752
0319A:  MOVFF  733,751
0319E:  MOVFF  732,750
031A2:  MOVFF  72D,757
031A6:  MOVFF  72C,756
031AA:  MOVFF  72B,755
031AE:  MOVFF  72A,754
031B2:  CALL   0DA4
031B6:  MOVFF  03,73B
031BA:  MOVFF  02,73A
031BE:  MOVFF  01,739
031C2:  MOVFF  00,738
031C6:  BCF    FD8.1
031C8:  MOVFF  03,74D
031CC:  MOVFF  02,74C
031D0:  MOVFF  01,74B
031D4:  MOVFF  00,74A
031D8:  MOVLW  C4
031DA:  MOVLB  7
031DC:  MOVWF  x51
031DE:  MOVLW  1D
031E0:  MOVWF  x50
031E2:  MOVLW  1E
031E4:  MOVWF  x4F
031E6:  MOVLW  78
031E8:  MOVWF  x4E
031EA:  MOVLB  0
031EC:  CALL   0E9A
031F0:  MOVFF  03,735
031F4:  MOVFF  02,734
031F8:  MOVFF  01,733
031FC:  MOVFF  00,732
....................    r = r*y + pe[3];
03200:  MOVFF  735,753
03204:  MOVFF  734,752
03208:  MOVFF  733,751
0320C:  MOVFF  732,750
03210:  MOVFF  72D,757
03214:  MOVFF  72C,756
03218:  MOVFF  72B,755
0321C:  MOVFF  72A,754
03220:  CALL   0DA4
03224:  MOVFF  03,73B
03228:  MOVFF  02,73A
0322C:  MOVFF  01,739
03230:  MOVFF  00,738
03234:  BCF    FD8.1
03236:  MOVFF  03,74D
0323A:  MOVFF  02,74C
0323E:  MOVFF  01,74B
03242:  MOVFF  00,74A
03246:  MOVLW  5E
03248:  MOVLB  7
0324A:  MOVWF  x51
0324C:  MOVLW  50
0324E:  MOVWF  x50
03250:  MOVLW  63
03252:  MOVWF  x4F
03254:  MOVLW  7A
03256:  MOVWF  x4E
03258:  MOVLB  0
0325A:  CALL   0E9A
0325E:  MOVFF  03,735
03262:  MOVFF  02,734
03266:  MOVFF  01,733
0326A:  MOVFF  00,732
....................    r = r*y + pe[4];
0326E:  MOVFF  735,753
03272:  MOVFF  734,752
03276:  MOVFF  733,751
0327A:  MOVFF  732,750
0327E:  MOVFF  72D,757
03282:  MOVFF  72C,756
03286:  MOVFF  72B,755
0328A:  MOVFF  72A,754
0328E:  CALL   0DA4
03292:  MOVFF  03,73B
03296:  MOVFF  02,73A
0329A:  MOVFF  01,739
0329E:  MOVFF  00,738
032A2:  BCF    FD8.1
032A4:  MOVFF  03,74D
032A8:  MOVFF  02,74C
032AC:  MOVFF  01,74B
032B0:  MOVFF  00,74A
032B4:  MOVLW  1A
032B6:  MOVLB  7
032B8:  MOVWF  x51
032BA:  MOVLW  FE
032BC:  MOVWF  x50
032BE:  MOVLW  75
032C0:  MOVWF  x4F
032C2:  MOVLW  7C
032C4:  MOVWF  x4E
032C6:  MOVLB  0
032C8:  CALL   0E9A
032CC:  MOVFF  03,735
032D0:  MOVFF  02,734
032D4:  MOVFF  01,733
032D8:  MOVFF  00,732
....................    r = r*y + pe[5];
032DC:  MOVFF  735,753
032E0:  MOVFF  734,752
032E4:  MOVFF  733,751
032E8:  MOVFF  732,750
032EC:  MOVFF  72D,757
032F0:  MOVFF  72C,756
032F4:  MOVFF  72B,755
032F8:  MOVFF  72A,754
032FC:  CALL   0DA4
03300:  MOVFF  03,73B
03304:  MOVFF  02,73A
03308:  MOVFF  01,739
0330C:  MOVFF  00,738
03310:  BCF    FD8.1
03312:  MOVFF  03,74D
03316:  MOVFF  02,74C
0331A:  MOVFF  01,74B
0331E:  MOVFF  00,74A
03322:  MOVLW  18
03324:  MOVLB  7
03326:  MOVWF  x51
03328:  MOVLW  72
0332A:  MOVWF  x50
0332C:  MOVLW  31
0332E:  MOVWF  x4F
03330:  MOVLW  7E
03332:  MOVWF  x4E
03334:  MOVLB  0
03336:  CALL   0E9A
0333A:  MOVFF  03,735
0333E:  MOVFF  02,734
03342:  MOVFF  01,733
03346:  MOVFF  00,732
.................... 
....................    res = res*(1.0 + y*r);
0334A:  MOVFF  72D,753
0334E:  MOVFF  72C,752
03352:  MOVFF  72B,751
03356:  MOVFF  72A,750
0335A:  MOVFF  735,757
0335E:  MOVFF  734,756
03362:  MOVFF  733,755
03366:  MOVFF  732,754
0336A:  CALL   0DA4
0336E:  BCF    FD8.1
03370:  MOVLB  7
03372:  CLRF   x4D
03374:  CLRF   x4C
03376:  CLRF   x4B
03378:  MOVLW  7F
0337A:  MOVWF  x4A
0337C:  MOVFF  03,751
03380:  MOVFF  02,750
03384:  MOVFF  01,74F
03388:  MOVFF  00,74E
0338C:  MOVLB  0
0338E:  CALL   0E9A
03392:  MOVFF  731,753
03396:  MOVFF  730,752
0339A:  MOVFF  72F,751
0339E:  MOVFF  72E,750
033A2:  MOVFF  03,757
033A6:  MOVFF  02,756
033AA:  MOVFF  01,755
033AE:  MOVFF  00,754
033B2:  CALL   0DA4
033B6:  MOVFF  03,731
033BA:  MOVFF  02,730
033BE:  MOVFF  01,72F
033C2:  MOVFF  00,72E
.................... 
....................    if (s)
033C6:  MOVLB  7
033C8:  BTFSS  x37.0
033CA:  BRA    33FE
....................       res = 1.0/res;
033CC:  CLRF   x42
033CE:  CLRF   x41
033D0:  CLRF   x40
033D2:  MOVLW  7F
033D4:  MOVWF  x3F
033D6:  MOVFF  731,746
033DA:  MOVFF  730,745
033DE:  MOVFF  72F,744
033E2:  MOVFF  72E,743
033E6:  MOVLB  0
033E8:  CALL   1DAA
033EC:  MOVFF  03,731
033F0:  MOVFF  02,730
033F4:  MOVFF  01,72F
033F8:  MOVFF  00,72E
033FC:  MOVLB  7
....................    return(res);
033FE:  MOVFF  72E,00
03402:  MOVFF  72F,01
03406:  MOVFF  730,02
0340A:  MOVFF  731,03
0340E:  MOVLB  0
03410:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
02C70:  MOVFF  729,72D
02C74:  MOVFF  728,72C
02C78:  MOVFF  727,72B
02C7C:  MOVFF  726,72A
.................... 
....................    if (y != 1.0)
02C80:  MOVFF  72D,749
02C84:  MOVFF  72C,748
02C88:  MOVFF  72B,747
02C8C:  MOVFF  72A,746
02C90:  MOVLB  7
02C92:  CLRF   x4D
02C94:  CLRF   x4C
02C96:  CLRF   x4B
02C98:  MOVLW  7F
02C9A:  MOVWF  x4A
02C9C:  MOVLB  0
02C9E:  CALL   1D30
02CA2:  BTFSC  FD8.2
02CA4:  BRA    2FE6
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02CA6:  MOVLW  07
02CA8:  MOVLB  7
02CAA:  MOVWF  x3C
02CAC:  MOVLW  2A
02CAE:  MOVFF  73C,FEA
02CB2:  MOVWF  FE9
02CB4:  MOVLW  7E
02CB6:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02CB8:  BSF    FD8.1
02CBA:  MOVFF  72D,74D
02CBE:  MOVFF  72C,74C
02CC2:  MOVFF  72B,74B
02CC6:  MOVFF  72A,74A
02CCA:  CLRF   x51
02CCC:  CLRF   x50
02CCE:  CLRF   x4F
02CD0:  MOVLW  7F
02CD2:  MOVWF  x4E
02CD4:  MOVLB  0
02CD6:  CALL   0E9A
02CDA:  MOVFF  03,73E
02CDE:  MOVFF  02,73D
02CE2:  MOVFF  01,73C
02CE6:  MOVFF  00,73B
02CEA:  BCF    FD8.1
02CEC:  MOVFF  72D,74D
02CF0:  MOVFF  72C,74C
02CF4:  MOVFF  72B,74B
02CF8:  MOVFF  72A,74A
02CFC:  MOVLB  7
02CFE:  CLRF   x51
02D00:  CLRF   x50
02D02:  CLRF   x4F
02D04:  MOVLW  7F
02D06:  MOVWF  x4E
02D08:  MOVLB  0
02D0A:  CALL   0E9A
02D0E:  MOVFF  73E,742
02D12:  MOVFF  73D,741
02D16:  MOVFF  73C,740
02D1A:  MOVFF  73B,73F
02D1E:  MOVFF  03,746
02D22:  MOVFF  02,745
02D26:  MOVFF  01,744
02D2A:  MOVFF  00,743
02D2E:  CALL   1DAA
02D32:  MOVFF  03,72D
02D36:  MOVFF  02,72C
02D3A:  MOVFF  01,72B
02D3E:  MOVFF  00,72A
.................... 
....................       y2=y*y;
02D42:  MOVFF  72D,753
02D46:  MOVFF  72C,752
02D4A:  MOVFF  72B,751
02D4E:  MOVFF  72A,750
02D52:  MOVFF  72D,757
02D56:  MOVFF  72C,756
02D5A:  MOVFF  72B,755
02D5E:  MOVFF  72A,754
02D62:  CALL   0DA4
02D66:  MOVFF  03,739
02D6A:  MOVFF  02,738
02D6E:  MOVFF  01,737
02D72:  MOVFF  00,736
.................... 
....................       res = pl[0]*y2 + pl[1];
02D76:  MOVLW  99
02D78:  MOVLB  7
02D7A:  MOVWF  x53
02D7C:  MOVLW  47
02D7E:  MOVWF  x52
02D80:  MOVLW  8A
02D82:  MOVWF  x51
02D84:  MOVLW  7F
02D86:  MOVWF  x50
02D88:  MOVFF  739,757
02D8C:  MOVFF  738,756
02D90:  MOVFF  737,755
02D94:  MOVFF  736,754
02D98:  MOVLB  0
02D9A:  CALL   0DA4
02D9E:  MOVFF  03,73E
02DA2:  MOVFF  02,73D
02DA6:  MOVFF  01,73C
02DAA:  MOVFF  00,73B
02DAE:  BCF    FD8.1
02DB0:  MOVFF  03,74D
02DB4:  MOVFF  02,74C
02DB8:  MOVFF  01,74B
02DBC:  MOVFF  00,74A
02DC0:  MOVLB  7
02DC2:  CLRF   x51
02DC4:  CLRF   x50
02DC6:  CLRF   x4F
02DC8:  MOVLW  80
02DCA:  MOVWF  x4E
02DCC:  MOVLB  0
02DCE:  CALL   0E9A
02DD2:  MOVFF  03,731
02DD6:  MOVFF  02,730
02DDA:  MOVFF  01,72F
02DDE:  MOVFF  00,72E
.................... 
....................       r = ql[0]*y2 + ql[1];
02DE2:  MOVLW  4C
02DE4:  MOVLB  7
02DE6:  MOVWF  x53
02DE8:  MOVLW  F3
02DEA:  MOVWF  x52
02DEC:  MOVLW  3A
02DEE:  MOVWF  x51
02DF0:  MOVLW  7B
02DF2:  MOVWF  x50
02DF4:  MOVFF  739,757
02DF8:  MOVFF  738,756
02DFC:  MOVFF  737,755
02E00:  MOVFF  736,754
02E04:  MOVLB  0
02E06:  CALL   0DA4
02E0A:  MOVFF  03,73E
02E0E:  MOVFF  02,73D
02E12:  MOVFF  01,73C
02E16:  MOVFF  00,73B
02E1A:  BCF    FD8.1
02E1C:  MOVFF  03,74D
02E20:  MOVFF  02,74C
02E24:  MOVFF  01,74B
02E28:  MOVFF  00,74A
02E2C:  MOVLW  2B
02E2E:  MOVLB  7
02E30:  MOVWF  x51
02E32:  MOVLW  9D
02E34:  MOVWF  x50
02E36:  MOVLW  DF
02E38:  MOVWF  x4F
02E3A:  MOVLW  7E
02E3C:  MOVWF  x4E
02E3E:  MOVLB  0
02E40:  CALL   0E9A
02E44:  MOVFF  03,735
02E48:  MOVFF  02,734
02E4C:  MOVFF  01,733
02E50:  MOVFF  00,732
....................       r = r*y2 + 1.0;
02E54:  MOVFF  735,753
02E58:  MOVFF  734,752
02E5C:  MOVFF  733,751
02E60:  MOVFF  732,750
02E64:  MOVFF  739,757
02E68:  MOVFF  738,756
02E6C:  MOVFF  737,755
02E70:  MOVFF  736,754
02E74:  CALL   0DA4
02E78:  MOVFF  03,73E
02E7C:  MOVFF  02,73D
02E80:  MOVFF  01,73C
02E84:  MOVFF  00,73B
02E88:  BCF    FD8.1
02E8A:  MOVFF  03,74D
02E8E:  MOVFF  02,74C
02E92:  MOVFF  01,74B
02E96:  MOVFF  00,74A
02E9A:  MOVLB  7
02E9C:  CLRF   x51
02E9E:  CLRF   x50
02EA0:  CLRF   x4F
02EA2:  MOVLW  7F
02EA4:  MOVWF  x4E
02EA6:  MOVLB  0
02EA8:  CALL   0E9A
02EAC:  MOVFF  03,735
02EB0:  MOVFF  02,734
02EB4:  MOVFF  01,733
02EB8:  MOVFF  00,732
.................... 
....................       res = y*res/r;
02EBC:  MOVFF  72D,753
02EC0:  MOVFF  72C,752
02EC4:  MOVFF  72B,751
02EC8:  MOVFF  72A,750
02ECC:  MOVFF  731,757
02ED0:  MOVFF  730,756
02ED4:  MOVFF  72F,755
02ED8:  MOVFF  72E,754
02EDC:  CALL   0DA4
02EE0:  MOVFF  03,73E
02EE4:  MOVFF  02,73D
02EE8:  MOVFF  01,73C
02EEC:  MOVFF  00,73B
02EF0:  MOVFF  03,742
02EF4:  MOVFF  02,741
02EF8:  MOVFF  01,740
02EFC:  MOVFF  00,73F
02F00:  MOVFF  735,746
02F04:  MOVFF  734,745
02F08:  MOVFF  733,744
02F0C:  MOVFF  732,743
02F10:  CALL   1DAA
02F14:  MOVFF  03,731
02F18:  MOVFF  02,730
02F1C:  MOVFF  01,72F
02F20:  MOVFF  00,72E
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02F24:  MOVLW  07
02F26:  MOVLB  7
02F28:  MOVWF  x3C
02F2A:  MOVLW  26
02F2C:  MOVFF  73C,FEA
02F30:  MOVWF  FE9
02F32:  MOVLW  7E
02F34:  SUBWF  FEF,W
02F36:  MOVWF  x3A
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02F38:  BTFSS  x3A.7
02F3A:  BRA    2F66
....................          r = -(float32)-n;
02F3C:  MOVLW  00
02F3E:  BSF    FD8.0
02F40:  SUBFWB x3A,W
02F42:  CLRF   x3D
02F44:  MOVWF  x3C
02F46:  BTFSC  x3C.7
02F48:  DECF   x3D,F
02F4A:  MOVLB  0
02F4C:  CALL   26D4
02F50:  MOVFF  00,732
02F54:  MOVF   01,W
02F56:  XORLW  80
02F58:  MOVLB  7
02F5A:  MOVWF  x33
02F5C:  MOVFF  02,734
02F60:  MOVFF  03,735
02F64:  BRA    2F88
....................       else
....................          r = (float32)n;
02F66:  CLRF   x3D
02F68:  MOVFF  73A,73C
02F6C:  BTFSC  x3C.7
02F6E:  DECF   x3D,F
02F70:  MOVLB  0
02F72:  CALL   26D4
02F76:  MOVFF  03,735
02F7A:  MOVFF  02,734
02F7E:  MOVFF  01,733
02F82:  MOVFF  00,732
02F86:  MOVLB  7
.................... 
....................       res += r*LN2;
02F88:  MOVFF  735,753
02F8C:  MOVFF  734,752
02F90:  MOVFF  733,751
02F94:  MOVFF  732,750
02F98:  MOVLW  18
02F9A:  MOVWF  x57
02F9C:  MOVLW  72
02F9E:  MOVWF  x56
02FA0:  MOVLW  31
02FA2:  MOVWF  x55
02FA4:  MOVLW  7E
02FA6:  MOVWF  x54
02FA8:  MOVLB  0
02FAA:  CALL   0DA4
02FAE:  BCF    FD8.1
02FB0:  MOVFF  731,74D
02FB4:  MOVFF  730,74C
02FB8:  MOVFF  72F,74B
02FBC:  MOVFF  72E,74A
02FC0:  MOVFF  03,751
02FC4:  MOVFF  02,750
02FC8:  MOVFF  01,74F
02FCC:  MOVFF  00,74E
02FD0:  CALL   0E9A
02FD4:  MOVFF  03,731
02FD8:  MOVFF  02,730
02FDC:  MOVFF  01,72F
02FE0:  MOVFF  00,72E
....................    }
02FE4:  BRA    2FF2
.................... 
....................    else
....................       res = 0.0;
02FE6:  MOVLB  7
02FE8:  CLRF   x31
02FEA:  CLRF   x30
02FEC:  CLRF   x2F
02FEE:  CLRF   x2E
02FF0:  MOVLB  0
.................... 
....................    return(res);
02FF2:  MOVFF  72E,00
02FF6:  MOVFF  72F,01
02FFA:  MOVFF  730,02
02FFE:  MOVFF  731,03
03002:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
03412:  MOVFF  71D,749
03416:  MOVFF  71C,748
0341A:  MOVFF  71B,747
0341E:  MOVFF  71A,746
03422:  MOVLB  7
03424:  CLRF   x4D
03426:  CLRF   x4C
03428:  CLRF   x4B
0342A:  CLRF   x4A
0342C:  MOVLB  0
0342E:  CALL   1D30
03432:  BTFSS  FD8.0
03434:  BRA    35D0
03436:  MOVFF  721,725
0343A:  MOVFF  720,724
0343E:  MOVFF  71F,723
03442:  MOVFF  71E,722
03446:  MOVLB  7
03448:  CLRF   x29
0344A:  CLRF   x28
0344C:  CLRF   x27
0344E:  MOVLW  7F
03450:  MOVWF  x26
03452:  MOVLB  0
03454:  CALL   2B0A
03458:  MOVFF  03,725
0345C:  MOVFF  02,724
03460:  MOVFF  01,723
03464:  MOVFF  00,722
03468:  MOVFF  03,749
0346C:  MOVFF  02,748
03470:  MOVFF  01,747
03474:  MOVFF  00,746
03478:  MOVLB  7
0347A:  CLRF   x4D
0347C:  CLRF   x4C
0347E:  CLRF   x4B
03480:  CLRF   x4A
03482:  MOVLB  0
03484:  CALL   1D30
03488:  BTFSS  FD8.2
0348A:  BRA    35D0
....................       if(fmod(y, 2) == 0) {
0348C:  MOVFF  721,725
03490:  MOVFF  720,724
03494:  MOVFF  71F,723
03498:  MOVFF  71E,722
0349C:  MOVLB  7
0349E:  CLRF   x29
034A0:  CLRF   x28
034A2:  CLRF   x27
034A4:  MOVLW  80
034A6:  MOVWF  x26
034A8:  MOVLB  0
034AA:  CALL   2B0A
034AE:  MOVFF  03,725
034B2:  MOVFF  02,724
034B6:  MOVFF  01,723
034BA:  MOVFF  00,722
034BE:  MOVFF  03,749
034C2:  MOVFF  02,748
034C6:  MOVFF  01,747
034CA:  MOVFF  00,746
034CE:  MOVLB  7
034D0:  CLRF   x4D
034D2:  CLRF   x4C
034D4:  CLRF   x4B
034D6:  CLRF   x4A
034D8:  MOVLB  0
034DA:  CALL   1D30
034DE:  BNZ   3556
....................          return (exp(log(-x) * y));
034E0:  MOVLB  7
034E2:  MOVF   x1B,W
034E4:  XORLW  80
034E6:  MOVWF  x23
034E8:  MOVFF  71D,729
034EC:  MOVFF  71C,728
034F0:  MOVWF  x27
034F2:  MOVFF  71A,726
034F6:  MOVLB  0
034F8:  CALL   2C70
034FC:  MOVFF  03,725
03500:  MOVFF  02,724
03504:  MOVFF  01,723
03508:  MOVFF  00,722
0350C:  MOVFF  03,753
03510:  MOVFF  02,752
03514:  MOVFF  01,751
03518:  MOVFF  00,750
0351C:  MOVFF  721,757
03520:  MOVFF  720,756
03524:  MOVFF  71F,755
03528:  MOVFF  71E,754
0352C:  CALL   0DA4
03530:  MOVFF  03,725
03534:  MOVFF  02,724
03538:  MOVFF  01,723
0353C:  MOVFF  00,722
03540:  MOVFF  03,729
03544:  MOVFF  02,728
03548:  MOVFF  01,727
0354C:  MOVFF  00,726
03550:  RCALL  3004
03552:  BRA    370E
....................       } else {
03554:  BRA    35CE
....................          return (-exp(log(-x) * y));
03556:  MOVLB  7
03558:  MOVF   x1B,W
0355A:  XORLW  80
0355C:  MOVWF  x23
0355E:  MOVFF  71D,729
03562:  MOVFF  71C,728
03566:  MOVWF  x27
03568:  MOVFF  71A,726
0356C:  MOVLB  0
0356E:  CALL   2C70
03572:  MOVFF  03,725
03576:  MOVFF  02,724
0357A:  MOVFF  01,723
0357E:  MOVFF  00,722
03582:  MOVFF  03,753
03586:  MOVFF  02,752
0358A:  MOVFF  01,751
0358E:  MOVFF  00,750
03592:  MOVFF  721,757
03596:  MOVFF  720,756
0359A:  MOVFF  71F,755
0359E:  MOVFF  71E,754
035A2:  CALL   0DA4
035A6:  MOVFF  03,725
035AA:  MOVFF  02,724
035AE:  MOVFF  01,723
035B2:  MOVFF  00,722
035B6:  MOVFF  03,729
035BA:  MOVFF  02,728
035BE:  MOVFF  01,727
035C2:  MOVFF  00,726
035C6:  RCALL  3004
035C8:  MOVLW  80
035CA:  XORWF  01,F
035CC:  BRA    370E
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
035CE:  BRA    370E
035D0:  MOVFF  71D,749
035D4:  MOVFF  71C,748
035D8:  MOVFF  71B,747
035DC:  MOVFF  71A,746
035E0:  MOVLB  7
035E2:  CLRF   x4D
035E4:  CLRF   x4C
035E6:  CLRF   x4B
035E8:  CLRF   x4A
035EA:  MOVLB  0
035EC:  CALL   1D30
035F0:  BNC   3652
035F2:  MOVFF  721,725
035F6:  MOVFF  720,724
035FA:  MOVFF  71F,723
035FE:  MOVFF  71E,722
03602:  MOVLB  7
03604:  CLRF   x29
03606:  CLRF   x28
03608:  CLRF   x27
0360A:  MOVLW  7F
0360C:  MOVWF  x26
0360E:  MOVLB  0
03610:  CALL   2B0A
03614:  MOVFF  03,725
03618:  MOVFF  02,724
0361C:  MOVFF  01,723
03620:  MOVFF  00,722
03624:  MOVFF  03,749
03628:  MOVFF  02,748
0362C:  MOVFF  01,747
03630:  MOVFF  00,746
03634:  MOVLB  7
03636:  CLRF   x4D
03638:  CLRF   x4C
0363A:  CLRF   x4B
0363C:  CLRF   x4A
0363E:  MOVLB  0
03640:  CALL   1D30
03644:  BZ    3652
....................       return 0;
03646:  CLRF   00
03648:  CLRF   01
0364A:  CLRF   02
0364C:  CLRF   03
0364E:  BRA    370E
....................    } else {
03650:  BRA    370E
....................       if(x != 0 || 0 >= y) {
03652:  MOVFF  71D,749
03656:  MOVFF  71C,748
0365A:  MOVFF  71B,747
0365E:  MOVFF  71A,746
03662:  MOVLB  7
03664:  CLRF   x4D
03666:  CLRF   x4C
03668:  CLRF   x4B
0366A:  CLRF   x4A
0366C:  MOVLB  0
0366E:  CALL   1D30
03672:  BNZ   3698
03674:  MOVFF  721,749
03678:  MOVFF  720,748
0367C:  MOVFF  71F,747
03680:  MOVFF  71E,746
03684:  MOVLB  7
03686:  CLRF   x4D
03688:  CLRF   x4C
0368A:  CLRF   x4B
0368C:  CLRF   x4A
0368E:  MOVLB  0
03690:  CALL   1D30
03694:  BC    3698
03696:  BNZ   3706
....................          return (exp(log(x) * y));
03698:  MOVFF  71D,729
0369C:  MOVFF  71C,728
036A0:  MOVFF  71B,727
036A4:  MOVFF  71A,726
036A8:  CALL   2C70
036AC:  MOVFF  03,725
036B0:  MOVFF  02,724
036B4:  MOVFF  01,723
036B8:  MOVFF  00,722
036BC:  MOVFF  03,753
036C0:  MOVFF  02,752
036C4:  MOVFF  01,751
036C8:  MOVFF  00,750
036CC:  MOVFF  721,757
036D0:  MOVFF  720,756
036D4:  MOVFF  71F,755
036D8:  MOVFF  71E,754
036DC:  CALL   0DA4
036E0:  MOVFF  03,725
036E4:  MOVFF  02,724
036E8:  MOVFF  01,723
036EC:  MOVFF  00,722
036F0:  MOVFF  03,729
036F4:  MOVFF  02,728
036F8:  MOVFF  01,727
036FC:  MOVFF  00,726
03700:  RCALL  3004
03702:  BRA    370E
....................       } else return 0;
03704:  BRA    370E
03706:  CLRF   00
03708:  CLRF   01
0370A:  CLRF   02
0370C:  CLRF   03
....................    }
0370E:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01F08:  MOVLB  7
01F0A:  BCF    x38.0
....................    flag = 0;
01F0C:  BCF    x38.1
....................    y = x;
01F0E:  MOVFF  72B,72F
01F12:  MOVFF  72A,72E
01F16:  MOVFF  729,72D
01F1A:  MOVFF  728,72C
.................... 
....................    if (x < 0)
01F1E:  MOVFF  72B,749
01F22:  MOVFF  72A,748
01F26:  MOVFF  729,747
01F2A:  MOVFF  728,746
01F2E:  CLRF   x4D
01F30:  CLRF   x4C
01F32:  CLRF   x4B
01F34:  CLRF   x4A
01F36:  MOVLB  0
01F38:  RCALL  1D30
01F3A:  BNC   1F48
....................    {
....................       s = 1;
01F3C:  MOVLB  7
01F3E:  BSF    x38.0
....................       y = -y;
01F40:  MOVF   x2D,W
01F42:  XORLW  80
01F44:  MOVWF  x2D
01F46:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01F48:  MOVLB  7
01F4A:  CLRF   x49
01F4C:  CLRF   x48
01F4E:  CLRF   x47
01F50:  MOVLW  7F
01F52:  MOVWF  x46
01F54:  MOVFF  72F,74D
01F58:  MOVFF  72E,74C
01F5C:  MOVFF  72D,74B
01F60:  MOVFF  72C,74A
01F64:  MOVLB  0
01F66:  RCALL  1D30
01F68:  BNC   1FA0
....................    {
....................       y = 1.0/y;
01F6A:  MOVLB  7
01F6C:  CLRF   x42
01F6E:  CLRF   x41
01F70:  CLRF   x40
01F72:  MOVLW  7F
01F74:  MOVWF  x3F
01F76:  MOVFF  72F,746
01F7A:  MOVFF  72E,745
01F7E:  MOVFF  72D,744
01F82:  MOVFF  72C,743
01F86:  MOVLB  0
01F88:  RCALL  1DAA
01F8A:  MOVFF  03,72F
01F8E:  MOVFF  02,72E
01F92:  MOVFF  01,72D
01F96:  MOVFF  00,72C
....................       flag = 1;
01F9A:  MOVLB  7
01F9C:  BSF    x38.1
01F9E:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
01FA0:  MOVLW  0A
01FA2:  MOVLB  7
01FA4:  MOVWF  x53
01FA6:  MOVLW  89
01FA8:  MOVWF  x52
01FAA:  MOVLW  34
01FAC:  MOVWF  x51
01FAE:  MOVLW  7C
01FB0:  MOVWF  x50
01FB2:  MOVFF  72F,757
01FB6:  MOVFF  72E,756
01FBA:  MOVFF  72D,755
01FBE:  MOVFF  72C,754
01FC2:  MOVLB  0
01FC4:  CALL   0DA4
01FC8:  MOVFF  03,73C
01FCC:  MOVFF  02,73B
01FD0:  MOVFF  01,73A
01FD4:  MOVFF  00,739
01FD8:  MOVFF  03,753
01FDC:  MOVFF  02,752
01FE0:  MOVFF  01,751
01FE4:  MOVFF  00,750
01FE8:  MOVFF  72F,757
01FEC:  MOVFF  72E,756
01FF0:  MOVFF  72D,755
01FF4:  MOVFF  72C,754
01FF8:  CALL   0DA4
01FFC:  MOVFF  03,73C
02000:  MOVFF  02,73B
02004:  MOVFF  01,73A
02008:  MOVFF  00,739
0200C:  BCF    FD8.1
0200E:  MOVFF  03,74D
02012:  MOVFF  02,74C
02016:  MOVFF  01,74B
0201A:  MOVFF  00,74A
0201E:  MOVLW  7C
02020:  MOVLB  7
02022:  MOVWF  x51
02024:  MOVLW  79
02026:  MOVWF  x50
02028:  MOVLW  35
0202A:  MOVWF  x4F
0202C:  MOVLW  81
0202E:  MOVWF  x4E
02030:  MOVLB  0
02032:  CALL   0E9A
02036:  MOVFF  03,733
0203A:  MOVFF  02,732
0203E:  MOVFF  01,731
02042:  MOVFF  00,730
....................    res = res*y*y + pat[2];
02046:  MOVFF  733,753
0204A:  MOVFF  732,752
0204E:  MOVFF  731,751
02052:  MOVFF  730,750
02056:  MOVFF  72F,757
0205A:  MOVFF  72E,756
0205E:  MOVFF  72D,755
02062:  MOVFF  72C,754
02066:  CALL   0DA4
0206A:  MOVFF  03,73C
0206E:  MOVFF  02,73B
02072:  MOVFF  01,73A
02076:  MOVFF  00,739
0207A:  MOVFF  03,753
0207E:  MOVFF  02,752
02082:  MOVFF  01,751
02086:  MOVFF  00,750
0208A:  MOVFF  72F,757
0208E:  MOVFF  72E,756
02092:  MOVFF  72D,755
02096:  MOVFF  72C,754
0209A:  CALL   0DA4
0209E:  MOVFF  03,73C
020A2:  MOVFF  02,73B
020A6:  MOVFF  01,73A
020AA:  MOVFF  00,739
020AE:  BCF    FD8.1
020B0:  MOVFF  03,74D
020B4:  MOVFF  02,74C
020B8:  MOVFF  01,74B
020BC:  MOVFF  00,74A
020C0:  MOVLW  3F
020C2:  MOVLB  7
020C4:  MOVWF  x51
020C6:  MOVLW  02
020C8:  MOVWF  x50
020CA:  MOVLW  33
020CC:  MOVWF  x4F
020CE:  MOVLW  83
020D0:  MOVWF  x4E
020D2:  MOVLB  0
020D4:  CALL   0E9A
020D8:  MOVFF  03,733
020DC:  MOVFF  02,732
020E0:  MOVFF  01,731
020E4:  MOVFF  00,730
....................    res = res*y*y + pat[3];
020E8:  MOVFF  733,753
020EC:  MOVFF  732,752
020F0:  MOVFF  731,751
020F4:  MOVFF  730,750
020F8:  MOVFF  72F,757
020FC:  MOVFF  72E,756
02100:  MOVFF  72D,755
02104:  MOVFF  72C,754
02108:  CALL   0DA4
0210C:  MOVFF  03,73C
02110:  MOVFF  02,73B
02114:  MOVFF  01,73A
02118:  MOVFF  00,739
0211C:  MOVFF  03,753
02120:  MOVFF  02,752
02124:  MOVFF  01,751
02128:  MOVFF  00,750
0212C:  MOVFF  72F,757
02130:  MOVFF  72E,756
02134:  MOVFF  72D,755
02138:  MOVFF  72C,754
0213C:  CALL   0DA4
02140:  MOVFF  03,73C
02144:  MOVFF  02,73B
02148:  MOVFF  01,73A
0214C:  MOVFF  00,739
02150:  BCF    FD8.1
02152:  MOVFF  03,74D
02156:  MOVFF  02,74C
0215A:  MOVFF  01,74B
0215E:  MOVFF  00,74A
02162:  MOVLW  33
02164:  MOVLB  7
02166:  MOVWF  x51
02168:  MOVLW  8C
0216A:  MOVWF  x50
0216C:  MOVLW  1E
0216E:  MOVWF  x4F
02170:  MOVLW  83
02172:  MOVWF  x4E
02174:  MOVLB  0
02176:  CALL   0E9A
0217A:  MOVFF  03,733
0217E:  MOVFF  02,732
02182:  MOVFF  01,731
02186:  MOVFF  00,730
.................... 
....................    r = qat[0]*y*y + qat[1];
0218A:  MOVLB  7
0218C:  CLRF   x53
0218E:  CLRF   x52
02190:  CLRF   x51
02192:  MOVLW  7F
02194:  MOVWF  x50
02196:  MOVFF  72F,757
0219A:  MOVFF  72E,756
0219E:  MOVFF  72D,755
021A2:  MOVFF  72C,754
021A6:  MOVLB  0
021A8:  CALL   0DA4
021AC:  MOVFF  03,73C
021B0:  MOVFF  02,73B
021B4:  MOVFF  01,73A
021B8:  MOVFF  00,739
021BC:  MOVFF  03,753
021C0:  MOVFF  02,752
021C4:  MOVFF  01,751
021C8:  MOVFF  00,750
021CC:  MOVFF  72F,757
021D0:  MOVFF  72E,756
021D4:  MOVFF  72D,755
021D8:  MOVFF  72C,754
021DC:  CALL   0DA4
021E0:  MOVFF  03,73C
021E4:  MOVFF  02,73B
021E8:  MOVFF  01,73A
021EC:  MOVFF  00,739
021F0:  BCF    FD8.1
021F2:  MOVFF  03,74D
021F6:  MOVFF  02,74C
021FA:  MOVFF  01,74B
021FE:  MOVFF  00,74A
02202:  MOVLW  1B
02204:  MOVLB  7
02206:  MOVWF  x51
02208:  MOVLW  E4
0220A:  MOVWF  x50
0220C:  MOVLW  35
0220E:  MOVWF  x4F
02210:  MOVLW  82
02212:  MOVWF  x4E
02214:  MOVLB  0
02216:  CALL   0E9A
0221A:  MOVFF  03,737
0221E:  MOVFF  02,736
02222:  MOVFF  01,735
02226:  MOVFF  00,734
....................    r = r*y*y + qat[2];
0222A:  MOVFF  737,753
0222E:  MOVFF  736,752
02232:  MOVFF  735,751
02236:  MOVFF  734,750
0223A:  MOVFF  72F,757
0223E:  MOVFF  72E,756
02242:  MOVFF  72D,755
02246:  MOVFF  72C,754
0224A:  CALL   0DA4
0224E:  MOVFF  03,73C
02252:  MOVFF  02,73B
02256:  MOVFF  01,73A
0225A:  MOVFF  00,739
0225E:  MOVFF  03,753
02262:  MOVFF  02,752
02266:  MOVFF  01,751
0226A:  MOVFF  00,750
0226E:  MOVFF  72F,757
02272:  MOVFF  72E,756
02276:  MOVFF  72D,755
0227A:  MOVFF  72C,754
0227E:  CALL   0DA4
02282:  MOVFF  03,73C
02286:  MOVFF  02,73B
0228A:  MOVFF  01,73A
0228E:  MOVFF  00,739
02292:  BCF    FD8.1
02294:  MOVFF  03,74D
02298:  MOVFF  02,74C
0229C:  MOVFF  01,74B
022A0:  MOVFF  00,74A
022A4:  MOVLW  A4
022A6:  MOVLB  7
022A8:  MOVWF  x51
022AA:  MOVLW  DB
022AC:  MOVWF  x50
022AE:  MOVLW  67
022B0:  MOVWF  x4F
022B2:  MOVLW  83
022B4:  MOVWF  x4E
022B6:  MOVLB  0
022B8:  CALL   0E9A
022BC:  MOVFF  03,737
022C0:  MOVFF  02,736
022C4:  MOVFF  01,735
022C8:  MOVFF  00,734
....................    r = r*y*y + qat[3];
022CC:  MOVFF  737,753
022D0:  MOVFF  736,752
022D4:  MOVFF  735,751
022D8:  MOVFF  734,750
022DC:  MOVFF  72F,757
022E0:  MOVFF  72E,756
022E4:  MOVFF  72D,755
022E8:  MOVFF  72C,754
022EC:  CALL   0DA4
022F0:  MOVFF  03,73C
022F4:  MOVFF  02,73B
022F8:  MOVFF  01,73A
022FC:  MOVFF  00,739
02300:  MOVFF  03,753
02304:  MOVFF  02,752
02308:  MOVFF  01,751
0230C:  MOVFF  00,750
02310:  MOVFF  72F,757
02314:  MOVFF  72E,756
02318:  MOVFF  72D,755
0231C:  MOVFF  72C,754
02320:  CALL   0DA4
02324:  MOVFF  03,73C
02328:  MOVFF  02,73B
0232C:  MOVFF  01,73A
02330:  MOVFF  00,739
02334:  BCF    FD8.1
02336:  MOVFF  03,74D
0233A:  MOVFF  02,74C
0233E:  MOVFF  01,74B
02342:  MOVFF  00,74A
02346:  MOVLW  33
02348:  MOVLB  7
0234A:  MOVWF  x51
0234C:  MOVLW  8C
0234E:  MOVWF  x50
02350:  MOVLW  1E
02352:  MOVWF  x4F
02354:  MOVLW  83
02356:  MOVWF  x4E
02358:  MOVLB  0
0235A:  CALL   0E9A
0235E:  MOVFF  03,737
02362:  MOVFF  02,736
02366:  MOVFF  01,735
0236A:  MOVFF  00,734
.................... 
....................    res = y*res/r;
0236E:  MOVFF  72F,753
02372:  MOVFF  72E,752
02376:  MOVFF  72D,751
0237A:  MOVFF  72C,750
0237E:  MOVFF  733,757
02382:  MOVFF  732,756
02386:  MOVFF  731,755
0238A:  MOVFF  730,754
0238E:  CALL   0DA4
02392:  MOVFF  03,73C
02396:  MOVFF  02,73B
0239A:  MOVFF  01,73A
0239E:  MOVFF  00,739
023A2:  MOVFF  03,742
023A6:  MOVFF  02,741
023AA:  MOVFF  01,740
023AE:  MOVFF  00,73F
023B2:  MOVFF  737,746
023B6:  MOVFF  736,745
023BA:  MOVFF  735,744
023BE:  MOVFF  734,743
023C2:  RCALL  1DAA
023C4:  MOVFF  03,733
023C8:  MOVFF  02,732
023CC:  MOVFF  01,731
023D0:  MOVFF  00,730
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
023D4:  MOVLB  7
023D6:  BTFSS  x38.1
023D8:  BRA    2414
....................       res = PI_DIV_BY_TWO - res;
023DA:  BSF    FD8.1
023DC:  MOVLW  DB
023DE:  MOVWF  x4D
023E0:  MOVLW  0F
023E2:  MOVWF  x4C
023E4:  MOVLW  49
023E6:  MOVWF  x4B
023E8:  MOVLW  7F
023EA:  MOVWF  x4A
023EC:  MOVFF  733,751
023F0:  MOVFF  732,750
023F4:  MOVFF  731,74F
023F8:  MOVFF  730,74E
023FC:  MOVLB  0
023FE:  CALL   0E9A
02402:  MOVFF  03,733
02406:  MOVFF  02,732
0240A:  MOVFF  01,731
0240E:  MOVFF  00,730
02412:  MOVLB  7
....................    if (s)
02414:  BTFSS  x38.0
02416:  BRA    241E
....................       res = -res;
02418:  MOVF   x31,W
0241A:  XORLW  80
0241C:  MOVWF  x31
.................... 
....................    return(res);
0241E:  MOVFF  730,00
02422:  MOVFF  731,01
02426:  MOVFF  732,02
0242A:  MOVFF  733,03
0242E:  MOVLB  0
02430:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
02432:  MOVLB  7
02434:  BCF    x26.0
....................    quad=0; //quadrant
02436:  CLRF   x27
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
02438:  MOVFF  71D,749
0243C:  MOVFF  71C,748
02440:  MOVFF  71B,747
02444:  MOVFF  71A,746
02448:  CLRF   x4D
0244A:  CLRF   x4C
0244C:  CLRF   x4B
0244E:  CLRF   x4A
02450:  MOVLB  0
02452:  RCALL  1D30
02454:  BC    2458
02456:  BNZ   2482
02458:  MOVFF  721,749
0245C:  MOVFF  720,748
02460:  MOVFF  71F,747
02464:  MOVFF  71E,746
02468:  MOVLB  7
0246A:  CLRF   x4D
0246C:  CLRF   x4C
0246E:  CLRF   x4B
02470:  CLRF   x4A
02472:  MOVLB  0
02474:  RCALL  1D30
02476:  BC    247A
02478:  BNZ   247E
0247A:  MOVLW  03
0247C:  BRA    2480
0247E:  MOVLW  04
02480:  BRA    24A8
02482:  MOVFF  721,749
02486:  MOVFF  720,748
0248A:  MOVFF  71F,747
0248E:  MOVFF  71E,746
02492:  MOVLB  7
02494:  CLRF   x4D
02496:  CLRF   x4C
02498:  CLRF   x4B
0249A:  CLRF   x4A
0249C:  MOVLB  0
0249E:  RCALL  1D30
024A0:  BNC   24A6
024A2:  MOVLW  02
024A4:  BRA    24A8
024A6:  MOVLW  01
024A8:  MOVLB  7
024AA:  MOVWF  x27
....................    if(y<0.0)
024AC:  MOVFF  71D,749
024B0:  MOVFF  71C,748
024B4:  MOVFF  71B,747
024B8:  MOVFF  71A,746
024BC:  CLRF   x4D
024BE:  CLRF   x4C
024C0:  CLRF   x4B
024C2:  CLRF   x4A
024C4:  MOVLB  0
024C6:  RCALL  1D30
024C8:  BNC   24D6
....................    {
....................       sign=1;
024CA:  MOVLB  7
024CC:  BSF    x26.0
....................       y=-y;
024CE:  MOVF   x1B,W
024D0:  XORLW  80
024D2:  MOVWF  x1B
024D4:  MOVLB  0
....................    }
....................    if(x<0.0)
024D6:  MOVFF  721,749
024DA:  MOVFF  720,748
024DE:  MOVFF  71F,747
024E2:  MOVFF  71E,746
024E6:  MOVLB  7
024E8:  CLRF   x4D
024EA:  CLRF   x4C
024EC:  CLRF   x4B
024EE:  CLRF   x4A
024F0:  MOVLB  0
024F2:  RCALL  1D30
024F4:  BNC   2500
....................    {
....................       x=-x;
024F6:  MOVLB  7
024F8:  MOVF   x1F,W
024FA:  XORLW  80
024FC:  MOVWF  x1F
024FE:  MOVLB  0
....................    }
....................    if (x==0.0)
02500:  MOVFF  721,749
02504:  MOVFF  720,748
02508:  MOVFF  71F,747
0250C:  MOVFF  71E,746
02510:  MOVLB  7
02512:  CLRF   x4D
02514:  CLRF   x4C
02516:  CLRF   x4B
02518:  CLRF   x4A
0251A:  MOVLB  0
0251C:  RCALL  1D30
0251E:  BNZ   2574
....................    {
....................       if(y==0.0)
02520:  MOVFF  71D,749
02524:  MOVFF  71C,748
02528:  MOVFF  71B,747
0252C:  MOVFF  71A,746
02530:  MOVLB  7
02532:  CLRF   x4D
02534:  CLRF   x4C
02536:  CLRF   x4B
02538:  CLRF   x4A
0253A:  MOVLB  0
0253C:  CALL   1D30
02540:  BNZ   2544
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
02542:  BRA    2572
....................       else
....................       {
....................          if(sign)
02544:  MOVLB  7
02546:  BTFSS  x26.0
02548:  BRA    255E
....................          {
....................          return (-(PI_DIV_BY_TWO));
0254A:  MOVLW  7F
0254C:  MOVWF  00
0254E:  MOVLW  C9
02550:  MOVWF  01
02552:  MOVLW  0F
02554:  MOVWF  02
02556:  MOVLW  DB
02558:  MOVWF  03
0255A:  BRA    26AC
....................          }
0255C:  BRA    2570
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
0255E:  MOVLW  7F
02560:  MOVWF  00
02562:  MOVLW  49
02564:  MOVWF  01
02566:  MOVLW  0F
02568:  MOVWF  02
0256A:  MOVLW  DB
0256C:  MOVWF  03
0256E:  BRA    26AC
02570:  MOVLB  0
....................          }
....................       }
....................    }
02572:  BRA    26AA
....................    else
....................    {
....................       z=y/x;
02574:  MOVFF  71D,742
02578:  MOVFF  71C,741
0257C:  MOVFF  71B,740
02580:  MOVFF  71A,73F
02584:  MOVFF  721,746
02588:  MOVFF  720,745
0258C:  MOVFF  71F,744
02590:  MOVFF  71E,743
02594:  RCALL  1DAA
02596:  MOVFF  03,725
0259A:  MOVFF  02,724
0259E:  MOVFF  01,723
025A2:  MOVFF  00,722
....................       switch(quad)
025A6:  MOVLW  01
025A8:  MOVLB  7
025AA:  SUBWF  x27,W
025AC:  ADDLW  FC
025AE:  BTFSC  FD8.0
025B0:  BRA    26AC
025B2:  ADDLW  04
025B4:  MOVLB  0
025B6:  GOTO   26B2
....................       {
....................          case 1:
....................          {
....................             return atan(z);
025BA:  MOVFF  725,72B
025BE:  MOVFF  724,72A
025C2:  MOVFF  723,729
025C6:  MOVFF  722,728
025CA:  RCALL  1F08
025CC:  MOVLB  7
025CE:  BRA    26AC
....................             break;
025D0:  BRA    26AC
025D2:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
025D4:  MOVFF  725,72B
025D8:  MOVFF  724,72A
025DC:  MOVFF  723,729
025E0:  MOVFF  722,728
025E4:  RCALL  1F08
025E6:  MOVFF  FEA,729
025EA:  MOVFF  FE9,728
025EE:  BSF    FD8.1
025F0:  MOVLW  DB
025F2:  MOVLB  7
025F4:  MOVWF  x4D
025F6:  MOVLW  0F
025F8:  MOVWF  x4C
025FA:  MOVLW  49
025FC:  MOVWF  x4B
025FE:  MOVLW  80
02600:  MOVWF  x4A
02602:  MOVFF  03,751
02606:  MOVFF  02,750
0260A:  MOVFF  01,74F
0260E:  MOVFF  00,74E
02612:  MOVLB  0
02614:  CALL   0E9A
02618:  MOVFF  729,FEA
0261C:  MOVFF  728,FE9
02620:  MOVLB  7
02622:  BRA    26AC
....................             break;
02624:  BRA    26AC
02626:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
02628:  MOVFF  725,72B
0262C:  MOVFF  724,72A
02630:  MOVFF  723,729
02634:  MOVFF  722,728
02638:  RCALL  1F08
0263A:  MOVFF  03,72B
0263E:  MOVFF  02,72A
02642:  MOVFF  01,729
02646:  MOVFF  00,728
0264A:  MOVFF  FEA,72D
0264E:  MOVFF  FE9,72C
02652:  BSF    FD8.1
02654:  MOVFF  03,74D
02658:  MOVFF  02,74C
0265C:  MOVFF  01,74B
02660:  MOVFF  00,74A
02664:  MOVLW  DB
02666:  MOVLB  7
02668:  MOVWF  x51
0266A:  MOVLW  0F
0266C:  MOVWF  x50
0266E:  MOVLW  49
02670:  MOVWF  x4F
02672:  MOVLW  80
02674:  MOVWF  x4E
02676:  MOVLB  0
02678:  CALL   0E9A
0267C:  MOVFF  72D,FEA
02680:  MOVFF  72C,FE9
02684:  MOVLB  7
02686:  BRA    26AC
....................             break;
02688:  BRA    26AC
0268A:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
0268C:  MOVFF  725,72B
02690:  MOVFF  724,72A
02694:  MOVFF  723,729
02698:  MOVFF  722,728
0269C:  RCALL  1F08
0269E:  MOVLW  80
026A0:  XORWF  01,F
026A2:  MOVLB  7
026A4:  BRA    26AC
....................             break;
026A6:  BRA    26AC
026A8:  MOVLB  0
026AA:  MOVLB  7
....................          }
....................       }
....................    }
026AC:  MOVLB  0
026AE:  GOTO   3DB8 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 100ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... #define BUFFER_SIZE 5
.................... 
.................... signed int32 sQ_x[BUFFER_SIZE];
.................... signed int32 cQ_x[BUFFER_SIZE];
.................... signed int32 sQ_y[BUFFER_SIZE];
.................... signed int32 cQ_y[BUFFER_SIZE];
.................... int sIn_x=0;
.................... int cIn_x=0;
.................... int sIn_y=0;
.................... int cIn_y=0;
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    signed int32 avgSin;
....................    signed int32 avgCos;
.................... } smData[2] = 
.................... {
....................    {false, false, 0, 0},
....................    {false, false, 0, 0}
.................... };
.................... 
.................... void push(signed int32* buff, int* idx, signed int32 newData) {
....................    buff[*idx]=newData;
*
00908:  MOVFF  730,FEA
0090C:  MOVLB  7
0090E:  MOVFF  72F,FE9
00912:  CLRF   x42
00914:  MOVFF  FEF,741
00918:  CLRF   x44
0091A:  MOVLW  04
0091C:  MOVWF  x43
0091E:  MOVLB  0
00920:  RCALL  08BA
00922:  MOVF   01,W
00924:  MOVLB  7
00926:  ADDWF  x2D,W
00928:  MOVWF  FE9
0092A:  MOVF   x2E,W
0092C:  ADDWFC 02,W
0092E:  MOVWF  FEA
00930:  MOVFF  731,FEF
00934:  MOVFF  732,FEC
00938:  MOVFF  733,FEC
0093C:  MOVFF  734,FEC
....................    *idx=(*idx+1) % BUFFER_SIZE;
00940:  MOVFF  730,736
00944:  MOVFF  730,FEA
00948:  MOVFF  72F,FE9
0094C:  MOVLW  01
0094E:  ADDWF  FEF,W
00950:  MOVWF  x38
00952:  MOVWF  x3A
00954:  MOVLW  05
00956:  MOVWF  x3B
00958:  MOVLB  0
0095A:  RCALL  08DC
0095C:  MOVLB  7
0095E:  MOVFF  736,FEA
00962:  MOVFF  72F,FE9
00966:  MOVFF  00,FEF
0096A:  MOVLB  0
0096C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task(){
....................    static int8 state = 0;
....................    if (adc_done()){
*
01112:  MOVLB  F
01114:  BTFSC  x5B.0
01116:  BRA    1662
....................       switch (state)
01118:  MOVLB  1
0111A:  MOVF   xE6,W
0111C:  ADDLW  F9
0111E:  BTFSC  FD8.0
01120:  BRA    1660
01122:  ADDLW  07
01124:  MOVLB  0
01126:  GOTO   1668
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
0112A:  MOVLB  F
0112C:  BTFSC  x5B.0
0112E:  BRA    112C
01130:  MOVFF  F5F,02
01134:  MOVFF  F5E,01
01138:  MOVFF  02,6FC
0113C:  MOVFF  01,6FB
01140:  MOVFF  02,74B
01144:  MOVFF  01,74A
01148:  MOVLB  0
0114A:  RCALL  0D6E
0114C:  MOVFF  03,753
01150:  MOVFF  02,752
01154:  MOVFF  01,751
01158:  MOVFF  00,750
0115C:  MOVFF  C9,757
01160:  MOVFF  C8,756
01164:  MOVFF  C7,755
01168:  MOVFF  C6,754
0116C:  RCALL  0DA4
0116E:  MOVFF  03,6FE
01172:  MOVFF  02,6FD
01176:  MOVFF  01,6FC
0117A:  MOVFF  00,6FB
0117E:  BCF    FD8.1
01180:  MOVFF  03,74D
01184:  MOVFF  02,74C
01188:  MOVFF  01,74B
0118C:  MOVFF  00,74A
01190:  MOVFF  C5,751
01194:  MOVFF  C4,750
01198:  MOVFF  C3,74F
0119C:  MOVFF  C2,74E
011A0:  RCALL  0E9A
011A2:  MOVFF  03,FE
011A6:  MOVFF  02,FD
011AA:  MOVFF  01,FC
011AE:  MOVFF  00,FB
....................             set_adc_channel(vMon200);
011B2:  MOVLB  F
011B4:  MOVF   x5A,W
011B6:  ANDLW  3F
011B8:  MOVWF  01
011BA:  MOVLW  10
011BC:  MOVWF  x5A
011BE:  BTFSS  x5B.7
011C0:  BRA    11D0
011C2:  MOVF   01,W
011C4:  SUBLW  10
011C6:  BZ    11D0
011C8:  BSF    x5B.0
011CA:  NOP   
011CC:  BTFSC  x5B.0
011CE:  BRA    11CC
....................             delay_ms(10);
011D0:  MOVLW  0A
011D2:  MOVLB  7
011D4:  MOVWF  x01
011D6:  MOVLB  0
011D8:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
011DC:  MOVLB  F
011DE:  BSF    x5B.0
011E0:  NOP   
....................             state = 1;
011E2:  MOVLW  01
011E4:  MOVLB  1
011E6:  MOVWF  xE6
....................          break;
011E8:  BRA    1660
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
011EA:  MOVLB  F
011EC:  BTFSC  x5B.0
011EE:  BRA    11EC
011F0:  MOVFF  F5F,02
011F4:  MOVFF  F5E,01
011F8:  MOVFF  02,6FC
011FC:  MOVFF  01,6FB
01200:  MOVFF  02,74B
01204:  MOVFF  01,74A
01208:  MOVLB  0
0120A:  RCALL  0D6E
0120C:  MOVFF  03,753
01210:  MOVFF  02,752
01214:  MOVFF  01,751
01218:  MOVFF  00,750
0121C:  MOVFF  D1,757
01220:  MOVFF  D0,756
01224:  MOVFF  CF,755
01228:  MOVFF  CE,754
0122C:  RCALL  0DA4
0122E:  MOVFF  03,6FE
01232:  MOVFF  02,6FD
01236:  MOVFF  01,6FC
0123A:  MOVFF  00,6FB
0123E:  BCF    FD8.1
01240:  MOVFF  03,74D
01244:  MOVFF  02,74C
01248:  MOVFF  01,74B
0124C:  MOVFF  00,74A
01250:  MOVFF  CD,751
01254:  MOVFF  CC,750
01258:  MOVFF  CB,74F
0125C:  MOVFF  CA,74E
01260:  RCALL  0E9A
01262:  MOVFF  03,102
01266:  MOVFF  02,101
0126A:  MOVFF  01,100
0126E:  MOVFF  00,FF
....................             set_adc_channel(vMon5V6);
01272:  MOVLB  F
01274:  MOVF   x5A,W
01276:  ANDLW  3F
01278:  MOVWF  01
0127A:  MOVLW  18
0127C:  MOVWF  x5A
0127E:  BTFSS  x5B.7
01280:  BRA    1290
01282:  MOVF   01,W
01284:  SUBLW  18
01286:  BZ    1290
01288:  BSF    x5B.0
0128A:  NOP   
0128C:  BTFSC  x5B.0
0128E:  BRA    128C
....................             delay_ms(10);
01290:  MOVLW  0A
01292:  MOVLB  7
01294:  MOVWF  x01
01296:  MOVLB  0
01298:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
0129C:  MOVLB  F
0129E:  BSF    x5B.0
012A0:  NOP   
....................             state = 2;
012A2:  MOVLW  02
012A4:  MOVLB  1
012A6:  MOVWF  xE6
....................          break;
012A8:  BRA    1660
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
012AA:  MOVLB  F
012AC:  BTFSC  x5B.0
012AE:  BRA    12AC
012B0:  MOVFF  F5F,02
012B4:  MOVFF  F5E,01
012B8:  MOVFF  02,6FC
012BC:  MOVFF  01,6FB
012C0:  MOVFF  02,74B
012C4:  MOVFF  01,74A
012C8:  MOVLB  0
012CA:  RCALL  0D6E
012CC:  MOVFF  03,753
012D0:  MOVFF  02,752
012D4:  MOVFF  01,751
012D8:  MOVFF  00,750
012DC:  MOVFF  D9,757
012E0:  MOVFF  D8,756
012E4:  MOVFF  D7,755
012E8:  MOVFF  D6,754
012EC:  RCALL  0DA4
012EE:  MOVFF  03,6FE
012F2:  MOVFF  02,6FD
012F6:  MOVFF  01,6FC
012FA:  MOVFF  00,6FB
012FE:  BCF    FD8.1
01300:  MOVFF  03,74D
01304:  MOVFF  02,74C
01308:  MOVFF  01,74B
0130C:  MOVFF  00,74A
01310:  MOVFF  D5,751
01314:  MOVFF  D4,750
01318:  MOVFF  D3,74F
0131C:  MOVFF  D2,74E
01320:  RCALL  0E9A
01322:  MOVFF  03,106
01326:  MOVFF  02,105
0132A:  MOVFF  01,104
0132E:  MOVFF  00,103
....................             set_adc_channel(vMon5VA);
01332:  MOVLB  F
01334:  MOVF   x5A,W
01336:  ANDLW  3F
01338:  MOVWF  01
0133A:  MOVLW  19
0133C:  MOVWF  x5A
0133E:  BTFSS  x5B.7
01340:  BRA    1350
01342:  MOVF   01,W
01344:  SUBLW  19
01346:  BZ    1350
01348:  BSF    x5B.0
0134A:  NOP   
0134C:  BTFSC  x5B.0
0134E:  BRA    134C
....................             delay_ms(10);
01350:  MOVLW  0A
01352:  MOVLB  7
01354:  MOVWF  x01
01356:  MOVLB  0
01358:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
0135C:  MOVLB  F
0135E:  BSF    x5B.0
01360:  NOP   
....................             state = 3;
01362:  MOVLW  03
01364:  MOVLB  1
01366:  MOVWF  xE6
....................          break;
01368:  BRA    1660
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
0136A:  MOVLB  F
0136C:  BTFSC  x5B.0
0136E:  BRA    136C
01370:  MOVFF  F5F,02
01374:  MOVFF  F5E,01
01378:  MOVFF  02,6FC
0137C:  MOVFF  01,6FB
01380:  MOVFF  02,74B
01384:  MOVFF  01,74A
01388:  MOVLB  0
0138A:  RCALL  0D6E
0138C:  MOVFF  03,753
01390:  MOVFF  02,752
01394:  MOVFF  01,751
01398:  MOVFF  00,750
0139C:  MOVFF  E1,757
013A0:  MOVFF  E0,756
013A4:  MOVFF  DF,755
013A8:  MOVFF  DE,754
013AC:  RCALL  0DA4
013AE:  MOVFF  03,6FE
013B2:  MOVFF  02,6FD
013B6:  MOVFF  01,6FC
013BA:  MOVFF  00,6FB
013BE:  BCF    FD8.1
013C0:  MOVFF  03,74D
013C4:  MOVFF  02,74C
013C8:  MOVFF  01,74B
013CC:  MOVFF  00,74A
013D0:  MOVFF  DD,751
013D4:  MOVFF  DC,750
013D8:  MOVFF  DB,74F
013DC:  MOVFF  DA,74E
013E0:  RCALL  0E9A
013E2:  MOVFF  03,10A
013E6:  MOVFF  02,109
013EA:  MOVFF  01,108
013EE:  MOVFF  00,107
....................             set_adc_channel(vMon3V6X);
013F2:  MOVLB  F
013F4:  MOVF   x5A,W
013F6:  ANDLW  3F
013F8:  MOVWF  01
013FA:  MOVLW  11
013FC:  MOVWF  x5A
013FE:  BTFSS  x5B.7
01400:  BRA    1410
01402:  MOVF   01,W
01404:  SUBLW  11
01406:  BZ    1410
01408:  BSF    x5B.0
0140A:  NOP   
0140C:  BTFSC  x5B.0
0140E:  BRA    140C
....................             delay_ms(10);
01410:  MOVLW  0A
01412:  MOVLB  7
01414:  MOVWF  x01
01416:  MOVLB  0
01418:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
0141C:  MOVLB  F
0141E:  BSF    x5B.0
01420:  NOP   
....................             state = 4;
01422:  MOVLW  04
01424:  MOVLB  1
01426:  MOVWF  xE6
....................          break;
01428:  BRA    1660
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
0142A:  MOVLB  F
0142C:  BTFSC  x5B.0
0142E:  BRA    142C
01430:  MOVFF  F5F,02
01434:  MOVFF  F5E,01
01438:  MOVFF  02,6FC
0143C:  MOVFF  01,6FB
01440:  MOVFF  02,74B
01444:  MOVFF  01,74A
01448:  MOVLB  0
0144A:  RCALL  0D6E
0144C:  MOVFF  03,753
01450:  MOVFF  02,752
01454:  MOVFF  01,751
01458:  MOVFF  00,750
0145C:  MOVFF  E9,757
01460:  MOVFF  E8,756
01464:  MOVFF  E7,755
01468:  MOVFF  E6,754
0146C:  RCALL  0DA4
0146E:  MOVFF  03,6FE
01472:  MOVFF  02,6FD
01476:  MOVFF  01,6FC
0147A:  MOVFF  00,6FB
0147E:  BCF    FD8.1
01480:  MOVFF  03,74D
01484:  MOVFF  02,74C
01488:  MOVFF  01,74B
0148C:  MOVFF  00,74A
01490:  MOVFF  E5,751
01494:  MOVFF  E4,750
01498:  MOVFF  E3,74F
0149C:  MOVFF  E2,74E
014A0:  RCALL  0E9A
014A2:  MOVFF  03,10E
014A6:  MOVFF  02,10D
014AA:  MOVFF  01,10C
014AE:  MOVFF  00,10B
....................             set_adc_channel(vMon3V3A);
014B2:  MOVLB  F
014B4:  MOVF   x5A,W
014B6:  ANDLW  3F
014B8:  MOVWF  01
014BA:  MOVLW  1B
014BC:  MOVWF  x5A
014BE:  BTFSS  x5B.7
014C0:  BRA    14D0
014C2:  MOVF   01,W
014C4:  SUBLW  1B
014C6:  BZ    14D0
014C8:  BSF    x5B.0
014CA:  NOP   
014CC:  BTFSC  x5B.0
014CE:  BRA    14CC
....................             delay_ms(10);
014D0:  MOVLW  0A
014D2:  MOVLB  7
014D4:  MOVWF  x01
014D6:  MOVLB  0
014D8:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
014DC:  MOVLB  F
014DE:  BSF    x5B.0
014E0:  NOP   
....................             state = 5;
014E2:  MOVLW  05
014E4:  MOVLB  1
014E6:  MOVWF  xE6
....................          break;
014E8:  BRA    1660
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
014EA:  MOVLB  F
014EC:  BTFSC  x5B.0
014EE:  BRA    14EC
014F0:  MOVFF  F5F,02
014F4:  MOVFF  F5E,01
014F8:  MOVFF  02,6FC
014FC:  MOVFF  01,6FB
01500:  MOVFF  02,74B
01504:  MOVFF  01,74A
01508:  MOVLB  0
0150A:  RCALL  0D6E
0150C:  MOVFF  03,753
01510:  MOVFF  02,752
01514:  MOVFF  01,751
01518:  MOVFF  00,750
0151C:  MOVFF  F1,757
01520:  MOVFF  F0,756
01524:  MOVFF  EF,755
01528:  MOVFF  EE,754
0152C:  RCALL  0DA4
0152E:  MOVFF  03,6FE
01532:  MOVFF  02,6FD
01536:  MOVFF  01,6FC
0153A:  MOVFF  00,6FB
0153E:  BCF    FD8.1
01540:  MOVFF  03,74D
01544:  MOVFF  02,74C
01548:  MOVFF  01,74B
0154C:  MOVFF  00,74A
01550:  MOVFF  ED,751
01554:  MOVFF  EC,750
01558:  MOVFF  EB,74F
0155C:  MOVFF  EA,74E
01560:  RCALL  0E9A
01562:  MOVFF  03,112
01566:  MOVFF  02,111
0156A:  MOVFF  01,110
0156E:  MOVFF  00,10F
....................             set_adc_channel(vMon3V3D);
01572:  MOVLB  F
01574:  MOVF   x5A,W
01576:  ANDLW  3F
01578:  MOVWF  01
0157A:  MOVLW  1A
0157C:  MOVWF  x5A
0157E:  BTFSS  x5B.7
01580:  BRA    1590
01582:  MOVF   01,W
01584:  SUBLW  1A
01586:  BZ    1590
01588:  BSF    x5B.0
0158A:  NOP   
0158C:  BTFSC  x5B.0
0158E:  BRA    158C
....................             delay_ms(10);
01590:  MOVLW  0A
01592:  MOVLB  7
01594:  MOVWF  x01
01596:  MOVLB  0
01598:  CALL   03CC
....................             read_adc(ADC_START_ONLY);
0159C:  MOVLB  F
0159E:  BSF    x5B.0
015A0:  NOP   
....................             state = 6;
015A2:  MOVLW  06
015A4:  MOVLB  1
015A6:  MOVWF  xE6
....................          break;
015A8:  BRA    1660
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
015AA:  MOVLB  F
015AC:  BTFSC  x5B.0
015AE:  BRA    15AC
015B0:  MOVFF  F5F,02
015B4:  MOVFF  F5E,01
015B8:  MOVFF  02,6FC
015BC:  MOVFF  01,6FB
015C0:  MOVFF  02,74B
015C4:  MOVFF  01,74A
015C8:  MOVLB  0
015CA:  CALL   0D6E
015CE:  MOVFF  03,753
015D2:  MOVFF  02,752
015D6:  MOVFF  01,751
015DA:  MOVFF  00,750
015DE:  MOVFF  F9,757
015E2:  MOVFF  F8,756
015E6:  MOVFF  F7,755
015EA:  MOVFF  F6,754
015EE:  CALL   0DA4
015F2:  MOVFF  03,6FE
015F6:  MOVFF  02,6FD
015FA:  MOVFF  01,6FC
015FE:  MOVFF  00,6FB
01602:  BCF    FD8.1
01604:  MOVFF  03,74D
01608:  MOVFF  02,74C
0160C:  MOVFF  01,74B
01610:  MOVFF  00,74A
01614:  MOVFF  F5,751
01618:  MOVFF  F4,750
0161C:  MOVFF  F3,74F
01620:  MOVFF  F2,74E
01624:  RCALL  0E9A
01626:  MOVFF  03,116
0162A:  MOVFF  02,115
0162E:  MOVFF  01,114
01632:  MOVFF  00,113
....................             set_adc_channel(vMonN15);
01636:  MOVLB  F
01638:  MOVF   x5A,W
0163A:  ANDLW  3F
0163C:  MOVWF  01
0163E:  MOVLW  06
01640:  MOVWF  x5A
01642:  BTFSS  x5B.7
01644:  BRA    1654
01646:  MOVF   01,W
01648:  SUBLW  06
0164A:  BZ    1654
0164C:  BSF    x5B.0
0164E:  NOP   
01650:  BTFSC  x5B.0
01652:  BRA    1650
....................             read_adc(ADC_START_ONLY);
01654:  BSF    x5B.0
01656:  NOP   
....................             state = 0;
01658:  MOVLB  1
0165A:  CLRF   xE6
....................          break;   
0165C:  BRA    1660
0165E:  MOVLB  1
01660:  MOVLB  F
....................       }
....................    }
01662:  MOVLB  0
01664:  GOTO   A6EA (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch){
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
03710:  MOVLB  7
03712:  MOVF   x03,W
03714:  MULLW  26
03716:  MOVF   FF3,W
03718:  CLRF   x0D
0371A:  MOVWF  x0C
0371C:  MOVLW  10
0371E:  ADDWF  x0C,W
03720:  MOVWF  01
03722:  MOVLW  00
03724:  ADDWFC x0D,W
03726:  MOVWF  03
03728:  MOVF   01,W
0372A:  ADDLW  17
0372C:  MOVWF  01
0372E:  MOVLW  01
03730:  ADDWFC 03,F
03732:  MOVFF  01,70C
03736:  MOVFF  03,70D
0373A:  MOVF   x03,W
0373C:  MULLW  26
0373E:  MOVF   FF3,W
03740:  CLRF   x0F
03742:  MOVWF  x0E
03744:  MOVLW  08
03746:  ADDWF  x0E,W
03748:  MOVWF  01
0374A:  MOVLW  00
0374C:  ADDWFC x0F,W
0374E:  MOVWF  03
03750:  MOVF   01,W
03752:  ADDLW  17
03754:  MOVWF  FE9
03756:  MOVLW  01
03758:  ADDWFC 03,W
0375A:  MOVWF  FEA
0375C:  MOVFF  FEF,00
03760:  MOVFF  FEC,01
03764:  MOVFF  FEC,02
03768:  MOVFF  FEC,03
0376C:  MOVFF  70D,FEA
03770:  MOVFF  70C,FE9
03774:  MOVFF  00,FEF
03778:  MOVFF  01,FEC
0377C:  MOVFF  02,FEC
03780:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
03784:  MOVF   x03,W
03786:  MULLW  26
03788:  MOVF   FF3,W
0378A:  CLRF   x0D
0378C:  MOVWF  x0C
0378E:  MOVLW  14
03790:  ADDWF  x0C,W
03792:  MOVWF  01
03794:  MOVLW  00
03796:  ADDWFC x0D,W
03798:  MOVWF  03
0379A:  MOVF   01,W
0379C:  ADDLW  17
0379E:  MOVWF  01
037A0:  MOVLW  01
037A2:  ADDWFC 03,F
037A4:  MOVFF  01,70C
037A8:  MOVFF  03,70D
037AC:  MOVF   x03,W
037AE:  MULLW  26
037B0:  MOVF   FF3,W
037B2:  CLRF   x0F
037B4:  MOVWF  x0E
037B6:  MOVLW  0C
037B8:  ADDWF  x0E,W
037BA:  MOVWF  01
037BC:  MOVLW  00
037BE:  ADDWFC x0F,W
037C0:  MOVWF  03
037C2:  MOVF   01,W
037C4:  ADDLW  17
037C6:  MOVWF  FE9
037C8:  MOVLW  01
037CA:  ADDWFC 03,W
037CC:  MOVWF  FEA
037CE:  MOVFF  FEF,00
037D2:  MOVFF  FEC,01
037D6:  MOVFF  FEC,02
037DA:  MOVFF  FEC,03
037DE:  MOVFF  70D,FEA
037E2:  MOVFF  70C,FE9
037E6:  MOVFF  00,FEF
037EA:  MOVFF  01,FEC
037EE:  MOVFF  02,FEC
037F2:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)smData[ch].avgSin;
037F6:  MOVF   x03,W
037F8:  MULLW  26
037FA:  MOVF   FF3,W
037FC:  CLRF   x0D
037FE:  MOVWF  x0C
03800:  MOVLW  17
03802:  ADDWF  x0C,W
03804:  MOVWF  01
03806:  MOVLW  01
03808:  ADDWFC x0D,W
0380A:  MOVWF  03
0380C:  MOVFF  01,70E
03810:  MOVWF  x0F
03812:  MOVF   x03,W
03814:  MULLW  09
03816:  MOVF   FF3,W
03818:  CLRF   x11
0381A:  MOVWF  x10
0381C:  MOVLW  01
0381E:  ADDWF  x10,W
03820:  MOVWF  01
03822:  MOVLW  00
03824:  ADDWFC x11,W
03826:  MOVWF  03
03828:  MOVF   01,W
0382A:  ADDLW  D4
0382C:  MOVWF  FE9
0382E:  MOVLW  01
03830:  ADDWFC 03,W
03832:  MOVWF  FEA
03834:  MOVFF  FEF,710
03838:  MOVFF  FEC,01
0383C:  MOVFF  FEC,02
03840:  MOVFF  FEC,03
03844:  MOVFF  03,713
03848:  MOVFF  02,712
0384C:  MOVFF  01,711
03850:  MOVLB  0
03852:  CALL   1CD6
03856:  MOVFF  70F,FEA
0385A:  MOVFF  70E,FE9
0385E:  MOVFF  00,FEF
03862:  MOVFF  01,FEC
03866:  MOVFF  02,FEC
0386A:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)smData[ch].avgCos;
0386E:  MOVLB  7
03870:  MOVF   x03,W
03872:  MULLW  26
03874:  MOVF   FF3,W
03876:  CLRF   x0D
03878:  MOVWF  x0C
0387A:  MOVLW  04
0387C:  ADDWF  x0C,W
0387E:  MOVWF  01
03880:  MOVLW  00
03882:  ADDWFC x0D,W
03884:  MOVWF  03
03886:  MOVF   01,W
03888:  ADDLW  17
0388A:  MOVWF  01
0388C:  MOVLW  01
0388E:  ADDWFC 03,F
03890:  MOVFF  01,70C
03894:  MOVFF  03,70D
03898:  MOVF   x03,W
0389A:  MULLW  09
0389C:  MOVF   FF3,W
0389E:  CLRF   x0F
038A0:  MOVWF  x0E
038A2:  MOVLW  05
038A4:  ADDWF  x0E,W
038A6:  MOVWF  01
038A8:  MOVLW  00
038AA:  ADDWFC x0F,W
038AC:  MOVWF  03
038AE:  MOVF   01,W
038B0:  ADDLW  D4
038B2:  MOVWF  FE9
038B4:  MOVLW  01
038B6:  ADDWFC 03,W
038B8:  MOVWF  FEA
038BA:  MOVFF  FEF,710
038BE:  MOVFF  FEC,01
038C2:  MOVFF  FEC,02
038C6:  MOVFF  FEC,03
038CA:  MOVFF  03,713
038CE:  MOVFF  02,712
038D2:  MOVFF  01,711
038D6:  MOVLB  0
038D8:  CALL   1CD6
038DC:  MOVFF  70D,FEA
038E0:  MOVFF  70C,FE9
038E4:  MOVFF  00,FEF
038E8:  MOVFF  01,FEC
038EC:  MOVFF  02,FEC
038F0:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
038F4:  MOVLB  7
038F6:  MOVF   x03,W
038F8:  MULLW  26
038FA:  MOVF   FF3,W
038FC:  CLRF   x0D
038FE:  MOVWF  x0C
03900:  MOVLW  08
03902:  ADDWF  x0C,W
03904:  MOVWF  01
03906:  MOVLW  00
03908:  ADDWFC x0D,W
0390A:  MOVWF  03
0390C:  MOVF   01,W
0390E:  ADDLW  17
03910:  MOVWF  01
03912:  MOVLW  01
03914:  ADDWFC 03,F
03916:  MOVFF  01,70C
0391A:  MOVFF  03,70D
0391E:  MOVF   x03,W
03920:  MULLW  26
03922:  MOVF   FF3,W
03924:  CLRF   x0F
03926:  MOVWF  x0E
03928:  MOVLW  17
0392A:  ADDWF  x0E,W
0392C:  MOVWF  FE9
0392E:  MOVLW  01
03930:  ADDWFC x0F,W
03932:  MOVWF  FEA
03934:  MOVFF  FEF,750
03938:  MOVFF  FEC,751
0393C:  MOVFF  FEC,752
03940:  MOVFF  FEC,753
03944:  MOVF   x03,W
03946:  MULLW  10
03948:  MOVF   FF3,W
0394A:  CLRF   x15
0394C:  MOVWF  x14
0394E:  MOVLW  08
03950:  ADDWF  x14,W
03952:  MOVWF  01
03954:  MOVLW  00
03956:  ADDWFC x15,W
03958:  MOVWF  03
0395A:  MOVF   01,W
0395C:  ADDLW  72
0395E:  MOVWF  FE9
03960:  MOVLW  00
03962:  ADDWFC 03,W
03964:  MOVWF  FEA
03966:  MOVFF  FEF,754
0396A:  MOVFF  FEC,01
0396E:  MOVFF  FEC,02
03972:  MOVFF  FEC,03
03976:  MOVFF  03,757
0397A:  MOVFF  02,756
0397E:  MOVFF  01,755
03982:  MOVLB  0
03984:  CALL   0DA4
03988:  MOVFF  03,74D
0398C:  MOVFF  02,74C
03990:  MOVFF  01,74B
03994:  MOVFF  00,74A
03998:  MOVLB  7
0399A:  MOVF   x03,W
0399C:  MULLW  10
0399E:  MOVF   FF3,W
039A0:  CLRF   x15
039A2:  MOVWF  x14
039A4:  MOVLW  72
039A6:  ADDWF  x14,W
039A8:  MOVWF  FE9
039AA:  MOVLW  00
039AC:  ADDWFC x15,W
039AE:  MOVWF  FEA
039B0:  MOVFF  FEF,74E
039B4:  MOVFF  FEC,01
039B8:  MOVFF  FEC,02
039BC:  MOVFF  FEC,03
039C0:  BCF    FD8.1
039C2:  MOVFF  03,751
039C6:  MOVFF  02,750
039CA:  MOVFF  01,74F
039CE:  MOVLB  0
039D0:  CALL   0E9A
039D4:  MOVFF  70D,FEA
039D8:  MOVFF  70C,FE9
039DC:  MOVFF  00,FEF
039E0:  MOVFF  01,FEC
039E4:  MOVFF  02,FEC
039E8:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
039EC:  MOVLB  7
039EE:  MOVF   x03,W
039F0:  MULLW  26
039F2:  MOVF   FF3,W
039F4:  CLRF   x0D
039F6:  MOVWF  x0C
039F8:  MOVLW  0C
039FA:  ADDWF  x0C,W
039FC:  MOVWF  01
039FE:  MOVLW  00
03A00:  ADDWFC x0D,W
03A02:  MOVWF  03
03A04:  MOVF   01,W
03A06:  ADDLW  17
03A08:  MOVWF  01
03A0A:  MOVLW  01
03A0C:  ADDWFC 03,F
03A0E:  MOVFF  01,70C
03A12:  MOVFF  03,70D
03A16:  MOVF   x03,W
03A18:  MULLW  26
03A1A:  MOVF   FF3,W
03A1C:  CLRF   x0F
03A1E:  MOVWF  x0E
03A20:  MOVLW  04
03A22:  ADDWF  x0E,W
03A24:  MOVWF  01
03A26:  MOVLW  00
03A28:  ADDWFC x0F,W
03A2A:  MOVWF  03
03A2C:  MOVF   01,W
03A2E:  ADDLW  17
03A30:  MOVWF  FE9
03A32:  MOVLW  01
03A34:  ADDWFC 03,W
03A36:  MOVWF  FEA
03A38:  MOVFF  FEF,750
03A3C:  MOVFF  FEC,751
03A40:  MOVFF  FEC,752
03A44:  MOVFF  FEC,753
03A48:  MOVF   x03,W
03A4A:  MULLW  10
03A4C:  MOVF   FF3,W
03A4E:  CLRF   x13
03A50:  MOVWF  x12
03A52:  MOVLW  0C
03A54:  ADDWF  x12,W
03A56:  MOVWF  01
03A58:  MOVLW  00
03A5A:  ADDWFC x13,W
03A5C:  MOVWF  03
03A5E:  MOVF   01,W
03A60:  ADDLW  72
03A62:  MOVWF  FE9
03A64:  MOVLW  00
03A66:  ADDWFC 03,W
03A68:  MOVWF  FEA
03A6A:  MOVFF  FEF,754
03A6E:  MOVFF  FEC,01
03A72:  MOVFF  FEC,02
03A76:  MOVFF  FEC,03
03A7A:  MOVFF  03,757
03A7E:  MOVFF  02,756
03A82:  MOVFF  01,755
03A86:  MOVLB  0
03A88:  CALL   0DA4
03A8C:  MOVFF  03,74D
03A90:  MOVFF  02,74C
03A94:  MOVFF  01,74B
03A98:  MOVFF  00,74A
03A9C:  MOVLB  7
03A9E:  MOVF   x03,W
03AA0:  MULLW  10
03AA2:  MOVF   FF3,W
03AA4:  CLRF   x13
03AA6:  MOVWF  x12
03AA8:  MOVLW  04
03AAA:  ADDWF  x12,W
03AAC:  MOVWF  01
03AAE:  MOVLW  00
03AB0:  ADDWFC x13,W
03AB2:  MOVWF  03
03AB4:  MOVF   01,W
03AB6:  ADDLW  72
03AB8:  MOVWF  FE9
03ABA:  MOVLW  00
03ABC:  ADDWFC 03,W
03ABE:  MOVWF  FEA
03AC0:  MOVFF  FEF,74E
03AC4:  MOVFF  FEC,01
03AC8:  MOVFF  FEC,02
03ACC:  MOVFF  FEC,03
03AD0:  BCF    FD8.1
03AD2:  MOVFF  03,751
03AD6:  MOVFF  02,750
03ADA:  MOVFF  01,74F
03ADE:  MOVLB  0
03AE0:  CALL   0E9A
03AE4:  MOVFF  70D,FEA
03AE8:  MOVFF  70C,FE9
03AEC:  MOVFF  00,FEF
03AF0:  MOVFF  01,FEC
03AF4:  MOVFF  02,FEC
03AF8:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
03AFC:  MOVLB  7
03AFE:  CLRF   x07
03B00:  CLRF   x06
03B02:  CLRF   x05
03B04:  CLRF   x04
03B06:  CLRF   x0B
03B08:  CLRF   x0A
03B0A:  CLRF   x09
03B0C:  MOVLW  7F
03B0E:  MOVWF  x08
....................    
....................    if (adcVals[ch].cosCounts < 0){
03B10:  MOVF   x03,W
03B12:  MULLW  26
03B14:  MOVF   FF3,W
03B16:  CLRF   x0D
03B18:  MOVWF  x0C
03B1A:  MOVLW  0C
03B1C:  ADDWF  x0C,W
03B1E:  MOVWF  01
03B20:  MOVLW  00
03B22:  ADDWFC x0D,W
03B24:  MOVWF  03
03B26:  MOVF   01,W
03B28:  ADDLW  17
03B2A:  MOVWF  FE9
03B2C:  MOVLW  01
03B2E:  ADDWFC 03,W
03B30:  MOVWF  FEA
03B32:  MOVFF  FEF,746
03B36:  MOVFF  FEC,747
03B3A:  MOVFF  FEC,748
03B3E:  MOVFF  FEC,749
03B42:  CLRF   x4D
03B44:  CLRF   x4C
03B46:  CLRF   x4B
03B48:  CLRF   x4A
03B4A:  MOVLB  0
03B4C:  CALL   1D30
03B50:  BTFSS  FD8.0
03B52:  BRA    3CBC
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03B54:  MOVLB  7
03B56:  MOVF   x03,W
03B58:  MULLW  26
03B5A:  MOVF   FF3,W
03B5C:  CLRF   x0D
03B5E:  MOVWF  x0C
03B60:  MOVLW  08
03B62:  ADDWF  x0C,W
03B64:  MOVWF  01
03B66:  MOVLW  00
03B68:  ADDWFC x0D,W
03B6A:  MOVWF  03
03B6C:  MOVF   01,W
03B6E:  ADDLW  17
03B70:  MOVWF  FE9
03B72:  MOVLW  01
03B74:  ADDWFC 03,W
03B76:  MOVWF  FEA
03B78:  MOVFF  FEF,74A
03B7C:  MOVFF  FEC,70D
03B80:  MOVFF  FEC,74C
03B84:  MOVFF  FEC,74D
03B88:  CLRF   x49
03B8A:  CLRF   x48
03B8C:  CLRF   x47
03B8E:  CLRF   x46
03B90:  MOVFF  70D,74B
03B94:  MOVLB  0
03B96:  CALL   1D30
03B9A:  BNC   3C08
03B9C:  MOVLB  7
03B9E:  MOVF   x03,W
03BA0:  MULLW  26
03BA2:  MOVF   FF3,W
03BA4:  CLRF   x0D
03BA6:  MOVWF  x0C
03BA8:  MOVLW  10
03BAA:  ADDWF  x0C,W
03BAC:  MOVWF  01
03BAE:  MOVLW  00
03BB0:  ADDWFC x0D,W
03BB2:  MOVWF  03
03BB4:  MOVF   01,W
03BB6:  ADDLW  17
03BB8:  MOVWF  FE9
03BBA:  MOVLW  01
03BBC:  ADDWFC 03,W
03BBE:  MOVWF  FEA
03BC0:  MOVFF  FEF,746
03BC4:  MOVFF  FEC,747
03BC8:  MOVFF  FEC,748
03BCC:  MOVFF  FEC,749
03BD0:  CLRF   x4D
03BD2:  CLRF   x4C
03BD4:  CLRF   x4B
03BD6:  CLRF   x4A
03BD8:  MOVLB  0
03BDA:  CALL   1D30
03BDE:  BNC   3C08
....................          adcVals[ch].npoles--;
03BE0:  MOVLB  7
03BE2:  MOVF   x03,W
03BE4:  MULLW  26
03BE6:  MOVF   FF3,W
03BE8:  CLRF   x0D
03BEA:  MOVWF  x0C
03BEC:  MOVLW  1C
03BEE:  ADDWF  x0C,W
03BF0:  MOVWF  01
03BF2:  MOVLW  00
03BF4:  ADDWFC x0D,W
03BF6:  MOVWF  03
03BF8:  MOVF   01,W
03BFA:  ADDLW  17
03BFC:  MOVWF  FE9
03BFE:  MOVLW  01
03C00:  ADDWFC 03,W
03C02:  MOVWF  FEA
03C04:  DECF   FEF,F
....................       }
03C06:  BRA    3CBA
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03C08:  MOVLB  7
03C0A:  MOVF   x03,W
03C0C:  MULLW  26
03C0E:  MOVF   FF3,W
03C10:  CLRF   x0D
03C12:  MOVWF  x0C
03C14:  MOVLW  08
03C16:  ADDWF  x0C,W
03C18:  MOVWF  01
03C1A:  MOVLW  00
03C1C:  ADDWFC x0D,W
03C1E:  MOVWF  03
03C20:  MOVF   01,W
03C22:  ADDLW  17
03C24:  MOVWF  FE9
03C26:  MOVLW  01
03C28:  ADDWFC 03,W
03C2A:  MOVWF  FEA
03C2C:  MOVFF  FEF,746
03C30:  MOVFF  FEC,70D
03C34:  MOVFF  FEC,748
03C38:  MOVFF  FEC,749
03C3C:  MOVFF  70D,747
03C40:  CLRF   x4D
03C42:  CLRF   x4C
03C44:  CLRF   x4B
03C46:  CLRF   x4A
03C48:  MOVLB  0
03C4A:  CALL   1D30
03C4E:  BNC   3CBC
03C50:  MOVLB  7
03C52:  MOVF   x03,W
03C54:  MULLW  26
03C56:  MOVF   FF3,W
03C58:  CLRF   x0D
03C5A:  MOVWF  x0C
03C5C:  MOVLW  10
03C5E:  ADDWF  x0C,W
03C60:  MOVWF  01
03C62:  MOVLW  00
03C64:  ADDWFC x0D,W
03C66:  MOVWF  03
03C68:  MOVF   01,W
03C6A:  ADDLW  17
03C6C:  MOVWF  FE9
03C6E:  MOVLW  01
03C70:  ADDWFC 03,W
03C72:  MOVWF  FEA
03C74:  MOVFF  FEF,74A
03C78:  MOVFF  FEC,74B
03C7C:  MOVFF  FEC,74C
03C80:  MOVFF  FEC,74D
03C84:  CLRF   x49
03C86:  CLRF   x48
03C88:  CLRF   x47
03C8A:  CLRF   x46
03C8C:  MOVLB  0
03C8E:  CALL   1D30
03C92:  BNC   3CBC
....................          adcVals[ch].npoles++;
03C94:  MOVLB  7
03C96:  MOVF   x03,W
03C98:  MULLW  26
03C9A:  MOVF   FF3,W
03C9C:  CLRF   x0D
03C9E:  MOVWF  x0C
03CA0:  MOVLW  1C
03CA2:  ADDWF  x0C,W
03CA4:  MOVWF  01
03CA6:  MOVLW  00
03CA8:  ADDWFC x0D,W
03CAA:  MOVWF  03
03CAC:  MOVF   01,W
03CAE:  ADDLW  17
03CB0:  MOVWF  FE9
03CB2:  MOVLW  01
03CB4:  ADDWFC 03,W
03CB6:  MOVWF  FEA
03CB8:  INCF   FEF,F
03CBA:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03CBC:  MOVLB  7
03CBE:  MOVF   x03,W
03CC0:  MULLW  26
03CC2:  MOVF   FF3,W
03CC4:  CLRF   x0D
03CC6:  MOVWF  x0C
03CC8:  MOVLW  18
03CCA:  ADDWF  x0C,W
03CCC:  MOVWF  01
03CCE:  MOVLW  00
03CD0:  ADDWFC x0D,W
03CD2:  MOVWF  03
03CD4:  MOVF   01,W
03CD6:  ADDLW  17
03CD8:  MOVWF  01
03CDA:  MOVLW  01
03CDC:  ADDWFC 03,F
03CDE:  MOVFF  01,70C
03CE2:  MOVFF  03,70D
03CE6:  MOVFF  70B,753
03CEA:  MOVFF  70A,752
03CEE:  MOVFF  709,751
03CF2:  MOVFF  708,750
03CF6:  MOVLW  AA
03CF8:  MOVWF  x57
03CFA:  MOVLW  27
03CFC:  MOVWF  x56
03CFE:  MOVLW  1F
03D00:  MOVWF  x55
03D02:  MOVLW  86
03D04:  MOVWF  x54
03D06:  MOVLB  0
03D08:  CALL   0DA4
03D0C:  MOVFF  03,711
03D10:  MOVFF  02,710
03D14:  MOVFF  01,70F
03D18:  MOVFF  00,70E
03D1C:  MOVLB  7
03D1E:  MOVF   x03,W
03D20:  MULLW  26
03D22:  MOVF   FF3,W
03D24:  CLRF   x13
03D26:  MOVWF  x12
03D28:  MOVLW  08
03D2A:  ADDWF  x12,W
03D2C:  MOVWF  01
03D2E:  MOVLW  00
03D30:  ADDWFC x13,W
03D32:  MOVWF  03
03D34:  MOVF   01,W
03D36:  ADDLW  17
03D38:  MOVWF  FE9
03D3A:  MOVLW  01
03D3C:  ADDWFC 03,W
03D3E:  MOVWF  FEA
03D40:  MOVFF  FEF,712
03D44:  MOVFF  FEC,713
03D48:  MOVFF  FEC,714
03D4C:  MOVFF  FEC,715
03D50:  MOVF   x03,W
03D52:  MULLW  26
03D54:  MOVF   FF3,W
03D56:  CLRF   x17
03D58:  MOVWF  x16
03D5A:  MOVLW  0C
03D5C:  ADDWF  x16,W
03D5E:  MOVWF  01
03D60:  MOVLW  00
03D62:  ADDWFC x17,W
03D64:  MOVWF  03
03D66:  MOVF   01,W
03D68:  ADDLW  17
03D6A:  MOVWF  FE9
03D6C:  MOVLW  01
03D6E:  ADDWFC 03,W
03D70:  MOVWF  FEA
03D72:  MOVFF  FEF,00
03D76:  MOVFF  FEC,01
03D7A:  MOVFF  FEC,02
03D7E:  MOVFF  FEC,03
03D82:  MOVFF  03,719
03D86:  MOVFF  02,718
03D8A:  MOVFF  01,717
03D8E:  MOVFF  00,716
03D92:  MOVFF  715,71D
03D96:  MOVFF  714,71C
03D9A:  MOVFF  713,71B
03D9E:  MOVFF  712,71A
03DA2:  MOVFF  03,721
03DA6:  MOVFF  02,720
03DAA:  MOVFF  01,71F
03DAE:  MOVFF  00,71E
03DB2:  MOVLB  0
03DB4:  GOTO   2432
03DB8:  MOVFF  711,753
03DBC:  MOVFF  710,752
03DC0:  MOVFF  70F,751
03DC4:  MOVFF  70E,750
03DC8:  MOVFF  03,757
03DCC:  MOVFF  02,756
03DD0:  MOVFF  01,755
03DD4:  MOVFF  00,754
03DD8:  CALL   0DA4
03DDC:  MOVFF  70D,FEA
03DE0:  MOVFF  70C,FE9
03DE4:  MOVFF  00,FEF
03DE8:  MOVFF  01,FEC
03DEC:  MOVFF  02,FEC
03DF0:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
03DF4:  MOVLB  7
03DF6:  MOVF   x03,W
03DF8:  MULLW  26
03DFA:  MOVF   FF3,W
03DFC:  CLRF   x0D
03DFE:  MOVWF  x0C
03E00:  MOVLW  18
03E02:  ADDWF  x0C,W
03E04:  MOVWF  01
03E06:  MOVLW  00
03E08:  ADDWFC x0D,W
03E0A:  MOVWF  03
03E0C:  MOVF   01,W
03E0E:  ADDLW  17
03E10:  MOVWF  FE9
03E12:  MOVLW  01
03E14:  ADDWFC 03,W
03E16:  MOVWF  FEA
03E18:  MOVFF  FEF,70C
03E1C:  MOVFF  FEC,70D
03E20:  MOVFF  FEC,70E
03E24:  MOVFF  FEC,70F
03E28:  CLRF   x53
03E2A:  CLRF   x52
03E2C:  MOVLW  7A
03E2E:  MOVWF  x51
03E30:  MOVLW  88
03E32:  MOVWF  x50
03E34:  MOVFF  70B,757
03E38:  MOVFF  70A,756
03E3C:  MOVFF  709,755
03E40:  MOVFF  708,754
03E44:  MOVLB  0
03E46:  CALL   0DA4
03E4A:  MOVFF  03,713
03E4E:  MOVFF  02,712
03E52:  MOVFF  01,711
03E56:  MOVFF  00,710
03E5A:  MOVLB  7
03E5C:  MOVF   x03,W
03E5E:  MULLW  26
03E60:  MOVF   FF3,W
03E62:  CLRF   x15
03E64:  MOVWF  x14
03E66:  MOVLW  1C
03E68:  ADDWF  x14,W
03E6A:  MOVWF  01
03E6C:  MOVLW  00
03E6E:  ADDWFC x15,W
03E70:  MOVWF  03
03E72:  MOVF   01,W
03E74:  ADDLW  17
03E76:  MOVWF  FE9
03E78:  MOVLW  01
03E7A:  ADDWFC 03,W
03E7C:  MOVWF  FEA
03E7E:  MOVF   FEF,W
03E80:  CLRF   x3D
03E82:  MOVWF  x3C
03E84:  BTFSC  x3C.7
03E86:  DECF   x3D,F
03E88:  MOVLB  0
03E8A:  CALL   26D4
03E8E:  MOVFF  713,753
03E92:  MOVFF  712,752
03E96:  MOVFF  711,751
03E9A:  MOVFF  710,750
03E9E:  MOVFF  03,757
03EA2:  MOVFF  02,756
03EA6:  MOVFF  01,755
03EAA:  MOVFF  00,754
03EAE:  CALL   0DA4
03EB2:  MOVFF  FEA,711
03EB6:  MOVFF  FE9,710
03EBA:  BCF    FD8.1
03EBC:  MOVFF  70F,74D
03EC0:  MOVFF  70E,74C
03EC4:  MOVFF  70D,74B
03EC8:  MOVFF  70C,74A
03ECC:  MOVFF  03,751
03ED0:  MOVFF  02,750
03ED4:  MOVFF  01,74F
03ED8:  MOVFF  00,74E
03EDC:  CALL   0E9A
03EE0:  MOVFF  711,FEA
03EE4:  MOVFF  710,FE9
03EE8:  MOVFF  03,707
03EEC:  MOVFF  02,706
03EF0:  MOVFF  01,705
03EF4:  MOVFF  00,704
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03EF8:  MOVLB  7
03EFA:  MOVF   x03,W
03EFC:  MULLW  26
03EFE:  MOVF   FF3,W
03F00:  CLRF   x0D
03F02:  MOVWF  x0C
03F04:  MOVLW  1D
03F06:  ADDWF  x0C,W
03F08:  MOVWF  01
03F0A:  MOVLW  00
03F0C:  ADDWFC x0D,W
03F0E:  MOVWF  03
03F10:  MOVF   01,W
03F12:  ADDLW  17
03F14:  MOVWF  01
03F16:  MOVLW  01
03F18:  ADDWFC 03,F
03F1A:  MOVFF  01,70C
03F1E:  MOVFF  03,70D
03F22:  MOVF   x03,W
03F24:  MULLW  18
03F26:  MOVF   FF3,W
03F28:  CLRF   x0F
03F2A:  MOVWF  x0E
03F2C:  MOVLW  14
03F2E:  ADDWF  x0E,W
03F30:  MOVWF  01
03F32:  MOVLW  00
03F34:  ADDWFC x0F,W
03F36:  MOVWF  03
03F38:  MOVF   01,W
03F3A:  ADDLW  92
03F3C:  MOVWF  FE9
03F3E:  MOVLW  00
03F40:  ADDWFC 03,W
03F42:  MOVWF  FEA
03F44:  MOVFF  FEF,754
03F48:  MOVFF  FEC,01
03F4C:  MOVFF  FEC,02
03F50:  MOVFF  FEC,03
03F54:  MOVFF  707,753
03F58:  MOVFF  706,752
03F5C:  MOVFF  705,751
03F60:  MOVFF  704,750
03F64:  MOVFF  03,757
03F68:  MOVFF  02,756
03F6C:  MOVFF  01,755
03F70:  MOVLB  0
03F72:  CALL   0DA4
03F76:  MOVFF  03,711
03F7A:  MOVFF  02,710
03F7E:  MOVFF  01,70F
03F82:  MOVFF  00,70E
03F86:  MOVFF  03,71D
03F8A:  MOVFF  02,71C
03F8E:  MOVFF  01,71B
03F92:  MOVFF  00,71A
03F96:  MOVLB  7
03F98:  CLRF   x21
03F9A:  CLRF   x20
03F9C:  MOVLW  20
03F9E:  MOVWF  x1F
03FA0:  MOVLW  81
03FA2:  MOVWF  x1E
03FA4:  MOVLB  0
03FA6:  CALL   3412
03FAA:  MOVFF  03,711
03FAE:  MOVFF  02,710
03FB2:  MOVFF  01,70F
03FB6:  MOVFF  00,70E
03FBA:  MOVLB  7
03FBC:  MOVF   x03,W
03FBE:  MULLW  18
03FC0:  MOVF   FF3,W
03FC2:  CLRF   x13
03FC4:  MOVWF  x12
03FC6:  MOVLW  10
03FC8:  ADDWF  x12,W
03FCA:  MOVWF  01
03FCC:  MOVLW  00
03FCE:  ADDWFC x13,W
03FD0:  MOVWF  03
03FD2:  MOVF   01,W
03FD4:  ADDLW  92
03FD6:  MOVWF  FE9
03FD8:  MOVLW  00
03FDA:  ADDWFC 03,W
03FDC:  MOVWF  FEA
03FDE:  MOVFF  FEF,754
03FE2:  MOVFF  FEC,01
03FE6:  MOVFF  FEC,02
03FEA:  MOVFF  FEC,03
03FEE:  MOVFF  707,753
03FF2:  MOVFF  706,752
03FF6:  MOVFF  705,751
03FFA:  MOVFF  704,750
03FFE:  MOVFF  03,757
04002:  MOVFF  02,756
04006:  MOVFF  01,755
0400A:  MOVLB  0
0400C:  CALL   0DA4
04010:  MOVFF  03,715
04014:  MOVFF  02,714
04018:  MOVFF  01,713
0401C:  MOVFF  00,712
04020:  MOVFF  03,71D
04024:  MOVFF  02,71C
04028:  MOVFF  01,71B
0402C:  MOVFF  00,71A
04030:  MOVLB  7
04032:  CLRF   x21
04034:  CLRF   x20
04036:  CLRF   x1F
04038:  MOVLW  81
0403A:  MOVWF  x1E
0403C:  MOVLB  0
0403E:  CALL   3412
04042:  MOVFF  FEA,713
04046:  MOVFF  FE9,712
0404A:  BCF    FD8.1
0404C:  MOVFF  711,74D
04050:  MOVFF  710,74C
04054:  MOVFF  70F,74B
04058:  MOVFF  70E,74A
0405C:  MOVFF  03,751
04060:  MOVFF  02,750
04064:  MOVFF  01,74F
04068:  MOVFF  00,74E
0406C:  CALL   0E9A
04070:  MOVFF  713,FEA
04074:  MOVFF  712,FE9
04078:  MOVFF  03,711
0407C:  MOVFF  02,710
04080:  MOVFF  01,70F
04084:  MOVFF  00,70E
04088:  MOVLB  7
0408A:  MOVF   x03,W
0408C:  MULLW  18
0408E:  MOVF   FF3,W
04090:  CLRF   x15
04092:  MOVWF  x14
04094:  MOVLW  0C
04096:  ADDWF  x14,W
04098:  MOVWF  01
0409A:  MOVLW  00
0409C:  ADDWFC x15,W
0409E:  MOVWF  03
040A0:  MOVF   01,W
040A2:  ADDLW  92
040A4:  MOVWF  FE9
040A6:  MOVLW  00
040A8:  ADDWFC 03,W
040AA:  MOVWF  FEA
040AC:  MOVFF  FEF,754
040B0:  MOVFF  FEC,01
040B4:  MOVFF  FEC,02
040B8:  MOVFF  FEC,03
040BC:  MOVFF  707,753
040C0:  MOVFF  706,752
040C4:  MOVFF  705,751
040C8:  MOVFF  704,750
040CC:  MOVFF  03,757
040D0:  MOVFF  02,756
040D4:  MOVFF  01,755
040D8:  MOVLB  0
040DA:  CALL   0DA4
040DE:  MOVFF  03,717
040E2:  MOVFF  02,716
040E6:  MOVFF  01,715
040EA:  MOVFF  00,714
040EE:  MOVFF  03,71D
040F2:  MOVFF  02,71C
040F6:  MOVFF  01,71B
040FA:  MOVFF  00,71A
040FE:  MOVLB  7
04100:  CLRF   x21
04102:  CLRF   x20
04104:  MOVLW  40
04106:  MOVWF  x1F
04108:  MOVLW  80
0410A:  MOVWF  x1E
0410C:  MOVLB  0
0410E:  CALL   3412
04112:  MOVFF  FEA,715
04116:  MOVFF  FE9,714
0411A:  BCF    FD8.1
0411C:  MOVFF  711,74D
04120:  MOVFF  710,74C
04124:  MOVFF  70F,74B
04128:  MOVFF  70E,74A
0412C:  MOVFF  03,751
04130:  MOVFF  02,750
04134:  MOVFF  01,74F
04138:  MOVFF  00,74E
0413C:  CALL   0E9A
04140:  MOVFF  715,FEA
04144:  MOVFF  714,FE9
04148:  MOVFF  03,711
0414C:  MOVFF  02,710
04150:  MOVFF  01,70F
04154:  MOVFF  00,70E
04158:  MOVLB  7
0415A:  MOVF   x03,W
0415C:  MULLW  18
0415E:  MOVF   FF3,W
04160:  CLRF   x17
04162:  MOVWF  x16
04164:  MOVLW  08
04166:  ADDWF  x16,W
04168:  MOVWF  01
0416A:  MOVLW  00
0416C:  ADDWFC x17,W
0416E:  MOVWF  03
04170:  MOVF   01,W
04172:  ADDLW  92
04174:  MOVWF  FE9
04176:  MOVLW  00
04178:  ADDWFC 03,W
0417A:  MOVWF  FEA
0417C:  MOVFF  FEF,754
04180:  MOVFF  FEC,01
04184:  MOVFF  FEC,02
04188:  MOVFF  FEC,03
0418C:  MOVFF  707,753
04190:  MOVFF  706,752
04194:  MOVFF  705,751
04198:  MOVFF  704,750
0419C:  MOVFF  03,757
041A0:  MOVFF  02,756
041A4:  MOVFF  01,755
041A8:  MOVLB  0
041AA:  CALL   0DA4
041AE:  MOVFF  03,719
041B2:  MOVFF  02,718
041B6:  MOVFF  01,717
041BA:  MOVFF  00,716
041BE:  MOVFF  03,71D
041C2:  MOVFF  02,71C
041C6:  MOVFF  01,71B
041CA:  MOVFF  00,71A
041CE:  MOVLB  7
041D0:  CLRF   x21
041D2:  CLRF   x20
041D4:  CLRF   x1F
041D6:  MOVLW  80
041D8:  MOVWF  x1E
041DA:  MOVLB  0
041DC:  CALL   3412
041E0:  MOVFF  FEA,717
041E4:  MOVFF  FE9,716
041E8:  BCF    FD8.1
041EA:  MOVFF  711,74D
041EE:  MOVFF  710,74C
041F2:  MOVFF  70F,74B
041F6:  MOVFF  70E,74A
041FA:  MOVFF  03,751
041FE:  MOVFF  02,750
04202:  MOVFF  01,74F
04206:  MOVFF  00,74E
0420A:  CALL   0E9A
0420E:  MOVFF  717,FEA
04212:  MOVFF  716,FE9
04216:  MOVFF  03,711
0421A:  MOVFF  02,710
0421E:  MOVFF  01,70F
04222:  MOVFF  00,70E
04226:  MOVLB  7
04228:  MOVF   x03,W
0422A:  MULLW  18
0422C:  MOVF   FF3,W
0422E:  CLRF   x19
04230:  MOVWF  x18
04232:  MOVLW  04
04234:  ADDWF  x18,W
04236:  MOVWF  01
04238:  MOVLW  00
0423A:  ADDWFC x19,W
0423C:  MOVWF  03
0423E:  MOVF   01,W
04240:  ADDLW  92
04242:  MOVWF  FE9
04244:  MOVLW  00
04246:  ADDWFC 03,W
04248:  MOVWF  FEA
0424A:  MOVFF  FEF,754
0424E:  MOVFF  FEC,01
04252:  MOVFF  FEC,02
04256:  MOVFF  FEC,03
0425A:  MOVFF  707,753
0425E:  MOVFF  706,752
04262:  MOVFF  705,751
04266:  MOVFF  704,750
0426A:  MOVFF  03,757
0426E:  MOVFF  02,756
04272:  MOVFF  01,755
04276:  MOVLB  0
04278:  CALL   0DA4
0427C:  MOVFF  FEA,719
04280:  MOVFF  FE9,718
04284:  BCF    FD8.1
04286:  MOVFF  711,74D
0428A:  MOVFF  710,74C
0428E:  MOVFF  70F,74B
04292:  MOVFF  70E,74A
04296:  MOVFF  03,751
0429A:  MOVFF  02,750
0429E:  MOVFF  01,74F
042A2:  MOVFF  00,74E
042A6:  CALL   0E9A
042AA:  MOVFF  719,FEA
042AE:  MOVFF  718,FE9
042B2:  MOVFF  03,74D
042B6:  MOVFF  02,74C
042BA:  MOVFF  01,74B
042BE:  MOVFF  00,74A
042C2:  MOVLB  7
042C4:  MOVF   x03,W
042C6:  MULLW  18
042C8:  MOVF   FF3,W
042CA:  CLRF   x1B
042CC:  MOVWF  x1A
042CE:  MOVLW  92
042D0:  ADDWF  x1A,W
042D2:  MOVWF  FE9
042D4:  MOVLW  00
042D6:  ADDWFC x1B,W
042D8:  MOVWF  FEA
042DA:  MOVFF  FEF,74E
042DE:  MOVFF  FEC,01
042E2:  MOVFF  FEC,02
042E6:  MOVFF  FEC,03
042EA:  BCF    FD8.1
042EC:  MOVFF  03,751
042F0:  MOVFF  02,750
042F4:  MOVFF  01,74F
042F8:  MOVLB  0
042FA:  CALL   0E9A
042FE:  MOVFF  70D,FEA
04302:  MOVFF  70C,FE9
04306:  MOVFF  00,FEF
0430A:  MOVFF  01,FEC
0430E:  MOVFF  02,FEC
04312:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
04316:  MOVLB  7
04318:  MOVF   x03,F
0431A:  BNZ   4378
0431C:  MOVF   x03,W
0431E:  MULLW  26
04320:  MOVF   FF3,W
04322:  CLRF   x0D
04324:  MOVWF  x0C
04326:  MOVLW  1D
04328:  ADDWF  x0C,W
0432A:  MOVWF  01
0432C:  MOVLW  00
0432E:  ADDWFC x0D,W
04330:  MOVWF  03
04332:  MOVF   01,W
04334:  ADDLW  17
04336:  MOVWF  FE9
04338:  MOVLW  01
0433A:  ADDWFC 03,W
0433C:  MOVWF  FEA
0433E:  MOVFF  FEF,750
04342:  MOVFF  FEC,751
04346:  MOVFF  FEC,752
0434A:  MOVFF  FEC,753
0434E:  MOVF   FED,F
04350:  MOVF   FED,F
04352:  MOVF   FED,F
04354:  CLRF   x57
04356:  CLRF   x56
04358:  MOVLW  80
0435A:  MOVWF  x55
0435C:  MOVLW  7F
0435E:  MOVWF  x54
04360:  MOVLB  0
04362:  CALL   0DA4
04366:  MOVFF  00,FEF
0436A:  MOVFF  01,FEC
0436E:  MOVFF  02,FEC
04372:  MOVFF  03,FEC
04376:  MOVLB  7
....................    PID[ch].PVold = PID[ch].PV;
04378:  MOVF   x03,W
0437A:  MULLW  28
0437C:  MOVF   FF3,W
0437E:  CLRF   x0D
04380:  MOVWF  x0C
04382:  MOVLW  14
04384:  ADDWF  x0C,W
04386:  MOVWF  01
04388:  MOVLW  00
0438A:  ADDWFC x0D,W
0438C:  MOVWF  03
0438E:  MOVF   01,W
04390:  ADDLW  20
04392:  MOVWF  01
04394:  MOVLW  00
04396:  ADDWFC 03,F
04398:  MOVFF  01,70C
0439C:  MOVFF  03,70D
043A0:  MOVF   x03,W
043A2:  MULLW  28
043A4:  MOVF   FF3,W
043A6:  CLRF   x0F
043A8:  MOVWF  x0E
043AA:  MOVLW  10
043AC:  ADDWF  x0E,W
043AE:  MOVWF  01
043B0:  MOVLW  00
043B2:  ADDWFC x0F,W
043B4:  MOVWF  03
043B6:  MOVF   01,W
043B8:  ADDLW  20
043BA:  MOVWF  FE9
043BC:  MOVLW  00
043BE:  ADDWFC 03,W
043C0:  MOVWF  FEA
043C2:  MOVFF  FEF,00
043C6:  MOVFF  FEC,01
043CA:  MOVFF  FEC,02
043CE:  MOVFF  FEC,03
043D2:  MOVFF  70D,FEA
043D6:  MOVFF  70C,FE9
043DA:  MOVFF  00,FEF
043DE:  MOVFF  01,FEC
043E2:  MOVFF  02,FEC
043E6:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
043EA:  MOVF   x03,W
043EC:  MULLW  28
043EE:  MOVF   FF3,W
043F0:  CLRF   x0D
043F2:  MOVWF  x0C
043F4:  MOVLW  10
043F6:  ADDWF  x0C,W
043F8:  MOVWF  01
043FA:  MOVLW  00
043FC:  ADDWFC x0D,W
043FE:  MOVWF  03
04400:  MOVF   01,W
04402:  ADDLW  20
04404:  MOVWF  01
04406:  MOVLW  00
04408:  ADDWFC 03,F
0440A:  MOVFF  01,70C
0440E:  MOVFF  03,70D
04412:  MOVF   x03,W
04414:  MULLW  26
04416:  MOVF   FF3,W
04418:  CLRF   x0F
0441A:  MOVWF  x0E
0441C:  MOVLW  1D
0441E:  ADDWF  x0E,W
04420:  MOVWF  01
04422:  MOVLW  00
04424:  ADDWFC x0F,W
04426:  MOVWF  03
04428:  MOVF   01,W
0442A:  ADDLW  17
0442C:  MOVWF  FE9
0442E:  MOVLW  01
04430:  ADDWFC 03,W
04432:  MOVWF  FEA
04434:  MOVFF  FEF,00
04438:  MOVFF  FEC,01
0443C:  MOVFF  FEC,02
04440:  MOVFF  FEC,03
04444:  MOVFF  70D,FEA
04448:  MOVFF  70C,FE9
0444C:  MOVFF  00,FEF
04450:  MOVFF  01,FEC
04454:  MOVFF  02,FEC
04458:  MOVFF  03,FEC
0445C:  MOVLB  0
0445E:  GOTO   45BE (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task(){
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy){
*
001F8:  MOVLB  1
001FA:  MOVF   xE7,W
001FC:  MULLW  09
001FE:  MOVF   FF3,W
00200:  MOVLB  7
00202:  CLRF   x72
00204:  MOVWF  x71
00206:  MOVLW  D4
00208:  ADDWF  x71,W
0020A:  MOVWF  FE9
0020C:  MOVLW  01
0020E:  ADDWFC x72,W
00210:  MOVWF  FEA
00212:  BTFSC  FEF.1
00214:  BRA    028E
....................       smData[ch].adcBusy = true;
00216:  MOVLB  1
00218:  MOVF   xE7,W
0021A:  MULLW  09
0021C:  MOVF   FF3,W
0021E:  MOVLB  7
00220:  CLRF   x72
00222:  MOVWF  x71
00224:  MOVLW  D4
00226:  ADDWF  x71,W
00228:  MOVWF  FE9
0022A:  MOVLW  01
0022C:  ADDWFC x72,W
0022E:  MOVWF  FEA
00230:  BSF    FEF.1
....................          
....................       ads_start_conv_block(ch);
00232:  MOVFF  1E7,771
00236:  MOVLB  0
00238:  BRA    01DC
....................       ch = !ch;
0023A:  MOVLB  1
0023C:  MOVF   xE7,F
0023E:  BZ    0244
00240:  MOVLW  00
00242:  BRA    0246
00244:  MOVLW  01
00246:  MOVWF  xE7
....................          
....................       smData[!ch].dataReady = true;
00248:  MOVF   xE7,F
0024A:  BZ    0250
0024C:  MOVLW  00
0024E:  BRA    0252
00250:  MOVLW  01
00252:  MULLW  09
00254:  MOVF   FF3,W
00256:  MOVLB  7
00258:  CLRF   x72
0025A:  MOVWF  x71
0025C:  MOVLW  D4
0025E:  ADDWF  x71,W
00260:  MOVWF  FE9
00262:  MOVLW  01
00264:  ADDWFC x72,W
00266:  MOVWF  FEA
00268:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
0026A:  MOVLB  1
0026C:  MOVF   xE7,F
0026E:  BZ    0274
00270:  MOVLW  00
00272:  BRA    0276
00274:  MOVLW  01
00276:  MULLW  09
00278:  MOVF   FF3,W
0027A:  MOVLB  7
0027C:  CLRF   x72
0027E:  MOVWF  x71
00280:  MOVLW  D4
00282:  ADDWF  x71,W
00284:  MOVWF  FE9
00286:  MOVLW  01
00288:  ADDWFC x72,W
0028A:  MOVWF  FEA
0028C:  BCF    FEF.1
....................    }
0028E:  MOVLB  0
00290:  GOTO   0352 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Interquartile Mean Ring Buffer                                            */
.................... /* Filters the ADC data to remove spurious readings                          */
.................... /*****************************************************************************/
.................... void iqm_ring_buffer(int8 ch, signed int32 sinCnts, signed int32 cosCnts){
*
0177A:  MOVLB  7
0177C:  CLRF   x17
0177E:  CLRF   x16
01780:  CLRF   x15
01782:  CLRF   x14
01784:  CLRF   x1B
01786:  CLRF   x1A
01788:  CLRF   x19
0178A:  CLRF   x18
0178C:  CLRF   x1F
0178E:  CLRF   x1E
01790:  CLRF   x1D
01792:  CLRF   x1C
01794:  CLRF   x23
01796:  CLRF   x22
01798:  CLRF   x21
0179A:  CLRF   x20
0179C:  CLRF   x27
0179E:  CLRF   x26
017A0:  CLRF   x25
017A2:  CLRF   x24
017A4:  CLRF   x2B
017A6:  CLRF   x2A
017A8:  CLRF   x29
017AA:  CLRF   x28
....................    signed int32* sQ_ch;
....................    signed int32* cQ_ch;
....................    int* sIn_ch;
....................    int* cIn_ch;
.................... 
....................    signed int32 sumSin=0;
....................    signed int32 sumCos=0;
....................    
....................    signed int32 sinMax=0;
....................    signed int32 sinMin=0;
....................    signed int32 cosMax=0;
....................    signed int32 cosMin=0;
....................    
....................    if (ch==0){
017AC:  MOVF   x03,F
017AE:  BNZ   17D2
....................       sQ_ch = sQ_x;
017B0:  MOVLW  01
017B2:  MOVWF  x0D
017B4:  MOVLW  80
017B6:  MOVWF  x0C
....................       cQ_ch = cQ_x;
017B8:  MOVLW  01
017BA:  MOVWF  x0F
017BC:  MOVLW  94
017BE:  MOVWF  x0E
....................       sIn_ch = &sIn_x;
017C0:  MOVLW  01
017C2:  MOVWF  x11
017C4:  MOVLW  D0
017C6:  MOVWF  x10
....................       cIn_ch = &cIn_x;
017C8:  MOVLW  01
017CA:  MOVWF  x13
017CC:  MOVLW  D1
017CE:  MOVWF  x12
....................    }
017D0:  BRA    17F6
....................    else if (ch==1){
017D2:  DECFSZ x03,W
017D4:  BRA    17F6
....................       sQ_ch = sQ_y;
017D6:  MOVLW  01
017D8:  MOVWF  x0D
017DA:  MOVLW  A8
017DC:  MOVWF  x0C
....................       cQ_ch = cQ_y;
017DE:  MOVLW  01
017E0:  MOVWF  x0F
017E2:  MOVLW  BC
017E4:  MOVWF  x0E
....................       sIn_ch = &sIn_y;
017E6:  MOVLW  01
017E8:  MOVWF  x11
017EA:  MOVLW  D2
017EC:  MOVWF  x10
....................       cIn_ch = &cIn_y;
017EE:  MOVLW  01
017F0:  MOVWF  x13
017F2:  MOVLW  D3
017F4:  MOVWF  x12
....................    }
.................... 
....................    push(sQ_ch, sIn_ch, sinCnts); // push new data into queues
017F6:  MOVFF  70D,72E
017FA:  MOVFF  70C,72D
017FE:  MOVFF  711,730
01802:  MOVFF  710,72F
01806:  MOVFF  707,734
0180A:  MOVFF  706,733
0180E:  MOVFF  705,732
01812:  MOVFF  704,731
01816:  MOVLB  0
01818:  CALL   0908
....................    push(cQ_ch, cIn_ch, cosCnts);
0181C:  MOVFF  70F,72E
01820:  MOVFF  70E,72D
01824:  MOVFF  713,730
01828:  MOVFF  712,72F
0182C:  MOVFF  70B,734
01830:  MOVFF  70A,733
01834:  MOVFF  709,732
01838:  MOVFF  708,731
0183C:  CALL   0908
....................    
....................    // MAX and MIN of the rolling buffer initial vals
....................    sinMax=sQ_ch[0];
01840:  MOVLB  7
01842:  MOVFF  70C,FE9
01846:  MOVFF  70D,FEA
0184A:  MOVFF  FEF,71C
0184E:  MOVFF  FEC,71D
01852:  MOVFF  FEC,71E
01856:  MOVFF  FEC,71F
....................    sinMin=sQ_ch[0];
0185A:  MOVFF  70C,FE9
0185E:  MOVFF  70D,FEA
01862:  MOVFF  FEF,720
01866:  MOVFF  FEC,721
0186A:  MOVFF  FEC,722
0186E:  MOVFF  FEC,723
....................    cosMax=cQ_ch[0];
01872:  MOVFF  70E,FE9
01876:  MOVFF  70F,FEA
0187A:  MOVFF  FEF,724
0187E:  MOVFF  FEC,725
01882:  MOVFF  FEC,726
01886:  MOVFF  FEC,727
....................    cosMin=cQ_ch[0];
0188A:  MOVFF  70E,FE9
0188E:  MOVFF  70F,FEA
01892:  MOVFF  FEF,728
01896:  MOVFF  FEC,729
0189A:  MOVFF  FEC,72A
0189E:  MOVFF  FEC,72B
....................    
....................    // step thru buffer, adding up all vals and finding MAX and MIN
....................    for (int i=1; i<BUFFER_SIZE; i++){
018A2:  MOVLW  01
018A4:  MOVWF  x2C
018A6:  MOVF   x2C,W
018A8:  SUBLW  04
018AA:  BTFSS  FD8.0
018AC:  BRA    1BBC
....................       (sinMax < sQ_ch[i]) ? (sinMax=sQ_ch[i]) : (0);
018AE:  CLRF   x42
018B0:  MOVFF  72C,741
018B4:  CLRF   x44
018B6:  MOVLW  04
018B8:  MOVWF  x43
018BA:  MOVLB  0
018BC:  CALL   08BA
018C0:  MOVFF  02,03
018C4:  MOVF   01,W
018C6:  MOVLB  7
018C8:  ADDWF  x0C,W
018CA:  MOVWF  FE9
018CC:  MOVF   x0D,W
018CE:  ADDWFC 02,W
018D0:  MOVWF  FEA
018D2:  MOVFF  FEF,00
018D6:  MOVFF  FEC,01
018DA:  MOVFF  FEC,02
018DE:  MOVFF  FEC,03
018E2:  BTFSS  x1F.7
018E4:  BRA    18EC
018E6:  BTFSS  03.7
018E8:  BRA    190E
018EA:  BRA    18F0
018EC:  BTFSC  03.7
018EE:  BRA    1944
018F0:  MOVF   x1F,W
018F2:  SUBWF  03,W
018F4:  BNC   1944
018F6:  BNZ   190E
018F8:  MOVF   x1E,W
018FA:  SUBWF  02,W
018FC:  BNC   1944
018FE:  BNZ   190E
01900:  MOVF   x1D,W
01902:  SUBWF  01,W
01904:  BNC   1944
01906:  BNZ   190E
01908:  MOVF   00,W
0190A:  SUBWF  x1C,W
0190C:  BC    1944
0190E:  CLRF   x42
01910:  MOVFF  72C,741
01914:  CLRF   x44
01916:  MOVLW  04
01918:  MOVWF  x43
0191A:  MOVLB  0
0191C:  CALL   08BA
01920:  MOVFF  02,03
01924:  MOVF   01,W
01926:  MOVLB  7
01928:  ADDWF  x0C,W
0192A:  MOVWF  FE9
0192C:  MOVF   x0D,W
0192E:  ADDWFC 02,W
01930:  MOVWF  FEA
01932:  MOVFF  FEF,71C
01936:  MOVFF  FEC,71D
0193A:  MOVFF  FEC,71E
0193E:  MOVFF  FEC,71F
01942:  MOVF   x1C,W
....................       (sinMin > sQ_ch[i]) ? (sinMin=sQ_ch[i]) : (0);
01944:  CLRF   x42
01946:  MOVFF  72C,741
0194A:  CLRF   x44
0194C:  MOVLW  04
0194E:  MOVWF  x43
01950:  MOVLB  0
01952:  CALL   08BA
01956:  MOVFF  02,03
0195A:  MOVF   01,W
0195C:  MOVLB  7
0195E:  ADDWF  x0C,W
01960:  MOVWF  FE9
01962:  MOVF   x0D,W
01964:  ADDWFC 02,W
01966:  MOVWF  FEA
01968:  MOVFF  FEF,00
0196C:  MOVFF  FEC,01
01970:  MOVFF  FEC,02
01974:  MOVFF  FEC,03
01978:  BTFSS  03.7
0197A:  BRA    1982
0197C:  BTFSS  x23.7
0197E:  BRA    19A4
01980:  BRA    1986
01982:  BTFSC  x23.7
01984:  BRA    19E8
01986:  MOVF   03,W
01988:  SUBWF  x23,W
0198A:  BNC   19E8
0198C:  BNZ   19A4
0198E:  MOVF   02,W
01990:  SUBWF  x22,W
01992:  BNC   19E8
01994:  BNZ   19A4
01996:  MOVF   01,W
01998:  SUBWF  x21,W
0199A:  BNC   19E8
0199C:  BNZ   19A4
0199E:  MOVF   x20,W
019A0:  SUBWF  00,W
019A2:  BC    19E8
019A4:  CLRF   x42
019A6:  MOVFF  72C,741
019AA:  CLRF   x44
019AC:  MOVLW  04
019AE:  MOVWF  x43
019B0:  MOVLB  0
019B2:  CALL   08BA
019B6:  MOVFF  02,03
019BA:  MOVF   01,W
019BC:  MOVLB  7
019BE:  ADDWF  x0C,W
019C0:  MOVWF  FE9
019C2:  MOVF   x0D,W
019C4:  ADDWFC 02,W
019C6:  MOVWF  FEA
019C8:  MOVFF  FEF,720
019CC:  MOVFF  FEC,721
019D0:  MOVFF  FEC,722
019D4:  MOVFF  FEC,723
019D8:  MOVFF  720,00
019DC:  MOVFF  721,01
019E0:  MOVFF  722,02
019E4:  MOVFF  723,03
....................       (cosMax < cQ_ch[i]) ? (cosMax=cQ_ch[i]) : (0);
019E8:  CLRF   x42
019EA:  MOVFF  72C,741
019EE:  CLRF   x44
019F0:  MOVLW  04
019F2:  MOVWF  x43
019F4:  MOVLB  0
019F6:  CALL   08BA
019FA:  MOVFF  02,03
019FE:  MOVF   01,W
01A00:  MOVLB  7
01A02:  ADDWF  x0E,W
01A04:  MOVWF  FE9
01A06:  MOVF   x0F,W
01A08:  ADDWFC 02,W
01A0A:  MOVWF  FEA
01A0C:  MOVFF  FEF,00
01A10:  MOVFF  FEC,01
01A14:  MOVFF  FEC,02
01A18:  MOVFF  FEC,03
01A1C:  BTFSS  x27.7
01A1E:  BRA    1A26
01A20:  BTFSS  03.7
01A22:  BRA    1A48
01A24:  BRA    1A2A
01A26:  BTFSC  03.7
01A28:  BRA    1A8C
01A2A:  MOVF   x27,W
01A2C:  SUBWF  03,W
01A2E:  BNC   1A8C
01A30:  BNZ   1A48
01A32:  MOVF   x26,W
01A34:  SUBWF  02,W
01A36:  BNC   1A8C
01A38:  BNZ   1A48
01A3A:  MOVF   x25,W
01A3C:  SUBWF  01,W
01A3E:  BNC   1A8C
01A40:  BNZ   1A48
01A42:  MOVF   00,W
01A44:  SUBWF  x24,W
01A46:  BC    1A8C
01A48:  CLRF   x42
01A4A:  MOVFF  72C,741
01A4E:  CLRF   x44
01A50:  MOVLW  04
01A52:  MOVWF  x43
01A54:  MOVLB  0
01A56:  CALL   08BA
01A5A:  MOVFF  02,03
01A5E:  MOVF   01,W
01A60:  MOVLB  7
01A62:  ADDWF  x0E,W
01A64:  MOVWF  FE9
01A66:  MOVF   x0F,W
01A68:  ADDWFC 02,W
01A6A:  MOVWF  FEA
01A6C:  MOVFF  FEF,724
01A70:  MOVFF  FEC,725
01A74:  MOVFF  FEC,726
01A78:  MOVFF  FEC,727
01A7C:  MOVFF  724,00
01A80:  MOVFF  725,01
01A84:  MOVFF  726,02
01A88:  MOVFF  727,03
....................       (cosMin > cQ_ch[i]) ? (cosMin=cQ_ch[i]) : (0);
01A8C:  CLRF   x42
01A8E:  MOVFF  72C,741
01A92:  CLRF   x44
01A94:  MOVLW  04
01A96:  MOVWF  x43
01A98:  MOVLB  0
01A9A:  CALL   08BA
01A9E:  MOVFF  02,03
01AA2:  MOVF   01,W
01AA4:  MOVLB  7
01AA6:  ADDWF  x0E,W
01AA8:  MOVWF  FE9
01AAA:  MOVF   x0F,W
01AAC:  ADDWFC 02,W
01AAE:  MOVWF  FEA
01AB0:  MOVFF  FEF,00
01AB4:  MOVFF  FEC,01
01AB8:  MOVFF  FEC,02
01ABC:  MOVFF  FEC,03
01AC0:  BTFSS  03.7
01AC2:  BRA    1ACA
01AC4:  BTFSS  x2B.7
01AC6:  BRA    1AEC
01AC8:  BRA    1ACE
01ACA:  BTFSC  x2B.7
01ACC:  BRA    1B30
01ACE:  MOVF   03,W
01AD0:  SUBWF  x2B,W
01AD2:  BNC   1B30
01AD4:  BNZ   1AEC
01AD6:  MOVF   02,W
01AD8:  SUBWF  x2A,W
01ADA:  BNC   1B30
01ADC:  BNZ   1AEC
01ADE:  MOVF   01,W
01AE0:  SUBWF  x29,W
01AE2:  BNC   1B30
01AE4:  BNZ   1AEC
01AE6:  MOVF   x28,W
01AE8:  SUBWF  00,W
01AEA:  BC    1B30
01AEC:  CLRF   x42
01AEE:  MOVFF  72C,741
01AF2:  CLRF   x44
01AF4:  MOVLW  04
01AF6:  MOVWF  x43
01AF8:  MOVLB  0
01AFA:  CALL   08BA
01AFE:  MOVFF  02,03
01B02:  MOVF   01,W
01B04:  MOVLB  7
01B06:  ADDWF  x0E,W
01B08:  MOVWF  FE9
01B0A:  MOVF   x0F,W
01B0C:  ADDWFC 02,W
01B0E:  MOVWF  FEA
01B10:  MOVFF  FEF,728
01B14:  MOVFF  FEC,729
01B18:  MOVFF  FEC,72A
01B1C:  MOVFF  FEC,72B
01B20:  MOVFF  728,00
01B24:  MOVFF  729,01
01B28:  MOVFF  72A,02
01B2C:  MOVFF  72B,03
....................       sumSin+=sQ_ch[i];
01B30:  CLRF   x42
01B32:  MOVFF  72C,741
01B36:  CLRF   x44
01B38:  MOVLW  04
01B3A:  MOVWF  x43
01B3C:  MOVLB  0
01B3E:  CALL   08BA
01B42:  MOVFF  02,03
01B46:  MOVF   01,W
01B48:  MOVLB  7
01B4A:  ADDWF  x0C,W
01B4C:  MOVWF  FE9
01B4E:  MOVF   x0D,W
01B50:  ADDWFC 02,W
01B52:  MOVWF  FEA
01B54:  MOVFF  FEF,00
01B58:  MOVFF  FEC,01
01B5C:  MOVFF  FEC,02
01B60:  MOVFF  FEC,03
01B64:  MOVF   00,W
01B66:  ADDWF  x14,F
01B68:  MOVF   01,W
01B6A:  ADDWFC x15,F
01B6C:  MOVF   02,W
01B6E:  ADDWFC x16,F
01B70:  MOVF   03,W
01B72:  ADDWFC x17,F
....................       sumCos+=cQ_ch[i];
01B74:  CLRF   x42
01B76:  MOVFF  72C,741
01B7A:  CLRF   x44
01B7C:  MOVLW  04
01B7E:  MOVWF  x43
01B80:  MOVLB  0
01B82:  CALL   08BA
01B86:  MOVFF  02,03
01B8A:  MOVF   01,W
01B8C:  MOVLB  7
01B8E:  ADDWF  x0E,W
01B90:  MOVWF  FE9
01B92:  MOVF   x0F,W
01B94:  ADDWFC 02,W
01B96:  MOVWF  FEA
01B98:  MOVFF  FEF,00
01B9C:  MOVFF  FEC,01
01BA0:  MOVFF  FEC,02
01BA4:  MOVFF  FEC,03
01BA8:  MOVF   00,W
01BAA:  ADDWF  x18,F
01BAC:  MOVF   01,W
01BAE:  ADDWFC x19,F
01BB0:  MOVF   02,W
01BB2:  ADDWFC x1A,F
01BB4:  MOVF   03,W
01BB6:  ADDWFC x1B,F
01BB8:  INCF   x2C,F
01BBA:  BRA    18A6
....................    }
....................    
....................    // subtract MAX and MIN from sum
....................    sumSin-=(sinMax+sinMin);
01BBC:  MOVF   x20,W
01BBE:  ADDWF  x1C,W
01BC0:  MOVWF  00
01BC2:  MOVF   x21,W
01BC4:  ADDWFC x1D,W
01BC6:  MOVWF  01
01BC8:  MOVF   x22,W
01BCA:  ADDWFC x1E,W
01BCC:  MOVWF  02
01BCE:  MOVF   x23,W
01BD0:  ADDWFC x1F,W
01BD2:  MOVWF  03
01BD4:  MOVF   00,W
01BD6:  SUBWF  x14,F
01BD8:  MOVF   01,W
01BDA:  SUBWFB x15,F
01BDC:  MOVF   02,W
01BDE:  SUBWFB x16,F
01BE0:  MOVF   03,W
01BE2:  SUBWFB x17,F
....................    sumCos-=(cosMax+cosMin);
01BE4:  MOVF   x28,W
01BE6:  ADDWF  x24,W
01BE8:  MOVWF  00
01BEA:  MOVF   x29,W
01BEC:  ADDWFC x25,W
01BEE:  MOVWF  01
01BF0:  MOVF   x2A,W
01BF2:  ADDWFC x26,W
01BF4:  MOVWF  02
01BF6:  MOVF   x2B,W
01BF8:  ADDWFC x27,W
01BFA:  MOVWF  03
01BFC:  MOVF   00,W
01BFE:  SUBWF  x18,F
01C00:  MOVF   01,W
01C02:  SUBWFB x19,F
01C04:  MOVF   02,W
01C06:  SUBWFB x1A,F
01C08:  MOVF   03,W
01C0A:  SUBWFB x1B,F
....................    
....................    // calc AVG
....................    smData[ch].avgSin = sumSin / (BUFFER_SIZE-2);
01C0C:  MOVF   x03,W
01C0E:  MULLW  09
01C10:  MOVF   FF3,W
01C12:  CLRF   x2E
01C14:  MOVWF  x2D
01C16:  MOVLW  01
01C18:  ADDWF  x2D,W
01C1A:  MOVWF  01
01C1C:  MOVLW  00
01C1E:  ADDWFC x2E,W
01C20:  MOVWF  03
01C22:  MOVF   01,W
01C24:  ADDLW  D4
01C26:  MOVWF  FE9
01C28:  MOVLW  01
01C2A:  ADDWFC 03,W
01C2C:  MOVWF  FEA
01C2E:  MOVFF  FEA,730
01C32:  MOVFF  FE9,72F
01C36:  BCF    FD8.1
01C38:  MOVFF  717,734
01C3C:  MOVFF  716,733
01C40:  MOVFF  715,732
01C44:  MOVFF  714,731
01C48:  CLRF   x38
01C4A:  CLRF   x37
01C4C:  CLRF   x36
01C4E:  MOVLW  03
01C50:  MOVWF  x35
01C52:  MOVLB  0
01C54:  RCALL  1690
01C56:  MOVFF  730,FEA
01C5A:  MOVFF  72F,FE9
01C5E:  MOVFF  00,FEF
01C62:  MOVFF  01,FEC
01C66:  MOVFF  02,FEC
01C6A:  MOVFF  03,FEC
....................    smData[ch].avgCos = sumCos / (BUFFER_SIZE-2);
01C6E:  MOVLB  7
01C70:  MOVF   x03,W
01C72:  MULLW  09
01C74:  MOVF   FF3,W
01C76:  CLRF   x2E
01C78:  MOVWF  x2D
01C7A:  MOVLW  05
01C7C:  ADDWF  x2D,W
01C7E:  MOVWF  01
01C80:  MOVLW  00
01C82:  ADDWFC x2E,W
01C84:  MOVWF  03
01C86:  MOVF   01,W
01C88:  ADDLW  D4
01C8A:  MOVWF  FE9
01C8C:  MOVLW  01
01C8E:  ADDWFC 03,W
01C90:  MOVWF  FEA
01C92:  MOVFF  FEA,730
01C96:  MOVFF  FE9,72F
01C9A:  BCF    FD8.1
01C9C:  MOVFF  71B,734
01CA0:  MOVFF  71A,733
01CA4:  MOVFF  719,732
01CA8:  MOVFF  718,731
01CAC:  CLRF   x38
01CAE:  CLRF   x37
01CB0:  CLRF   x36
01CB2:  MOVLW  03
01CB4:  MOVWF  x35
01CB6:  MOVLB  0
01CB8:  RCALL  1690
01CBA:  MOVFF  730,FEA
01CBE:  MOVFF  72F,FE9
01CC2:  MOVFF  00,FEF
01CC6:  MOVFF  01,FEC
01CCA:  MOVFF  02,FEC
01CCE:  MOVFF  03,FEC
01CD2:  GOTO   4546 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                 */
.................... /*****************************************************************************/
.................... void sensor_monitor_task(){
*
04462:  MOVLB  6
04464:  CLRF   xFE
04466:  CLRF   xFD
04468:  CLRF   xFC
0446A:  CLRF   xFB
0446C:  MOVLB  7
0446E:  CLRF   x02
04470:  CLRF   x01
04472:  CLRF   x00
04474:  MOVLB  6
04476:  CLRF   xFF
....................    static int8 ch = 0;
....................    signed int32 sinNew = 0;
....................    signed int32 cosNew = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
04478:  MOVLB  1
0447A:  MOVF   xE8,W
0447C:  MULLW  09
0447E:  MOVF   FF3,W
04480:  MOVLB  7
04482:  CLRF   x04
04484:  MOVWF  x03
04486:  MOVLW  D4
04488:  ADDWF  x03,W
0448A:  MOVWF  FE9
0448C:  MOVLW  01
0448E:  ADDWFC x04,W
04490:  MOVWF  FEA
04492:  BTFSC  FEF.1
04494:  BRA    4612
04496:  MOVLB  1
04498:  MOVF   xE8,W
0449A:  MULLW  09
0449C:  MOVF   FF3,W
0449E:  MOVLB  7
044A0:  CLRF   x06
044A2:  MOVWF  x05
044A4:  MOVLW  D4
044A6:  ADDWF  x05,W
044A8:  MOVWF  FE9
044AA:  MOVLW  01
044AC:  ADDWFC x06,W
044AE:  MOVWF  FEA
044B0:  BTFSS  FEF.0
044B2:  BRA    4612
....................       smData[ch].adcBusy = true;
044B4:  MOVLB  1
044B6:  MOVF   xE8,W
044B8:  MULLW  09
044BA:  MOVF   FF3,W
044BC:  MOVLB  7
044BE:  CLRF   x04
044C0:  MOVWF  x03
044C2:  MOVLW  D4
044C4:  ADDWF  x03,W
044C6:  MOVWF  FE9
044C8:  MOVLW  01
044CA:  ADDWFC x04,W
044CC:  MOVWF  FEA
044CE:  BSF    FEF.1
....................       
....................       sinNew = ads_read_data(ch*2);
044D0:  BCF    FD8.0
044D2:  MOVLB  1
044D4:  RLCF   xE8,W
044D6:  MOVLB  7
044D8:  MOVWF  x03
044DA:  MOVWF  x04
044DC:  MOVLB  0
044DE:  CALL   0860
044E2:  MOVFF  03,6FE
044E6:  MOVFF  02,6FD
044EA:  MOVFF  01,6FC
044EE:  MOVFF  00,6FB
....................       cosNew = ads_read_data(ch*2+1);      
044F2:  BCF    FD8.0
044F4:  MOVLB  1
044F6:  RLCF   xE8,W
044F8:  ADDLW  01
044FA:  MOVLB  7
044FC:  MOVWF  x03
044FE:  MOVWF  x04
04500:  MOVLB  0
04502:  CALL   0860
04506:  MOVFF  03,702
0450A:  MOVFF  02,701
0450E:  MOVFF  01,700
04512:  MOVFF  00,6FF
....................       
....................       if (adcFilter){
04516:  MOVLB  1
04518:  BTFSS  x63.0
0451A:  BRA    454A
....................          iqm_ring_buffer(ch, sinNew, cosNew);
0451C:  MOVFF  1E8,703
04520:  MOVFF  6FE,707
04524:  MOVFF  6FD,706
04528:  MOVFF  6FC,705
0452C:  MOVFF  6FB,704
04530:  MOVFF  702,70B
04534:  MOVFF  701,70A
04538:  MOVFF  700,709
0453C:  MOVFF  6FF,708
04540:  MOVLB  0
04542:  GOTO   177A
....................       }
04546:  BRA    45B6
04548:  MOVLB  1
....................       else{
....................          smData[ch].avgSin = sinNew;
0454A:  MOVF   xE8,W
0454C:  MULLW  09
0454E:  MOVF   FF3,W
04550:  MOVLB  7
04552:  CLRF   x04
04554:  MOVWF  x03
04556:  MOVLW  01
04558:  ADDWF  x03,W
0455A:  MOVWF  01
0455C:  MOVLW  00
0455E:  ADDWFC x04,W
04560:  MOVWF  03
04562:  MOVF   01,W
04564:  ADDLW  D4
04566:  MOVWF  FE9
04568:  MOVLW  01
0456A:  ADDWFC 03,W
0456C:  MOVWF  FEA
0456E:  MOVFF  6FB,FEF
04572:  MOVFF  6FC,FEC
04576:  MOVFF  6FD,FEC
0457A:  MOVFF  6FE,FEC
....................          smData[ch].avgCos = cosNew;
0457E:  MOVLB  1
04580:  MOVF   xE8,W
04582:  MULLW  09
04584:  MOVF   FF3,W
04586:  MOVLB  7
04588:  CLRF   x04
0458A:  MOVWF  x03
0458C:  MOVLW  05
0458E:  ADDWF  x03,W
04590:  MOVWF  01
04592:  MOVLW  00
04594:  ADDWFC x04,W
04596:  MOVWF  03
04598:  MOVF   01,W
0459A:  ADDLW  D4
0459C:  MOVWF  FE9
0459E:  MOVLW  01
045A0:  ADDWFC 03,W
045A2:  MOVWF  FEA
045A4:  MOVFF  6FF,FEF
045A8:  MOVFF  700,FEC
045AC:  MOVFF  701,FEC
045B0:  MOVFF  702,FEC
045B4:  MOVLB  0
....................       }
....................       
....................       sensor_process_data(ch);
045B6:  MOVFF  1E8,703
045BA:  GOTO   3710
....................       ch = !ch;
045BE:  MOVLB  1
045C0:  MOVF   xE8,F
045C2:  BZ    45C8
045C4:  MOVLW  00
045C6:  BRA    45CA
045C8:  MOVLW  01
045CA:  MOVWF  xE8
....................       
....................       smData[!ch].dataReady = false;
045CC:  MOVF   xE8,F
045CE:  BZ    45D4
045D0:  MOVLW  00
045D2:  BRA    45D6
045D4:  MOVLW  01
045D6:  MULLW  09
045D8:  MOVF   FF3,W
045DA:  MOVLB  7
045DC:  CLRF   x04
045DE:  MOVWF  x03
045E0:  MOVLW  D4
045E2:  ADDWF  x03,W
045E4:  MOVWF  FE9
045E6:  MOVLW  01
045E8:  ADDWFC x04,W
045EA:  MOVWF  FEA
045EC:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
045EE:  MOVLB  1
045F0:  MOVF   xE8,F
045F2:  BZ    45F8
045F4:  MOVLW  00
045F6:  BRA    45FA
045F8:  MOVLW  01
045FA:  MULLW  09
045FC:  MOVF   FF3,W
045FE:  MOVLB  7
04600:  CLRF   x04
04602:  MOVWF  x03
04604:  MOVLW  D4
04606:  ADDWF  x03,W
04608:  MOVWF  FE9
0460A:  MOVLW  01
0460C:  ADDWFC x04,W
0460E:  MOVWF  FEA
04610:  BCF    FEF.1
....................    }
04612:  MOVLB  0
04614:  GOTO   A6EE (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs(){
*
0096E:  MOVLB  6
00970:  CLRF   xFB
00972:  CLRF   xFC
00974:  CLRF   xFD
00976:  CLRF   xFE
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for (int ch = 0; ch < 4; ch++){
00978:  CLRF   xFF
0097A:  MOVF   xFF,W
0097C:  SUBLW  03
0097E:  BNC   09B4
....................       rc0=reg0config;
00980:  MOVLW  30
00982:  MOVWF  xFB
....................       rc1=reg1config;
00984:  MOVLW  10
00986:  MOVWF  xFC
....................       rc2=reg2config;
00988:  CLRF   xFD
....................       rc3=reg3config;
0098A:  CLRF   xFE
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0098C:  MOVFF  6FF,701
00990:  MOVFF  6FB,702
00994:  MOVFF  6FC,703
00998:  MOVFF  6FD,704
0099C:  MOVFF  6FE,705
009A0:  MOVLB  0
009A2:  BRA    0792
....................       delay_ms(100);
009A4:  MOVLW  64
009A6:  MOVLB  7
009A8:  MOVWF  x01
009AA:  MOVLB  0
009AC:  RCALL  03CC
009AE:  MOVLB  6
009B0:  INCF   xFF,F
009B2:  BRA    097A
....................    }
....................    
....................    if (adcFilter){
009B4:  MOVLB  1
009B6:  BTFSS  x63.0
009B8:  BRA    0ADA
....................       for (int i = 0; i < BUFFER_SIZE; i++){
009BA:  MOVLB  7
009BC:  CLRF   x00
009BE:  MOVF   x00,W
009C0:  SUBLW  04
009C2:  BTFSS  FD8.0
009C4:  BRA    0AD8
....................          ads_start_conv_all();
009C6:  MOVLB  0
009C8:  BRA    0830
....................          delay_ms(50);
009CA:  MOVLW  32
009CC:  MOVLB  7
009CE:  MOVWF  x01
009D0:  MOVLB  0
009D2:  RCALL  03CC
....................          push(sQ_x, &sIn_x, ads_read_data(0));
009D4:  MOVLB  7
009D6:  CLRF   x04
009D8:  MOVLB  0
009DA:  RCALL  0860
009DC:  MOVFF  03,704
009E0:  MOVFF  02,703
009E4:  MOVFF  01,702
009E8:  MOVFF  00,701
009EC:  MOVLW  01
009EE:  MOVLB  7
009F0:  MOVWF  x2E
009F2:  MOVLW  80
009F4:  MOVWF  x2D
009F6:  MOVLW  01
009F8:  MOVWF  x30
009FA:  MOVLW  D0
009FC:  MOVWF  x2F
009FE:  MOVFF  03,734
00A02:  MOVFF  02,733
00A06:  MOVFF  01,732
00A0A:  MOVFF  00,731
00A0E:  MOVLB  0
00A10:  RCALL  0908
....................          push(cQ_x, &cIn_x, ads_read_data(1));      
00A12:  MOVLW  01
00A14:  MOVLB  7
00A16:  MOVWF  x04
00A18:  MOVLB  0
00A1A:  RCALL  0860
00A1C:  MOVFF  03,704
00A20:  MOVFF  02,703
00A24:  MOVFF  01,702
00A28:  MOVFF  00,701
00A2C:  MOVLW  01
00A2E:  MOVLB  7
00A30:  MOVWF  x2E
00A32:  MOVLW  94
00A34:  MOVWF  x2D
00A36:  MOVLW  01
00A38:  MOVWF  x30
00A3A:  MOVLW  D1
00A3C:  MOVWF  x2F
00A3E:  MOVFF  03,734
00A42:  MOVFF  02,733
00A46:  MOVFF  01,732
00A4A:  MOVFF  00,731
00A4E:  MOVLB  0
00A50:  RCALL  0908
....................          push(sQ_y, &sIn_y, ads_read_data(2));
00A52:  MOVLW  02
00A54:  MOVLB  7
00A56:  MOVWF  x04
00A58:  MOVLB  0
00A5A:  RCALL  0860
00A5C:  MOVFF  03,704
00A60:  MOVFF  02,703
00A64:  MOVFF  01,702
00A68:  MOVFF  00,701
00A6C:  MOVLW  01
00A6E:  MOVLB  7
00A70:  MOVWF  x2E
00A72:  MOVLW  A8
00A74:  MOVWF  x2D
00A76:  MOVLW  01
00A78:  MOVWF  x30
00A7A:  MOVLW  D2
00A7C:  MOVWF  x2F
00A7E:  MOVFF  03,734
00A82:  MOVFF  02,733
00A86:  MOVFF  01,732
00A8A:  MOVFF  00,731
00A8E:  MOVLB  0
00A90:  RCALL  0908
....................          push(cQ_y, &cIn_y, ads_read_data(3));      
00A92:  MOVLW  03
00A94:  MOVLB  7
00A96:  MOVWF  x04
00A98:  MOVLB  0
00A9A:  RCALL  0860
00A9C:  MOVFF  03,704
00AA0:  MOVFF  02,703
00AA4:  MOVFF  01,702
00AA8:  MOVFF  00,701
00AAC:  MOVLW  01
00AAE:  MOVLB  7
00AB0:  MOVWF  x2E
00AB2:  MOVLW  BC
00AB4:  MOVWF  x2D
00AB6:  MOVLW  01
00AB8:  MOVWF  x30
00ABA:  MOVLW  D3
00ABC:  MOVWF  x2F
00ABE:  MOVFF  03,734
00AC2:  MOVFF  02,733
00AC6:  MOVFF  01,732
00ACA:  MOVFF  00,731
00ACE:  MOVLB  0
00AD0:  RCALL  0908
00AD2:  MOVLB  7
00AD4:  INCF   x00,F
00AD6:  BRA    09BE
00AD8:  MOVLB  1
....................       }
....................    }
00ADA:  MOVLB  0
00ADC:  GOTO   0B40 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init(){
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
00AE0:  MOVLW  00
00AE2:  MOVLB  F
00AE4:  MOVWF  x53
00AE6:  MOVLW  40
00AE8:  MOVWF  x0C
00AEA:  MOVLW  00
00AEC:  MOVWF  x14
00AEE:  MOVLW  03
00AF0:  MOVWF  x1C
00AF2:  MOVLW  0F
00AF4:  MOVWF  x21
00AF6:  MOVLW  00
00AF8:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00AFA:  MOVLW  08
00AFC:  MOVWF  x55
00AFE:  CLRF   x56
00B00:  CLRF   x52
00B02:  SETF   x57
00B04:  CLRF   F61
00B06:  MOVLW  94
00B08:  MOVWF  x5B
....................    output_high(EN_EXC);
00B0A:  MOVLW  E8
00B0C:  MOVWF  F8B
00B0E:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00B10:  MOVF   x5A,W
00B12:  ANDLW  3F
00B14:  MOVWF  01
00B16:  MOVLW  06
00B18:  MOVWF  x5A
00B1A:  BTFSS  x5B.7
00B1C:  BRA    0B2C
00B1E:  MOVF   01,W
00B20:  SUBLW  06
00B22:  BZ    0B2C
00B24:  BSF    x5B.0
00B26:  NOP   
00B28:  BTFSC  x5B.0
00B2A:  BRA    0B28
....................    delay_ms(10);
00B2C:  MOVLW  0A
00B2E:  MOVLB  7
00B30:  MOVWF  x01
00B32:  MOVLB  0
00B34:  RCALL  03CC
....................    read_adc(ADC_START_ONLY);
00B36:  MOVLB  F
00B38:  BSF    x5B.0
00B3A:  NOP   
....................    setup_external_ADCs();
00B3C:  MOVLB  0
00B3E:  BRA    096E
....................    intTimeoutReg = sensorSampleRate;
00B40:  MOVLB  1
00B42:  CLRF   x7F
00B44:  MOVLW  32
00B46:  MOVWF  x7E
00B48:  MOVLB  0
00B4A:  GOTO   A6D0 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
046E0:  MOVLB  7
046E2:  MOVF   x01,W
046E4:  MULLW  28
046E6:  MOVF   FF3,W
046E8:  CLRF   x0F
046EA:  MOVWF  x0E
046EC:  MOVLW  0C
046EE:  ADDWF  x0E,W
046F0:  MOVWF  01
046F2:  MOVLW  00
046F4:  ADDWFC x0F,W
046F6:  MOVWF  03
046F8:  MOVF   01,W
046FA:  ADDLW  20
046FC:  MOVWF  FE9
046FE:  MOVLW  00
04700:  ADDWFC 03,W
04702:  MOVWF  FEA
04704:  MOVFF  FEF,74A
04708:  MOVFF  FEC,74B
0470C:  MOVFF  FEC,74C
04710:  MOVFF  FEC,74D
04714:  MOVF   x01,W
04716:  MULLW  28
04718:  MOVF   FF3,W
0471A:  CLRF   x13
0471C:  MOVWF  x12
0471E:  MOVLW  10
04720:  ADDWF  x12,W
04722:  MOVWF  01
04724:  MOVLW  00
04726:  ADDWFC x13,W
04728:  MOVWF  03
0472A:  MOVF   01,W
0472C:  ADDLW  20
0472E:  MOVWF  FE9
04730:  MOVLW  00
04732:  ADDWFC 03,W
04734:  MOVWF  FEA
04736:  MOVFF  FEF,74E
0473A:  MOVFF  FEC,01
0473E:  MOVFF  FEC,02
04742:  MOVFF  FEC,03
04746:  MOVFF  FEA,713
0474A:  MOVFF  FE9,712
0474E:  BSF    FD8.1
04750:  MOVFF  03,751
04754:  MOVFF  02,750
04758:  MOVFF  01,74F
0475C:  MOVLB  0
0475E:  CALL   0E9A
04762:  MOVFF  713,FEA
04766:  MOVFF  712,FE9
0476A:  MOVFF  03,705
0476E:  MOVFF  02,704
04772:  MOVFF  01,703
04776:  MOVFF  00,702
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
0477A:  MOVLB  7
0477C:  MOVF   x01,W
0477E:  MULLW  28
04780:  MOVF   FF3,W
04782:  CLRF   x0F
04784:  MOVWF  x0E
04786:  MOVLW  1C
04788:  ADDWF  x0E,W
0478A:  MOVWF  01
0478C:  MOVLW  00
0478E:  ADDWFC x0F,W
04790:  MOVWF  03
04792:  MOVF   01,W
04794:  ADDLW  20
04796:  MOVWF  01
04798:  MOVLW  00
0479A:  ADDWFC 03,F
0479C:  MOVFF  01,70E
047A0:  MOVFF  03,70F
047A4:  MOVFF  03,FEA
047A8:  MOVFF  01,FE9
047AC:  MOVFF  FEF,710
047B0:  MOVFF  FEC,711
047B4:  MOVFF  FEC,712
047B8:  MOVFF  FEC,713
047BC:  MOVF   x01,W
047BE:  MULLW  28
047C0:  MOVF   FF3,W
047C2:  CLRF   x15
047C4:  MOVWF  x14
047C6:  MOVLW  04
047C8:  ADDWF  x14,W
047CA:  MOVWF  01
047CC:  MOVLW  00
047CE:  ADDWFC x15,W
047D0:  MOVWF  03
047D2:  MOVF   01,W
047D4:  ADDLW  20
047D6:  MOVWF  FE9
047D8:  MOVLW  00
047DA:  ADDWFC 03,W
047DC:  MOVWF  FEA
047DE:  MOVFF  FEF,754
047E2:  MOVFF  FEC,01
047E6:  MOVFF  FEC,02
047EA:  MOVFF  FEC,03
047EE:  MOVFF  705,753
047F2:  MOVFF  704,752
047F6:  MOVFF  703,751
047FA:  MOVFF  702,750
047FE:  MOVFF  03,757
04802:  MOVFF  02,756
04806:  MOVFF  01,755
0480A:  MOVLB  0
0480C:  CALL   0DA4
04810:  BCF    FD8.1
04812:  MOVFF  713,74D
04816:  MOVFF  712,74C
0481A:  MOVFF  711,74B
0481E:  MOVFF  710,74A
04822:  MOVFF  03,751
04826:  MOVFF  02,750
0482A:  MOVFF  01,74F
0482E:  MOVFF  00,74E
04832:  CALL   0E9A
04836:  MOVFF  70F,FEA
0483A:  MOVFF  70E,FE9
0483E:  MOVFF  00,FEF
04842:  MOVFF  01,FEC
04846:  MOVFF  02,FEC
0484A:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
0484E:  MOVLB  7
04850:  MOVF   x01,W
04852:  MULLW  28
04854:  MOVF   FF3,W
04856:  CLRF   x0F
04858:  MOVWF  x0E
0485A:  MOVLW  1C
0485C:  ADDWF  x0E,W
0485E:  MOVWF  01
04860:  MOVLW  00
04862:  ADDWFC x0F,W
04864:  MOVWF  03
04866:  MOVF   01,W
04868:  ADDLW  20
0486A:  MOVWF  FE9
0486C:  MOVLW  00
0486E:  ADDWFC 03,W
04870:  MOVWF  FEA
04872:  MOVFF  FEF,74A
04876:  MOVFF  FEC,70F
0487A:  MOVFF  FEC,74C
0487E:  MOVFF  FEC,74D
04882:  CLRF   x49
04884:  CLRF   x48
04886:  MOVLW  7C
04888:  MOVWF  x47
0488A:  MOVLW  84
0488C:  MOVWF  x46
0488E:  MOVFF  70F,74B
04892:  MOVLB  0
04894:  CALL   1D30
04898:  BNC   48CC
0489A:  MOVLB  7
0489C:  MOVF   x01,W
0489E:  MULLW  28
048A0:  MOVF   FF3,W
048A2:  CLRF   x0F
048A4:  MOVWF  x0E
048A6:  MOVLW  1C
048A8:  ADDWF  x0E,W
048AA:  MOVWF  01
048AC:  MOVLW  00
048AE:  ADDWFC x0F,W
048B0:  MOVWF  03
048B2:  MOVF   01,W
048B4:  ADDLW  20
048B6:  MOVWF  FE9
048B8:  MOVLW  00
048BA:  ADDWFC 03,W
048BC:  MOVWF  FEA
048BE:  MOVLW  84
048C0:  MOVWF  FEF
048C2:  MOVLW  7C
048C4:  MOVWF  FEC
048C6:  CLRF   FEC
048C8:  CLRF   FEC
048CA:  BRA    4948
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
048CC:  MOVLB  7
048CE:  MOVF   x01,W
048D0:  MULLW  28
048D2:  MOVF   FF3,W
048D4:  CLRF   x0F
048D6:  MOVWF  x0E
048D8:  MOVLW  1C
048DA:  ADDWF  x0E,W
048DC:  MOVWF  01
048DE:  MOVLW  00
048E0:  ADDWFC x0F,W
048E2:  MOVWF  03
048E4:  MOVF   01,W
048E6:  ADDLW  20
048E8:  MOVWF  FE9
048EA:  MOVLW  00
048EC:  ADDWFC 03,W
048EE:  MOVWF  FEA
048F0:  MOVFF  FEF,746
048F4:  MOVFF  FEC,70F
048F8:  MOVFF  FEC,748
048FC:  MOVFF  FEC,749
04900:  MOVFF  70F,747
04904:  CLRF   x4D
04906:  CLRF   x4C
04908:  MOVLW  C0
0490A:  MOVWF  x4B
0490C:  MOVLW  82
0490E:  MOVWF  x4A
04910:  MOVLB  0
04912:  CALL   1D30
04916:  BNC   494A
04918:  MOVLB  7
0491A:  MOVF   x01,W
0491C:  MULLW  28
0491E:  MOVF   FF3,W
04920:  CLRF   x0F
04922:  MOVWF  x0E
04924:  MOVLW  1C
04926:  ADDWF  x0E,W
04928:  MOVWF  01
0492A:  MOVLW  00
0492C:  ADDWFC x0F,W
0492E:  MOVWF  03
04930:  MOVF   01,W
04932:  ADDLW  20
04934:  MOVWF  FE9
04936:  MOVLW  00
04938:  ADDWFC 03,W
0493A:  MOVWF  FEA
0493C:  MOVLW  82
0493E:  MOVWF  FEF
04940:  MOVLW  C0
04942:  MOVWF  FEC
04944:  CLRF   FEC
04946:  CLRF   FEC
04948:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
0494A:  MOVLB  7
0494C:  MOVF   x01,W
0494E:  MULLW  28
04950:  MOVF   FF3,W
04952:  CLRF   x0F
04954:  MOVWF  x0E
04956:  MOVLW  20
04958:  ADDWF  x0E,W
0495A:  MOVWF  FE9
0495C:  MOVLW  00
0495E:  ADDWFC x0F,W
04960:  MOVWF  FEA
04962:  MOVFF  FEF,754
04966:  MOVFF  FEC,01
0496A:  MOVFF  FEC,02
0496E:  MOVFF  FEC,03
04972:  MOVFF  705,753
04976:  MOVFF  704,752
0497A:  MOVFF  703,751
0497E:  MOVFF  702,750
04982:  MOVFF  03,757
04986:  MOVFF  02,756
0498A:  MOVFF  01,755
0498E:  MOVLB  0
04990:  CALL   0DA4
04994:  MOVFF  03,709
04998:  MOVFF  02,708
0499C:  MOVFF  01,707
049A0:  MOVFF  00,706
049A4:  MOVLB  7
049A6:  MOVF   x01,W
049A8:  MULLW  28
049AA:  MOVF   FF3,W
049AC:  CLRF   x11
049AE:  MOVWF  x10
049B0:  MOVLW  08
049B2:  ADDWF  x10,W
049B4:  MOVWF  01
049B6:  MOVLW  00
049B8:  ADDWFC x11,W
049BA:  MOVWF  03
049BC:  MOVF   01,W
049BE:  ADDLW  20
049C0:  MOVWF  FE9
049C2:  MOVLW  00
049C4:  ADDWFC 03,W
049C6:  MOVWF  FEA
049C8:  MOVFF  FEF,710
049CC:  MOVFF  FEC,711
049D0:  MOVFF  FEC,712
049D4:  MOVFF  FEC,713
049D8:  MOVF   x01,W
049DA:  MULLW  28
049DC:  MOVF   FF3,W
049DE:  CLRF   x15
049E0:  MOVWF  x14
049E2:  MOVLW  10
049E4:  ADDWF  x14,W
049E6:  MOVWF  01
049E8:  MOVLW  00
049EA:  ADDWFC x15,W
049EC:  MOVWF  03
049EE:  MOVF   01,W
049F0:  ADDLW  20
049F2:  MOVWF  FE9
049F4:  MOVLW  00
049F6:  ADDWFC 03,W
049F8:  MOVWF  FEA
049FA:  MOVFF  FEF,74A
049FE:  MOVFF  FEC,74B
04A02:  MOVFF  FEC,74C
04A06:  MOVFF  FEC,74D
04A0A:  MOVF   x01,W
04A0C:  MULLW  28
04A0E:  MOVF   FF3,W
04A10:  CLRF   x19
04A12:  MOVWF  x18
04A14:  MOVLW  14
04A16:  ADDWF  x18,W
04A18:  MOVWF  01
04A1A:  MOVLW  00
04A1C:  ADDWFC x19,W
04A1E:  MOVWF  03
04A20:  MOVF   01,W
04A22:  ADDLW  20
04A24:  MOVWF  FE9
04A26:  MOVLW  00
04A28:  ADDWFC 03,W
04A2A:  MOVWF  FEA
04A2C:  MOVFF  FEF,74E
04A30:  MOVFF  FEC,01
04A34:  MOVFF  FEC,02
04A38:  MOVFF  FEC,03
04A3C:  MOVFF  FEA,719
04A40:  MOVFF  FE9,718
04A44:  BSF    FD8.1
04A46:  MOVFF  03,751
04A4A:  MOVFF  02,750
04A4E:  MOVFF  01,74F
04A52:  MOVLB  0
04A54:  CALL   0E9A
04A58:  MOVFF  719,FEA
04A5C:  MOVFF  718,FE9
04A60:  MOVFF  713,753
04A64:  MOVFF  712,752
04A68:  MOVFF  711,751
04A6C:  MOVFF  710,750
04A70:  MOVFF  03,757
04A74:  MOVFF  02,756
04A78:  MOVFF  01,755
04A7C:  MOVFF  00,754
04A80:  CALL   0DA4
04A84:  MOVFF  03,70D
04A88:  MOVFF  02,70C
04A8C:  MOVFF  01,70B
04A90:  MOVFF  00,70A
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
04A94:  MOVLB  7
04A96:  MOVF   x01,W
04A98:  MULLW  28
04A9A:  MOVF   FF3,W
04A9C:  CLRF   x0F
04A9E:  MOVWF  x0E
04AA0:  MOVLW  18
04AA2:  ADDWF  x0E,W
04AA4:  MOVWF  01
04AA6:  MOVLW  00
04AA8:  ADDWFC x0F,W
04AAA:  MOVWF  03
04AAC:  MOVF   01,W
04AAE:  ADDLW  20
04AB0:  MOVWF  01
04AB2:  MOVLW  00
04AB4:  ADDWFC 03,F
04AB6:  MOVFF  01,70E
04ABA:  MOVFF  03,70F
04ABE:  MOVF   x01,W
04AC0:  MULLW  28
04AC2:  MOVF   FF3,W
04AC4:  CLRF   x11
04AC6:  MOVWF  x10
04AC8:  MOVLW  1C
04ACA:  ADDWF  x10,W
04ACC:  MOVWF  01
04ACE:  MOVLW  00
04AD0:  ADDWFC x11,W
04AD2:  MOVWF  03
04AD4:  MOVF   01,W
04AD6:  ADDLW  20
04AD8:  MOVWF  FE9
04ADA:  MOVLW  00
04ADC:  ADDWFC 03,W
04ADE:  MOVWF  FEA
04AE0:  MOVFF  FEF,74E
04AE4:  MOVFF  FEC,01
04AE8:  MOVFF  FEC,02
04AEC:  MOVFF  FEC,03
04AF0:  MOVFF  FEA,711
04AF4:  MOVFF  FE9,710
04AF8:  BCF    FD8.1
04AFA:  MOVFF  709,74D
04AFE:  MOVFF  708,74C
04B02:  MOVFF  707,74B
04B06:  MOVFF  706,74A
04B0A:  MOVFF  03,751
04B0E:  MOVFF  02,750
04B12:  MOVFF  01,74F
04B16:  MOVLB  0
04B18:  CALL   0E9A
04B1C:  MOVFF  711,FEA
04B20:  MOVFF  710,FE9
04B24:  MOVFF  03,715
04B28:  MOVFF  02,714
04B2C:  MOVFF  01,713
04B30:  MOVFF  00,712
04B34:  BCF    FD8.1
04B36:  MOVFF  03,74D
04B3A:  MOVFF  02,74C
04B3E:  MOVFF  01,74B
04B42:  MOVFF  00,74A
04B46:  MOVFF  70D,751
04B4A:  MOVFF  70C,750
04B4E:  MOVFF  70B,74F
04B52:  MOVFF  70A,74E
04B56:  CALL   0E9A
04B5A:  MOVFF  70F,FEA
04B5E:  MOVFF  70E,FE9
04B62:  MOVFF  00,FEF
04B66:  MOVFF  01,FEC
04B6A:  MOVFF  02,FEC
04B6E:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04B72:  MOVLB  7
04B74:  MOVF   x01,W
04B76:  MULLW  28
04B78:  MOVF   FF3,W
04B7A:  CLRF   x0F
04B7C:  MOVWF  x0E
04B7E:  MOVLW  18
04B80:  ADDWF  x0E,W
04B82:  MOVWF  01
04B84:  MOVLW  00
04B86:  ADDWFC x0F,W
04B88:  MOVWF  03
04B8A:  MOVF   01,W
04B8C:  ADDLW  20
04B8E:  MOVWF  FE9
04B90:  MOVLW  00
04B92:  ADDWFC 03,W
04B94:  MOVWF  FEA
04B96:  MOVFF  FEF,74A
04B9A:  MOVFF  FEC,70F
04B9E:  MOVFF  FEC,74C
04BA2:  MOVFF  FEC,74D
04BA6:  CLRF   x49
04BA8:  CLRF   x48
04BAA:  MOVLW  7C
04BAC:  MOVWF  x47
04BAE:  MOVLW  84
04BB0:  MOVWF  x46
04BB2:  MOVFF  70F,74B
04BB6:  MOVLB  0
04BB8:  CALL   1D30
04BBC:  BNC   4BF0
04BBE:  MOVLB  7
04BC0:  MOVF   x01,W
04BC2:  MULLW  28
04BC4:  MOVF   FF3,W
04BC6:  CLRF   x0F
04BC8:  MOVWF  x0E
04BCA:  MOVLW  18
04BCC:  ADDWF  x0E,W
04BCE:  MOVWF  01
04BD0:  MOVLW  00
04BD2:  ADDWFC x0F,W
04BD4:  MOVWF  03
04BD6:  MOVF   01,W
04BD8:  ADDLW  20
04BDA:  MOVWF  FE9
04BDC:  MOVLW  00
04BDE:  ADDWFC 03,W
04BE0:  MOVWF  FEA
04BE2:  MOVLW  84
04BE4:  MOVWF  FEF
04BE6:  MOVLW  7C
04BE8:  MOVWF  FEC
04BEA:  CLRF   FEC
04BEC:  CLRF   FEC
04BEE:  BRA    4C6C
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
04BF0:  MOVLB  7
04BF2:  MOVF   x01,W
04BF4:  MULLW  28
04BF6:  MOVF   FF3,W
04BF8:  CLRF   x0F
04BFA:  MOVWF  x0E
04BFC:  MOVLW  18
04BFE:  ADDWF  x0E,W
04C00:  MOVWF  01
04C02:  MOVLW  00
04C04:  ADDWFC x0F,W
04C06:  MOVWF  03
04C08:  MOVF   01,W
04C0A:  ADDLW  20
04C0C:  MOVWF  FE9
04C0E:  MOVLW  00
04C10:  ADDWFC 03,W
04C12:  MOVWF  FEA
04C14:  MOVFF  FEF,746
04C18:  MOVFF  FEC,70F
04C1C:  MOVFF  FEC,748
04C20:  MOVFF  FEC,749
04C24:  MOVFF  70F,747
04C28:  CLRF   x4D
04C2A:  CLRF   x4C
04C2C:  MOVLW  C0
04C2E:  MOVWF  x4B
04C30:  MOVLW  82
04C32:  MOVWF  x4A
04C34:  MOVLB  0
04C36:  CALL   1D30
04C3A:  BNC   4C6C
04C3C:  MOVLB  7
04C3E:  MOVF   x01,W
04C40:  MULLW  28
04C42:  MOVF   FF3,W
04C44:  CLRF   x0F
04C46:  MOVWF  x0E
04C48:  MOVLW  18
04C4A:  ADDWF  x0E,W
04C4C:  MOVWF  01
04C4E:  MOVLW  00
04C50:  ADDWFC x0F,W
04C52:  MOVWF  03
04C54:  MOVF   01,W
04C56:  ADDLW  20
04C58:  MOVWF  FE9
04C5A:  MOVLW  00
04C5C:  ADDWFC 03,W
04C5E:  MOVWF  FEA
04C60:  MOVLW  82
04C62:  MOVWF  FEF
04C64:  MOVLW  C0
04C66:  MOVWF  FEC
04C68:  CLRF   FEC
04C6A:  CLRF   FEC
04C6C:  MOVLB  0
04C6E:  GOTO   4CEC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04C72:  MOVLB  6
04C74:  MOVF   xFE,W
04C76:  MULLW  28
04C78:  MOVF   FF3,W
04C7A:  MOVLB  7
04C7C:  CLRF   x01
04C7E:  MOVWF  x00
04C80:  MOVLW  0C
04C82:  ADDWF  x00,W
04C84:  MOVWF  01
04C86:  MOVLW  00
04C88:  ADDWFC x01,W
04C8A:  MOVWF  03
04C8C:  MOVF   01,W
04C8E:  ADDLW  20
04C90:  MOVWF  FE9
04C92:  MOVLW  00
04C94:  ADDWFC 03,W
04C96:  MOVWF  FEA
04C98:  MOVFF  FEF,746
04C9C:  MOVFF  FEC,747
04CA0:  MOVFF  FEC,748
04CA4:  MOVFF  FEC,749
04CA8:  MOVLB  6
04CAA:  MOVF   xFE,W
04CAC:  MULLW  28
04CAE:  MOVF   FF3,W
04CB0:  MOVLB  7
04CB2:  CLRF   x05
04CB4:  MOVWF  x04
04CB6:  MOVLW  10
04CB8:  ADDWF  x04,W
04CBA:  MOVWF  01
04CBC:  MOVLW  00
04CBE:  ADDWFC x05,W
04CC0:  MOVWF  03
04CC2:  MOVF   01,W
04CC4:  ADDLW  20
04CC6:  MOVWF  FE9
04CC8:  MOVLW  00
04CCA:  ADDWFC 03,W
04CCC:  MOVWF  FEA
04CCE:  MOVFF  FEF,74A
04CD2:  MOVFF  FEC,74B
04CD6:  MOVFF  FEC,74C
04CDA:  MOVFF  FEC,74D
04CDE:  MOVLB  0
04CE0:  CALL   1D30
04CE4:  BZ    4CEC
04CE6:  MOVFF  6FE,701
04CEA:  BRA    46E0
....................    if ((index++) >= numChannels) index = 0;
04CEC:  MOVLB  1
04CEE:  MOVF   xE9,W
04CF0:  INCF   xE9,F
04CF2:  SUBLW  01
04CF4:  BC    4CF8
04CF6:  CLRF   xE9
04CF8:  MOVLB  0
04CFA:  GOTO   4E0C (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
00B4E:  CLRF   03
00B50:  MOVF   F91,W
00B52:  MOVFF  700,F91
00B56:  RRCF   F94,W
00B58:  BNC   0B56
00B5A:  MOVF   F91,W
00B5C:  MOVWF  02
00B5E:  MOVFF  6FF,F91
00B62:  RRCF   F94,W
00B64:  BNC   0B62
00B66:  MOVF   F91,W
00B68:  MOVWF  01
00B6A:  MOVFF  6FE,F91
00B6E:  RRCF   F94,W
00B70:  BNC   0B6E
00B72:  MOVFF  F91,00
00B76:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
0464E:  MOVLB  6
04650:  MOVF   xFF,F
04652:  BZ    469A
....................       if (chMap[0] == ch) output_low(INV_HVX);
04654:  MOVLW  00
04656:  MOVLB  0
04658:  BTFSC  x70.0
0465A:  MOVLW  01
0465C:  MOVLB  6
0465E:  SUBWF  xFE,W
04660:  BNZ   4668
04662:  MOVLW  04
04664:  MOVWF  F88
04666:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
04668:  MOVLW  00
0466A:  MOVLB  0
0466C:  BTFSC  x70.1
0466E:  MOVLW  01
04670:  MOVLB  6
04672:  SUBWF  xFE,W
04674:  BNZ   467C
04676:  MOVLW  04
04678:  MOVWF  F88
0467A:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
0467C:  MOVF   xFE,W
0467E:  MULLW  07
04680:  MOVF   FF3,W
04682:  MOVLB  7
04684:  CLRF   x01
04686:  MOVWF  x00
04688:  MOVLW  64
0468A:  ADDWF  x00,W
0468C:  MOVWF  FE9
0468E:  MOVLW  01
04690:  ADDWFC x01,W
04692:  MOVWF  FEA
04694:  BSF    FEF.0
....................    }
04696:  BRA    46DC
04698:  MOVLB  6
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
0469A:  MOVLW  00
0469C:  MOVLB  0
0469E:  BTFSC  x70.0
046A0:  MOVLW  01
046A2:  MOVLB  6
046A4:  SUBWF  xFE,W
046A6:  BNZ   46AE
046A8:  MOVLW  04
046AA:  MOVWF  F88
046AC:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
046AE:  MOVLW  00
046B0:  MOVLB  0
046B2:  BTFSC  x70.1
046B4:  MOVLW  01
046B6:  MOVLB  6
046B8:  SUBWF  xFE,W
046BA:  BNZ   46C2
046BC:  MOVLW  04
046BE:  MOVWF  F88
046C0:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
046C2:  MOVF   xFE,W
046C4:  MULLW  07
046C6:  MOVF   FF3,W
046C8:  MOVLB  7
046CA:  CLRF   x01
046CC:  MOVWF  x00
046CE:  MOVLW  64
046D0:  ADDWF  x00,W
046D2:  MOVWF  FE9
046D4:  MOVLW  01
046D6:  ADDWFC x01,W
046D8:  MOVWF  FEA
046DA:  BCF    FEF.0
....................    }
046DC:  MOVLB  0
046DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
04CFE:  MOVLB  6
04D00:  CLRF   xFD
04D02:  CLRF   xFC
....................     unsigned int16 txData = 0;
....................    
....................     // use dacVals.opPcnt values if channel is manual mode
....................     // else, use PID control variable
....................     if (chMode[ch] == MANUAL){
04D04:  MOVFF  6FB,70D
04D08:  MOVLB  7
04D0A:  CLRF   x0F
04D0C:  MOVLW  71
04D0E:  MOVWF  x0E
04D10:  MOVLB  0
04D12:  RCALL  4618
04D14:  MOVF   01,F
04D16:  BNZ   4E06
....................         if ( dacVals[ch].opPcnt < 0) invert_voltage(ch, TRUE); 
04D18:  MOVLB  6
04D1A:  MOVF   xFB,W
04D1C:  MULLW  07
04D1E:  MOVF   FF3,W
04D20:  CLRF   xFF
04D22:  MOVWF  xFE
04D24:  MOVLW  03
04D26:  ADDWF  xFE,W
04D28:  MOVWF  01
04D2A:  MOVLW  00
04D2C:  ADDWFC xFF,W
04D2E:  MOVWF  03
04D30:  MOVF   01,W
04D32:  ADDLW  64
04D34:  MOVWF  FE9
04D36:  MOVLW  01
04D38:  ADDWFC 03,W
04D3A:  MOVWF  FEA
04D3C:  MOVFF  FEF,746
04D40:  MOVFF  FEC,747
04D44:  MOVFF  FEC,748
04D48:  MOVFF  FEC,749
04D4C:  MOVLB  7
04D4E:  CLRF   x4D
04D50:  CLRF   x4C
04D52:  CLRF   x4B
04D54:  CLRF   x4A
04D56:  MOVLB  0
04D58:  CALL   1D30
04D5C:  BNC   4D6E
04D5E:  MOVFF  6FB,6FE
04D62:  MOVLW  01
04D64:  MOVLB  6
04D66:  MOVWF  xFF
04D68:  MOVLB  0
04D6A:  RCALL  464E
04D6C:  BRA    4D7A
....................         else                         invert_voltage(ch, FALSE);
04D6E:  MOVFF  6FB,6FE
04D72:  MOVLB  6
04D74:  CLRF   xFF
04D76:  MOVLB  0
04D78:  RCALL  464E
....................       
....................         txData = (unsigned int16)(abs(dacVals[ch].opPcnt) * DACfullScale);
04D7A:  MOVLB  6
04D7C:  MOVF   xFB,W
04D7E:  MULLW  07
04D80:  MOVF   FF3,W
04D82:  CLRF   xFF
04D84:  MOVWF  xFE
04D86:  MOVLW  03
04D88:  ADDWF  xFE,W
04D8A:  MOVWF  01
04D8C:  MOVLW  00
04D8E:  ADDWFC xFF,W
04D90:  MOVWF  03
04D92:  MOVF   01,W
04D94:  ADDLW  64
04D96:  MOVWF  FE9
04D98:  MOVLW  01
04D9A:  ADDWFC 03,W
04D9C:  MOVWF  FEA
04D9E:  MOVFF  FEF,00
04DA2:  MOVFF  FEC,01
04DA6:  MOVFF  FEC,02
04DAA:  MOVFF  FEC,03
04DAE:  BCF    01.7
04DB0:  MOVFF  03,701
04DB4:  MOVFF  02,700
04DB8:  MOVFF  01,6FF
04DBC:  MOVFF  00,6FE
04DC0:  MOVFF  03,753
04DC4:  MOVFF  02,752
04DC8:  MOVFF  01,751
04DCC:  MOVFF  00,750
04DD0:  MOVLW  66
04DD2:  MOVLB  7
04DD4:  MOVWF  x57
04DD6:  MOVLW  D6
04DD8:  MOVWF  x56
04DDA:  MOVLW  23
04DDC:  MOVWF  x55
04DDE:  MOVLW  88
04DE0:  MOVWF  x54
04DE2:  MOVLB  0
04DE4:  CALL   0DA4
04DE8:  MOVFF  03,749
04DEC:  MOVFF  02,748
04DF0:  MOVFF  01,747
04DF4:  MOVFF  00,746
04DF8:  CALL   2724
04DFC:  MOVFF  02,6FD
04E00:  MOVFF  01,6FC
....................     }
04E04:  BRA    4EFC
....................     else {
....................         pid_task(ch);
04E06:  MOVFF  6FB,6FE
04E0A:  BRA    4C72
....................         if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
04E0C:  MOVLB  6
04E0E:  MOVF   xFB,W
04E10:  MULLW  28
04E12:  MOVF   FF3,W
04E14:  CLRF   xFF
04E16:  MOVWF  xFE
04E18:  MOVLW  18
04E1A:  ADDWF  xFE,W
04E1C:  MOVWF  01
04E1E:  MOVLW  00
04E20:  ADDWFC xFF,W
04E22:  MOVWF  03
04E24:  MOVF   01,W
04E26:  ADDLW  20
04E28:  MOVWF  FE9
04E2A:  MOVLW  00
04E2C:  ADDWFC 03,W
04E2E:  MOVWF  FEA
04E30:  MOVFF  FEF,746
04E34:  MOVFF  FEC,747
04E38:  MOVFF  FEC,748
04E3C:  MOVFF  FEC,749
04E40:  MOVLB  7
04E42:  CLRF   x4D
04E44:  CLRF   x4C
04E46:  CLRF   x4B
04E48:  CLRF   x4A
04E4A:  MOVLB  0
04E4C:  CALL   1D30
04E50:  BNC   4E64
04E52:  MOVFF  6FB,6FE
04E56:  MOVLW  01
04E58:  MOVLB  6
04E5A:  MOVWF  xFF
04E5C:  MOVLB  0
04E5E:  CALL   464E
04E62:  BRA    4E72
....................         else                       invert_voltage(ch, FALSE);
04E64:  MOVFF  6FB,6FE
04E68:  MOVLB  6
04E6A:  CLRF   xFF
04E6C:  MOVLB  0
04E6E:  CALL   464E
....................       
....................         txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04E72:  MOVLB  6
04E74:  MOVF   xFB,W
04E76:  MULLW  28
04E78:  MOVF   FF3,W
04E7A:  CLRF   xFF
04E7C:  MOVWF  xFE
04E7E:  MOVLW  18
04E80:  ADDWF  xFE,W
04E82:  MOVWF  01
04E84:  MOVLW  00
04E86:  ADDWFC xFF,W
04E88:  MOVWF  03
04E8A:  MOVF   01,W
04E8C:  ADDLW  20
04E8E:  MOVWF  FE9
04E90:  MOVLW  00
04E92:  ADDWFC 03,W
04E94:  MOVWF  FEA
04E96:  MOVFF  FEF,00
04E9A:  MOVFF  FEC,01
04E9E:  MOVFF  FEC,02
04EA2:  MOVFF  FEC,03
04EA6:  BCF    01.7
04EA8:  MOVFF  03,701
04EAC:  MOVFF  02,700
04EB0:  MOVFF  01,6FF
04EB4:  MOVFF  00,6FE
04EB8:  MOVFF  03,753
04EBC:  MOVFF  02,752
04EC0:  MOVFF  01,751
04EC4:  MOVFF  00,750
04EC8:  MOVLW  66
04ECA:  MOVLB  7
04ECC:  MOVWF  x57
04ECE:  MOVLW  D6
04ED0:  MOVWF  x56
04ED2:  MOVLW  23
04ED4:  MOVWF  x55
04ED6:  MOVLW  88
04ED8:  MOVWF  x54
04EDA:  MOVLB  0
04EDC:  CALL   0DA4
04EE0:  MOVFF  03,749
04EE4:  MOVFF  02,748
04EE8:  MOVFF  01,747
04EEC:  MOVFF  00,746
04EF0:  CALL   2724
04EF4:  MOVFF  02,6FD
04EF8:  MOVFF  01,6FC
....................     }
....................    
....................     dacVals[ch].ipVal = txData;
04EFC:  MOVLB  6
04EFE:  MOVF   xFB,W
04F00:  MULLW  07
04F02:  MOVF   FF3,W
04F04:  CLRF   xFF
04F06:  MOVWF  xFE
04F08:  MOVLW  01
04F0A:  ADDWF  xFE,W
04F0C:  MOVWF  01
04F0E:  MOVLW  00
04F10:  ADDWFC xFF,W
04F12:  MOVWF  03
04F14:  MOVF   01,W
04F16:  ADDLW  64
04F18:  MOVWF  FE9
04F1A:  MOVLW  01
04F1C:  ADDWFC 03,W
04F1E:  MOVWF  FEA
04F20:  MOVFF  6FD,FEC
04F24:  MOVF   FED,F
04F26:  MOVFF  6FC,FEF
....................    
....................     // use channel map to decide which outputs channels to update
....................     // strobe _sync low to push data to the outputs
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04F2A:  MOVLW  00
04F2C:  MOVLB  0
04F2E:  BTFSC  x70.0
04F30:  MOVLW  01
04F32:  MOVLB  6
04F34:  SUBWF  xFB,W
04F36:  BNZ   4F3E
04F38:  MOVLW  E8
04F3A:  MOVWF  F8B
04F3C:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04F3E:  MOVLW  00
04F40:  MOVLB  0
04F42:  BTFSC  x70.1
04F44:  MOVLW  01
04F46:  MOVLB  6
04F48:  SUBWF  xFB,W
04F4A:  BNZ   4F52
04F4C:  MOVLW  E8
04F4E:  MOVWF  F8B
04F50:  BSF    F86.1
....................    
....................     delay_ms(1);
04F52:  MOVLW  01
04F54:  MOVLB  7
04F56:  MOVWF  x01
04F58:  MOVLB  0
04F5A:  CALL   03CC
....................    
....................     if (chMap[0] == ch) output_low(_SYNC_X);
04F5E:  MOVLW  00
04F60:  BTFSC  x70.0
04F62:  MOVLW  01
04F64:  MOVLB  6
04F66:  SUBWF  xFB,W
04F68:  BNZ   4F70
04F6A:  MOVLW  E8
04F6C:  MOVWF  F8B
04F6E:  BCF    F86.2
....................     if (chMap[1] == ch) output_low(_SYNC_Y);
04F70:  MOVLW  00
04F72:  MOVLB  0
04F74:  BTFSC  x70.1
04F76:  MOVLW  01
04F78:  MOVLB  6
04F7A:  SUBWF  xFB,W
04F7C:  BNZ   4F84
04F7E:  MOVLW  E8
04F80:  MOVWF  F8B
04F82:  BCF    F86.1
....................     delay_ms(1);
04F84:  MOVLW  01
04F86:  MOVLB  7
04F88:  MOVWF  x01
04F8A:  MOVLB  0
04F8C:  CALL   03CC
....................    
....................     // shift 16 bits of data
....................     spi_xfer(SPI_ctrl, txData, 24);
04F90:  MOVLB  7
04F92:  CLRF   x01
04F94:  CLRF   x00
04F96:  MOVFF  6FD,6FF
04F9A:  MOVFF  6FC,6FE
04F9E:  MOVLB  0
04FA0:  CALL   0B4E
....................     delay_ms(1);
04FA4:  MOVLW  01
04FA6:  MOVLB  7
04FA8:  MOVWF  x01
04FAA:  MOVLB  0
04FAC:  CALL   03CC
....................    
....................     if (chMap[0] == ch) output_high(_SYNC_X);
04FB0:  MOVLW  00
04FB2:  BTFSC  x70.0
04FB4:  MOVLW  01
04FB6:  MOVLB  6
04FB8:  SUBWF  xFB,W
04FBA:  BNZ   4FC2
04FBC:  MOVLW  E8
04FBE:  MOVWF  F8B
04FC0:  BSF    F86.2
....................     if (chMap[1] == ch) output_high(_SYNC_Y);
04FC2:  MOVLW  00
04FC4:  MOVLB  0
04FC6:  BTFSC  x70.1
04FC8:  MOVLW  01
04FCA:  MOVLB  6
04FCC:  SUBWF  xFB,W
04FCE:  BNZ   4FD6
04FD0:  MOVLW  E8
04FD2:  MOVWF  F8B
04FD4:  BSF    F86.1
04FD6:  MOVLB  0
04FD8:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Axis homing routines and helper functions                                */ 
.................... /*****************************************************************************/
.................... void slew_to_upper_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt < op_upper_bound){
....................         dacVals[ch].opPcnt += 10;   // increase output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_upper_bound;    // set output to upper bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void slew_to_lower_bound(channelMap ch){
....................     chMode[ch] = MANUAL;        // set channel to manual
....................     
....................     while (dacVals[ch].opPcnt > op_lower_bound){
....................         dacVals[ch].opPcnt -= 10;   // decrease output by 10%
....................         set_nanoDAC_outputs(ch);
....................         delay_ms(500);
....................     }
....................     dacVals[ch].opPcnt = op_lower_bound;    // set output to lower bound
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
.................... }
.................... 
.................... void home_axis(channelMap ch){
....................     float maxSP = 0;
....................     float minSP = 0;
....................     int loops = 3;
....................     
....................     // Slew up and down a couple times then set output to 0 to settle the piezo
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     slew_to_upper_bound(ch);
....................     slew_to_lower_bound(ch);
....................     dacVals[ch].opPcnt = 0;
....................     set_nanoDAC_outputs(ch);
....................     delay_ms(500);
....................     
....................     for (int i=0; i<loops; i++){
....................         slew_to_upper_bound(ch);
....................         sensor_monitor_task();
....................         maxSP+=adcVals[ch].pReal;
....................         
....................         slew_to_lower_bound(ch);
....................         sensor_monitor_task();
....................         minSP+=adcVals[ch].pReal;
....................     }
....................     
....................     PID[ch].maxSP = maxSP / (float)loops;
....................     PID[ch].minSP = minSP / (float)loops;
....................     adcVals[ch].pHome = (maxSP+minSP) / ((float)loops*2);
....................     adcVals[ch].homeFlag = False;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04FDA:  MOVLB  1
04FDC:  MOVF   xEA,W
04FDE:  XORLW  00
04FE0:  MOVLB  0
04FE2:  BZ    4FEA
04FE4:  XORLW  01
04FE6:  BZ    4FFC
04FE8:  BRA    500C
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
04FEA:  MOVLB  6
04FEC:  CLRF   xFB
04FEE:  MOVLB  0
04FF0:  RCALL  4CFE
....................          state = 1;
04FF2:  MOVLW  01
04FF4:  MOVLB  1
04FF6:  MOVWF  xEA
....................       break;
04FF8:  MOVLB  0
04FFA:  BRA    500C
....................       case 1:
....................          set_nanoDAC_outputs(chY);
04FFC:  MOVLW  01
04FFE:  MOVLB  6
05000:  MOVWF  xFB
05002:  MOVLB  0
05004:  RCALL  4CFE
....................          state = 0;
05006:  MOVLB  1
05008:  CLRF   xEA
....................       break;
0500A:  MOVLB  0
....................    }
0500C:  GOTO   A700 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00B78:  MOVLB  7
00B7A:  CLRF   x01
00B7C:  CLRF   x00
00B7E:  MOVLB  6
00B80:  CLRF   xFF
00B82:  CLRF   xFE
00B84:  MOVLB  0
00B86:  RCALL  0B4E
....................    output_low(_SYNC_X);
00B88:  MOVLW  E8
00B8A:  MOVWF  F8B
00B8C:  BCF    F86.2
....................    output_low(_SYNC_Y);
00B8E:  MOVWF  F8B
00B90:  BCF    F86.1
....................    output_high(_SYNC_X);
00B92:  MOVWF  F8B
00B94:  BSF    F86.2
....................    output_high(_SYNC_Y);
00B96:  MOVWF  F8B
00B98:  BSF    F86.1
00B9A:  GOTO   A6D4 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
00B9E:  MOVLB  7
00BA0:  MOVF   x01,W
00BA2:  SUBLW  03
00BA4:  BTFSS  FD8.0
00BA6:  BRA    0D14
....................    {
....................       for (int i = 0; i <numParam; i ++)
00BA8:  CLRF   x02
00BAA:  MOVF   x02,W
00BAC:  SUBLW  06
00BAE:  BNC   0BFE
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
00BB0:  CLRF   x42
00BB2:  MOVFF  701,741
00BB6:  CLRF   x44
00BB8:  MOVLW  B5
00BBA:  MOVWF  x43
00BBC:  MOVLB  0
00BBE:  RCALL  08BA
00BC0:  MOVFF  02,704
00BC4:  MOVFF  01,703
00BC8:  MOVLW  06
00BCA:  MOVLB  7
00BCC:  ADDWF  x03,F
00BCE:  MOVLW  00
00BD0:  ADDWFC x04,F
00BD2:  CLRF   x42
00BD4:  MOVFF  702,741
00BD8:  CLRF   x44
00BDA:  MOVLW  19
00BDC:  MOVWF  x43
00BDE:  MOVLB  0
00BE0:  RCALL  08BA
00BE2:  MOVF   01,W
00BE4:  MOVLB  7
00BE6:  ADDWF  x03,F
00BE8:  MOVF   02,W
00BEA:  ADDWFC x04,F
00BEC:  MOVLW  EB
00BEE:  ADDWF  x03,W
00BF0:  MOVWF  FE9
00BF2:  MOVLW  01
00BF4:  ADDWFC x04,W
00BF6:  MOVWF  FEA
00BF8:  CLRF   FEF
00BFA:  INCF   x02,F
00BFC:  BRA    0BAA
....................       }
....................       SERcmd[recNum].t = 0;
00BFE:  CLRF   x42
00C00:  MOVFF  701,741
00C04:  CLRF   x44
00C06:  MOVLW  B5
00C08:  MOVWF  x43
00C0A:  MOVLB  0
00C0C:  RCALL  08BA
00C0E:  MOVFF  01,703
00C12:  MOVLW  05
00C14:  MOVLB  7
00C16:  ADDWF  01,W
00C18:  MOVWF  01
00C1A:  MOVLW  00
00C1C:  ADDWFC 02,W
00C1E:  MOVWF  03
00C20:  MOVF   01,W
00C22:  ADDLW  EB
00C24:  MOVWF  FE9
00C26:  MOVLW  01
00C28:  ADDWFC 03,W
00C2A:  MOVWF  FEA
00C2C:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00C2E:  CLRF   x42
00C30:  MOVFF  701,741
00C34:  CLRF   x44
00C36:  MOVLW  B5
00C38:  MOVWF  x43
00C3A:  MOVLB  0
00C3C:  RCALL  08BA
00C3E:  MOVFF  01,703
00C42:  MOVLW  01
00C44:  MOVLB  7
00C46:  ADDWF  01,W
00C48:  MOVWF  01
00C4A:  MOVLW  00
00C4C:  ADDWFC 02,W
00C4E:  MOVWF  03
00C50:  MOVF   01,W
00C52:  ADDLW  EB
00C54:  MOVWF  FE9
00C56:  MOVLW  01
00C58:  ADDWFC 03,W
00C5A:  MOVWF  FEA
00C5C:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00C5E:  CLRF   x42
00C60:  MOVFF  701,741
00C64:  CLRF   x44
00C66:  MOVLW  B5
00C68:  MOVWF  x43
00C6A:  MOVLB  0
00C6C:  RCALL  08BA
00C6E:  MOVFF  01,703
00C72:  MOVLW  02
00C74:  MOVLB  7
00C76:  ADDWF  01,W
00C78:  MOVWF  01
00C7A:  MOVLW  00
00C7C:  ADDWFC 02,W
00C7E:  MOVWF  03
00C80:  MOVF   01,W
00C82:  ADDLW  EB
00C84:  MOVWF  FE9
00C86:  MOVLW  01
00C88:  ADDWFC 03,W
00C8A:  MOVWF  FEA
00C8C:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
00C8E:  CLRF   x42
00C90:  MOVFF  701,741
00C94:  CLRF   x44
00C96:  MOVLW  B5
00C98:  MOVWF  x43
00C9A:  MOVLB  0
00C9C:  RCALL  08BA
00C9E:  MOVFF  01,703
00CA2:  MOVLW  03
00CA4:  MOVLB  7
00CA6:  ADDWF  01,W
00CA8:  MOVWF  01
00CAA:  MOVLW  00
00CAC:  ADDWFC 02,W
00CAE:  MOVWF  03
00CB0:  MOVF   01,W
00CB2:  ADDLW  EB
00CB4:  MOVWF  FE9
00CB6:  MOVLW  01
00CB8:  ADDWFC 03,W
00CBA:  MOVWF  FEA
00CBC:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
00CBE:  CLRF   x42
00CC0:  MOVFF  701,741
00CC4:  CLRF   x44
00CC6:  MOVLW  B5
00CC8:  MOVWF  x43
00CCA:  MOVLB  0
00CCC:  RCALL  08BA
00CCE:  MOVFF  01,703
00CD2:  MOVLW  04
00CD4:  MOVLB  7
00CD6:  ADDWF  01,W
00CD8:  MOVWF  01
00CDA:  MOVLW  00
00CDC:  ADDWFC 02,W
00CDE:  MOVWF  03
00CE0:  MOVF   01,W
00CE2:  ADDLW  EB
00CE4:  MOVWF  FE9
00CE6:  MOVLW  01
00CE8:  ADDWFC 03,W
00CEA:  MOVWF  FEA
00CEC:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00CEE:  CLRF   x42
00CF0:  MOVFF  701,741
00CF4:  CLRF   x44
00CF6:  MOVLW  B5
00CF8:  MOVWF  x43
00CFA:  MOVLB  0
00CFC:  RCALL  08BA
00CFE:  MOVLW  EB
00D00:  MOVLB  7
00D02:  ADDWF  01,W
00D04:  MOVWF  FE9
00D06:  MOVLW  01
00D08:  ADDWFC 02,W
00D0A:  MOVWF  FEA
00D0C:  BCF    FEF.0
....................       retData[0] = '\0';
00D0E:  MOVLB  4
00D10:  CLRF   xC1
00D12:  MOVLB  7
....................    }
00D14:  MOVLB  0
00D16:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
05614:  MOVLB  7
05616:  CLRF   x42
05618:  MOVFF  4BF,741
0561C:  CLRF   x44
0561E:  MOVLW  B5
05620:  MOVWF  x43
05622:  MOVLB  0
05624:  CALL   08BA
05628:  MOVFF  02,702
0562C:  MOVFF  01,701
05630:  MOVLW  EB
05632:  MOVLB  7
05634:  ADDWF  01,W
05636:  MOVWF  FE9
05638:  MOVLW  01
0563A:  ADDWFC 02,W
0563C:  MOVWF  FEA
0563E:  BTFSC  FEF.0
05640:  BRA    5662
....................    {
....................       if (SRI == SWI) return FALSE;
05642:  MOVLB  4
05644:  MOVF   xC0,W
05646:  SUBWF  xBF,W
05648:  BNZ   5650
0564A:  MOVLW  00
0564C:  MOVWF  01
0564E:  BRA    5668
....................       SRI +=1;
05650:  MOVLW  01
05652:  ADDWF  xBF,F
....................       if (SRI >= numRecords) SRI=0;
05654:  MOVF   xBF,W
05656:  SUBLW  03
05658:  BC    565C
0565A:  CLRF   xBF
0565C:  MOVLB  0
0565E:  BRA    5614
05660:  MOVLB  7
....................    }
....................    return TRUE;
05662:  MOVLW  01
05664:  MOVWF  01
05666:  MOVLB  4
05668:  MOVLB  0
0566A:  GOTO   A042 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
05048:  MOVLW  01
0504A:  MOVLB  4
0504C:  ADDWF  xC0,F
....................    if (SWI >= numRecords) SWI=0;
0504E:  MOVF   xC0,W
05050:  SUBLW  03
05052:  BC    5056
05054:  CLRF   xC0
05056:  MOVLB  0
05058:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B7,PIN_B6,PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... //!#use rs232(ICD, DISABLE_INTS, stream=ICD_STREAM)
.................... #use rs232(ICD, stream=ICD_STREAM)
*
000CA:  MOVLW  04
000CC:  MOVWF  F88
000CE:  BTFSC  F8D.6
000D0:  BRA    00CE
000D2:  MOVLW  08
000D4:  MOVWF  00
000D6:  MOVLB  7
000D8:  CLRF   x75
000DA:  MOVFF  FF2,776
000DE:  BCF    FF2.7
000E0:  BSF    00.7
000E2:  BRA    0100
000E4:  BCF    00.7
000E6:  BRA    0100
000E8:  BCF    FD8.0
000EA:  BTFSC  F8D.6
000EC:  BSF    FD8.0
000EE:  RRCF   x75,F
000F0:  BSF    00.6
000F2:  BRA    0100
000F4:  BCF    00.6
000F6:  DECFSZ 00,F
000F8:  BRA    00E8
000FA:  MOVFF  775,01
000FE:  BRA    0118
00100:  MOVLW  84
00102:  BTFSC  00.7
00104:  MOVLW  24
00106:  MOVWF  01
00108:  DECFSZ 01,F
0010A:  BRA    0108
0010C:  BRA    010E
0010E:  BTFSC  00.7
00110:  BRA    00E4
00112:  BTFSC  00.6
00114:  BRA    00F4
00116:  BRA    00E8
00118:  BTFSC  x76.7
0011A:  BSF    FF2.7
0011C:  MOVLB  0
0011E:  GOTO   0144 (RETURN)
*
0505A:  MOVFF  FF2,03
0505E:  BCF    FF2.7
05060:  MOVLW  04
05062:  MOVWF  F88
05064:  BCF    F83.7
05066:  MOVLW  08
05068:  MOVWF  01
0506A:  BRA    506C
0506C:  NOP   
0506E:  BSF    01.7
05070:  BRA    5092
05072:  BCF    01.7
05074:  MOVLB  7
05076:  RRCF   x05,F
05078:  MOVLB  0
0507A:  BTFSC  FD8.0
0507C:  BSF    F83.7
0507E:  BTFSS  FD8.0
05080:  BCF    F83.7
05082:  BSF    01.6
05084:  BRA    5092
05086:  BCF    01.6
05088:  DECFSZ 01,F
0508A:  BRA    5074
0508C:  BRA    508E
0508E:  NOP   
05090:  BSF    F83.7
05092:  MOVLW  84
05094:  MOVWF  FE9
05096:  DECFSZ FE9,F
05098:  BRA    5096
0509A:  BRA    509C
0509C:  NOP   
0509E:  BTFSC  01.7
050A0:  BRA    5072
050A2:  BTFSC  01.6
050A4:  BRA    5086
050A6:  BTFSC  03.7
050A8:  BSF    FF2.7
050AA:  RETURN 0
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, UART1, stream=SERIAL, ERRORS)
.................... //!#use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL, ERRORS)
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PRINTOUT                                                           */
.................... /*****************************************************************************/
.................... void serial_out(char* printBuffer){
....................     output_high(TX_ENABLE);
....................     delay_us(200);
....................     
....................     fprintf(SERIAL, "%s\n", printBuffer);
....................     delay_us(200);
....................     
....................     output_low(TX_ENABLE);
.................... }
.................... 
.................... void icd_out(char* printBuffer){
....................     fprintf(ICD_STREAM, "%s\n", printBuffer);
*
050D2:  MOVFF  702,FEA
050D6:  MOVFF  701,FE9
050DA:  BRA    50AC
050DC:  MOVLW  0A
050DE:  MOVLB  7
050E0:  MOVWF  x05
050E2:  MOVLB  0
050E4:  RCALL  505A
050E6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr() {   
*
00122:  MOVLB  0
....................     #ifdef DEBUG_ON_ICD            
....................     while (kbhit(SERIAL)) {
....................         UART_BUFFER[UART_WR_PTR]=fgetc(SERIAL);
....................         UART_WR_PTR +=1;
....................         if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
....................         BYTES_AVAILABLE=TRUE;
....................     }
....................     #else
....................     while (kbhit(ICD_STREAM)) {
00124:  BTFSC  F8D.6
00126:  BRA    0166
....................         UART_BUFFER[UART_WR_PTR]=fgetc(ICD_STREAM);
00128:  CLRF   03
0012A:  MOVLB  5
0012C:  MOVF   x61,W
0012E:  ADDLW  25
00130:  MOVWF  FE9
00132:  MOVLW  05
00134:  ADDWFC 03,W
00136:  MOVWF  FEA
00138:  MOVFF  FEA,774
0013C:  MOVFF  FE9,773
00140:  MOVLB  0
00142:  BRA    00CA
00144:  MOVFF  774,FEA
00148:  MOVFF  773,FE9
0014C:  MOVFF  01,FEF
....................         UART_WR_PTR +=1;
00150:  MOVLW  01
00152:  MOVLB  5
00154:  ADDWF  x61,F
....................         if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
00156:  MOVF   x61,W
00158:  SUBLW  3B
0015A:  BC    015E
0015C:  CLRF   x61
....................         BYTES_AVAILABLE=TRUE;
0015E:  MOVLB  1
00160:  BSF    x63.1
00162:  MOVLB  0
00164:  BRA    0124
....................     }
....................     #endif
00166:  MOVLB  E
00168:  BCF    xC8.5
0016A:  MOVLB  0
0016C:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
05010:  CLRF   03
05012:  MOVLB  5
05014:  MOVF   x62,W
05016:  ADDLW  25
05018:  MOVWF  FE9
0501A:  MOVLW  05
0501C:  ADDWFC 03,W
0501E:  MOVWF  FEA
05020:  MOVFF  FEF,6FC
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
05024:  MOVLW  01
05026:  ADDWF  x62,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
05028:  MOVF   x62,W
0502A:  SUBLW  3B
0502C:  BC    5030
0502E:  CLRF   x62
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
05030:  MOVF   x61,W
05032:  SUBWF  x62,W
05034:  BNZ   503C
05036:  MOVLB  1
05038:  BCF    x63.1
0503A:  MOVLB  5
....................    return data;
0503C:  MOVLB  6
0503E:  MOVFF  6FC,01
05042:  MOVLB  0
05044:  GOTO   5130 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
050E8:  MOVLB  1
050EA:  BTFSS  x63.1
050EC:  BRA    5608
050EE:  MOVLB  7
050F0:  CLRF   x42
050F2:  MOVFF  4C0,741
050F6:  CLRF   x44
050F8:  MOVLW  B5
050FA:  MOVWF  x43
050FC:  MOVLB  0
050FE:  CALL   08BA
05102:  MOVFF  02,6FD
05106:  MOVFF  01,6FC
0510A:  MOVLW  EB
0510C:  MOVLB  6
0510E:  ADDWF  01,W
05110:  MOVWF  01
05112:  MOVLW  01
05114:  ADDWFC 02,W
05116:  MOVWF  03
05118:  MOVFF  01,FE9
0511C:  MOVWF  FEA
0511E:  BTFSS  FEF.0
05120:  BRA    5126
05122:  MOVLB  1
05124:  BRA    5608
....................    {  
....................       output_high(TX_ENABLE);
05126:  MOVLW  93
05128:  MOVWF  F89
0512A:  BSF    F84.5
....................       unsigned int8 rxChar = getchFromBuffer();
0512C:  MOVLB  0
0512E:  BRA    5010
05130:  MOVFF  01,6FB
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
05134:  MOVLB  6
05136:  MOVF   xFB,W
05138:  SUBLW  0D
0513A:  BZ    5142
0513C:  MOVF   xFB,W
0513E:  SUBLW  20
05140:  BNZ   5144
....................       {
....................       }
05142:  BRA    5602
....................       else if (rxChar == UART_SOT_CHAR)
05144:  MOVF   xFB,W
05146:  SUBLW  7E
05148:  BNZ   518C
....................       {
....................          resetSERcmd(SWI);
0514A:  MOVFF  4C0,701
0514E:  MOVLB  0
05150:  CALL   0B9E
....................          SERcmd[SWI].t = rxChar;
05154:  MOVLB  7
05156:  CLRF   x42
05158:  MOVFF  4C0,741
0515C:  CLRF   x44
0515E:  MOVLW  B5
05160:  MOVWF  x43
05162:  MOVLB  0
05164:  CALL   08BA
05168:  MOVFF  01,6FC
0516C:  MOVLW  05
0516E:  MOVLB  6
05170:  ADDWF  01,W
05172:  MOVWF  01
05174:  MOVLW  00
05176:  ADDWFC 02,W
05178:  MOVWF  03
0517A:  MOVF   01,W
0517C:  ADDLW  EB
0517E:  MOVWF  FE9
05180:  MOVLW  01
05182:  ADDWFC 03,W
05184:  MOVWF  FEA
05186:  MOVFF  6FB,FEF
....................       }
0518A:  BRA    5602
....................       else if (rxChar >= oneByteCmdTestValue)
0518C:  MOVF   xFB,W
0518E:  SUBLW  7F
05190:  BC    51FE
....................       {
....................          resetSERcmd(SWI);
05192:  MOVFF  4C0,701
05196:  MOVLB  0
05198:  CALL   0B9E
....................          SERcmd[SWI].t = rxChar;
0519C:  MOVLB  7
0519E:  CLRF   x42
051A0:  MOVFF  4C0,741
051A4:  CLRF   x44
051A6:  MOVLW  B5
051A8:  MOVWF  x43
051AA:  MOVLB  0
051AC:  CALL   08BA
051B0:  MOVFF  01,6FC
051B4:  MOVLW  05
051B6:  MOVLB  6
051B8:  ADDWF  01,W
051BA:  MOVWF  01
051BC:  MOVLW  00
051BE:  ADDWFC 02,W
051C0:  MOVWF  03
051C2:  MOVF   01,W
051C4:  ADDLW  EB
051C6:  MOVWF  FE9
051C8:  MOVLW  01
051CA:  ADDWFC 03,W
051CC:  MOVWF  FEA
051CE:  MOVFF  6FB,FEF
....................          SERcmd[SWI].full = TRUE;
051D2:  MOVLB  7
051D4:  CLRF   x42
051D6:  MOVFF  4C0,741
051DA:  CLRF   x44
051DC:  MOVLW  B5
051DE:  MOVWF  x43
051E0:  MOVLB  0
051E2:  CALL   08BA
051E6:  MOVLW  EB
051E8:  MOVLB  6
051EA:  ADDWF  01,W
051EC:  MOVWF  FE9
051EE:  MOVLW  01
051F0:  ADDWFC 02,W
051F2:  MOVWF  FEA
051F4:  BSF    FEF.0
....................          setNextSERWriteIndex();
051F6:  MOVLB  0
051F8:  RCALL  5048
....................       }
051FA:  BRA    5600
051FC:  MOVLB  6
....................       else if (rxChar == UART_EOT_CHAR2)
051FE:  MOVF   xFB,W
05200:  SUBLW  0A
05202:  BTFSS  FD8.2
05204:  BRA    5312
....................       {
....................          SERcmd[SWI].full = TRUE;
05206:  MOVLB  7
05208:  CLRF   x42
0520A:  MOVFF  4C0,741
0520E:  CLRF   x44
05210:  MOVLW  B5
05212:  MOVWF  x43
05214:  MOVLB  0
05216:  CALL   08BA
0521A:  MOVLW  EB
0521C:  MOVLB  6
0521E:  ADDWF  01,W
05220:  MOVWF  FE9
05222:  MOVLW  01
05224:  ADDWFC 02,W
05226:  MOVWF  FEA
05228:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
0522A:  MOVLB  7
0522C:  CLRF   x42
0522E:  MOVFF  4C0,741
05232:  CLRF   x44
05234:  MOVLW  B5
05236:  MOVWF  x43
05238:  MOVLB  0
0523A:  CALL   08BA
0523E:  MOVFF  01,6FC
05242:  MOVLW  04
05244:  ADDWF  01,W
05246:  MOVWF  01
05248:  MOVLW  00
0524A:  ADDWFC 02,W
0524C:  MOVWF  03
0524E:  MOVF   01,W
05250:  ADDLW  EB
05252:  MOVWF  01
05254:  MOVLW  01
05256:  ADDWFC 03,F
05258:  MOVFF  01,6FC
0525C:  MOVFF  03,6FD
05260:  MOVLB  7
05262:  CLRF   x42
05264:  MOVFF  4C0,741
05268:  CLRF   x44
0526A:  MOVLW  B5
0526C:  MOVWF  x43
0526E:  MOVLB  0
05270:  CALL   08BA
05274:  MOVFF  01,6FE
05278:  MOVLW  02
0527A:  MOVLB  6
0527C:  ADDWF  01,W
0527E:  MOVWF  01
05280:  MOVLW  00
05282:  ADDWFC 02,W
05284:  MOVWF  03
05286:  MOVF   01,W
05288:  ADDLW  EB
0528A:  MOVWF  FE9
0528C:  MOVLW  01
0528E:  ADDWFC 03,W
05290:  MOVWF  FEA
05292:  MOVFF  FEF,6FE
05296:  MOVFF  6FD,FEA
0529A:  MOVFF  6FC,FE9
0529E:  MOVFF  6FE,FEF
....................          SERcmd[SWI].chrIndex = 0;
052A2:  MOVLB  7
052A4:  CLRF   x42
052A6:  MOVFF  4C0,741
052AA:  CLRF   x44
052AC:  MOVLW  B5
052AE:  MOVWF  x43
052B0:  MOVLB  0
052B2:  CALL   08BA
052B6:  MOVFF  01,6FC
052BA:  MOVLW  01
052BC:  MOVLB  6
052BE:  ADDWF  01,W
052C0:  MOVWF  01
052C2:  MOVLW  00
052C4:  ADDWFC 02,W
052C6:  MOVWF  03
052C8:  MOVF   01,W
052CA:  ADDLW  EB
052CC:  MOVWF  FE9
052CE:  MOVLW  01
052D0:  ADDWFC 03,W
052D2:  MOVWF  FEA
052D4:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
052D6:  MOVLB  7
052D8:  CLRF   x42
052DA:  MOVFF  4C0,741
052DE:  CLRF   x44
052E0:  MOVLW  B5
052E2:  MOVWF  x43
052E4:  MOVLB  0
052E6:  CALL   08BA
052EA:  MOVFF  01,6FC
052EE:  MOVLW  02
052F0:  MOVLB  6
052F2:  ADDWF  01,W
052F4:  MOVWF  01
052F6:  MOVLW  00
052F8:  ADDWFC 02,W
052FA:  MOVWF  03
052FC:  MOVF   01,W
052FE:  ADDLW  EB
05300:  MOVWF  FE9
05302:  MOVLW  01
05304:  ADDWFC 03,W
05306:  MOVWF  FEA
05308:  CLRF   FEF
....................          setNextSERWriteIndex();
0530A:  MOVLB  0
0530C:  RCALL  5048
....................       }
0530E:  BRA    5600
05310:  MOVLB  6
....................       else if (rxChar == delimiter)
05312:  MOVF   xFB,W
05314:  SUBLW  2C
05316:  BNZ   53DE
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
05318:  MOVLB  7
0531A:  CLRF   x42
0531C:  MOVFF  4C0,741
05320:  CLRF   x44
05322:  MOVLW  B5
05324:  MOVWF  x43
05326:  MOVLB  0
05328:  CALL   08BA
0532C:  MOVFF  02,6FD
05330:  MOVFF  01,6FC
05334:  MOVLW  02
05336:  MOVLB  6
05338:  ADDWF  01,W
0533A:  MOVWF  01
0533C:  MOVLW  00
0533E:  ADDWFC 02,W
05340:  MOVWF  03
05342:  MOVF   01,W
05344:  ADDLW  EB
05346:  MOVWF  FE9
05348:  MOVLW  01
0534A:  ADDWFC 03,W
0534C:  MOVWF  FEA
0534E:  MOVF   FEF,W
05350:  SUBLW  05
05352:  BNC   53C2
....................          {
....................             SERcmd[SWI].paramIndex +=1;
05354:  MOVLB  7
05356:  CLRF   x42
05358:  MOVFF  4C0,741
0535C:  CLRF   x44
0535E:  MOVLW  B5
05360:  MOVWF  x43
05362:  MOVLB  0
05364:  CALL   08BA
05368:  MOVFF  01,6FC
0536C:  MOVLW  02
0536E:  MOVLB  6
05370:  ADDWF  01,W
05372:  MOVWF  01
05374:  MOVLW  00
05376:  ADDWFC 02,W
05378:  MOVWF  03
0537A:  MOVF   01,W
0537C:  ADDLW  EB
0537E:  MOVWF  FE9
05380:  MOVLW  01
05382:  ADDWFC 03,W
05384:  MOVWF  FEA
05386:  MOVLW  01
05388:  ADDWF  FEF,W
0538A:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
0538C:  MOVLB  7
0538E:  CLRF   x42
05390:  MOVFF  4C0,741
05394:  CLRF   x44
05396:  MOVLW  B5
05398:  MOVWF  x43
0539A:  MOVLB  0
0539C:  CALL   08BA
053A0:  MOVFF  01,6FC
053A4:  MOVLW  01
053A6:  MOVLB  6
053A8:  ADDWF  01,W
053AA:  MOVWF  01
053AC:  MOVLW  00
053AE:  ADDWFC 02,W
053B0:  MOVWF  03
053B2:  MOVF   01,W
053B4:  ADDLW  EB
053B6:  MOVWF  FE9
053B8:  MOVLW  01
053BA:  ADDWFC 03,W
053BC:  MOVWF  FEA
053BE:  CLRF   FEF
....................          }
053C0:  BRA    53DC
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
053C2:  MOVFF  4C0,701
053C6:  MOVLB  0
053C8:  CALL   0B9E
....................             #ifdef DEBUG_ON_ICD
....................             serial_out(retData);
....................             #else
....................             icd_out(retData);
053CC:  MOVLW  04
053CE:  MOVLB  7
053D0:  MOVWF  x02
053D2:  MOVLW  C1
053D4:  MOVWF  x01
053D6:  MOVLB  0
053D8:  RCALL  50D2
053DA:  MOVLB  6
....................             #endif
....................          }
....................       }
053DC:  BRA    5602
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
053DE:  MOVLB  7
053E0:  CLRF   x42
053E2:  MOVFF  4C0,741
053E6:  CLRF   x44
053E8:  MOVLW  B5
053EA:  MOVWF  x43
053EC:  MOVLB  0
053EE:  CALL   08BA
053F2:  MOVFF  02,6FD
053F6:  MOVFF  01,6FC
053FA:  MOVLW  01
053FC:  MOVLB  6
053FE:  ADDWF  01,W
05400:  MOVWF  01
05402:  MOVLW  00
05404:  ADDWFC 02,W
05406:  MOVWF  03
05408:  MOVF   01,W
0540A:  ADDLW  EB
0540C:  MOVWF  FE9
0540E:  MOVLW  01
05410:  ADDWFC 03,W
05412:  MOVWF  FEA
05414:  MOVF   FEF,W
05416:  SUBLW  18
05418:  BTFSS  FD8.0
0541A:  BRA    55E8
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
0541C:  MOVLB  7
0541E:  CLRF   x42
05420:  MOVFF  4C0,741
05424:  CLRF   x44
05426:  MOVLW  B5
05428:  MOVWF  x43
0542A:  MOVLB  0
0542C:  CALL   08BA
05430:  MOVFF  02,6FD
05434:  MOVFF  01,6FC
05438:  MOVLW  06
0543A:  MOVLB  6
0543C:  ADDWF  xFC,F
0543E:  MOVLW  00
05440:  ADDWFC xFD,F
05442:  MOVLB  7
05444:  CLRF   x42
05446:  MOVFF  4C0,741
0544A:  CLRF   x44
0544C:  MOVLW  B5
0544E:  MOVWF  x43
05450:  MOVLB  0
05452:  CALL   08BA
05456:  MOVFF  02,6FF
0545A:  MOVFF  01,6FE
0545E:  MOVLW  02
05460:  ADDWF  01,W
05462:  MOVWF  01
05464:  MOVLW  00
05466:  ADDWFC 02,W
05468:  MOVWF  03
0546A:  MOVF   01,W
0546C:  ADDLW  EB
0546E:  MOVWF  FE9
05470:  MOVLW  01
05472:  ADDWFC 03,W
05474:  MOVWF  FEA
05476:  MOVLB  7
05478:  CLRF   x42
0547A:  MOVFF  FEF,741
0547E:  CLRF   x44
05480:  MOVLW  19
05482:  MOVWF  x43
05484:  MOVLB  0
05486:  CALL   08BA
0548A:  MOVFF  02,03
0548E:  MOVF   01,W
05490:  MOVLB  6
05492:  ADDWF  xFC,F
05494:  MOVF   02,W
05496:  ADDWFC xFD,F
05498:  MOVLB  7
0549A:  CLRF   x42
0549C:  MOVFF  4C0,741
054A0:  CLRF   x44
054A2:  MOVLW  B5
054A4:  MOVWF  x43
054A6:  MOVLB  0
054A8:  CALL   08BA
054AC:  MOVFF  01,6FE
054B0:  MOVLW  01
054B2:  MOVLB  6
054B4:  ADDWF  01,W
054B6:  MOVWF  01
054B8:  MOVLW  00
054BA:  ADDWFC 02,W
054BC:  MOVWF  03
054BE:  MOVF   01,W
054C0:  ADDLW  EB
054C2:  MOVWF  FE9
054C4:  MOVLW  01
054C6:  ADDWFC 03,W
054C8:  MOVWF  FEA
054CA:  MOVF   FEF,W
054CC:  ADDWF  xFC,W
054CE:  MOVWF  01
054D0:  MOVLW  00
054D2:  ADDWFC xFD,W
054D4:  MOVWF  03
054D6:  MOVF   01,W
054D8:  ADDLW  EB
054DA:  MOVWF  FE9
054DC:  MOVLW  01
054DE:  ADDWFC 03,W
054E0:  MOVWF  FEA
054E2:  MOVFF  6FB,FEF
....................             SERcmd[SWI].chrIndex += 1;
054E6:  MOVLB  7
054E8:  CLRF   x42
054EA:  MOVFF  4C0,741
054EE:  CLRF   x44
054F0:  MOVLW  B5
054F2:  MOVWF  x43
054F4:  MOVLB  0
054F6:  CALL   08BA
054FA:  MOVFF  01,6FC
054FE:  MOVLW  01
05500:  MOVLB  6
05502:  ADDWF  01,W
05504:  MOVWF  01
05506:  MOVLW  00
05508:  ADDWFC 02,W
0550A:  MOVWF  03
0550C:  MOVF   01,W
0550E:  ADDLW  EB
05510:  MOVWF  FE9
05512:  MOVLW  01
05514:  ADDWFC 03,W
05516:  MOVWF  FEA
05518:  MOVLW  01
0551A:  ADDWF  FEF,W
0551C:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
0551E:  MOVLB  7
05520:  CLRF   x42
05522:  MOVFF  4C0,741
05526:  CLRF   x44
05528:  MOVLW  B5
0552A:  MOVWF  x43
0552C:  MOVLB  0
0552E:  CALL   08BA
05532:  MOVFF  02,6FD
05536:  MOVFF  01,6FC
0553A:  MOVLW  06
0553C:  MOVLB  6
0553E:  ADDWF  xFC,F
05540:  MOVLW  00
05542:  ADDWFC xFD,F
05544:  MOVLB  7
05546:  CLRF   x42
05548:  MOVFF  4C0,741
0554C:  CLRF   x44
0554E:  MOVLW  B5
05550:  MOVWF  x43
05552:  MOVLB  0
05554:  CALL   08BA
05558:  MOVFF  02,6FF
0555C:  MOVFF  01,6FE
05560:  MOVLW  02
05562:  ADDWF  01,W
05564:  MOVWF  01
05566:  MOVLW  00
05568:  ADDWFC 02,W
0556A:  MOVWF  03
0556C:  MOVF   01,W
0556E:  ADDLW  EB
05570:  MOVWF  FE9
05572:  MOVLW  01
05574:  ADDWFC 03,W
05576:  MOVWF  FEA
05578:  MOVLB  7
0557A:  CLRF   x42
0557C:  MOVFF  FEF,741
05580:  CLRF   x44
05582:  MOVLW  19
05584:  MOVWF  x43
05586:  MOVLB  0
05588:  CALL   08BA
0558C:  MOVFF  02,03
05590:  MOVF   01,W
05592:  MOVLB  6
05594:  ADDWF  xFC,F
05596:  MOVF   02,W
05598:  ADDWFC xFD,F
0559A:  MOVLB  7
0559C:  CLRF   x42
0559E:  MOVFF  4C0,741
055A2:  CLRF   x44
055A4:  MOVLW  B5
055A6:  MOVWF  x43
055A8:  MOVLB  0
055AA:  CALL   08BA
055AE:  MOVFF  01,6FE
055B2:  MOVLW  01
055B4:  MOVLB  6
055B6:  ADDWF  01,W
055B8:  MOVWF  01
055BA:  MOVLW  00
055BC:  ADDWFC 02,W
055BE:  MOVWF  03
055C0:  MOVF   01,W
055C2:  ADDLW  EB
055C4:  MOVWF  FE9
055C6:  MOVLW  01
055C8:  ADDWFC 03,W
055CA:  MOVWF  FEA
055CC:  MOVF   FEF,W
055CE:  ADDWF  xFC,W
055D0:  MOVWF  01
055D2:  MOVLW  00
055D4:  ADDWFC xFD,W
055D6:  MOVWF  03
055D8:  MOVF   01,W
055DA:  ADDLW  EB
055DC:  MOVWF  FE9
055DE:  MOVLW  01
055E0:  ADDWFC 03,W
055E2:  MOVWF  FEA
055E4:  CLRF   FEF
....................          }
055E6:  BRA    5602
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
055E8:  MOVFF  4C0,701
055EC:  MOVLB  0
055EE:  CALL   0B9E
....................             #ifdef DEBUG_ON_ICD
....................             serial_out(retData);
....................             #else
....................             icd_out(retData);
055F2:  MOVLW  04
055F4:  MOVLB  7
055F6:  MOVWF  x02
055F8:  MOVLW  C1
055FA:  MOVWF  x01
055FC:  MOVLB  0
055FE:  RCALL  50D2
05600:  MOVLB  6
....................             #endif
....................          }
....................       }
05602:  MOVLB  0
05604:  BRA    50E8
05606:  MOVLB  1
....................    }
....................    output_low(TX_ENABLE);
05608:  MOVLW  93
0560A:  MOVWF  F89
0560C:  BCF    F84.5
0560E:  MOVLB  0
05610:  GOTO   A714 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00D18:  MOVLB  6
00D1A:  CLRF   xFB
00D1C:  MOVF   xFB,W
00D1E:  SUBLW  03
00D20:  BNC   0D30
....................    {
....................       resetSERcmd(i);
00D22:  MOVFF  6FB,701
00D26:  MOVLB  0
00D28:  RCALL  0B9E
00D2A:  MOVLB  6
00D2C:  INCF   xFB,F
00D2E:  BRA    0D1C
....................    }
....................    enable_interrupts(INT_RDA);
00D30:  MOVLB  E
00D32:  BSF    xC0.5
00D34:  MOVLB  0
00D36:  GOTO   A6D8 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00D3A:  MOVLB  E
00D3C:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00D3E:  MOVLW  01
00D40:  MOVWF  FD1
00D42:  MOVLW  07
00D44:  MOVWF  FCE
00D46:  CLRF   FCF
00D48:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00D4A:  MOVLB  1
00D4C:  CLRF   x75
00D4E:  CLRF   x74
00D50:  CLRF   x73
00D52:  CLRF   x72
....................    timeoutReg1 = 0;
00D54:  CLRF   x79
00D56:  CLRF   x78
00D58:  CLRF   x77
00D5A:  CLRF   x76
....................    timeoutReg2 = 0;
00D5C:  CLRF   x7D
00D5E:  CLRF   x7C
00D60:  CLRF   x7B
00D62:  CLRF   x7A
.................... //!   intTimeoutReg = 50;
....................    enable_interrupts(INT_TIMER1);
00D64:  MOVLB  E
00D66:  BSF    xC1.0
00D68:  MOVLB  0
00D6A:  GOTO   A6DC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00294:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00296:  MOVLW  0B
00298:  MOVWF  FCD
0029A:  MOVLW  DB
0029C:  MOVWF  FCC
0029E:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
002A0:  MOVLB  1
002A2:  MOVF   x75,F
002A4:  BNZ   02B4
002A6:  MOVF   x74,F
002A8:  BNZ   02B4
002AA:  MOVF   x73,F
002AC:  BNZ   02B4
002AE:  MOVF   x72,W
002B0:  SUBLW  0A
002B2:  BC    02C2
002B4:  MOVLW  0A
002B6:  SUBWF  x72,F
002B8:  MOVLW  00
002BA:  SUBWFB x73,F
002BC:  SUBWFB x74,F
002BE:  SUBWFB x75,F
002C0:  BRA    02CA
002C2:  CLRF   x75
002C4:  CLRF   x74
002C6:  CLRF   x73
002C8:  CLRF   x72
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
002CA:  MOVF   x79,F
002CC:  BNZ   02DC
002CE:  MOVF   x78,F
002D0:  BNZ   02DC
002D2:  MOVF   x77,F
002D4:  BNZ   02DC
002D6:  MOVF   x76,W
002D8:  SUBLW  0A
002DA:  BC    02EA
002DC:  MOVLW  0A
002DE:  SUBWF  x76,F
002E0:  MOVLW  00
002E2:  SUBWFB x77,F
002E4:  SUBWFB x78,F
002E6:  SUBWFB x79,F
002E8:  BRA    02F2
002EA:  CLRF   x79
002EC:  CLRF   x78
002EE:  CLRF   x77
002F0:  CLRF   x76
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002F2:  MOVF   x7D,F
002F4:  BNZ   0304
002F6:  MOVF   x7C,F
002F8:  BNZ   0304
002FA:  MOVF   x7B,F
002FC:  BNZ   0304
002FE:  MOVF   x7A,W
00300:  SUBLW  0A
00302:  BC    0312
00304:  MOVLW  0A
00306:  SUBWF  x7A,F
00308:  MOVLW  00
0030A:  SUBWFB x7B,F
0030C:  SUBWFB x7C,F
0030E:  SUBWFB x7D,F
00310:  BRA    031A
00312:  CLRF   x7D
00314:  CLRF   x7C
00316:  CLRF   x7B
00318:  CLRF   x7A
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
0031A:  MOVF   x7E,F
0031C:  BNZ   0322
0031E:  MOVF   x7F,F
00320:  BZ    035E
....................    {
....................       timeCounter+=10;
00322:  MOVLW  0A
00324:  MOVLB  5
00326:  ADDWF  x66,F
00328:  MOVLW  00
0032A:  ADDWFC x67,F
0032C:  ADDWFC x68,F
0032E:  ADDWFC x69,F
....................       if (timeCounter >= intTimeoutReg)
00330:  MOVF   x69,F
00332:  BNZ   034E
00334:  MOVF   x68,F
00336:  BNZ   034E
00338:  MOVLB  1
0033A:  MOVF   x7F,W
0033C:  MOVLB  5
0033E:  SUBWF  x67,W
00340:  BNC   035C
00342:  BNZ   034E
00344:  MOVLB  1
00346:  MOVF   x7E,W
00348:  MOVLB  5
0034A:  SUBWF  x66,W
0034C:  BNC   035C
....................       {
....................          sensor_monitor_interrupt_task();
0034E:  MOVLB  0
00350:  BRA    01F8
....................          timeCounter = 0;
00352:  MOVLB  5
00354:  CLRF   x69
00356:  CLRF   x68
00358:  CLRF   x67
0035A:  CLRF   x66
0035C:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................     float kP;      // proportional gain
....................     float kI;      // integral gain
....................     float kD;      // derivative gain
....................     float SP;      // set point-- desired output
....................     float PV;      // process variable-- measured output
....................     float PVold;   // oldPV value  
....................     float CV;      // control variable-- output -- 0 to 100%
....................     float I;       // integral value
....................     float maxSP;   // Max setpoint in microns
....................     float minSP;   // Min setpoint in microns
.................... }PID[2] = {
....................    //  P     I     D
....................    //0.01    0.3   0.1
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}, 
....................     {0.01,   0.3,  0.1, 0,0,0,0,0,0,0}
....................     };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... //!#define op_upper_bound 63  // CRYO
.................... //!#define op_lower_bound -63 // CRYO
.................... 
.................... #define op_upper_bound 63  // AMBIENT 
.................... #define op_lower_bound -12 // AMBIENT
.................... 
.................... //!#define op_upper_bound 100  // FULL 
.................... //!#define op_lower_bound -100 // FULL
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;    // number of poles passed
....................    float pReal;            // real position in microns
....................    float pHome;            // Home position in microns
....................    BOOLEAN homeFlag;       // Flag to trigger the homing routine
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0,0,FALSE},
....................    {0,0,0,0,0,0,0,0,0,0,FALSE}
.................... };
.................... 
.................... BOOLEAN adcFilter = FALSE;
.................... 
.................... struct dacV
.................... {
....................     BOOLEAN invV;
....................     unsigned int16 ipVal;
....................     float opPcnt;
....................    
.................... }dacVals[2] = 
.................... {
....................     {FALSE,0,0},
....................     {FALSE,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
0035E:  MOVLB  E
00360:  BCF    xC9.0
00362:  MOVLB  0
00364:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................     int8 id;
....................     char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                 // gr 
.................... int8 getSN(unsigned int8);                  // gs
.................... 
.................... int8 getOPchMap(unsigned int8);             // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);             // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);            // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);            // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);             // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);             // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);              // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);             // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);            // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);            // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8);  // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);      // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);      // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);     // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);     // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);        // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);             // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);              // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);           // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);           // sManOP,   {1|2}, <float>  
.................... 
.................... int8 setFilterOn(unsigned int8);            // sFiltOn
.................... int8 setFilterOff(unsigned int8);           // sFiltOff
.................... 
.................... int8 setHomeAxis(unsigned int8);            // sHome,    {1|2}      
....................                                                        
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................     char *cmd_name;
....................     int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................     {"gr",       &getRev},
....................     {"gs",       &getSN},
....................     {"gChMap",   &getOPchMap},
....................     {"sChMap",   &setOPchMap},
....................     {"gChMode",  &getIPchMode},
....................     {"sChMode",  &setIPchMode},
....................     {"gPID",     &getPIDvals},
....................     {"sPID",     &setPIDvals},
....................     {"gSP",      &getSetPoint},
....................     {"sSP",      &setSetPoint},
....................     {"gSCals",   &getAllSensorCalParams},
....................     {"gSCal",    &getSensorCalParam},
....................     {"sSCal",    &setSensorCalParam},
....................     {"gMCal",    &getMonitorCalParam},
....................     {"sMCal",    &setMonitorCalParam},
....................     {"gMon",     &getMonitorValue},
....................     {"gPIDdata", &getPIDdata},
....................     {"gIPdata",  &getIPdata},
....................     {"gManOP",   &getManOPvals},
....................     {"sManOP",   &setManOPvals},
....................     {"sFiltOn",  &setFilterOn},
....................     {"sFiltOff", &setFilterOff},
....................     {"sHome",    &setHomeAxis},
....................     {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", version);
*
057BC:  MOVLW  04
057BE:  MOVLB  7
057C0:  MOVWF  x42
057C2:  MOVLW  C1
057C4:  MOVWF  x41
057C6:  MOVLB  0
057C8:  RCALL  566E
057CA:  MOVFF  02,03
057CE:  MOVF   01,W
057D0:  ADDLW  C1
057D2:  MOVLB  7
057D4:  MOVWF  x0B
057D6:  MOVLW  04
057D8:  ADDWFC 02,W
057DA:  MOVWF  x0C
057DC:  MOVFF  FE8,565
057E0:  MOVFF  70B,564
057E4:  MOVLW  68
057E6:  MOVWF  FF6
057E8:  MOVLW  03
057EA:  MOVWF  FF7
057EC:  MOVLB  0
057EE:  RCALL  579C
057F0:  MOVLW  2C
057F2:  MOVLB  7
057F4:  MOVWF  x50
057F6:  MOVLB  0
057F8:  RCALL  56A6
....................     return SUCCESS;
057FA:  MOVLW  00
057FC:  MOVWF  01
057FE:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................     sprintf(retData+strlen(retData), "%s,", serialID);
05800:  MOVLW  04
05802:  MOVLB  7
05804:  MOVWF  x42
05806:  MOVLW  C1
05808:  MOVWF  x41
0580A:  MOVLB  0
0580C:  RCALL  566E
0580E:  MOVFF  02,03
05812:  MOVF   01,W
05814:  ADDLW  C1
05816:  MOVLB  7
05818:  MOVWF  x0B
0581A:  MOVLW  04
0581C:  ADDWFC 02,W
0581E:  MOVWF  x0C
05820:  MOVFF  FE8,565
05824:  MOVFF  70B,564
05828:  MOVLW  72
0582A:  MOVWF  FF6
0582C:  MOVLW  03
0582E:  MOVWF  FF7
05830:  MOVLB  0
05832:  RCALL  579C
05834:  MOVLW  2C
05836:  MOVLB  7
05838:  MOVWF  x50
0583A:  MOVLB  0
0583C:  RCALL  56A6
....................     return SUCCESS;
0583E:  MOVLW  00
05840:  MOVWF  01
05842:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................    
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05D48:  MOVLB  7
05D4A:  CLRF   x42
05D4C:  MOVFF  690,741
05D50:  CLRF   x44
05D52:  MOVLW  B5
05D54:  MOVWF  x43
05D56:  MOVLB  0
05D58:  CALL   08BA
05D5C:  MOVFF  02,70D
05D60:  MOVFF  01,70C
05D64:  MOVLW  06
05D66:  MOVLB  7
05D68:  ADDWF  x0C,F
05D6A:  MOVLW  00
05D6C:  ADDWFC x0D,F
05D6E:  MOVLW  32
05D70:  ADDWF  x0C,W
05D72:  MOVWF  01
05D74:  MOVLW  00
05D76:  ADDWFC x0D,W
05D78:  MOVWF  03
05D7A:  MOVF   01,W
05D7C:  ADDLW  EB
05D7E:  MOVWF  01
05D80:  MOVLW  01
05D82:  ADDWFC 03,F
05D84:  MOVFF  01,70C
05D88:  MOVFF  03,70D
05D8C:  MOVFF  03,734
05D90:  MOVFF  01,733
05D94:  MOVLB  0
05D96:  RCALL  5844
05D98:  MOVF   01,F
05D9A:  BNZ   5DA4
05D9C:  MOVLW  02
05D9E:  MOVWF  01
05DA0:  BRA    5EEA
05DA2:  BRA    5E00
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05DA4:  MOVLB  7
05DA6:  CLRF   x42
05DA8:  MOVFF  690,741
05DAC:  CLRF   x44
05DAE:  MOVLW  B5
05DB0:  MOVWF  x43
05DB2:  MOVLB  0
05DB4:  CALL   08BA
05DB8:  MOVFF  02,70D
05DBC:  MOVFF  01,70C
05DC0:  MOVLW  06
05DC2:  MOVLB  7
05DC4:  ADDWF  x0C,F
05DC6:  MOVLW  00
05DC8:  ADDWFC x0D,F
05DCA:  MOVLW  32
05DCC:  ADDWF  x0C,W
05DCE:  MOVWF  01
05DD0:  MOVLW  00
05DD2:  ADDWFC x0D,W
05DD4:  MOVWF  03
05DD6:  MOVF   01,W
05DD8:  ADDLW  EB
05DDA:  MOVWF  01
05DDC:  MOVLW  01
05DDE:  ADDWFC 03,F
05DE0:  MOVFF  01,70C
05DE4:  MOVFF  03,70D
05DE8:  MOVFF  03,734
05DEC:  MOVFF  01,733
05DF0:  CLRF   x36
05DF2:  CLRF   x35
05DF4:  MOVLW  0A
05DF6:  MOVWF  x37
05DF8:  MOVLB  0
05DFA:  RCALL  5934
05DFC:  MOVFF  01,70B
....................    
....................     /*** GET CHANNEL MAP ***************/ 
....................     if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05E00:  MOVLW  01
05E02:  MOVLB  7
05E04:  SUBWF  x0B,W
05E06:  MOVWF  x0D
05E08:  CLRF   x0F
05E0A:  MOVLW  70
05E0C:  MOVWF  x0E
05E0E:  MOVLB  0
05E10:  CALL   4618
05E14:  BTFSC  01.0
05E16:  BRA    5E6C
05E18:  MOVLW  04
05E1A:  MOVLB  7
05E1C:  MOVWF  x42
05E1E:  MOVLW  C1
05E20:  MOVWF  x41
05E22:  MOVLB  0
05E24:  RCALL  566E
05E26:  MOVFF  02,03
05E2A:  MOVF   01,W
05E2C:  ADDLW  C1
05E2E:  MOVLB  7
05E30:  MOVWF  x0C
05E32:  MOVLW  04
05E34:  ADDWFC 02,W
05E36:  MOVWF  x0D
05E38:  MOVFF  FE8,565
05E3C:  MOVFF  70C,564
05E40:  MOVFF  70B,734
05E44:  MOVLW  18
05E46:  MOVWF  x35
05E48:  MOVLB  0
05E4A:  RCALL  5C88
05E4C:  MOVLW  2C
05E4E:  MOVLB  7
05E50:  MOVWF  x50
05E52:  MOVLB  0
05E54:  RCALL  56A6
05E56:  MOVLW  58
05E58:  MOVLB  7
05E5A:  MOVWF  x50
05E5C:  MOVLB  0
05E5E:  RCALL  56A6
05E60:  MOVLW  2C
05E62:  MOVLB  7
05E64:  MOVWF  x50
05E66:  MOVLB  0
05E68:  RCALL  56A6
05E6A:  BRA    5EE6
....................     else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05E6C:  MOVLW  01
05E6E:  MOVLB  7
05E70:  SUBWF  x0B,W
05E72:  MOVWF  x0D
05E74:  CLRF   x0F
05E76:  MOVLW  70
05E78:  MOVWF  x0E
05E7A:  MOVLB  0
05E7C:  CALL   4618
05E80:  BTFSS  01.0
05E82:  BRA    5EE0
05E84:  MOVLW  04
05E86:  MOVLB  7
05E88:  MOVWF  x42
05E8A:  MOVLW  C1
05E8C:  MOVWF  x41
05E8E:  MOVLB  0
05E90:  CALL   566E
05E94:  MOVFF  02,03
05E98:  MOVF   01,W
05E9A:  ADDLW  C1
05E9C:  MOVLB  7
05E9E:  MOVWF  x0C
05EA0:  MOVLW  04
05EA2:  ADDWFC 02,W
05EA4:  MOVWF  x0D
05EA6:  MOVFF  FE8,565
05EAA:  MOVFF  70C,564
05EAE:  MOVFF  70B,734
05EB2:  MOVLW  18
05EB4:  MOVWF  x35
05EB6:  MOVLB  0
05EB8:  RCALL  5C88
05EBA:  MOVLW  2C
05EBC:  MOVLB  7
05EBE:  MOVWF  x50
05EC0:  MOVLB  0
05EC2:  CALL   56A6
05EC6:  MOVLW  59
05EC8:  MOVLB  7
05ECA:  MOVWF  x50
05ECC:  MOVLB  0
05ECE:  CALL   56A6
05ED2:  MOVLW  2C
05ED4:  MOVLB  7
05ED6:  MOVWF  x50
05ED8:  MOVLB  0
05EDA:  CALL   56A6
05EDE:  BRA    5EE6
....................     else return INV_PARAM;
05EE0:  MOVLW  02
05EE2:  MOVWF  01
05EE4:  BRA    5EEA
....................    
....................     return SUCCESS;
05EE6:  MOVLW  00
05EE8:  MOVWF  01
05EEA:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05F2E:  MOVLB  7
05F30:  CLRF   x42
05F32:  MOVFF  690,741
05F36:  CLRF   x44
05F38:  MOVLW  B5
05F3A:  MOVWF  x43
05F3C:  MOVLB  0
05F3E:  CALL   08BA
05F42:  MOVFF  02,70E
05F46:  MOVFF  01,70D
05F4A:  MOVLW  06
05F4C:  MOVLB  7
05F4E:  ADDWF  x0D,F
05F50:  MOVLW  00
05F52:  ADDWFC x0E,F
05F54:  MOVLW  32
05F56:  ADDWF  x0D,W
05F58:  MOVWF  01
05F5A:  MOVLW  00
05F5C:  ADDWFC x0E,W
05F5E:  MOVWF  03
05F60:  MOVF   01,W
05F62:  ADDLW  EB
05F64:  MOVWF  01
05F66:  MOVLW  01
05F68:  ADDWFC 03,F
05F6A:  MOVFF  01,70D
05F6E:  MOVFF  03,70E
05F72:  MOVFF  03,734
05F76:  MOVFF  01,733
05F7A:  MOVLB  0
05F7C:  RCALL  5844
05F7E:  MOVF   01,F
05F80:  BNZ   5F8A
05F82:  MOVLW  02
05F84:  MOVWF  01
05F86:  BRA    60DA
05F88:  BRA    5FE6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05F8A:  MOVLB  7
05F8C:  CLRF   x42
05F8E:  MOVFF  690,741
05F92:  CLRF   x44
05F94:  MOVLW  B5
05F96:  MOVWF  x43
05F98:  MOVLB  0
05F9A:  CALL   08BA
05F9E:  MOVFF  02,70E
05FA2:  MOVFF  01,70D
05FA6:  MOVLW  06
05FA8:  MOVLB  7
05FAA:  ADDWF  x0D,F
05FAC:  MOVLW  00
05FAE:  ADDWFC x0E,F
05FB0:  MOVLW  32
05FB2:  ADDWF  x0D,W
05FB4:  MOVWF  01
05FB6:  MOVLW  00
05FB8:  ADDWFC x0E,W
05FBA:  MOVWF  03
05FBC:  MOVF   01,W
05FBE:  ADDLW  EB
05FC0:  MOVWF  01
05FC2:  MOVLW  01
05FC4:  ADDWFC 03,F
05FC6:  MOVFF  01,70D
05FCA:  MOVFF  03,70E
05FCE:  MOVFF  03,734
05FD2:  MOVFF  01,733
05FD6:  CLRF   x36
05FD8:  CLRF   x35
05FDA:  MOVLW  0A
05FDC:  MOVWF  x37
05FDE:  MOVLB  0
05FE0:  RCALL  5934
05FE2:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05FE6:  MOVLB  7
05FE8:  CLRF   x42
05FEA:  MOVFF  690,741
05FEE:  CLRF   x44
05FF0:  MOVLW  B5
05FF2:  MOVWF  x43
05FF4:  MOVLB  0
05FF6:  CALL   08BA
05FFA:  MOVFF  02,70E
05FFE:  MOVFF  01,70D
06002:  MOVLW  06
06004:  MOVLB  7
06006:  ADDWF  x0D,F
06008:  MOVLW  00
0600A:  ADDWFC x0E,F
0600C:  MOVLW  4B
0600E:  ADDWF  x0D,W
06010:  MOVWF  01
06012:  MOVLW  00
06014:  ADDWFC x0E,W
06016:  MOVWF  03
06018:  MOVF   01,W
0601A:  ADDLW  EB
0601C:  MOVWF  01
0601E:  MOVLW  01
06020:  ADDWFC 03,F
06022:  MOVFF  01,70D
06026:  MOVFF  03,70E
0602A:  MOVFF  03,742
0602E:  MOVFF  01,741
06032:  MOVLB  0
06034:  CALL   566E
06038:  MOVFF  02,03
0603C:  MOVF   01,W
0603E:  SUBLW  01
06040:  BNZ   6046
06042:  MOVF   03,F
06044:  BZ    604E
06046:  MOVLW  02
06048:  MOVWF  01
0604A:  BRA    60DA
0604C:  BRA    608E
....................    else arg2 = SERcmd[rec].p[3][0];
0604E:  MOVLB  7
06050:  CLRF   x42
06052:  MOVFF  690,741
06056:  CLRF   x44
06058:  MOVLW  B5
0605A:  MOVWF  x43
0605C:  MOVLB  0
0605E:  CALL   08BA
06062:  MOVFF  02,70E
06066:  MOVFF  01,70D
0606A:  MOVLW  06
0606C:  MOVLB  7
0606E:  ADDWF  x0D,F
06070:  MOVLW  00
06072:  ADDWFC x0E,F
06074:  MOVLW  4B
06076:  ADDWF  x0D,F
06078:  MOVLW  00
0607A:  ADDWFC x0E,F
0607C:  MOVLW  EB
0607E:  ADDWF  x0D,W
06080:  MOVWF  FE9
06082:  MOVLW  01
06084:  ADDWFC x0E,W
06086:  MOVWF  FEA
06088:  MOVFF  FEF,70C
0608C:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
0608E:  MOVLB  7
06090:  MOVF   x0C,W
06092:  SUBLW  58
06094:  BNZ   60AE
06096:  MOVLW  01
06098:  SUBWF  x0B,W
0609A:  MOVWF  x0D
0609C:  MOVWF  x22
0609E:  CLRF   x23
060A0:  CLRF   x25
060A2:  MOVLW  70
060A4:  MOVWF  x24
060A6:  MOVLB  0
060A8:  RCALL  5EEC
060AA:  BRA    60D6
060AC:  MOVLB  7
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
060AE:  MOVF   x0C,W
060B0:  SUBLW  59
060B2:  BNZ   60CE
060B4:  MOVLW  01
060B6:  SUBWF  x0B,W
060B8:  MOVWF  x0D
060BA:  MOVWF  x22
060BC:  MOVLW  01
060BE:  MOVWF  x23
060C0:  CLRF   x25
060C2:  MOVLW  70
060C4:  MOVWF  x24
060C6:  MOVLB  0
060C8:  RCALL  5EEC
060CA:  BRA    60D6
060CC:  MOVLB  7
....................    else return INV_PARAM;
060CE:  MOVLW  02
060D0:  MOVWF  01
060D2:  MOVLB  0
060D4:  BRA    60DA
....................    
....................    return SUCCESS;
060D6:  MOVLW  00
060D8:  MOVWF  01
060DA:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06106:  MOVLB  7
06108:  CLRF   x42
0610A:  MOVFF  690,741
0610E:  CLRF   x44
06110:  MOVLW  B5
06112:  MOVWF  x43
06114:  MOVLB  0
06116:  CALL   08BA
0611A:  MOVFF  02,70D
0611E:  MOVFF  01,70C
06122:  MOVLW  06
06124:  MOVLB  7
06126:  ADDWF  x0C,F
06128:  MOVLW  00
0612A:  ADDWFC x0D,F
0612C:  MOVLW  32
0612E:  ADDWF  x0C,W
06130:  MOVWF  01
06132:  MOVLW  00
06134:  ADDWFC x0D,W
06136:  MOVWF  03
06138:  MOVF   01,W
0613A:  ADDLW  EB
0613C:  MOVWF  01
0613E:  MOVLW  01
06140:  ADDWFC 03,F
06142:  MOVFF  01,70C
06146:  MOVFF  03,70D
0614A:  MOVFF  03,734
0614E:  MOVFF  01,733
06152:  MOVLB  0
06154:  CALL   5844
06158:  MOVF   01,F
0615A:  BNZ   6164
0615C:  MOVLW  02
0615E:  MOVWF  01
06160:  BRA    6290
06162:  BRA    61C2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06164:  MOVLB  7
06166:  CLRF   x42
06168:  MOVFF  690,741
0616C:  CLRF   x44
0616E:  MOVLW  B5
06170:  MOVWF  x43
06172:  MOVLB  0
06174:  CALL   08BA
06178:  MOVFF  02,70D
0617C:  MOVFF  01,70C
06180:  MOVLW  06
06182:  MOVLB  7
06184:  ADDWF  x0C,F
06186:  MOVLW  00
06188:  ADDWFC x0D,F
0618A:  MOVLW  32
0618C:  ADDWF  x0C,W
0618E:  MOVWF  01
06190:  MOVLW  00
06192:  ADDWFC x0D,W
06194:  MOVWF  03
06196:  MOVF   01,W
06198:  ADDLW  EB
0619A:  MOVWF  01
0619C:  MOVLW  01
0619E:  ADDWFC 03,F
061A0:  MOVFF  01,70C
061A4:  MOVFF  03,70D
061A8:  MOVFF  03,734
061AC:  MOVFF  01,733
061B0:  CLRF   x36
061B2:  CLRF   x35
061B4:  MOVLW  0A
061B6:  MOVWF  x37
061B8:  MOVLB  0
061BA:  CALL   5934
061BE:  MOVFF  01,70B
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
061C2:  MOVLW  01
061C4:  MOVLB  7
061C6:  SUBWF  x0B,W
061C8:  MOVWF  x0D
061CA:  CLRF   x0F
061CC:  MOVLW  71
061CE:  MOVWF  x0E
061D0:  MOVLB  0
061D2:  CALL   4618
061D6:  BTFSC  01.0
061D8:  BRA    6224
061DA:  MOVLW  04
061DC:  MOVLB  7
061DE:  MOVWF  x42
061E0:  MOVLW  C1
061E2:  MOVWF  x41
061E4:  MOVLB  0
061E6:  CALL   566E
061EA:  MOVFF  02,03
061EE:  MOVF   01,W
061F0:  ADDLW  C1
061F2:  MOVLB  7
061F4:  MOVWF  x0C
061F6:  MOVLW  04
061F8:  ADDWFC 02,W
061FA:  MOVWF  x0D
061FC:  MOVFF  FE8,565
06200:  MOVFF  70C,564
06204:  MOVFF  70B,734
06208:  MOVLW  18
0620A:  MOVWF  x35
0620C:  MOVLB  0
0620E:  RCALL  5C88
06210:  MOVLW  7A
06212:  MOVWF  FF6
06214:  MOVLW  03
06216:  MOVWF  FF7
06218:  MOVLW  08
0621A:  MOVLB  7
0621C:  MOVWF  x0F
0621E:  MOVLB  0
06220:  RCALL  60DC
06222:  BRA    628C
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
06224:  MOVLW  01
06226:  MOVLB  7
06228:  SUBWF  x0B,W
0622A:  MOVWF  x0D
0622C:  CLRF   x0F
0622E:  MOVLW  71
06230:  MOVWF  x0E
06232:  MOVLB  0
06234:  CALL   4618
06238:  BTFSS  01.0
0623A:  BRA    6286
0623C:  MOVLW  04
0623E:  MOVLB  7
06240:  MOVWF  x42
06242:  MOVLW  C1
06244:  MOVWF  x41
06246:  MOVLB  0
06248:  CALL   566E
0624C:  MOVFF  02,03
06250:  MOVF   01,W
06252:  ADDLW  C1
06254:  MOVLB  7
06256:  MOVWF  x0C
06258:  MOVLW  04
0625A:  ADDWFC 02,W
0625C:  MOVWF  x0D
0625E:  MOVFF  FE8,565
06262:  MOVFF  70C,564
06266:  MOVFF  70B,734
0626A:  MOVLW  18
0626C:  MOVWF  x35
0626E:  MOVLB  0
06270:  RCALL  5C88
06272:  MOVLW  86
06274:  MOVWF  FF6
06276:  MOVLW  03
06278:  MOVWF  FF7
0627A:  MOVLW  08
0627C:  MOVLB  7
0627E:  MOVWF  x0F
06280:  MOVLB  0
06282:  RCALL  60DC
06284:  BRA    628C
....................    else return INV_PARAM;
06286:  MOVLW  02
06288:  MOVWF  01
0628A:  BRA    6290
....................    
....................    return SUCCESS;
0628C:  MOVLW  00
0628E:  MOVWF  01
06290:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
06292:  MOVLW  4D
06294:  MOVLB  7
06296:  MOVWF  x10
06298:  MOVLW  41
0629A:  MOVWF  x11
0629C:  MOVLW  4E
0629E:  MOVWF  x12
062A0:  MOVLW  55
062A2:  MOVWF  x13
062A4:  MOVLW  41
062A6:  MOVWF  x14
062A8:  MOVLW  4C
062AA:  MOVWF  x15
062AC:  CLRF   x16
062AE:  MOVLW  07
062B0:  MOVWF  x0F
062B2:  MOVLW  10
062B4:  MOVWF  x0E
....................    char *s_magsns = "MAGSNS";
062B6:  MOVLW  4D
062B8:  MOVWF  x19
062BA:  MOVLW  41
062BC:  MOVWF  x1A
062BE:  MOVLW  47
062C0:  MOVWF  x1B
062C2:  MOVLW  53
062C4:  MOVWF  x1C
062C6:  MOVLW  4E
062C8:  MOVWF  x1D
062CA:  MOVLW  53
062CC:  MOVWF  x1E
062CE:  CLRF   x1F
062D0:  MOVLW  07
062D2:  MOVWF  x18
062D4:  MOVLW  19
062D6:  MOVWF  x17
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
062D8:  CLRF   x42
062DA:  MOVFF  690,741
062DE:  CLRF   x44
062E0:  MOVLW  B5
062E2:  MOVWF  x43
062E4:  MOVLB  0
062E6:  CALL   08BA
062EA:  MOVFF  02,721
062EE:  MOVFF  01,720
062F2:  MOVLW  06
062F4:  MOVLB  7
062F6:  ADDWF  x20,F
062F8:  MOVLW  00
062FA:  ADDWFC x21,F
062FC:  MOVLW  32
062FE:  ADDWF  x20,W
06300:  MOVWF  01
06302:  MOVLW  00
06304:  ADDWFC x21,W
06306:  MOVWF  03
06308:  MOVF   01,W
0630A:  ADDLW  EB
0630C:  MOVWF  01
0630E:  MOVLW  01
06310:  ADDWFC 03,F
06312:  MOVFF  01,720
06316:  MOVFF  03,721
0631A:  MOVFF  03,734
0631E:  MOVFF  01,733
06322:  MOVLB  0
06324:  CALL   5844
06328:  MOVF   01,F
0632A:  BNZ   6334
0632C:  MOVLW  02
0632E:  MOVWF  01
06330:  BRA    64AA
06332:  BRA    6392
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06334:  MOVLB  7
06336:  CLRF   x42
06338:  MOVFF  690,741
0633C:  CLRF   x44
0633E:  MOVLW  B5
06340:  MOVWF  x43
06342:  MOVLB  0
06344:  CALL   08BA
06348:  MOVFF  02,721
0634C:  MOVFF  01,720
06350:  MOVLW  06
06352:  MOVLB  7
06354:  ADDWF  x20,F
06356:  MOVLW  00
06358:  ADDWFC x21,F
0635A:  MOVLW  32
0635C:  ADDWF  x20,W
0635E:  MOVWF  01
06360:  MOVLW  00
06362:  ADDWFC x21,W
06364:  MOVWF  03
06366:  MOVF   01,W
06368:  ADDLW  EB
0636A:  MOVWF  01
0636C:  MOVLW  01
0636E:  ADDWFC 03,F
06370:  MOVFF  01,720
06374:  MOVFF  03,721
06378:  MOVFF  03,734
0637C:  MOVFF  01,733
06380:  CLRF   x36
06382:  CLRF   x35
06384:  MOVLW  0A
06386:  MOVWF  x37
06388:  MOVLB  0
0638A:  CALL   5934
0638E:  MOVFF  01,70B
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
06392:  MOVLB  7
06394:  CLRF   x42
06396:  MOVFF  690,741
0639A:  CLRF   x44
0639C:  MOVLW  B5
0639E:  MOVWF  x43
063A0:  MOVLB  0
063A2:  CALL   08BA
063A6:  MOVFF  02,721
063AA:  MOVFF  01,720
063AE:  MOVLW  06
063B0:  MOVLB  7
063B2:  ADDWF  x20,F
063B4:  MOVLW  00
063B6:  ADDWFC x21,F
063B8:  MOVLW  4B
063BA:  ADDWF  x20,W
063BC:  MOVWF  01
063BE:  MOVLW  00
063C0:  ADDWFC x21,W
063C2:  MOVWF  03
063C4:  MOVF   01,W
063C6:  ADDLW  EB
063C8:  MOVWF  01
063CA:  MOVLW  01
063CC:  ADDWFC 03,F
063CE:  MOVFF  01,720
063D2:  MOVFF  03,721
063D6:  MOVFF  03,742
063DA:  MOVFF  01,741
063DE:  MOVLB  0
063E0:  CALL   566E
063E4:  MOVFF  02,03
063E8:  MOVF   01,W
063EA:  BNZ   63F8
063EC:  MOVF   03,F
063EE:  BNZ   63F8
063F0:  MOVLW  02
063F2:  MOVWF  01
063F4:  BRA    64AA
063F6:  BRA    643E
....................    else arg2 = SERcmd[rec].p[3];
063F8:  MOVLB  7
063FA:  CLRF   x42
063FC:  MOVFF  690,741
06400:  CLRF   x44
06402:  MOVLW  B5
06404:  MOVWF  x43
06406:  MOVLB  0
06408:  CALL   08BA
0640C:  MOVFF  02,721
06410:  MOVFF  01,720
06414:  MOVLW  06
06416:  MOVLB  7
06418:  ADDWF  x20,F
0641A:  MOVLW  00
0641C:  ADDWFC x21,F
0641E:  MOVLW  4B
06420:  ADDWF  x20,W
06422:  MOVWF  01
06424:  MOVLW  00
06426:  ADDWFC x21,W
06428:  MOVWF  03
0642A:  MOVF   01,W
0642C:  ADDLW  EB
0642E:  MOVWF  01
06430:  MOVLW  01
06432:  ADDWFC 03,F
06434:  MOVFF  01,70C
06438:  MOVFF  03,70D
0643C:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
0643E:  MOVFF  70F,742
06442:  MOVFF  70E,741
06446:  MOVFF  70D,744
0644A:  MOVFF  70C,743
0644E:  CALL   5724
06452:  MOVF   01,F
06454:  BNZ   646E
06456:  MOVLW  01
06458:  MOVLB  7
0645A:  SUBWF  x0B,W
0645C:  MOVWF  x20
0645E:  MOVWF  x22
06460:  CLRF   x23
06462:  CLRF   x25
06464:  MOVLW  71
06466:  MOVWF  x24
06468:  MOVLB  0
0646A:  RCALL  5EEC
0646C:  BRA    64A6
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
0646E:  MOVFF  718,742
06472:  MOVFF  717,741
06476:  MOVFF  70D,744
0647A:  MOVFF  70C,743
0647E:  CALL   5724
06482:  MOVF   01,F
06484:  BNZ   64A0
06486:  MOVLW  01
06488:  MOVLB  7
0648A:  SUBWF  x0B,W
0648C:  MOVWF  x20
0648E:  MOVWF  x22
06490:  MOVLW  01
06492:  MOVWF  x23
06494:  CLRF   x25
06496:  MOVLW  71
06498:  MOVWF  x24
0649A:  MOVLB  0
0649C:  RCALL  5EEC
0649E:  BRA    64A6
....................    else return INV_PARAM;
064A0:  MOVLW  02
064A2:  MOVWF  01
064A4:  BRA    64AA
....................    
....................    return SUCCESS;
064A6:  MOVLW  00
064A8:  MOVWF  01
064AA:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06732:  MOVLB  7
06734:  CLRF   x42
06736:  MOVFF  690,741
0673A:  CLRF   x44
0673C:  MOVLW  B5
0673E:  MOVWF  x43
06740:  MOVLB  0
06742:  CALL   08BA
06746:  MOVFF  02,70E
0674A:  MOVFF  01,70D
0674E:  MOVLW  06
06750:  MOVLB  7
06752:  ADDWF  x0D,F
06754:  MOVLW  00
06756:  ADDWFC x0E,F
06758:  MOVLW  32
0675A:  ADDWF  x0D,W
0675C:  MOVWF  01
0675E:  MOVLW  00
06760:  ADDWFC x0E,W
06762:  MOVWF  03
06764:  MOVF   01,W
06766:  ADDLW  EB
06768:  MOVWF  01
0676A:  MOVLW  01
0676C:  ADDWFC 03,F
0676E:  MOVFF  01,70D
06772:  MOVFF  03,70E
06776:  MOVFF  03,734
0677A:  MOVFF  01,733
0677E:  MOVLB  0
06780:  CALL   5844
06784:  MOVF   01,F
06786:  BNZ   6790
06788:  MOVLW  02
0678A:  MOVWF  01
0678C:  BRA    6BE6
0678E:  BRA    67EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06790:  MOVLB  7
06792:  CLRF   x42
06794:  MOVFF  690,741
06798:  CLRF   x44
0679A:  MOVLW  B5
0679C:  MOVWF  x43
0679E:  MOVLB  0
067A0:  CALL   08BA
067A4:  MOVFF  02,70E
067A8:  MOVFF  01,70D
067AC:  MOVLW  06
067AE:  MOVLB  7
067B0:  ADDWF  x0D,F
067B2:  MOVLW  00
067B4:  ADDWFC x0E,F
067B6:  MOVLW  32
067B8:  ADDWF  x0D,W
067BA:  MOVWF  01
067BC:  MOVLW  00
067BE:  ADDWFC x0E,W
067C0:  MOVWF  03
067C2:  MOVF   01,W
067C4:  ADDLW  EB
067C6:  MOVWF  01
067C8:  MOVLW  01
067CA:  ADDWFC 03,F
067CC:  MOVFF  01,70D
067D0:  MOVFF  03,70E
067D4:  MOVFF  03,734
067D8:  MOVFF  01,733
067DC:  CLRF   x36
067DE:  CLRF   x35
067E0:  MOVLW  0A
067E2:  MOVWF  x37
067E4:  MOVLB  0
067E6:  CALL   5934
067EA:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
067EE:  MOVLB  7
067F0:  CLRF   x42
067F2:  MOVFF  690,741
067F6:  CLRF   x44
067F8:  MOVLW  B5
067FA:  MOVWF  x43
067FC:  MOVLB  0
067FE:  CALL   08BA
06802:  MOVFF  02,70E
06806:  MOVFF  01,70D
0680A:  MOVLW  06
0680C:  MOVLB  7
0680E:  ADDWF  x0D,F
06810:  MOVLW  00
06812:  ADDWFC x0E,F
06814:  MOVLW  4B
06816:  ADDWF  x0D,W
06818:  MOVWF  01
0681A:  MOVLW  00
0681C:  ADDWFC x0E,W
0681E:  MOVWF  03
06820:  MOVF   01,W
06822:  ADDLW  EB
06824:  MOVWF  01
06826:  MOVLW  01
06828:  ADDWFC 03,F
0682A:  MOVFF  01,70D
0682E:  MOVFF  03,70E
06832:  MOVFF  03,742
06836:  MOVFF  01,741
0683A:  MOVLB  0
0683C:  CALL   566E
06840:  MOVFF  02,03
06844:  MOVF   01,W
06846:  SUBLW  01
06848:  BNZ   684E
0684A:  MOVF   03,F
0684C:  BZ    6856
0684E:  MOVLW  02
06850:  MOVWF  01
06852:  BRA    6BE6
06854:  BRA    6896
....................    else arg2 = SERcmd[rec].p[3][0];
06856:  MOVLB  7
06858:  CLRF   x42
0685A:  MOVFF  690,741
0685E:  CLRF   x44
06860:  MOVLW  B5
06862:  MOVWF  x43
06864:  MOVLB  0
06866:  CALL   08BA
0686A:  MOVFF  02,70E
0686E:  MOVFF  01,70D
06872:  MOVLW  06
06874:  MOVLB  7
06876:  ADDWF  x0D,F
06878:  MOVLW  00
0687A:  ADDWFC x0E,F
0687C:  MOVLW  4B
0687E:  ADDWF  x0D,F
06880:  MOVLW  00
06882:  ADDWFC x0E,F
06884:  MOVLW  EB
06886:  ADDWF  x0D,W
06888:  MOVWF  FE9
0688A:  MOVLW  01
0688C:  ADDWFC x0E,W
0688E:  MOVWF  FEA
06890:  MOVFF  FEF,70C
06894:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
06896:  MOVLB  7
06898:  MOVF   x0C,W
0689A:  SUBLW  50
0689C:  BNZ   6936
0689E:  MOVLW  04
068A0:  MOVWF  x42
068A2:  MOVLW  C1
068A4:  MOVWF  x41
068A6:  MOVLB  0
068A8:  CALL   566E
068AC:  MOVFF  02,03
068B0:  MOVF   01,W
068B2:  ADDLW  C1
068B4:  MOVLB  7
068B6:  MOVWF  x0D
068B8:  MOVLW  04
068BA:  ADDWFC 02,W
068BC:  MOVWF  x0E
068BE:  MOVLW  01
068C0:  SUBWF  x0B,W
068C2:  MULLW  28
068C4:  MOVF   FF3,W
068C6:  CLRF   x10
068C8:  MOVWF  x0F
068CA:  MOVLW  20
068CC:  ADDWF  x0F,W
068CE:  MOVWF  FE9
068D0:  MOVLW  00
068D2:  ADDWFC x10,W
068D4:  MOVWF  FEA
068D6:  MOVFF  FEF,711
068DA:  MOVFF  FEC,712
068DE:  MOVFF  FEC,713
068E2:  MOVFF  FEC,714
068E6:  MOVFF  70E,565
068EA:  MOVFF  70D,564
068EE:  MOVFF  70B,734
068F2:  MOVLW  18
068F4:  MOVWF  x35
068F6:  MOVLB  0
068F8:  CALL   5C88
068FC:  MOVLW  2C
068FE:  MOVLB  7
06900:  MOVWF  x50
06902:  MOVLB  0
06904:  CALL   56A6
06908:  MOVLW  89
0690A:  MOVWF  FE9
0690C:  MOVFF  714,746
06910:  MOVFF  713,745
06914:  MOVFF  712,744
06918:  MOVFF  711,743
0691C:  MOVLW  02
0691E:  MOVLB  7
06920:  MOVWF  x47
06922:  MOVLB  0
06924:  RCALL  6582
06926:  MOVLW  2C
06928:  MOVLB  7
0692A:  MOVWF  x50
0692C:  MOVLB  0
0692E:  CALL   56A6
06932:  BRA    6BE2
06934:  MOVLB  7
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06936:  MOVF   x0C,W
06938:  SUBLW  49
0693A:  BNZ   69DC
0693C:  MOVLW  04
0693E:  MOVWF  x42
06940:  MOVLW  C1
06942:  MOVWF  x41
06944:  MOVLB  0
06946:  CALL   566E
0694A:  MOVF   01,W
0694C:  ADDLW  C1
0694E:  MOVLB  7
06950:  MOVWF  x0D
06952:  MOVLW  04
06954:  ADDWFC 02,W
06956:  MOVWF  x0E
06958:  MOVLW  01
0695A:  SUBWF  x0B,W
0695C:  MULLW  28
0695E:  MOVF   FF3,W
06960:  CLRF   x10
06962:  MOVWF  x0F
06964:  MOVLW  04
06966:  ADDWF  x0F,W
06968:  MOVWF  01
0696A:  MOVLW  00
0696C:  ADDWFC x10,W
0696E:  MOVWF  03
06970:  MOVF   01,W
06972:  ADDLW  20
06974:  MOVWF  FE9
06976:  MOVLW  00
06978:  ADDWFC 03,W
0697A:  MOVWF  FEA
0697C:  MOVFF  FEF,70F
06980:  MOVFF  FEC,710
06984:  MOVFF  FEC,711
06988:  MOVFF  FEC,712
0698C:  MOVFF  70E,565
06990:  MOVFF  70D,564
06994:  MOVFF  70B,734
06998:  MOVLW  18
0699A:  MOVWF  x35
0699C:  MOVLB  0
0699E:  CALL   5C88
069A2:  MOVLW  2C
069A4:  MOVLB  7
069A6:  MOVWF  x50
069A8:  MOVLB  0
069AA:  CALL   56A6
069AE:  MOVLW  89
069B0:  MOVWF  FE9
069B2:  MOVFF  712,746
069B6:  MOVFF  711,745
069BA:  MOVFF  710,744
069BE:  MOVFF  70F,743
069C2:  MOVLW  02
069C4:  MOVLB  7
069C6:  MOVWF  x47
069C8:  MOVLB  0
069CA:  RCALL  6582
069CC:  MOVLW  2C
069CE:  MOVLB  7
069D0:  MOVWF  x50
069D2:  MOVLB  0
069D4:  CALL   56A6
069D8:  BRA    6BE2
069DA:  MOVLB  7
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
069DC:  MOVF   x0C,W
069DE:  SUBLW  44
069E0:  BNZ   6A82
069E2:  MOVLW  04
069E4:  MOVWF  x42
069E6:  MOVLW  C1
069E8:  MOVWF  x41
069EA:  MOVLB  0
069EC:  CALL   566E
069F0:  MOVF   01,W
069F2:  ADDLW  C1
069F4:  MOVLB  7
069F6:  MOVWF  x0D
069F8:  MOVLW  04
069FA:  ADDWFC 02,W
069FC:  MOVWF  x0E
069FE:  MOVLW  01
06A00:  SUBWF  x0B,W
06A02:  MULLW  28
06A04:  MOVF   FF3,W
06A06:  CLRF   x10
06A08:  MOVWF  x0F
06A0A:  MOVLW  08
06A0C:  ADDWF  x0F,W
06A0E:  MOVWF  01
06A10:  MOVLW  00
06A12:  ADDWFC x10,W
06A14:  MOVWF  03
06A16:  MOVF   01,W
06A18:  ADDLW  20
06A1A:  MOVWF  FE9
06A1C:  MOVLW  00
06A1E:  ADDWFC 03,W
06A20:  MOVWF  FEA
06A22:  MOVFF  FEF,70F
06A26:  MOVFF  FEC,710
06A2A:  MOVFF  FEC,711
06A2E:  MOVFF  FEC,712
06A32:  MOVFF  70E,565
06A36:  MOVFF  70D,564
06A3A:  MOVFF  70B,734
06A3E:  MOVLW  18
06A40:  MOVWF  x35
06A42:  MOVLB  0
06A44:  CALL   5C88
06A48:  MOVLW  2C
06A4A:  MOVLB  7
06A4C:  MOVWF  x50
06A4E:  MOVLB  0
06A50:  CALL   56A6
06A54:  MOVLW  89
06A56:  MOVWF  FE9
06A58:  MOVFF  712,746
06A5C:  MOVFF  711,745
06A60:  MOVFF  710,744
06A64:  MOVFF  70F,743
06A68:  MOVLW  02
06A6A:  MOVLB  7
06A6C:  MOVWF  x47
06A6E:  MOVLB  0
06A70:  RCALL  6582
06A72:  MOVLW  2C
06A74:  MOVLB  7
06A76:  MOVWF  x50
06A78:  MOVLB  0
06A7A:  CALL   56A6
06A7E:  BRA    6BE2
06A80:  MOVLB  7
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06A82:  MOVF   x0C,W
06A84:  SUBLW  41
06A86:  BTFSS  FD8.2
06A88:  BRA    6BDA
06A8A:  MOVLW  04
06A8C:  MOVWF  x42
06A8E:  MOVLW  C1
06A90:  MOVWF  x41
06A92:  MOVLB  0
06A94:  CALL   566E
06A98:  MOVF   01,W
06A9A:  ADDLW  C1
06A9C:  MOVLB  7
06A9E:  MOVWF  x0D
06AA0:  MOVLW  04
06AA2:  ADDWFC 02,W
06AA4:  MOVWF  x0E
06AA6:  MOVLW  01
06AA8:  SUBWF  x0B,W
06AAA:  MULLW  28
06AAC:  MOVF   FF3,W
06AAE:  CLRF   x10
06AB0:  MOVWF  x0F
06AB2:  MOVLW  20
06AB4:  ADDWF  x0F,W
06AB6:  MOVWF  FE9
06AB8:  MOVLW  00
06ABA:  ADDWFC x10,W
06ABC:  MOVWF  FEA
06ABE:  MOVFF  FEF,711
06AC2:  MOVFF  FEC,712
06AC6:  MOVFF  FEC,713
06ACA:  MOVFF  FEC,714
06ACE:  MOVLW  01
06AD0:  SUBWF  x0B,W
06AD2:  MULLW  28
06AD4:  MOVF   FF3,W
06AD6:  CLRF   x16
06AD8:  MOVWF  x15
06ADA:  MOVLW  04
06ADC:  ADDWF  x15,W
06ADE:  MOVWF  01
06AE0:  MOVLW  00
06AE2:  ADDWFC x16,W
06AE4:  MOVWF  03
06AE6:  MOVF   01,W
06AE8:  ADDLW  20
06AEA:  MOVWF  FE9
06AEC:  MOVLW  00
06AEE:  ADDWFC 03,W
06AF0:  MOVWF  FEA
06AF2:  MOVFF  FEF,715
06AF6:  MOVFF  FEC,716
06AFA:  MOVFF  FEC,717
06AFE:  MOVFF  FEC,718
06B02:  MOVLW  01
06B04:  SUBWF  x0B,W
06B06:  MULLW  28
06B08:  MOVF   FF3,W
06B0A:  CLRF   x1A
06B0C:  MOVWF  x19
06B0E:  MOVLW  08
06B10:  ADDWF  x19,W
06B12:  MOVWF  01
06B14:  MOVLW  00
06B16:  ADDWFC x1A,W
06B18:  MOVWF  03
06B1A:  MOVF   01,W
06B1C:  ADDLW  20
06B1E:  MOVWF  FE9
06B20:  MOVLW  00
06B22:  ADDWFC 03,W
06B24:  MOVWF  FEA
06B26:  MOVFF  FEF,719
06B2A:  MOVFF  FEC,71A
06B2E:  MOVFF  FEC,71B
06B32:  MOVFF  FEC,71C
06B36:  MOVFF  70E,565
06B3A:  MOVFF  70D,564
06B3E:  MOVFF  70B,734
06B42:  MOVLW  18
06B44:  MOVWF  x35
06B46:  MOVLB  0
06B48:  CALL   5C88
06B4C:  MOVLW  2C
06B4E:  MOVLB  7
06B50:  MOVWF  x50
06B52:  MOVLB  0
06B54:  CALL   56A6
06B58:  MOVLW  89
06B5A:  MOVWF  FE9
06B5C:  MOVFF  714,746
06B60:  MOVFF  713,745
06B64:  MOVFF  712,744
06B68:  MOVFF  711,743
06B6C:  MOVLW  02
06B6E:  MOVLB  7
06B70:  MOVWF  x47
06B72:  MOVLB  0
06B74:  RCALL  6582
06B76:  MOVLW  2C
06B78:  MOVLB  7
06B7A:  MOVWF  x50
06B7C:  MOVLB  0
06B7E:  CALL   56A6
06B82:  MOVLW  89
06B84:  MOVWF  FE9
06B86:  MOVFF  718,746
06B8A:  MOVFF  717,745
06B8E:  MOVFF  716,744
06B92:  MOVFF  715,743
06B96:  MOVLW  02
06B98:  MOVLB  7
06B9A:  MOVWF  x47
06B9C:  MOVLB  0
06B9E:  RCALL  6582
06BA0:  MOVLW  2C
06BA2:  MOVLB  7
06BA4:  MOVWF  x50
06BA6:  MOVLB  0
06BA8:  CALL   56A6
06BAC:  MOVLW  89
06BAE:  MOVWF  FE9
06BB0:  MOVFF  71C,746
06BB4:  MOVFF  71B,745
06BB8:  MOVFF  71A,744
06BBC:  MOVFF  719,743
06BC0:  MOVLW  02
06BC2:  MOVLB  7
06BC4:  MOVWF  x47
06BC6:  MOVLB  0
06BC8:  RCALL  6582
06BCA:  MOVLW  2C
06BCC:  MOVLB  7
06BCE:  MOVWF  x50
06BD0:  MOVLB  0
06BD2:  CALL   56A6
06BD6:  BRA    6BE2
06BD8:  MOVLB  7
....................    else return INV_PARAM;
06BDA:  MOVLW  02
06BDC:  MOVWF  01
06BDE:  MOVLB  0
06BE0:  BRA    6BE6
....................    
....................    return SUCCESS;
06BE2:  MOVLW  00
06BE4:  MOVWF  01
06BE6:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06F04:  MOVLB  7
06F06:  CLRF   x42
06F08:  MOVFF  690,741
06F0C:  CLRF   x44
06F0E:  MOVLW  B5
06F10:  MOVWF  x43
06F12:  MOVLB  0
06F14:  CALL   08BA
06F18:  MOVFF  02,712
06F1C:  MOVFF  01,711
06F20:  MOVLW  06
06F22:  MOVLB  7
06F24:  ADDWF  x11,F
06F26:  MOVLW  00
06F28:  ADDWFC x12,F
06F2A:  MOVLW  32
06F2C:  ADDWF  x11,W
06F2E:  MOVWF  01
06F30:  MOVLW  00
06F32:  ADDWFC x12,W
06F34:  MOVWF  03
06F36:  MOVF   01,W
06F38:  ADDLW  EB
06F3A:  MOVWF  01
06F3C:  MOVLW  01
06F3E:  ADDWFC 03,F
06F40:  MOVFF  01,711
06F44:  MOVFF  03,712
06F48:  MOVFF  03,734
06F4C:  MOVFF  01,733
06F50:  MOVLB  0
06F52:  CALL   5844
06F56:  MOVF   01,F
06F58:  BNZ   6F62
06F5A:  MOVLW  02
06F5C:  MOVWF  01
06F5E:  BRA    71E2
06F60:  BRA    6FC0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06F62:  MOVLB  7
06F64:  CLRF   x42
06F66:  MOVFF  690,741
06F6A:  CLRF   x44
06F6C:  MOVLW  B5
06F6E:  MOVWF  x43
06F70:  MOVLB  0
06F72:  CALL   08BA
06F76:  MOVFF  02,712
06F7A:  MOVFF  01,711
06F7E:  MOVLW  06
06F80:  MOVLB  7
06F82:  ADDWF  x11,F
06F84:  MOVLW  00
06F86:  ADDWFC x12,F
06F88:  MOVLW  32
06F8A:  ADDWF  x11,W
06F8C:  MOVWF  01
06F8E:  MOVLW  00
06F90:  ADDWFC x12,W
06F92:  MOVWF  03
06F94:  MOVF   01,W
06F96:  ADDLW  EB
06F98:  MOVWF  01
06F9A:  MOVLW  01
06F9C:  ADDWFC 03,F
06F9E:  MOVFF  01,711
06FA2:  MOVFF  03,712
06FA6:  MOVFF  03,734
06FAA:  MOVFF  01,733
06FAE:  CLRF   x36
06FB0:  CLRF   x35
06FB2:  MOVLW  0A
06FB4:  MOVWF  x37
06FB6:  MOVLB  0
06FB8:  CALL   5934
06FBC:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
06FC0:  MOVLB  7
06FC2:  CLRF   x42
06FC4:  MOVFF  690,741
06FC8:  CLRF   x44
06FCA:  MOVLW  B5
06FCC:  MOVWF  x43
06FCE:  MOVLB  0
06FD0:  CALL   08BA
06FD4:  MOVFF  02,712
06FD8:  MOVFF  01,711
06FDC:  MOVLW  06
06FDE:  MOVLB  7
06FE0:  ADDWF  x11,F
06FE2:  MOVLW  00
06FE4:  ADDWFC x12,F
06FE6:  MOVLW  4B
06FE8:  ADDWF  x11,W
06FEA:  MOVWF  01
06FEC:  MOVLW  00
06FEE:  ADDWFC x12,W
06FF0:  MOVWF  03
06FF2:  MOVF   01,W
06FF4:  ADDLW  EB
06FF6:  MOVWF  01
06FF8:  MOVLW  01
06FFA:  ADDWFC 03,F
06FFC:  MOVFF  01,711
07000:  MOVFF  03,712
07004:  MOVFF  03,742
07008:  MOVFF  01,741
0700C:  MOVLB  0
0700E:  CALL   566E
07012:  MOVFF  02,03
07016:  MOVF   01,W
07018:  SUBLW  01
0701A:  BNZ   7020
0701C:  MOVF   03,F
0701E:  BZ    7028
07020:  MOVLW  02
07022:  MOVWF  01
07024:  BRA    71E2
07026:  BRA    7068
....................    else arg2 = SERcmd[rec].p[3][0];
07028:  MOVLB  7
0702A:  CLRF   x42
0702C:  MOVFF  690,741
07030:  CLRF   x44
07032:  MOVLW  B5
07034:  MOVWF  x43
07036:  MOVLB  0
07038:  CALL   08BA
0703C:  MOVFF  02,712
07040:  MOVFF  01,711
07044:  MOVLW  06
07046:  MOVLB  7
07048:  ADDWF  x11,F
0704A:  MOVLW  00
0704C:  ADDWFC x12,F
0704E:  MOVLW  4B
07050:  ADDWF  x11,F
07052:  MOVLW  00
07054:  ADDWFC x12,F
07056:  MOVLW  EB
07058:  ADDWF  x11,W
0705A:  MOVWF  FE9
0705C:  MOVLW  01
0705E:  ADDWFC x12,W
07060:  MOVWF  FEA
07062:  MOVFF  FEF,70C
07066:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07068:  MOVLB  7
0706A:  CLRF   x42
0706C:  MOVFF  690,741
07070:  CLRF   x44
07072:  MOVLW  B5
07074:  MOVWF  x43
07076:  MOVLB  0
07078:  CALL   08BA
0707C:  MOVFF  02,712
07080:  MOVFF  01,711
07084:  MOVLW  06
07086:  MOVLB  7
07088:  ADDWF  x11,F
0708A:  MOVLW  00
0708C:  ADDWFC x12,F
0708E:  MOVLW  64
07090:  ADDWF  x11,W
07092:  MOVWF  01
07094:  MOVLW  00
07096:  ADDWFC x12,W
07098:  MOVWF  03
0709A:  MOVF   01,W
0709C:  ADDLW  EB
0709E:  MOVWF  01
070A0:  MOVLW  01
070A2:  ADDWFC 03,F
070A4:  MOVFF  01,711
070A8:  MOVFF  03,712
070AC:  MOVFF  03,715
070B0:  MOVFF  01,714
070B4:  MOVLB  0
070B6:  RCALL  6BE8
070B8:  MOVF   01,F
070BA:  BNZ   70C4
070BC:  MOVLW  02
070BE:  MOVWF  01
070C0:  BRA    71E2
070C2:  BRA    7128
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
070C4:  MOVLB  7
070C6:  CLRF   x42
070C8:  MOVFF  690,741
070CC:  CLRF   x44
070CE:  MOVLW  B5
070D0:  MOVWF  x43
070D2:  MOVLB  0
070D4:  CALL   08BA
070D8:  MOVFF  02,712
070DC:  MOVFF  01,711
070E0:  MOVLW  06
070E2:  MOVLB  7
070E4:  ADDWF  x11,F
070E6:  MOVLW  00
070E8:  ADDWFC x12,F
070EA:  MOVLW  64
070EC:  ADDWF  x11,W
070EE:  MOVWF  01
070F0:  MOVLW  00
070F2:  ADDWFC x12,W
070F4:  MOVWF  03
070F6:  MOVF   01,W
070F8:  ADDLW  EB
070FA:  MOVWF  01
070FC:  MOVLW  01
070FE:  ADDWFC 03,F
07100:  MOVFF  01,711
07104:  MOVFF  03,712
07108:  MOVFF  03,715
0710C:  MOVFF  01,714
07110:  CLRF   x17
07112:  CLRF   x16
07114:  MOVLB  0
07116:  RCALL  6CAA
07118:  MOVFF  03,710
0711C:  MOVFF  02,70F
07120:  MOVFF  01,70E
07124:  MOVFF  00,70D
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
07128:  MOVLB  7
0712A:  MOVF   x0C,W
0712C:  SUBLW  50
0712E:  BNZ   715A
07130:  MOVLW  01
07132:  SUBWF  x0B,W
07134:  MULLW  28
07136:  MOVF   FF3,W
07138:  CLRF   x12
0713A:  MOVWF  x11
0713C:  MOVLW  20
0713E:  ADDWF  x11,W
07140:  MOVWF  FE9
07142:  MOVLW  00
07144:  ADDWFC x12,W
07146:  MOVWF  FEA
07148:  MOVFF  70D,FEF
0714C:  MOVFF  70E,FEC
07150:  MOVFF  70F,FEC
07154:  MOVFF  710,FEC
07158:  BRA    71DC
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
0715A:  MOVF   x0C,W
0715C:  SUBLW  49
0715E:  BNZ   7196
07160:  MOVLW  01
07162:  SUBWF  x0B,W
07164:  MULLW  28
07166:  MOVF   FF3,W
07168:  CLRF   x12
0716A:  MOVWF  x11
0716C:  MOVLW  04
0716E:  ADDWF  x11,W
07170:  MOVWF  01
07172:  MOVLW  00
07174:  ADDWFC x12,W
07176:  MOVWF  03
07178:  MOVF   01,W
0717A:  ADDLW  20
0717C:  MOVWF  FE9
0717E:  MOVLW  00
07180:  ADDWFC 03,W
07182:  MOVWF  FEA
07184:  MOVFF  70D,FEF
07188:  MOVFF  70E,FEC
0718C:  MOVFF  70F,FEC
07190:  MOVFF  710,FEC
07194:  BRA    71DC
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
07196:  MOVF   x0C,W
07198:  SUBLW  44
0719A:  BNZ   71D2
0719C:  MOVLW  01
0719E:  SUBWF  x0B,W
071A0:  MULLW  28
071A2:  MOVF   FF3,W
071A4:  CLRF   x12
071A6:  MOVWF  x11
071A8:  MOVLW  08
071AA:  ADDWF  x11,W
071AC:  MOVWF  01
071AE:  MOVLW  00
071B0:  ADDWFC x12,W
071B2:  MOVWF  03
071B4:  MOVF   01,W
071B6:  ADDLW  20
071B8:  MOVWF  FE9
071BA:  MOVLW  00
071BC:  ADDWFC 03,W
071BE:  MOVWF  FEA
071C0:  MOVFF  70D,FEF
071C4:  MOVFF  70E,FEC
071C8:  MOVFF  70F,FEC
071CC:  MOVFF  710,FEC
071D0:  BRA    71DC
....................    else return INV_PARAM;
071D2:  MOVLW  02
071D4:  MOVWF  01
071D6:  MOVLB  0
071D8:  BRA    71E2
071DA:  MOVLB  7
....................    
....................    return SUCCESS;
071DC:  MOVLW  00
071DE:  MOVWF  01
071E0:  MOVLB  0
071E2:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
071E4:  MOVLB  7
071E6:  CLRF   x42
071E8:  MOVFF  690,741
071EC:  CLRF   x44
071EE:  MOVLW  B5
071F0:  MOVWF  x43
071F2:  MOVLB  0
071F4:  CALL   08BA
071F8:  MOVFF  02,70D
071FC:  MOVFF  01,70C
07200:  MOVLW  06
07202:  MOVLB  7
07204:  ADDWF  x0C,F
07206:  MOVLW  00
07208:  ADDWFC x0D,F
0720A:  MOVLW  32
0720C:  ADDWF  x0C,W
0720E:  MOVWF  01
07210:  MOVLW  00
07212:  ADDWFC x0D,W
07214:  MOVWF  03
07216:  MOVF   01,W
07218:  ADDLW  EB
0721A:  MOVWF  01
0721C:  MOVLW  01
0721E:  ADDWFC 03,F
07220:  MOVFF  01,70C
07224:  MOVFF  03,70D
07228:  MOVFF  03,734
0722C:  MOVFF  01,733
07230:  MOVLB  0
07232:  CALL   5844
07236:  MOVF   01,F
07238:  BNZ   7242
0723A:  MOVLW  02
0723C:  MOVWF  01
0723E:  BRA    7344
07240:  BRA    72A0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07242:  MOVLB  7
07244:  CLRF   x42
07246:  MOVFF  690,741
0724A:  CLRF   x44
0724C:  MOVLW  B5
0724E:  MOVWF  x43
07250:  MOVLB  0
07252:  CALL   08BA
07256:  MOVFF  02,70D
0725A:  MOVFF  01,70C
0725E:  MOVLW  06
07260:  MOVLB  7
07262:  ADDWF  x0C,F
07264:  MOVLW  00
07266:  ADDWFC x0D,F
07268:  MOVLW  32
0726A:  ADDWF  x0C,W
0726C:  MOVWF  01
0726E:  MOVLW  00
07270:  ADDWFC x0D,W
07272:  MOVWF  03
07274:  MOVF   01,W
07276:  ADDLW  EB
07278:  MOVWF  01
0727A:  MOVLW  01
0727C:  ADDWFC 03,F
0727E:  MOVFF  01,70C
07282:  MOVFF  03,70D
07286:  MOVFF  03,734
0728A:  MOVFF  01,733
0728E:  CLRF   x36
07290:  CLRF   x35
07292:  MOVLW  0A
07294:  MOVWF  x37
07296:  MOVLB  0
07298:  CALL   5934
0729C:  MOVFF  01,70B
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
072A0:  MOVLW  04
072A2:  MOVLB  7
072A4:  MOVWF  x42
072A6:  MOVLW  C1
072A8:  MOVWF  x41
072AA:  MOVLB  0
072AC:  CALL   566E
072B0:  MOVF   01,W
072B2:  ADDLW  C1
072B4:  MOVLB  7
072B6:  MOVWF  x0C
072B8:  MOVLW  04
072BA:  ADDWFC 02,W
072BC:  MOVWF  x0D
072BE:  MOVLW  01
072C0:  SUBWF  x0B,W
072C2:  MULLW  28
072C4:  MOVF   FF3,W
072C6:  CLRF   x0F
072C8:  MOVWF  x0E
072CA:  MOVLW  0C
072CC:  ADDWF  x0E,W
072CE:  MOVWF  01
072D0:  MOVLW  00
072D2:  ADDWFC x0F,W
072D4:  MOVWF  03
072D6:  MOVF   01,W
072D8:  ADDLW  20
072DA:  MOVWF  FE9
072DC:  MOVLW  00
072DE:  ADDWFC 03,W
072E0:  MOVWF  FEA
072E2:  MOVFF  FEF,70E
072E6:  MOVFF  FEC,70F
072EA:  MOVFF  FEC,710
072EE:  MOVFF  FEC,711
072F2:  MOVFF  70D,565
072F6:  MOVFF  70C,564
072FA:  MOVFF  70B,734
072FE:  MOVLW  18
07300:  MOVWF  x35
07302:  MOVLB  0
07304:  CALL   5C88
07308:  MOVLW  2C
0730A:  MOVLB  7
0730C:  MOVWF  x50
0730E:  MOVLB  0
07310:  CALL   56A6
07314:  MOVLW  89
07316:  MOVWF  FE9
07318:  MOVFF  711,746
0731C:  MOVFF  710,745
07320:  MOVFF  70F,744
07324:  MOVFF  70E,743
07328:  MOVLW  02
0732A:  MOVLB  7
0732C:  MOVWF  x47
0732E:  MOVLB  0
07330:  CALL   6582
07334:  MOVLW  2C
07336:  MOVLB  7
07338:  MOVWF  x50
0733A:  MOVLB  0
0733C:  CALL   56A6
....................    return SUCCESS;
07340:  MOVLW  00
07342:  MOVWF  01
07344:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07346:  MOVLB  7
07348:  CLRF   x42
0734A:  MOVFF  690,741
0734E:  CLRF   x44
07350:  MOVLW  B5
07352:  MOVWF  x43
07354:  MOVLB  0
07356:  CALL   08BA
0735A:  MOVFF  02,711
0735E:  MOVFF  01,710
07362:  MOVLW  06
07364:  MOVLB  7
07366:  ADDWF  x10,F
07368:  MOVLW  00
0736A:  ADDWFC x11,F
0736C:  MOVLW  32
0736E:  ADDWF  x10,W
07370:  MOVWF  01
07372:  MOVLW  00
07374:  ADDWFC x11,W
07376:  MOVWF  03
07378:  MOVF   01,W
0737A:  ADDLW  EB
0737C:  MOVWF  01
0737E:  MOVLW  01
07380:  ADDWFC 03,F
07382:  MOVFF  01,710
07386:  MOVFF  03,711
0738A:  MOVFF  03,734
0738E:  MOVFF  01,733
07392:  MOVLB  0
07394:  CALL   5844
07398:  MOVF   01,F
0739A:  BNZ   73A4
0739C:  MOVLW  02
0739E:  MOVWF  01
073A0:  BRA    7502
073A2:  BRA    7402
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
073A4:  MOVLB  7
073A6:  CLRF   x42
073A8:  MOVFF  690,741
073AC:  CLRF   x44
073AE:  MOVLW  B5
073B0:  MOVWF  x43
073B2:  MOVLB  0
073B4:  CALL   08BA
073B8:  MOVFF  02,711
073BC:  MOVFF  01,710
073C0:  MOVLW  06
073C2:  MOVLB  7
073C4:  ADDWF  x10,F
073C6:  MOVLW  00
073C8:  ADDWFC x11,F
073CA:  MOVLW  32
073CC:  ADDWF  x10,W
073CE:  MOVWF  01
073D0:  MOVLW  00
073D2:  ADDWFC x11,W
073D4:  MOVWF  03
073D6:  MOVF   01,W
073D8:  ADDLW  EB
073DA:  MOVWF  01
073DC:  MOVLW  01
073DE:  ADDWFC 03,F
073E0:  MOVFF  01,710
073E4:  MOVFF  03,711
073E8:  MOVFF  03,734
073EC:  MOVFF  01,733
073F0:  CLRF   x36
073F2:  CLRF   x35
073F4:  MOVLW  0A
073F6:  MOVWF  x37
073F8:  MOVLB  0
073FA:  CALL   5934
073FE:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
07402:  MOVLB  7
07404:  CLRF   x42
07406:  MOVFF  690,741
0740A:  CLRF   x44
0740C:  MOVLW  B5
0740E:  MOVWF  x43
07410:  MOVLB  0
07412:  CALL   08BA
07416:  MOVFF  02,711
0741A:  MOVFF  01,710
0741E:  MOVLW  06
07420:  MOVLB  7
07422:  ADDWF  x10,F
07424:  MOVLW  00
07426:  ADDWFC x11,F
07428:  MOVLW  4B
0742A:  ADDWF  x10,W
0742C:  MOVWF  01
0742E:  MOVLW  00
07430:  ADDWFC x11,W
07432:  MOVWF  03
07434:  MOVF   01,W
07436:  ADDLW  EB
07438:  MOVWF  01
0743A:  MOVLW  01
0743C:  ADDWFC 03,F
0743E:  MOVFF  01,710
07442:  MOVFF  03,711
07446:  MOVFF  03,715
0744A:  MOVFF  01,714
0744E:  MOVLB  0
07450:  CALL   6BE8
07454:  MOVF   01,F
07456:  BNZ   7460
07458:  MOVLW  02
0745A:  MOVWF  01
0745C:  BRA    7502
0745E:  BRA    74C6
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
07460:  MOVLB  7
07462:  CLRF   x42
07464:  MOVFF  690,741
07468:  CLRF   x44
0746A:  MOVLW  B5
0746C:  MOVWF  x43
0746E:  MOVLB  0
07470:  CALL   08BA
07474:  MOVFF  02,711
07478:  MOVFF  01,710
0747C:  MOVLW  06
0747E:  MOVLB  7
07480:  ADDWF  x10,F
07482:  MOVLW  00
07484:  ADDWFC x11,F
07486:  MOVLW  4B
07488:  ADDWF  x10,W
0748A:  MOVWF  01
0748C:  MOVLW  00
0748E:  ADDWFC x11,W
07490:  MOVWF  03
07492:  MOVF   01,W
07494:  ADDLW  EB
07496:  MOVWF  01
07498:  MOVLW  01
0749A:  ADDWFC 03,F
0749C:  MOVFF  01,710
074A0:  MOVFF  03,711
074A4:  MOVFF  03,715
074A8:  MOVFF  01,714
074AC:  CLRF   x17
074AE:  CLRF   x16
074B0:  MOVLB  0
074B2:  CALL   6CAA
074B6:  MOVFF  03,70F
074BA:  MOVFF  02,70E
074BE:  MOVFF  01,70D
074C2:  MOVFF  00,70C
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
074C6:  MOVLW  01
074C8:  MOVLB  7
074CA:  SUBWF  x0B,W
074CC:  MULLW  28
074CE:  MOVF   FF3,W
074D0:  CLRF   x11
074D2:  MOVWF  x10
074D4:  MOVLW  0C
074D6:  ADDWF  x10,W
074D8:  MOVWF  01
074DA:  MOVLW  00
074DC:  ADDWFC x11,W
074DE:  MOVWF  03
074E0:  MOVF   01,W
074E2:  ADDLW  20
074E4:  MOVWF  FE9
074E6:  MOVLW  00
074E8:  ADDWFC 03,W
074EA:  MOVWF  FEA
074EC:  MOVFF  70C,FEF
074F0:  MOVFF  70D,FEC
074F4:  MOVFF  70E,FEC
074F8:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
074FC:  MOVLW  00
074FE:  MOVWF  01
07500:  MOVLB  0
07502:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07504:  MOVLB  7
07506:  CLRF   x42
07508:  MOVFF  690,741
0750C:  CLRF   x44
0750E:  MOVLW  B5
07510:  MOVWF  x43
07512:  MOVLB  0
07514:  CALL   08BA
07518:  MOVFF  02,70D
0751C:  MOVFF  01,70C
07520:  MOVLW  06
07522:  MOVLB  7
07524:  ADDWF  x0C,F
07526:  MOVLW  00
07528:  ADDWFC x0D,F
0752A:  MOVLW  32
0752C:  ADDWF  x0C,W
0752E:  MOVWF  01
07530:  MOVLW  00
07532:  ADDWFC x0D,W
07534:  MOVWF  03
07536:  MOVF   01,W
07538:  ADDLW  EB
0753A:  MOVWF  01
0753C:  MOVLW  01
0753E:  ADDWFC 03,F
07540:  MOVFF  01,70C
07544:  MOVFF  03,70D
07548:  MOVFF  03,734
0754C:  MOVFF  01,733
07550:  MOVLB  0
07552:  CALL   5844
07556:  MOVF   01,F
07558:  BNZ   7562
0755A:  MOVLW  02
0755C:  MOVWF  01
0755E:  BRA    78B8
07560:  BRA    75C0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07562:  MOVLB  7
07564:  CLRF   x42
07566:  MOVFF  690,741
0756A:  CLRF   x44
0756C:  MOVLW  B5
0756E:  MOVWF  x43
07570:  MOVLB  0
07572:  CALL   08BA
07576:  MOVFF  02,70D
0757A:  MOVFF  01,70C
0757E:  MOVLW  06
07580:  MOVLB  7
07582:  ADDWF  x0C,F
07584:  MOVLW  00
07586:  ADDWFC x0D,F
07588:  MOVLW  32
0758A:  ADDWF  x0C,W
0758C:  MOVWF  01
0758E:  MOVLW  00
07590:  ADDWFC x0D,W
07592:  MOVWF  03
07594:  MOVF   01,W
07596:  ADDLW  EB
07598:  MOVWF  01
0759A:  MOVLW  01
0759C:  ADDWFC 03,F
0759E:  MOVFF  01,70C
075A2:  MOVFF  03,70D
075A6:  MOVFF  03,734
075AA:  MOVFF  01,733
075AE:  CLRF   x36
075B0:  CLRF   x35
075B2:  MOVLW  0A
075B4:  MOVWF  x37
075B6:  MOVLB  0
075B8:  CALL   5934
075BC:  MOVFF  01,70B
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
075C0:  MOVLW  04
075C2:  MOVLB  7
075C4:  MOVWF  x42
075C6:  MOVLW  C1
075C8:  MOVWF  x41
075CA:  MOVLB  0
075CC:  CALL   566E
075D0:  MOVFF  02,03
075D4:  MOVF   01,W
075D6:  ADDLW  C1
075D8:  MOVLB  7
075DA:  MOVWF  x0C
075DC:  MOVLW  04
075DE:  ADDWFC 02,W
075E0:  MOVWF  x0D
075E2:  MOVFF  FE8,565
075E6:  MOVFF  70C,564
075EA:  MOVFF  70B,734
075EE:  MOVLW  18
075F0:  MOVWF  x35
075F2:  MOVLB  0
075F4:  CALL   5C88
075F8:  MOVLW  2C
075FA:  MOVLB  7
075FC:  MOVWF  x50
075FE:  MOVLB  0
07600:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
07604:  MOVLW  04
07606:  MOVLB  7
07608:  MOVWF  x42
0760A:  MOVLW  C1
0760C:  MOVWF  x41
0760E:  MOVLB  0
07610:  CALL   566E
07614:  MOVFF  02,03
07618:  MOVF   01,W
0761A:  ADDLW  C1
0761C:  MOVLB  7
0761E:  MOVWF  x0C
07620:  MOVLW  04
07622:  ADDWFC 02,W
07624:  MOVWF  x0D
07626:  MOVLW  01
07628:  SUBWF  x0B,W
0762A:  MULLW  18
0762C:  MOVF   FF3,W
0762E:  CLRF   x0F
07630:  MOVWF  x0E
07632:  MOVLW  92
07634:  ADDWF  x0E,W
07636:  MOVWF  FE9
07638:  MOVLW  00
0763A:  ADDWFC x0F,W
0763C:  MOVWF  FEA
0763E:  MOVFF  FEF,743
07642:  MOVFF  FEC,744
07646:  MOVFF  FEC,745
0764A:  MOVFF  FEC,746
0764E:  MOVFF  70D,565
07652:  MOVFF  70C,564
07656:  MOVLW  89
07658:  MOVWF  FE9
0765A:  MOVLW  02
0765C:  MOVWF  x47
0765E:  MOVLB  0
07660:  CALL   6582
07664:  MOVLW  2C
07666:  MOVLB  7
07668:  MOVWF  x50
0766A:  MOVLB  0
0766C:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
07670:  MOVLW  04
07672:  MOVLB  7
07674:  MOVWF  x42
07676:  MOVLW  C1
07678:  MOVWF  x41
0767A:  MOVLB  0
0767C:  CALL   566E
07680:  MOVF   01,W
07682:  ADDLW  C1
07684:  MOVLB  7
07686:  MOVWF  x0C
07688:  MOVLW  04
0768A:  ADDWFC 02,W
0768C:  MOVWF  x0D
0768E:  MOVLW  01
07690:  SUBWF  x0B,W
07692:  MULLW  18
07694:  MOVF   FF3,W
07696:  CLRF   x0F
07698:  MOVWF  x0E
0769A:  MOVLW  04
0769C:  ADDWF  x0E,W
0769E:  MOVWF  01
076A0:  MOVLW  00
076A2:  ADDWFC x0F,W
076A4:  MOVWF  03
076A6:  MOVF   01,W
076A8:  ADDLW  92
076AA:  MOVWF  FE9
076AC:  MOVLW  00
076AE:  ADDWFC 03,W
076B0:  MOVWF  FEA
076B2:  MOVFF  FEF,743
076B6:  MOVFF  FEC,744
076BA:  MOVFF  FEC,745
076BE:  MOVFF  FEC,746
076C2:  MOVFF  70D,565
076C6:  MOVFF  70C,564
076CA:  MOVLW  89
076CC:  MOVWF  FE9
076CE:  MOVLW  02
076D0:  MOVWF  x47
076D2:  MOVLB  0
076D4:  CALL   6582
076D8:  MOVLW  2C
076DA:  MOVLB  7
076DC:  MOVWF  x50
076DE:  MOVLB  0
076E0:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
076E4:  MOVLW  04
076E6:  MOVLB  7
076E8:  MOVWF  x42
076EA:  MOVLW  C1
076EC:  MOVWF  x41
076EE:  MOVLB  0
076F0:  CALL   566E
076F4:  MOVF   01,W
076F6:  ADDLW  C1
076F8:  MOVLB  7
076FA:  MOVWF  x0C
076FC:  MOVLW  04
076FE:  ADDWFC 02,W
07700:  MOVWF  x0D
07702:  MOVLW  01
07704:  SUBWF  x0B,W
07706:  MULLW  18
07708:  MOVF   FF3,W
0770A:  CLRF   x0F
0770C:  MOVWF  x0E
0770E:  MOVLW  08
07710:  ADDWF  x0E,W
07712:  MOVWF  01
07714:  MOVLW  00
07716:  ADDWFC x0F,W
07718:  MOVWF  03
0771A:  MOVF   01,W
0771C:  ADDLW  92
0771E:  MOVWF  FE9
07720:  MOVLW  00
07722:  ADDWFC 03,W
07724:  MOVWF  FEA
07726:  MOVFF  FEF,743
0772A:  MOVFF  FEC,744
0772E:  MOVFF  FEC,745
07732:  MOVFF  FEC,746
07736:  MOVFF  70D,565
0773A:  MOVFF  70C,564
0773E:  MOVLW  89
07740:  MOVWF  FE9
07742:  MOVLW  02
07744:  MOVWF  x47
07746:  MOVLB  0
07748:  CALL   6582
0774C:  MOVLW  2C
0774E:  MOVLB  7
07750:  MOVWF  x50
07752:  MOVLB  0
07754:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
07758:  MOVLW  04
0775A:  MOVLB  7
0775C:  MOVWF  x42
0775E:  MOVLW  C1
07760:  MOVWF  x41
07762:  MOVLB  0
07764:  CALL   566E
07768:  MOVF   01,W
0776A:  ADDLW  C1
0776C:  MOVLB  7
0776E:  MOVWF  x0C
07770:  MOVLW  04
07772:  ADDWFC 02,W
07774:  MOVWF  x0D
07776:  MOVLW  01
07778:  SUBWF  x0B,W
0777A:  MULLW  18
0777C:  MOVF   FF3,W
0777E:  CLRF   x0F
07780:  MOVWF  x0E
07782:  MOVLW  0C
07784:  ADDWF  x0E,W
07786:  MOVWF  01
07788:  MOVLW  00
0778A:  ADDWFC x0F,W
0778C:  MOVWF  03
0778E:  MOVF   01,W
07790:  ADDLW  92
07792:  MOVWF  FE9
07794:  MOVLW  00
07796:  ADDWFC 03,W
07798:  MOVWF  FEA
0779A:  MOVFF  FEF,743
0779E:  MOVFF  FEC,744
077A2:  MOVFF  FEC,745
077A6:  MOVFF  FEC,746
077AA:  MOVFF  70D,565
077AE:  MOVFF  70C,564
077B2:  MOVLW  89
077B4:  MOVWF  FE9
077B6:  MOVLW  02
077B8:  MOVWF  x47
077BA:  MOVLB  0
077BC:  CALL   6582
077C0:  MOVLW  2C
077C2:  MOVLB  7
077C4:  MOVWF  x50
077C6:  MOVLB  0
077C8:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
077CC:  MOVLW  04
077CE:  MOVLB  7
077D0:  MOVWF  x42
077D2:  MOVLW  C1
077D4:  MOVWF  x41
077D6:  MOVLB  0
077D8:  CALL   566E
077DC:  MOVF   01,W
077DE:  ADDLW  C1
077E0:  MOVLB  7
077E2:  MOVWF  x0C
077E4:  MOVLW  04
077E6:  ADDWFC 02,W
077E8:  MOVWF  x0D
077EA:  MOVLW  01
077EC:  SUBWF  x0B,W
077EE:  MULLW  18
077F0:  MOVF   FF3,W
077F2:  CLRF   x0F
077F4:  MOVWF  x0E
077F6:  MOVLW  10
077F8:  ADDWF  x0E,W
077FA:  MOVWF  01
077FC:  MOVLW  00
077FE:  ADDWFC x0F,W
07800:  MOVWF  03
07802:  MOVF   01,W
07804:  ADDLW  92
07806:  MOVWF  FE9
07808:  MOVLW  00
0780A:  ADDWFC 03,W
0780C:  MOVWF  FEA
0780E:  MOVFF  FEF,743
07812:  MOVFF  FEC,744
07816:  MOVFF  FEC,745
0781A:  MOVFF  FEC,746
0781E:  MOVFF  70D,565
07822:  MOVFF  70C,564
07826:  MOVLW  89
07828:  MOVWF  FE9
0782A:  MOVLW  02
0782C:  MOVWF  x47
0782E:  MOVLB  0
07830:  CALL   6582
07834:  MOVLW  2C
07836:  MOVLB  7
07838:  MOVWF  x50
0783A:  MOVLB  0
0783C:  CALL   56A6
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
07840:  MOVLW  04
07842:  MOVLB  7
07844:  MOVWF  x42
07846:  MOVLW  C1
07848:  MOVWF  x41
0784A:  MOVLB  0
0784C:  CALL   566E
07850:  MOVF   01,W
07852:  ADDLW  C1
07854:  MOVLB  7
07856:  MOVWF  x0C
07858:  MOVLW  04
0785A:  ADDWFC 02,W
0785C:  MOVWF  x0D
0785E:  MOVLW  01
07860:  SUBWF  x0B,W
07862:  MULLW  18
07864:  MOVF   FF3,W
07866:  CLRF   x0F
07868:  MOVWF  x0E
0786A:  MOVLW  14
0786C:  ADDWF  x0E,W
0786E:  MOVWF  01
07870:  MOVLW  00
07872:  ADDWFC x0F,W
07874:  MOVWF  03
07876:  MOVF   01,W
07878:  ADDLW  92
0787A:  MOVWF  FE9
0787C:  MOVLW  00
0787E:  ADDWFC 03,W
07880:  MOVWF  FEA
07882:  MOVFF  FEF,743
07886:  MOVFF  FEC,744
0788A:  MOVFF  FEC,745
0788E:  MOVFF  FEC,746
07892:  MOVFF  70D,565
07896:  MOVFF  70C,564
0789A:  MOVLW  89
0789C:  MOVWF  FE9
0789E:  MOVLW  02
078A0:  MOVWF  x47
078A2:  MOVLB  0
078A4:  CALL   6582
078A8:  MOVLW  2C
078AA:  MOVLB  7
078AC:  MOVWF  x50
078AE:  MOVLB  0
078B0:  CALL   56A6
....................    
....................    return SUCCESS;
078B4:  MOVLW  00
078B6:  MOVWF  01
078B8:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
078BA:  MOVLB  7
078BC:  CLRF   x42
078BE:  MOVFF  690,741
078C2:  CLRF   x44
078C4:  MOVLW  B5
078C6:  MOVWF  x43
078C8:  MOVLB  0
078CA:  CALL   08BA
078CE:  MOVFF  02,70E
078D2:  MOVFF  01,70D
078D6:  MOVLW  06
078D8:  MOVLB  7
078DA:  ADDWF  x0D,F
078DC:  MOVLW  00
078DE:  ADDWFC x0E,F
078E0:  MOVLW  32
078E2:  ADDWF  x0D,W
078E4:  MOVWF  01
078E6:  MOVLW  00
078E8:  ADDWFC x0E,W
078EA:  MOVWF  03
078EC:  MOVF   01,W
078EE:  ADDLW  EB
078F0:  MOVWF  01
078F2:  MOVLW  01
078F4:  ADDWFC 03,F
078F6:  MOVFF  01,70D
078FA:  MOVFF  03,70E
078FE:  MOVFF  03,734
07902:  MOVFF  01,733
07906:  MOVLB  0
07908:  CALL   5844
0790C:  MOVF   01,F
0790E:  BNZ   7918
07910:  MOVLW  02
07912:  MOVWF  01
07914:  BRA    7E14
07916:  BRA    7976
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07918:  MOVLB  7
0791A:  CLRF   x42
0791C:  MOVFF  690,741
07920:  CLRF   x44
07922:  MOVLW  B5
07924:  MOVWF  x43
07926:  MOVLB  0
07928:  CALL   08BA
0792C:  MOVFF  02,70E
07930:  MOVFF  01,70D
07934:  MOVLW  06
07936:  MOVLB  7
07938:  ADDWF  x0D,F
0793A:  MOVLW  00
0793C:  ADDWFC x0E,F
0793E:  MOVLW  32
07940:  ADDWF  x0D,W
07942:  MOVWF  01
07944:  MOVLW  00
07946:  ADDWFC x0E,W
07948:  MOVWF  03
0794A:  MOVF   01,W
0794C:  ADDLW  EB
0794E:  MOVWF  01
07950:  MOVLW  01
07952:  ADDWFC 03,F
07954:  MOVFF  01,70D
07958:  MOVFF  03,70E
0795C:  MOVFF  03,734
07960:  MOVFF  01,733
07964:  CLRF   x36
07966:  CLRF   x35
07968:  MOVLW  0A
0796A:  MOVWF  x37
0796C:  MOVLB  0
0796E:  CALL   5934
07972:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07976:  MOVLB  7
07978:  CLRF   x42
0797A:  MOVFF  690,741
0797E:  CLRF   x44
07980:  MOVLW  B5
07982:  MOVWF  x43
07984:  MOVLB  0
07986:  CALL   08BA
0798A:  MOVFF  02,70E
0798E:  MOVFF  01,70D
07992:  MOVLW  06
07994:  MOVLB  7
07996:  ADDWF  x0D,F
07998:  MOVLW  00
0799A:  ADDWFC x0E,F
0799C:  MOVLW  4B
0799E:  ADDWF  x0D,W
079A0:  MOVWF  01
079A2:  MOVLW  00
079A4:  ADDWFC x0E,W
079A6:  MOVWF  03
079A8:  MOVF   01,W
079AA:  ADDLW  EB
079AC:  MOVWF  01
079AE:  MOVLW  01
079B0:  ADDWFC 03,F
079B2:  MOVFF  01,70D
079B6:  MOVFF  03,70E
079BA:  MOVFF  03,742
079BE:  MOVFF  01,741
079C2:  MOVLB  0
079C4:  CALL   566E
079C8:  MOVFF  02,03
079CC:  MOVF   01,W
079CE:  SUBLW  01
079D0:  BNZ   79D6
079D2:  MOVF   03,F
079D4:  BZ    79DE
079D6:  MOVLW  02
079D8:  MOVWF  01
079DA:  BRA    7E14
079DC:  BRA    7A1E
....................    else arg2 = SERcmd[rec].p[3][0];
079DE:  MOVLB  7
079E0:  CLRF   x42
079E2:  MOVFF  690,741
079E6:  CLRF   x44
079E8:  MOVLW  B5
079EA:  MOVWF  x43
079EC:  MOVLB  0
079EE:  CALL   08BA
079F2:  MOVFF  02,70E
079F6:  MOVFF  01,70D
079FA:  MOVLW  06
079FC:  MOVLB  7
079FE:  ADDWF  x0D,F
07A00:  MOVLW  00
07A02:  ADDWFC x0E,F
07A04:  MOVLW  4B
07A06:  ADDWF  x0D,F
07A08:  MOVLW  00
07A0A:  ADDWFC x0E,F
07A0C:  MOVLW  EB
07A0E:  ADDWF  x0D,W
07A10:  MOVWF  FE9
07A12:  MOVLW  01
07A14:  ADDWFC x0E,W
07A16:  MOVWF  FEA
07A18:  MOVFF  FEF,70C
07A1C:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
07A1E:  MOVLB  7
07A20:  MOVF   x0C,W
07A22:  SUBLW  30
07A24:  BNZ   7AC0
07A26:  MOVLW  04
07A28:  MOVWF  x42
07A2A:  MOVLW  C1
07A2C:  MOVWF  x41
07A2E:  MOVLB  0
07A30:  CALL   566E
07A34:  MOVFF  02,03
07A38:  MOVF   01,W
07A3A:  ADDLW  C1
07A3C:  MOVLB  7
07A3E:  MOVWF  x0D
07A40:  MOVLW  04
07A42:  ADDWFC 02,W
07A44:  MOVWF  x0E
07A46:  MOVLW  01
07A48:  SUBWF  x0B,W
07A4A:  MULLW  18
07A4C:  MOVF   FF3,W
07A4E:  CLRF   x10
07A50:  MOVWF  x0F
07A52:  MOVLW  92
07A54:  ADDWF  x0F,W
07A56:  MOVWF  FE9
07A58:  MOVLW  00
07A5A:  ADDWFC x10,W
07A5C:  MOVWF  FEA
07A5E:  MOVFF  FEF,711
07A62:  MOVFF  FEC,712
07A66:  MOVFF  FEC,713
07A6A:  MOVFF  FEC,714
07A6E:  MOVFF  70E,565
07A72:  MOVFF  70D,564
07A76:  MOVFF  70B,734
07A7A:  MOVLW  18
07A7C:  MOVWF  x35
07A7E:  MOVLB  0
07A80:  CALL   5C88
07A84:  MOVLW  2C
07A86:  MOVLB  7
07A88:  MOVWF  x50
07A8A:  MOVLB  0
07A8C:  CALL   56A6
07A90:  MOVLW  89
07A92:  MOVWF  FE9
07A94:  MOVFF  714,746
07A98:  MOVFF  713,745
07A9C:  MOVFF  712,744
07AA0:  MOVFF  711,743
07AA4:  MOVLW  02
07AA6:  MOVLB  7
07AA8:  MOVWF  x47
07AAA:  MOVLB  0
07AAC:  CALL   6582
07AB0:  MOVLW  2C
07AB2:  MOVLB  7
07AB4:  MOVWF  x50
07AB6:  MOVLB  0
07AB8:  CALL   56A6
07ABC:  BRA    7E10
07ABE:  MOVLB  7
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
07AC0:  MOVF   x0C,W
07AC2:  SUBLW  31
07AC4:  BNZ   7B68
07AC6:  MOVLW  04
07AC8:  MOVWF  x42
07ACA:  MOVLW  C1
07ACC:  MOVWF  x41
07ACE:  MOVLB  0
07AD0:  CALL   566E
07AD4:  MOVF   01,W
07AD6:  ADDLW  C1
07AD8:  MOVLB  7
07ADA:  MOVWF  x0D
07ADC:  MOVLW  04
07ADE:  ADDWFC 02,W
07AE0:  MOVWF  x0E
07AE2:  MOVLW  01
07AE4:  SUBWF  x0B,W
07AE6:  MULLW  18
07AE8:  MOVF   FF3,W
07AEA:  CLRF   x10
07AEC:  MOVWF  x0F
07AEE:  MOVLW  04
07AF0:  ADDWF  x0F,W
07AF2:  MOVWF  01
07AF4:  MOVLW  00
07AF6:  ADDWFC x10,W
07AF8:  MOVWF  03
07AFA:  MOVF   01,W
07AFC:  ADDLW  92
07AFE:  MOVWF  FE9
07B00:  MOVLW  00
07B02:  ADDWFC 03,W
07B04:  MOVWF  FEA
07B06:  MOVFF  FEF,70F
07B0A:  MOVFF  FEC,710
07B0E:  MOVFF  FEC,711
07B12:  MOVFF  FEC,712
07B16:  MOVFF  70E,565
07B1A:  MOVFF  70D,564
07B1E:  MOVFF  70B,734
07B22:  MOVLW  18
07B24:  MOVWF  x35
07B26:  MOVLB  0
07B28:  CALL   5C88
07B2C:  MOVLW  2C
07B2E:  MOVLB  7
07B30:  MOVWF  x50
07B32:  MOVLB  0
07B34:  CALL   56A6
07B38:  MOVLW  89
07B3A:  MOVWF  FE9
07B3C:  MOVFF  712,746
07B40:  MOVFF  711,745
07B44:  MOVFF  710,744
07B48:  MOVFF  70F,743
07B4C:  MOVLW  02
07B4E:  MOVLB  7
07B50:  MOVWF  x47
07B52:  MOVLB  0
07B54:  CALL   6582
07B58:  MOVLW  2C
07B5A:  MOVLB  7
07B5C:  MOVWF  x50
07B5E:  MOVLB  0
07B60:  CALL   56A6
07B64:  BRA    7E10
07B66:  MOVLB  7
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07B68:  MOVF   x0C,W
07B6A:  SUBLW  32
07B6C:  BNZ   7C10
07B6E:  MOVLW  04
07B70:  MOVWF  x42
07B72:  MOVLW  C1
07B74:  MOVWF  x41
07B76:  MOVLB  0
07B78:  CALL   566E
07B7C:  MOVF   01,W
07B7E:  ADDLW  C1
07B80:  MOVLB  7
07B82:  MOVWF  x0D
07B84:  MOVLW  04
07B86:  ADDWFC 02,W
07B88:  MOVWF  x0E
07B8A:  MOVLW  01
07B8C:  SUBWF  x0B,W
07B8E:  MULLW  18
07B90:  MOVF   FF3,W
07B92:  CLRF   x10
07B94:  MOVWF  x0F
07B96:  MOVLW  08
07B98:  ADDWF  x0F,W
07B9A:  MOVWF  01
07B9C:  MOVLW  00
07B9E:  ADDWFC x10,W
07BA0:  MOVWF  03
07BA2:  MOVF   01,W
07BA4:  ADDLW  92
07BA6:  MOVWF  FE9
07BA8:  MOVLW  00
07BAA:  ADDWFC 03,W
07BAC:  MOVWF  FEA
07BAE:  MOVFF  FEF,70F
07BB2:  MOVFF  FEC,710
07BB6:  MOVFF  FEC,711
07BBA:  MOVFF  FEC,712
07BBE:  MOVFF  70E,565
07BC2:  MOVFF  70D,564
07BC6:  MOVFF  70B,734
07BCA:  MOVLW  18
07BCC:  MOVWF  x35
07BCE:  MOVLB  0
07BD0:  CALL   5C88
07BD4:  MOVLW  2C
07BD6:  MOVLB  7
07BD8:  MOVWF  x50
07BDA:  MOVLB  0
07BDC:  CALL   56A6
07BE0:  MOVLW  89
07BE2:  MOVWF  FE9
07BE4:  MOVFF  712,746
07BE8:  MOVFF  711,745
07BEC:  MOVFF  710,744
07BF0:  MOVFF  70F,743
07BF4:  MOVLW  02
07BF6:  MOVLB  7
07BF8:  MOVWF  x47
07BFA:  MOVLB  0
07BFC:  CALL   6582
07C00:  MOVLW  2C
07C02:  MOVLB  7
07C04:  MOVWF  x50
07C06:  MOVLB  0
07C08:  CALL   56A6
07C0C:  BRA    7E10
07C0E:  MOVLB  7
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07C10:  MOVF   x0C,W
07C12:  SUBLW  33
07C14:  BNZ   7CB8
07C16:  MOVLW  04
07C18:  MOVWF  x42
07C1A:  MOVLW  C1
07C1C:  MOVWF  x41
07C1E:  MOVLB  0
07C20:  CALL   566E
07C24:  MOVF   01,W
07C26:  ADDLW  C1
07C28:  MOVLB  7
07C2A:  MOVWF  x0D
07C2C:  MOVLW  04
07C2E:  ADDWFC 02,W
07C30:  MOVWF  x0E
07C32:  MOVLW  01
07C34:  SUBWF  x0B,W
07C36:  MULLW  18
07C38:  MOVF   FF3,W
07C3A:  CLRF   x10
07C3C:  MOVWF  x0F
07C3E:  MOVLW  0C
07C40:  ADDWF  x0F,W
07C42:  MOVWF  01
07C44:  MOVLW  00
07C46:  ADDWFC x10,W
07C48:  MOVWF  03
07C4A:  MOVF   01,W
07C4C:  ADDLW  92
07C4E:  MOVWF  FE9
07C50:  MOVLW  00
07C52:  ADDWFC 03,W
07C54:  MOVWF  FEA
07C56:  MOVFF  FEF,70F
07C5A:  MOVFF  FEC,710
07C5E:  MOVFF  FEC,711
07C62:  MOVFF  FEC,712
07C66:  MOVFF  70E,565
07C6A:  MOVFF  70D,564
07C6E:  MOVFF  70B,734
07C72:  MOVLW  18
07C74:  MOVWF  x35
07C76:  MOVLB  0
07C78:  CALL   5C88
07C7C:  MOVLW  2C
07C7E:  MOVLB  7
07C80:  MOVWF  x50
07C82:  MOVLB  0
07C84:  CALL   56A6
07C88:  MOVLW  89
07C8A:  MOVWF  FE9
07C8C:  MOVFF  712,746
07C90:  MOVFF  711,745
07C94:  MOVFF  710,744
07C98:  MOVFF  70F,743
07C9C:  MOVLW  02
07C9E:  MOVLB  7
07CA0:  MOVWF  x47
07CA2:  MOVLB  0
07CA4:  CALL   6582
07CA8:  MOVLW  2C
07CAA:  MOVLB  7
07CAC:  MOVWF  x50
07CAE:  MOVLB  0
07CB0:  CALL   56A6
07CB4:  BRA    7E10
07CB6:  MOVLB  7
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
07CB8:  MOVF   x0C,W
07CBA:  SUBLW  34
07CBC:  BNZ   7D60
07CBE:  MOVLW  04
07CC0:  MOVWF  x42
07CC2:  MOVLW  C1
07CC4:  MOVWF  x41
07CC6:  MOVLB  0
07CC8:  CALL   566E
07CCC:  MOVF   01,W
07CCE:  ADDLW  C1
07CD0:  MOVLB  7
07CD2:  MOVWF  x0D
07CD4:  MOVLW  04
07CD6:  ADDWFC 02,W
07CD8:  MOVWF  x0E
07CDA:  MOVLW  01
07CDC:  SUBWF  x0B,W
07CDE:  MULLW  18
07CE0:  MOVF   FF3,W
07CE2:  CLRF   x10
07CE4:  MOVWF  x0F
07CE6:  MOVLW  10
07CE8:  ADDWF  x0F,W
07CEA:  MOVWF  01
07CEC:  MOVLW  00
07CEE:  ADDWFC x10,W
07CF0:  MOVWF  03
07CF2:  MOVF   01,W
07CF4:  ADDLW  92
07CF6:  MOVWF  FE9
07CF8:  MOVLW  00
07CFA:  ADDWFC 03,W
07CFC:  MOVWF  FEA
07CFE:  MOVFF  FEF,70F
07D02:  MOVFF  FEC,710
07D06:  MOVFF  FEC,711
07D0A:  MOVFF  FEC,712
07D0E:  MOVFF  70E,565
07D12:  MOVFF  70D,564
07D16:  MOVFF  70B,734
07D1A:  MOVLW  18
07D1C:  MOVWF  x35
07D1E:  MOVLB  0
07D20:  CALL   5C88
07D24:  MOVLW  2C
07D26:  MOVLB  7
07D28:  MOVWF  x50
07D2A:  MOVLB  0
07D2C:  CALL   56A6
07D30:  MOVLW  89
07D32:  MOVWF  FE9
07D34:  MOVFF  712,746
07D38:  MOVFF  711,745
07D3C:  MOVFF  710,744
07D40:  MOVFF  70F,743
07D44:  MOVLW  02
07D46:  MOVLB  7
07D48:  MOVWF  x47
07D4A:  MOVLB  0
07D4C:  CALL   6582
07D50:  MOVLW  2C
07D52:  MOVLB  7
07D54:  MOVWF  x50
07D56:  MOVLB  0
07D58:  CALL   56A6
07D5C:  BRA    7E10
07D5E:  MOVLB  7
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
07D60:  MOVF   x0C,W
07D62:  SUBLW  35
07D64:  BNZ   7E08
07D66:  MOVLW  04
07D68:  MOVWF  x42
07D6A:  MOVLW  C1
07D6C:  MOVWF  x41
07D6E:  MOVLB  0
07D70:  CALL   566E
07D74:  MOVF   01,W
07D76:  ADDLW  C1
07D78:  MOVLB  7
07D7A:  MOVWF  x0D
07D7C:  MOVLW  04
07D7E:  ADDWFC 02,W
07D80:  MOVWF  x0E
07D82:  MOVLW  01
07D84:  SUBWF  x0B,W
07D86:  MULLW  18
07D88:  MOVF   FF3,W
07D8A:  CLRF   x10
07D8C:  MOVWF  x0F
07D8E:  MOVLW  14
07D90:  ADDWF  x0F,W
07D92:  MOVWF  01
07D94:  MOVLW  00
07D96:  ADDWFC x10,W
07D98:  MOVWF  03
07D9A:  MOVF   01,W
07D9C:  ADDLW  92
07D9E:  MOVWF  FE9
07DA0:  MOVLW  00
07DA2:  ADDWFC 03,W
07DA4:  MOVWF  FEA
07DA6:  MOVFF  FEF,70F
07DAA:  MOVFF  FEC,710
07DAE:  MOVFF  FEC,711
07DB2:  MOVFF  FEC,712
07DB6:  MOVFF  70E,565
07DBA:  MOVFF  70D,564
07DBE:  MOVFF  70B,734
07DC2:  MOVLW  18
07DC4:  MOVWF  x35
07DC6:  MOVLB  0
07DC8:  CALL   5C88
07DCC:  MOVLW  2C
07DCE:  MOVLB  7
07DD0:  MOVWF  x50
07DD2:  MOVLB  0
07DD4:  CALL   56A6
07DD8:  MOVLW  89
07DDA:  MOVWF  FE9
07DDC:  MOVFF  712,746
07DE0:  MOVFF  711,745
07DE4:  MOVFF  710,744
07DE8:  MOVFF  70F,743
07DEC:  MOVLW  02
07DEE:  MOVLB  7
07DF0:  MOVWF  x47
07DF2:  MOVLB  0
07DF4:  CALL   6582
07DF8:  MOVLW  2C
07DFA:  MOVLB  7
07DFC:  MOVWF  x50
07DFE:  MOVLB  0
07E00:  CALL   56A6
07E04:  BRA    7E10
07E06:  MOVLB  7
....................    else return INV_PARAM;
07E08:  MOVLW  02
07E0A:  MOVWF  01
07E0C:  MOVLB  0
07E0E:  BRA    7E14
....................    
....................    return SUCCESS;
07E10:  MOVLW  00
07E12:  MOVWF  01
07E14:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07E16:  MOVLB  7
07E18:  CLRF   x42
07E1A:  MOVFF  690,741
07E1E:  CLRF   x44
07E20:  MOVLW  B5
07E22:  MOVWF  x43
07E24:  MOVLB  0
07E26:  CALL   08BA
07E2A:  MOVFF  02,712
07E2E:  MOVFF  01,711
07E32:  MOVLW  06
07E34:  MOVLB  7
07E36:  ADDWF  x11,F
07E38:  MOVLW  00
07E3A:  ADDWFC x12,F
07E3C:  MOVLW  32
07E3E:  ADDWF  x11,W
07E40:  MOVWF  01
07E42:  MOVLW  00
07E44:  ADDWFC x12,W
07E46:  MOVWF  03
07E48:  MOVF   01,W
07E4A:  ADDLW  EB
07E4C:  MOVWF  01
07E4E:  MOVLW  01
07E50:  ADDWFC 03,F
07E52:  MOVFF  01,711
07E56:  MOVFF  03,712
07E5A:  MOVFF  03,734
07E5E:  MOVFF  01,733
07E62:  MOVLB  0
07E64:  CALL   5844
07E68:  MOVF   01,F
07E6A:  BNZ   7E74
07E6C:  MOVLW  02
07E6E:  MOVWF  01
07E70:  BRA    81AC
07E72:  BRA    7ED2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07E74:  MOVLB  7
07E76:  CLRF   x42
07E78:  MOVFF  690,741
07E7C:  CLRF   x44
07E7E:  MOVLW  B5
07E80:  MOVWF  x43
07E82:  MOVLB  0
07E84:  CALL   08BA
07E88:  MOVFF  02,712
07E8C:  MOVFF  01,711
07E90:  MOVLW  06
07E92:  MOVLB  7
07E94:  ADDWF  x11,F
07E96:  MOVLW  00
07E98:  ADDWFC x12,F
07E9A:  MOVLW  32
07E9C:  ADDWF  x11,W
07E9E:  MOVWF  01
07EA0:  MOVLW  00
07EA2:  ADDWFC x12,W
07EA4:  MOVWF  03
07EA6:  MOVF   01,W
07EA8:  ADDLW  EB
07EAA:  MOVWF  01
07EAC:  MOVLW  01
07EAE:  ADDWFC 03,F
07EB0:  MOVFF  01,711
07EB4:  MOVFF  03,712
07EB8:  MOVFF  03,734
07EBC:  MOVFF  01,733
07EC0:  CLRF   x36
07EC2:  CLRF   x35
07EC4:  MOVLW  0A
07EC6:  MOVWF  x37
07EC8:  MOVLB  0
07ECA:  CALL   5934
07ECE:  MOVFF  01,70B
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07ED2:  MOVLB  7
07ED4:  CLRF   x42
07ED6:  MOVFF  690,741
07EDA:  CLRF   x44
07EDC:  MOVLW  B5
07EDE:  MOVWF  x43
07EE0:  MOVLB  0
07EE2:  CALL   08BA
07EE6:  MOVFF  02,712
07EEA:  MOVFF  01,711
07EEE:  MOVLW  06
07EF0:  MOVLB  7
07EF2:  ADDWF  x11,F
07EF4:  MOVLW  00
07EF6:  ADDWFC x12,F
07EF8:  MOVLW  4B
07EFA:  ADDWF  x11,W
07EFC:  MOVWF  01
07EFE:  MOVLW  00
07F00:  ADDWFC x12,W
07F02:  MOVWF  03
07F04:  MOVF   01,W
07F06:  ADDLW  EB
07F08:  MOVWF  01
07F0A:  MOVLW  01
07F0C:  ADDWFC 03,F
07F0E:  MOVFF  01,711
07F12:  MOVFF  03,712
07F16:  MOVFF  03,742
07F1A:  MOVFF  01,741
07F1E:  MOVLB  0
07F20:  CALL   566E
07F24:  MOVFF  02,03
07F28:  MOVF   01,W
07F2A:  SUBLW  01
07F2C:  BNZ   7F32
07F2E:  MOVF   03,F
07F30:  BZ    7F3A
07F32:  MOVLW  02
07F34:  MOVWF  01
07F36:  BRA    81AC
07F38:  BRA    7F7A
....................    else arg2 = SERcmd[rec].p[3][0];
07F3A:  MOVLB  7
07F3C:  CLRF   x42
07F3E:  MOVFF  690,741
07F42:  CLRF   x44
07F44:  MOVLW  B5
07F46:  MOVWF  x43
07F48:  MOVLB  0
07F4A:  CALL   08BA
07F4E:  MOVFF  02,712
07F52:  MOVFF  01,711
07F56:  MOVLW  06
07F58:  MOVLB  7
07F5A:  ADDWF  x11,F
07F5C:  MOVLW  00
07F5E:  ADDWFC x12,F
07F60:  MOVLW  4B
07F62:  ADDWF  x11,F
07F64:  MOVLW  00
07F66:  ADDWFC x12,F
07F68:  MOVLW  EB
07F6A:  ADDWF  x11,W
07F6C:  MOVWF  FE9
07F6E:  MOVLW  01
07F70:  ADDWFC x12,W
07F72:  MOVWF  FEA
07F74:  MOVFF  FEF,70C
07F78:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
07F7A:  MOVLB  7
07F7C:  CLRF   x42
07F7E:  MOVFF  690,741
07F82:  CLRF   x44
07F84:  MOVLW  B5
07F86:  MOVWF  x43
07F88:  MOVLB  0
07F8A:  CALL   08BA
07F8E:  MOVFF  02,712
07F92:  MOVFF  01,711
07F96:  MOVLW  06
07F98:  MOVLB  7
07F9A:  ADDWF  x11,F
07F9C:  MOVLW  00
07F9E:  ADDWFC x12,F
07FA0:  MOVLW  64
07FA2:  ADDWF  x11,W
07FA4:  MOVWF  01
07FA6:  MOVLW  00
07FA8:  ADDWFC x12,W
07FAA:  MOVWF  03
07FAC:  MOVF   01,W
07FAE:  ADDLW  EB
07FB0:  MOVWF  01
07FB2:  MOVLW  01
07FB4:  ADDWFC 03,F
07FB6:  MOVFF  01,711
07FBA:  MOVFF  03,712
07FBE:  MOVFF  03,715
07FC2:  MOVFF  01,714
07FC6:  MOVLB  0
07FC8:  CALL   6BE8
07FCC:  MOVF   01,F
07FCE:  BNZ   7FD8
07FD0:  MOVLW  02
07FD2:  MOVWF  01
07FD4:  BRA    81AC
07FD6:  BRA    803E
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07FD8:  MOVLB  7
07FDA:  CLRF   x42
07FDC:  MOVFF  690,741
07FE0:  CLRF   x44
07FE2:  MOVLW  B5
07FE4:  MOVWF  x43
07FE6:  MOVLB  0
07FE8:  CALL   08BA
07FEC:  MOVFF  02,712
07FF0:  MOVFF  01,711
07FF4:  MOVLW  06
07FF6:  MOVLB  7
07FF8:  ADDWF  x11,F
07FFA:  MOVLW  00
07FFC:  ADDWFC x12,F
07FFE:  MOVLW  64
08000:  ADDWF  x11,W
08002:  MOVWF  01
08004:  MOVLW  00
08006:  ADDWFC x12,W
08008:  MOVWF  03
0800A:  MOVF   01,W
0800C:  ADDLW  EB
0800E:  MOVWF  01
08010:  MOVLW  01
08012:  ADDWFC 03,F
08014:  MOVFF  01,711
08018:  MOVFF  03,712
0801C:  MOVFF  03,715
08020:  MOVFF  01,714
08024:  CLRF   x17
08026:  CLRF   x16
08028:  MOVLB  0
0802A:  CALL   6CAA
0802E:  MOVFF  03,710
08032:  MOVFF  02,70F
08036:  MOVFF  01,70E
0803A:  MOVFF  00,70D
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
0803E:  MOVLB  7
08040:  MOVF   x0C,W
08042:  SUBLW  30
08044:  BNZ   8070
08046:  MOVLW  01
08048:  SUBWF  x0B,W
0804A:  MULLW  18
0804C:  MOVF   FF3,W
0804E:  CLRF   x12
08050:  MOVWF  x11
08052:  MOVLW  92
08054:  ADDWF  x11,W
08056:  MOVWF  FE9
08058:  MOVLW  00
0805A:  ADDWFC x12,W
0805C:  MOVWF  FEA
0805E:  MOVFF  70D,FEF
08062:  MOVFF  70E,FEC
08066:  MOVFF  70F,FEC
0806A:  MOVFF  710,FEC
0806E:  BRA    81A6
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
08070:  MOVF   x0C,W
08072:  SUBLW  31
08074:  BNZ   80AC
08076:  MOVLW  01
08078:  SUBWF  x0B,W
0807A:  MULLW  18
0807C:  MOVF   FF3,W
0807E:  CLRF   x12
08080:  MOVWF  x11
08082:  MOVLW  04
08084:  ADDWF  x11,W
08086:  MOVWF  01
08088:  MOVLW  00
0808A:  ADDWFC x12,W
0808C:  MOVWF  03
0808E:  MOVF   01,W
08090:  ADDLW  92
08092:  MOVWF  FE9
08094:  MOVLW  00
08096:  ADDWFC 03,W
08098:  MOVWF  FEA
0809A:  MOVFF  70D,FEF
0809E:  MOVFF  70E,FEC
080A2:  MOVFF  70F,FEC
080A6:  MOVFF  710,FEC
080AA:  BRA    81A6
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
080AC:  MOVF   x0C,W
080AE:  SUBLW  32
080B0:  BNZ   80E8
080B2:  MOVLW  01
080B4:  SUBWF  x0B,W
080B6:  MULLW  18
080B8:  MOVF   FF3,W
080BA:  CLRF   x12
080BC:  MOVWF  x11
080BE:  MOVLW  08
080C0:  ADDWF  x11,W
080C2:  MOVWF  01
080C4:  MOVLW  00
080C6:  ADDWFC x12,W
080C8:  MOVWF  03
080CA:  MOVF   01,W
080CC:  ADDLW  92
080CE:  MOVWF  FE9
080D0:  MOVLW  00
080D2:  ADDWFC 03,W
080D4:  MOVWF  FEA
080D6:  MOVFF  70D,FEF
080DA:  MOVFF  70E,FEC
080DE:  MOVFF  70F,FEC
080E2:  MOVFF  710,FEC
080E6:  BRA    81A6
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
080E8:  MOVF   x0C,W
080EA:  SUBLW  33
080EC:  BNZ   8124
080EE:  MOVLW  01
080F0:  SUBWF  x0B,W
080F2:  MULLW  18
080F4:  MOVF   FF3,W
080F6:  CLRF   x12
080F8:  MOVWF  x11
080FA:  MOVLW  0C
080FC:  ADDWF  x11,W
080FE:  MOVWF  01
08100:  MOVLW  00
08102:  ADDWFC x12,W
08104:  MOVWF  03
08106:  MOVF   01,W
08108:  ADDLW  92
0810A:  MOVWF  FE9
0810C:  MOVLW  00
0810E:  ADDWFC 03,W
08110:  MOVWF  FEA
08112:  MOVFF  70D,FEF
08116:  MOVFF  70E,FEC
0811A:  MOVFF  70F,FEC
0811E:  MOVFF  710,FEC
08122:  BRA    81A6
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
08124:  MOVF   x0C,W
08126:  SUBLW  34
08128:  BNZ   8160
0812A:  MOVLW  01
0812C:  SUBWF  x0B,W
0812E:  MULLW  18
08130:  MOVF   FF3,W
08132:  CLRF   x12
08134:  MOVWF  x11
08136:  MOVLW  10
08138:  ADDWF  x11,W
0813A:  MOVWF  01
0813C:  MOVLW  00
0813E:  ADDWFC x12,W
08140:  MOVWF  03
08142:  MOVF   01,W
08144:  ADDLW  92
08146:  MOVWF  FE9
08148:  MOVLW  00
0814A:  ADDWFC 03,W
0814C:  MOVWF  FEA
0814E:  MOVFF  70D,FEF
08152:  MOVFF  70E,FEC
08156:  MOVFF  70F,FEC
0815A:  MOVFF  710,FEC
0815E:  BRA    81A6
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
08160:  MOVF   x0C,W
08162:  SUBLW  35
08164:  BNZ   819C
08166:  MOVLW  01
08168:  SUBWF  x0B,W
0816A:  MULLW  18
0816C:  MOVF   FF3,W
0816E:  CLRF   x12
08170:  MOVWF  x11
08172:  MOVLW  14
08174:  ADDWF  x11,W
08176:  MOVWF  01
08178:  MOVLW  00
0817A:  ADDWFC x12,W
0817C:  MOVWF  03
0817E:  MOVF   01,W
08180:  ADDLW  92
08182:  MOVWF  FE9
08184:  MOVLW  00
08186:  ADDWFC 03,W
08188:  MOVWF  FEA
0818A:  MOVFF  70D,FEF
0818E:  MOVFF  70E,FEC
08192:  MOVFF  70F,FEC
08196:  MOVFF  710,FEC
0819A:  BRA    81A6
....................    else return INV_PARAM;
0819C:  MOVLW  02
0819E:  MOVWF  01
081A0:  MOVLB  0
081A2:  BRA    81AC
081A4:  MOVLB  7
....................    
....................    return SUCCESS;
081A6:  MOVLW  00
081A8:  MOVWF  01
081AA:  MOVLB  0
081AC:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
081AE:  MOVLW  4E
081B0:  MOVLB  7
081B2:  MOVWF  x0F
081B4:  MOVLW  31
081B6:  MOVWF  x10
081B8:  MOVLW  35
081BA:  MOVWF  x11
081BC:  CLRF   x12
081BE:  MOVLW  07
081C0:  MOVWF  x0E
081C2:  MOVLW  0F
081C4:  MOVWF  x0D
....................    char *s_200 = "200";
081C6:  MOVLW  32
081C8:  MOVWF  x15
081CA:  MOVLW  30
081CC:  MOVWF  x16
081CE:  MOVWF  x17
081D0:  CLRF   x18
081D2:  MOVLW  07
081D4:  MOVWF  x14
081D6:  MOVLW  15
081D8:  MOVWF  x13
....................    char *s_5V6 = "5V6";
081DA:  MOVLW  35
081DC:  MOVWF  x1B
081DE:  MOVLW  56
081E0:  MOVWF  x1C
081E2:  MOVLW  36
081E4:  MOVWF  x1D
081E6:  CLRF   x1E
081E8:  MOVLW  07
081EA:  MOVWF  x1A
081EC:  MOVLW  1B
081EE:  MOVWF  x19
....................    char *s_5VA = "5VA";
081F0:  MOVLW  35
081F2:  MOVWF  x21
081F4:  MOVLW  56
081F6:  MOVWF  x22
081F8:  MOVLW  41
081FA:  MOVWF  x23
081FC:  CLRF   x24
081FE:  MOVLW  07
08200:  MOVWF  x20
08202:  MOVLW  21
08204:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08206:  MOVLW  33
08208:  MOVWF  x27
0820A:  MOVLW  56
0820C:  MOVWF  x28
0820E:  MOVLW  36
08210:  MOVWF  x29
08212:  MOVLW  58
08214:  MOVWF  x2A
08216:  CLRF   x2B
08218:  MOVLW  07
0821A:  MOVWF  x26
0821C:  MOVLW  27
0821E:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08220:  MOVLW  33
08222:  MOVWF  x2E
08224:  MOVLW  56
08226:  MOVWF  x2F
08228:  MOVLW  33
0822A:  MOVWF  x30
0822C:  MOVLW  41
0822E:  MOVWF  x31
08230:  CLRF   x32
08232:  MOVLW  07
08234:  MOVWF  x2D
08236:  MOVLW  2E
08238:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
0823A:  MOVLW  33
0823C:  MOVWF  x35
0823E:  MOVLW  56
08240:  MOVWF  x36
08242:  MOVLW  33
08244:  MOVWF  x37
08246:  MOVLW  44
08248:  MOVWF  x38
0824A:  CLRF   x39
0824C:  MOVLW  07
0824E:  MOVWF  x34
08250:  MOVLW  35
08252:  MOVWF  x33
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
08254:  CLRF   x42
08256:  MOVFF  690,741
0825A:  CLRF   x44
0825C:  MOVLW  B5
0825E:  MOVWF  x43
08260:  MOVLB  0
08262:  CALL   08BA
08266:  MOVFF  02,73B
0826A:  MOVFF  01,73A
0826E:  MOVLW  06
08270:  MOVLB  7
08272:  ADDWF  x3A,F
08274:  MOVLW  00
08276:  ADDWFC x3B,F
08278:  MOVLW  32
0827A:  ADDWF  x3A,W
0827C:  MOVWF  01
0827E:  MOVLW  00
08280:  ADDWFC x3B,W
08282:  MOVWF  03
08284:  MOVF   01,W
08286:  ADDLW  EB
08288:  MOVWF  01
0828A:  MOVLW  01
0828C:  ADDWFC 03,F
0828E:  MOVFF  01,70B
08292:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08296:  MOVFF  70E,742
0829A:  MOVFF  70D,741
0829E:  MOVFF  70C,744
082A2:  MOVFF  70B,743
082A6:  MOVLB  0
082A8:  CALL   5724
082AC:  MOVF   01,F
082AE:  BNZ   8332
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
082B0:  MOVLW  04
082B2:  MOVLB  7
082B4:  MOVWF  x42
082B6:  MOVLW  C1
082B8:  MOVWF  x41
082BA:  MOVLB  0
082BC:  CALL   566E
082C0:  MOVFF  02,03
082C4:  MOVF   01,W
082C6:  ADDLW  C1
082C8:  MOVLB  7
082CA:  MOVWF  x3A
082CC:  MOVLW  04
082CE:  ADDWFC 02,W
082D0:  MOVWF  x3B
082D2:  MOVFF  FE8,565
082D6:  MOVFF  73A,564
082DA:  MOVLW  89
082DC:  MOVWF  FE9
082DE:  MOVFF  C5,746
082E2:  MOVFF  C4,745
082E6:  MOVFF  C3,744
082EA:  MOVFF  C2,743
082EE:  MOVLW  02
082F0:  MOVWF  x47
082F2:  MOVLB  0
082F4:  CALL   6582
082F8:  MOVLW  2C
082FA:  MOVLB  7
082FC:  MOVWF  x50
082FE:  MOVLB  0
08300:  CALL   56A6
08304:  MOVLW  89
08306:  MOVWF  FE9
08308:  MOVFF  C9,746
0830C:  MOVFF  C8,745
08310:  MOVFF  C7,744
08314:  MOVFF  C6,743
08318:  MOVLW  02
0831A:  MOVLB  7
0831C:  MOVWF  x47
0831E:  MOVLB  0
08320:  CALL   6582
08324:  MOVLW  2C
08326:  MOVLB  7
08328:  MOVWF  x50
0832A:  MOVLB  0
0832C:  CALL   56A6
....................    }
08330:  BRA    86D4
....................    else if (0 == strcmp(s_200, arg1)) {
08332:  MOVFF  714,742
08336:  MOVFF  713,741
0833A:  MOVFF  70C,744
0833E:  MOVFF  70B,743
08342:  CALL   5724
08346:  MOVF   01,F
08348:  BNZ   83CC
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
0834A:  MOVLW  04
0834C:  MOVLB  7
0834E:  MOVWF  x42
08350:  MOVLW  C1
08352:  MOVWF  x41
08354:  MOVLB  0
08356:  CALL   566E
0835A:  MOVFF  02,03
0835E:  MOVF   01,W
08360:  ADDLW  C1
08362:  MOVLB  7
08364:  MOVWF  x3A
08366:  MOVLW  04
08368:  ADDWFC 02,W
0836A:  MOVWF  x3B
0836C:  MOVFF  FE8,565
08370:  MOVFF  73A,564
08374:  MOVLW  89
08376:  MOVWF  FE9
08378:  MOVFF  CD,746
0837C:  MOVFF  CC,745
08380:  MOVFF  CB,744
08384:  MOVFF  CA,743
08388:  MOVLW  02
0838A:  MOVWF  x47
0838C:  MOVLB  0
0838E:  CALL   6582
08392:  MOVLW  2C
08394:  MOVLB  7
08396:  MOVWF  x50
08398:  MOVLB  0
0839A:  CALL   56A6
0839E:  MOVLW  89
083A0:  MOVWF  FE9
083A2:  MOVFF  D1,746
083A6:  MOVFF  D0,745
083AA:  MOVFF  CF,744
083AE:  MOVFF  CE,743
083B2:  MOVLW  02
083B4:  MOVLB  7
083B6:  MOVWF  x47
083B8:  MOVLB  0
083BA:  CALL   6582
083BE:  MOVLW  2C
083C0:  MOVLB  7
083C2:  MOVWF  x50
083C4:  MOVLB  0
083C6:  CALL   56A6
....................    }
083CA:  BRA    86D4
....................    else if (0 == strcmp(s_5V6, arg1)) {
083CC:  MOVFF  71A,742
083D0:  MOVFF  719,741
083D4:  MOVFF  70C,744
083D8:  MOVFF  70B,743
083DC:  CALL   5724
083E0:  MOVF   01,F
083E2:  BNZ   8466
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
083E4:  MOVLW  04
083E6:  MOVLB  7
083E8:  MOVWF  x42
083EA:  MOVLW  C1
083EC:  MOVWF  x41
083EE:  MOVLB  0
083F0:  CALL   566E
083F4:  MOVFF  02,03
083F8:  MOVF   01,W
083FA:  ADDLW  C1
083FC:  MOVLB  7
083FE:  MOVWF  x3A
08400:  MOVLW  04
08402:  ADDWFC 02,W
08404:  MOVWF  x3B
08406:  MOVFF  FE8,565
0840A:  MOVFF  73A,564
0840E:  MOVLW  89
08410:  MOVWF  FE9
08412:  MOVFF  D5,746
08416:  MOVFF  D4,745
0841A:  MOVFF  D3,744
0841E:  MOVFF  D2,743
08422:  MOVLW  02
08424:  MOVWF  x47
08426:  MOVLB  0
08428:  CALL   6582
0842C:  MOVLW  2C
0842E:  MOVLB  7
08430:  MOVWF  x50
08432:  MOVLB  0
08434:  CALL   56A6
08438:  MOVLW  89
0843A:  MOVWF  FE9
0843C:  MOVFF  D9,746
08440:  MOVFF  D8,745
08444:  MOVFF  D7,744
08448:  MOVFF  D6,743
0844C:  MOVLW  02
0844E:  MOVLB  7
08450:  MOVWF  x47
08452:  MOVLB  0
08454:  CALL   6582
08458:  MOVLW  2C
0845A:  MOVLB  7
0845C:  MOVWF  x50
0845E:  MOVLB  0
08460:  CALL   56A6
....................    }
08464:  BRA    86D4
....................    else if (0 == strcmp(s_5VA, arg1)) {
08466:  MOVFF  720,742
0846A:  MOVFF  71F,741
0846E:  MOVFF  70C,744
08472:  MOVFF  70B,743
08476:  CALL   5724
0847A:  MOVF   01,F
0847C:  BNZ   8500
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
0847E:  MOVLW  04
08480:  MOVLB  7
08482:  MOVWF  x42
08484:  MOVLW  C1
08486:  MOVWF  x41
08488:  MOVLB  0
0848A:  CALL   566E
0848E:  MOVFF  02,03
08492:  MOVF   01,W
08494:  ADDLW  C1
08496:  MOVLB  7
08498:  MOVWF  x3A
0849A:  MOVLW  04
0849C:  ADDWFC 02,W
0849E:  MOVWF  x3B
084A0:  MOVFF  FE8,565
084A4:  MOVFF  73A,564
084A8:  MOVLW  89
084AA:  MOVWF  FE9
084AC:  MOVFF  DD,746
084B0:  MOVFF  DC,745
084B4:  MOVFF  DB,744
084B8:  MOVFF  DA,743
084BC:  MOVLW  02
084BE:  MOVWF  x47
084C0:  MOVLB  0
084C2:  CALL   6582
084C6:  MOVLW  2C
084C8:  MOVLB  7
084CA:  MOVWF  x50
084CC:  MOVLB  0
084CE:  CALL   56A6
084D2:  MOVLW  89
084D4:  MOVWF  FE9
084D6:  MOVFF  E1,746
084DA:  MOVFF  E0,745
084DE:  MOVFF  DF,744
084E2:  MOVFF  DE,743
084E6:  MOVLW  02
084E8:  MOVLB  7
084EA:  MOVWF  x47
084EC:  MOVLB  0
084EE:  CALL   6582
084F2:  MOVLW  2C
084F4:  MOVLB  7
084F6:  MOVWF  x50
084F8:  MOVLB  0
084FA:  CALL   56A6
....................    }
084FE:  BRA    86D4
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08500:  MOVFF  726,742
08504:  MOVFF  725,741
08508:  MOVFF  70C,744
0850C:  MOVFF  70B,743
08510:  CALL   5724
08514:  MOVF   01,F
08516:  BNZ   859A
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
08518:  MOVLW  04
0851A:  MOVLB  7
0851C:  MOVWF  x42
0851E:  MOVLW  C1
08520:  MOVWF  x41
08522:  MOVLB  0
08524:  CALL   566E
08528:  MOVFF  02,03
0852C:  MOVF   01,W
0852E:  ADDLW  C1
08530:  MOVLB  7
08532:  MOVWF  x3A
08534:  MOVLW  04
08536:  ADDWFC 02,W
08538:  MOVWF  x3B
0853A:  MOVFF  FE8,565
0853E:  MOVFF  73A,564
08542:  MOVLW  89
08544:  MOVWF  FE9
08546:  MOVFF  E5,746
0854A:  MOVFF  E4,745
0854E:  MOVFF  E3,744
08552:  MOVFF  E2,743
08556:  MOVLW  02
08558:  MOVWF  x47
0855A:  MOVLB  0
0855C:  CALL   6582
08560:  MOVLW  2C
08562:  MOVLB  7
08564:  MOVWF  x50
08566:  MOVLB  0
08568:  CALL   56A6
0856C:  MOVLW  89
0856E:  MOVWF  FE9
08570:  MOVFF  E9,746
08574:  MOVFF  E8,745
08578:  MOVFF  E7,744
0857C:  MOVFF  E6,743
08580:  MOVLW  02
08582:  MOVLB  7
08584:  MOVWF  x47
08586:  MOVLB  0
08588:  CALL   6582
0858C:  MOVLW  2C
0858E:  MOVLB  7
08590:  MOVWF  x50
08592:  MOVLB  0
08594:  CALL   56A6
....................    }
08598:  BRA    86D4
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0859A:  MOVFF  72D,742
0859E:  MOVFF  72C,741
085A2:  MOVFF  70C,744
085A6:  MOVFF  70B,743
085AA:  CALL   5724
085AE:  MOVF   01,F
085B0:  BNZ   8634
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
085B2:  MOVLW  04
085B4:  MOVLB  7
085B6:  MOVWF  x42
085B8:  MOVLW  C1
085BA:  MOVWF  x41
085BC:  MOVLB  0
085BE:  CALL   566E
085C2:  MOVFF  02,03
085C6:  MOVF   01,W
085C8:  ADDLW  C1
085CA:  MOVLB  7
085CC:  MOVWF  x3A
085CE:  MOVLW  04
085D0:  ADDWFC 02,W
085D2:  MOVWF  x3B
085D4:  MOVFF  FE8,565
085D8:  MOVFF  73A,564
085DC:  MOVLW  89
085DE:  MOVWF  FE9
085E0:  MOVFF  ED,746
085E4:  MOVFF  EC,745
085E8:  MOVFF  EB,744
085EC:  MOVFF  EA,743
085F0:  MOVLW  02
085F2:  MOVWF  x47
085F4:  MOVLB  0
085F6:  CALL   6582
085FA:  MOVLW  2C
085FC:  MOVLB  7
085FE:  MOVWF  x50
08600:  MOVLB  0
08602:  CALL   56A6
08606:  MOVLW  89
08608:  MOVWF  FE9
0860A:  MOVFF  F1,746
0860E:  MOVFF  F0,745
08612:  MOVFF  EF,744
08616:  MOVFF  EE,743
0861A:  MOVLW  02
0861C:  MOVLB  7
0861E:  MOVWF  x47
08620:  MOVLB  0
08622:  CALL   6582
08626:  MOVLW  2C
08628:  MOVLB  7
0862A:  MOVWF  x50
0862C:  MOVLB  0
0862E:  CALL   56A6
....................    }
08632:  BRA    86D4
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08634:  MOVFF  734,742
08638:  MOVFF  733,741
0863C:  MOVFF  70C,744
08640:  MOVFF  70B,743
08644:  CALL   5724
08648:  MOVF   01,F
0864A:  BNZ   86CE
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
0864C:  MOVLW  04
0864E:  MOVLB  7
08650:  MOVWF  x42
08652:  MOVLW  C1
08654:  MOVWF  x41
08656:  MOVLB  0
08658:  CALL   566E
0865C:  MOVFF  02,03
08660:  MOVF   01,W
08662:  ADDLW  C1
08664:  MOVLB  7
08666:  MOVWF  x3A
08668:  MOVLW  04
0866A:  ADDWFC 02,W
0866C:  MOVWF  x3B
0866E:  MOVFF  FE8,565
08672:  MOVFF  73A,564
08676:  MOVLW  89
08678:  MOVWF  FE9
0867A:  MOVFF  F5,746
0867E:  MOVFF  F4,745
08682:  MOVFF  F3,744
08686:  MOVFF  F2,743
0868A:  MOVLW  02
0868C:  MOVWF  x47
0868E:  MOVLB  0
08690:  CALL   6582
08694:  MOVLW  2C
08696:  MOVLB  7
08698:  MOVWF  x50
0869A:  MOVLB  0
0869C:  CALL   56A6
086A0:  MOVLW  89
086A2:  MOVWF  FE9
086A4:  MOVFF  F9,746
086A8:  MOVFF  F8,745
086AC:  MOVFF  F7,744
086B0:  MOVFF  F6,743
086B4:  MOVLW  02
086B6:  MOVLB  7
086B8:  MOVWF  x47
086BA:  MOVLB  0
086BC:  CALL   6582
086C0:  MOVLW  2C
086C2:  MOVLB  7
086C4:  MOVWF  x50
086C6:  MOVLB  0
086C8:  CALL   56A6
....................    }
086CC:  BRA    86D4
....................    else return INV_PARAM;
086CE:  MOVLW  02
086D0:  MOVWF  01
086D2:  BRA    86D8
....................    
....................    return SUCCESS;
086D4:  MOVLW  00
086D6:  MOVWF  01
086D8:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
....................    return SUCCESS;
086DA:  MOVLW  00
086DC:  MOVWF  01
086DE:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
086E0:  MOVLW  4E
086E2:  MOVLB  7
086E4:  MOVWF  x0F
086E6:  MOVLW  31
086E8:  MOVWF  x10
086EA:  MOVLW  35
086EC:  MOVWF  x11
086EE:  CLRF   x12
086F0:  MOVLW  07
086F2:  MOVWF  x0E
086F4:  MOVLW  0F
086F6:  MOVWF  x0D
....................    char *s_200 = "200";
086F8:  MOVLW  32
086FA:  MOVWF  x15
086FC:  MOVLW  30
086FE:  MOVWF  x16
08700:  MOVWF  x17
08702:  CLRF   x18
08704:  MOVLW  07
08706:  MOVWF  x14
08708:  MOVLW  15
0870A:  MOVWF  x13
....................    char *s_5V6 = "5V6";
0870C:  MOVLW  35
0870E:  MOVWF  x1B
08710:  MOVLW  56
08712:  MOVWF  x1C
08714:  MOVLW  36
08716:  MOVWF  x1D
08718:  CLRF   x1E
0871A:  MOVLW  07
0871C:  MOVWF  x1A
0871E:  MOVLW  1B
08720:  MOVWF  x19
....................    char *s_5VA = "5VA";
08722:  MOVLW  35
08724:  MOVWF  x21
08726:  MOVLW  56
08728:  MOVWF  x22
0872A:  MOVLW  41
0872C:  MOVWF  x23
0872E:  CLRF   x24
08730:  MOVLW  07
08732:  MOVWF  x20
08734:  MOVLW  21
08736:  MOVWF  x1F
....................    char *s_3V6X = "3V6X";
08738:  MOVLW  33
0873A:  MOVWF  x27
0873C:  MOVLW  56
0873E:  MOVWF  x28
08740:  MOVLW  36
08742:  MOVWF  x29
08744:  MOVLW  58
08746:  MOVWF  x2A
08748:  CLRF   x2B
0874A:  MOVLW  07
0874C:  MOVWF  x26
0874E:  MOVLW  27
08750:  MOVWF  x25
....................    char *s_3V3A = "3V3A";
08752:  MOVLW  33
08754:  MOVWF  x2E
08756:  MOVLW  56
08758:  MOVWF  x2F
0875A:  MOVLW  33
0875C:  MOVWF  x30
0875E:  MOVLW  41
08760:  MOVWF  x31
08762:  CLRF   x32
08764:  MOVLW  07
08766:  MOVWF  x2D
08768:  MOVLW  2E
0876A:  MOVWF  x2C
....................    char *s_3V3D = "3V3D";
0876C:  MOVLW  33
0876E:  MOVWF  x35
08770:  MOVLW  56
08772:  MOVWF  x36
08774:  MOVLW  33
08776:  MOVWF  x37
08778:  MOVLW  44
0877A:  MOVWF  x38
0877C:  CLRF   x39
0877E:  MOVLW  07
08780:  MOVWF  x34
08782:  MOVLW  35
08784:  MOVWF  x33
....................    char *s_all = "all";
08786:  MOVLW  61
08788:  MOVWF  x3C
0878A:  MOVLW  6C
0878C:  MOVWF  x3D
0878E:  MOVWF  x3E
08790:  CLRF   x3F
08792:  MOVLW  07
08794:  MOVWF  x3B
08796:  MOVLW  3C
08798:  MOVWF  x3A
....................    
....................    arg1 = SERcmd[rec].p[2];
0879A:  CLRF   x42
0879C:  MOVFF  690,741
087A0:  CLRF   x44
087A2:  MOVLW  B5
087A4:  MOVWF  x43
087A6:  MOVLB  0
087A8:  CALL   08BA
087AC:  MOVFF  02,741
087B0:  MOVFF  01,740
087B4:  MOVLW  06
087B6:  MOVLB  7
087B8:  ADDWF  x40,F
087BA:  MOVLW  00
087BC:  ADDWFC x41,F
087BE:  MOVLW  32
087C0:  ADDWF  x40,W
087C2:  MOVWF  01
087C4:  MOVLW  00
087C6:  ADDWFC x41,W
087C8:  MOVWF  03
087CA:  MOVF   01,W
087CC:  ADDLW  EB
087CE:  MOVWF  01
087D0:  MOVLW  01
087D2:  ADDWFC 03,F
087D4:  MOVFF  01,70B
087D8:  MOVFF  03,70C
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
087DC:  MOVFF  70E,742
087E0:  MOVFF  70D,741
087E4:  MOVFF  70C,744
087E8:  MOVFF  70B,743
087EC:  MOVLB  0
087EE:  CALL   5724
087F2:  MOVF   01,F
087F4:  BNZ   884C
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
087F6:  MOVLW  04
087F8:  MOVLB  7
087FA:  MOVWF  x42
087FC:  MOVLW  C1
087FE:  MOVWF  x41
08800:  MOVLB  0
08802:  CALL   566E
08806:  MOVFF  02,03
0880A:  MOVF   01,W
0880C:  ADDLW  C1
0880E:  MOVLB  7
08810:  MOVWF  x40
08812:  MOVLW  04
08814:  ADDWFC 02,W
08816:  MOVWF  x41
08818:  MOVFF  FE8,565
0881C:  MOVFF  740,564
08820:  MOVLW  89
08822:  MOVWF  FE9
08824:  MOVFF  FE,746
08828:  MOVFF  FD,745
0882C:  MOVFF  FC,744
08830:  MOVFF  FB,743
08834:  MOVLW  02
08836:  MOVWF  x47
08838:  MOVLB  0
0883A:  CALL   6582
0883E:  MOVLW  2C
08840:  MOVLB  7
08842:  MOVWF  x50
08844:  MOVLB  0
08846:  CALL   56A6
....................    }
0884A:  BRA    8D4E
....................    else if (0 == strcmp(s_200, arg1)) {
0884C:  MOVFF  714,742
08850:  MOVFF  713,741
08854:  MOVFF  70C,744
08858:  MOVFF  70B,743
0885C:  CALL   5724
08860:  MOVF   01,F
08862:  BNZ   88BA
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08864:  MOVLW  04
08866:  MOVLB  7
08868:  MOVWF  x42
0886A:  MOVLW  C1
0886C:  MOVWF  x41
0886E:  MOVLB  0
08870:  CALL   566E
08874:  MOVFF  02,03
08878:  MOVF   01,W
0887A:  ADDLW  C1
0887C:  MOVLB  7
0887E:  MOVWF  x40
08880:  MOVLW  04
08882:  ADDWFC 02,W
08884:  MOVWF  x41
08886:  MOVFF  FE8,565
0888A:  MOVFF  740,564
0888E:  MOVLW  89
08890:  MOVWF  FE9
08892:  MOVFF  102,746
08896:  MOVFF  101,745
0889A:  MOVFF  100,744
0889E:  MOVFF  FF,743
088A2:  MOVLW  01
088A4:  MOVWF  x47
088A6:  MOVLB  0
088A8:  CALL   6582
088AC:  MOVLW  2C
088AE:  MOVLB  7
088B0:  MOVWF  x50
088B2:  MOVLB  0
088B4:  CALL   56A6
....................    }
088B8:  BRA    8D4E
....................    else if (0 == strcmp(s_5V6, arg1)) {
088BA:  MOVFF  71A,742
088BE:  MOVFF  719,741
088C2:  MOVFF  70C,744
088C6:  MOVFF  70B,743
088CA:  CALL   5724
088CE:  MOVF   01,F
088D0:  BNZ   8928
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
088D2:  MOVLW  04
088D4:  MOVLB  7
088D6:  MOVWF  x42
088D8:  MOVLW  C1
088DA:  MOVWF  x41
088DC:  MOVLB  0
088DE:  CALL   566E
088E2:  MOVFF  02,03
088E6:  MOVF   01,W
088E8:  ADDLW  C1
088EA:  MOVLB  7
088EC:  MOVWF  x40
088EE:  MOVLW  04
088F0:  ADDWFC 02,W
088F2:  MOVWF  x41
088F4:  MOVFF  FE8,565
088F8:  MOVFF  740,564
088FC:  MOVLW  89
088FE:  MOVWF  FE9
08900:  MOVFF  106,746
08904:  MOVFF  105,745
08908:  MOVFF  104,744
0890C:  MOVFF  103,743
08910:  MOVLW  03
08912:  MOVWF  x47
08914:  MOVLB  0
08916:  CALL   6582
0891A:  MOVLW  2C
0891C:  MOVLB  7
0891E:  MOVWF  x50
08920:  MOVLB  0
08922:  CALL   56A6
....................    }
08926:  BRA    8D4E
....................    else if (0 == strcmp(s_5VA, arg1)) {
08928:  MOVFF  720,742
0892C:  MOVFF  71F,741
08930:  MOVFF  70C,744
08934:  MOVFF  70B,743
08938:  CALL   5724
0893C:  MOVF   01,F
0893E:  BNZ   8996
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08940:  MOVLW  04
08942:  MOVLB  7
08944:  MOVWF  x42
08946:  MOVLW  C1
08948:  MOVWF  x41
0894A:  MOVLB  0
0894C:  CALL   566E
08950:  MOVFF  02,03
08954:  MOVF   01,W
08956:  ADDLW  C1
08958:  MOVLB  7
0895A:  MOVWF  x40
0895C:  MOVLW  04
0895E:  ADDWFC 02,W
08960:  MOVWF  x41
08962:  MOVFF  FE8,565
08966:  MOVFF  740,564
0896A:  MOVLW  89
0896C:  MOVWF  FE9
0896E:  MOVFF  10A,746
08972:  MOVFF  109,745
08976:  MOVFF  108,744
0897A:  MOVFF  107,743
0897E:  MOVLW  03
08980:  MOVWF  x47
08982:  MOVLB  0
08984:  CALL   6582
08988:  MOVLW  2C
0898A:  MOVLB  7
0898C:  MOVWF  x50
0898E:  MOVLB  0
08990:  CALL   56A6
....................    }
08994:  BRA    8D4E
....................    else if (0 == strcmp(s_3V6X, arg1)) {
08996:  MOVFF  726,742
0899A:  MOVFF  725,741
0899E:  MOVFF  70C,744
089A2:  MOVFF  70B,743
089A6:  CALL   5724
089AA:  MOVF   01,F
089AC:  BNZ   8A04
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
089AE:  MOVLW  04
089B0:  MOVLB  7
089B2:  MOVWF  x42
089B4:  MOVLW  C1
089B6:  MOVWF  x41
089B8:  MOVLB  0
089BA:  CALL   566E
089BE:  MOVFF  02,03
089C2:  MOVF   01,W
089C4:  ADDLW  C1
089C6:  MOVLB  7
089C8:  MOVWF  x40
089CA:  MOVLW  04
089CC:  ADDWFC 02,W
089CE:  MOVWF  x41
089D0:  MOVFF  FE8,565
089D4:  MOVFF  740,564
089D8:  MOVLW  89
089DA:  MOVWF  FE9
089DC:  MOVFF  10E,746
089E0:  MOVFF  10D,745
089E4:  MOVFF  10C,744
089E8:  MOVFF  10B,743
089EC:  MOVLW  03
089EE:  MOVWF  x47
089F0:  MOVLB  0
089F2:  CALL   6582
089F6:  MOVLW  2C
089F8:  MOVLB  7
089FA:  MOVWF  x50
089FC:  MOVLB  0
089FE:  CALL   56A6
....................    }
08A02:  BRA    8D4E
....................    else if (0 == strcmp(s_3V3A, arg1)) {
08A04:  MOVFF  72D,742
08A08:  MOVFF  72C,741
08A0C:  MOVFF  70C,744
08A10:  MOVFF  70B,743
08A14:  CALL   5724
08A18:  MOVF   01,F
08A1A:  BNZ   8A72
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08A1C:  MOVLW  04
08A1E:  MOVLB  7
08A20:  MOVWF  x42
08A22:  MOVLW  C1
08A24:  MOVWF  x41
08A26:  MOVLB  0
08A28:  CALL   566E
08A2C:  MOVFF  02,03
08A30:  MOVF   01,W
08A32:  ADDLW  C1
08A34:  MOVLB  7
08A36:  MOVWF  x40
08A38:  MOVLW  04
08A3A:  ADDWFC 02,W
08A3C:  MOVWF  x41
08A3E:  MOVFF  FE8,565
08A42:  MOVFF  740,564
08A46:  MOVLW  89
08A48:  MOVWF  FE9
08A4A:  MOVFF  112,746
08A4E:  MOVFF  111,745
08A52:  MOVFF  110,744
08A56:  MOVFF  10F,743
08A5A:  MOVLW  03
08A5C:  MOVWF  x47
08A5E:  MOVLB  0
08A60:  CALL   6582
08A64:  MOVLW  2C
08A66:  MOVLB  7
08A68:  MOVWF  x50
08A6A:  MOVLB  0
08A6C:  CALL   56A6
....................    }
08A70:  BRA    8D4E
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08A72:  MOVFF  734,742
08A76:  MOVFF  733,741
08A7A:  MOVFF  70C,744
08A7E:  MOVFF  70B,743
08A82:  CALL   5724
08A86:  MOVF   01,F
08A88:  BNZ   8AE0
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08A8A:  MOVLW  04
08A8C:  MOVLB  7
08A8E:  MOVWF  x42
08A90:  MOVLW  C1
08A92:  MOVWF  x41
08A94:  MOVLB  0
08A96:  CALL   566E
08A9A:  MOVFF  02,03
08A9E:  MOVF   01,W
08AA0:  ADDLW  C1
08AA2:  MOVLB  7
08AA4:  MOVWF  x40
08AA6:  MOVLW  04
08AA8:  ADDWFC 02,W
08AAA:  MOVWF  x41
08AAC:  MOVFF  FE8,565
08AB0:  MOVFF  740,564
08AB4:  MOVLW  89
08AB6:  MOVWF  FE9
08AB8:  MOVFF  116,746
08ABC:  MOVFF  115,745
08AC0:  MOVFF  114,744
08AC4:  MOVFF  113,743
08AC8:  MOVLW  03
08ACA:  MOVWF  x47
08ACC:  MOVLB  0
08ACE:  CALL   6582
08AD2:  MOVLW  2C
08AD4:  MOVLB  7
08AD6:  MOVWF  x50
08AD8:  MOVLB  0
08ADA:  CALL   56A6
....................    }
08ADE:  BRA    8D4E
....................    else if (0 == strcmp(s_all, arg1)) {
08AE0:  MOVFF  73B,742
08AE4:  MOVFF  73A,741
08AE8:  MOVFF  70C,744
08AEC:  MOVFF  70B,743
08AF0:  CALL   5724
08AF4:  MOVF   01,F
08AF6:  BTFSS  FD8.2
08AF8:  BRA    8D48
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08AFA:  MOVLW  04
08AFC:  MOVLB  7
08AFE:  MOVWF  x42
08B00:  MOVLW  C1
08B02:  MOVWF  x41
08B04:  MOVLB  0
08B06:  CALL   566E
08B0A:  MOVFF  02,03
08B0E:  MOVF   01,W
08B10:  ADDLW  C1
08B12:  MOVLB  7
08B14:  MOVWF  x40
08B16:  MOVLW  04
08B18:  ADDWFC 02,W
08B1A:  MOVWF  x41
08B1C:  MOVFF  FE8,565
08B20:  MOVFF  740,564
08B24:  MOVLW  89
08B26:  MOVWF  FE9
08B28:  MOVFF  FE,746
08B2C:  MOVFF  FD,745
08B30:  MOVFF  FC,744
08B34:  MOVFF  FB,743
08B38:  MOVLW  02
08B3A:  MOVWF  x47
08B3C:  MOVLB  0
08B3E:  CALL   6582
08B42:  MOVLW  2C
08B44:  MOVLB  7
08B46:  MOVWF  x50
08B48:  MOVLB  0
08B4A:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
08B4E:  MOVLW  04
08B50:  MOVLB  7
08B52:  MOVWF  x42
08B54:  MOVLW  C1
08B56:  MOVWF  x41
08B58:  MOVLB  0
08B5A:  CALL   566E
08B5E:  MOVFF  02,03
08B62:  MOVF   01,W
08B64:  ADDLW  C1
08B66:  MOVLB  7
08B68:  MOVWF  x40
08B6A:  MOVLW  04
08B6C:  ADDWFC 02,W
08B6E:  MOVWF  x41
08B70:  MOVFF  FE8,565
08B74:  MOVFF  740,564
08B78:  MOVLW  89
08B7A:  MOVWF  FE9
08B7C:  MOVFF  102,746
08B80:  MOVFF  101,745
08B84:  MOVFF  100,744
08B88:  MOVFF  FF,743
08B8C:  MOVLW  01
08B8E:  MOVWF  x47
08B90:  MOVLB  0
08B92:  CALL   6582
08B96:  MOVLW  2C
08B98:  MOVLB  7
08B9A:  MOVWF  x50
08B9C:  MOVLB  0
08B9E:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08BA2:  MOVLW  04
08BA4:  MOVLB  7
08BA6:  MOVWF  x42
08BA8:  MOVLW  C1
08BAA:  MOVWF  x41
08BAC:  MOVLB  0
08BAE:  CALL   566E
08BB2:  MOVFF  02,03
08BB6:  MOVF   01,W
08BB8:  ADDLW  C1
08BBA:  MOVLB  7
08BBC:  MOVWF  x40
08BBE:  MOVLW  04
08BC0:  ADDWFC 02,W
08BC2:  MOVWF  x41
08BC4:  MOVFF  FE8,565
08BC8:  MOVFF  740,564
08BCC:  MOVLW  89
08BCE:  MOVWF  FE9
08BD0:  MOVFF  106,746
08BD4:  MOVFF  105,745
08BD8:  MOVFF  104,744
08BDC:  MOVFF  103,743
08BE0:  MOVLW  03
08BE2:  MOVWF  x47
08BE4:  MOVLB  0
08BE6:  CALL   6582
08BEA:  MOVLW  2C
08BEC:  MOVLB  7
08BEE:  MOVWF  x50
08BF0:  MOVLB  0
08BF2:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
08BF6:  MOVLW  04
08BF8:  MOVLB  7
08BFA:  MOVWF  x42
08BFC:  MOVLW  C1
08BFE:  MOVWF  x41
08C00:  MOVLB  0
08C02:  CALL   566E
08C06:  MOVFF  02,03
08C0A:  MOVF   01,W
08C0C:  ADDLW  C1
08C0E:  MOVLB  7
08C10:  MOVWF  x40
08C12:  MOVLW  04
08C14:  ADDWFC 02,W
08C16:  MOVWF  x41
08C18:  MOVFF  FE8,565
08C1C:  MOVFF  740,564
08C20:  MOVLW  89
08C22:  MOVWF  FE9
08C24:  MOVFF  10A,746
08C28:  MOVFF  109,745
08C2C:  MOVFF  108,744
08C30:  MOVFF  107,743
08C34:  MOVLW  03
08C36:  MOVWF  x47
08C38:  MOVLB  0
08C3A:  CALL   6582
08C3E:  MOVLW  2C
08C40:  MOVLB  7
08C42:  MOVWF  x50
08C44:  MOVLB  0
08C46:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08C4A:  MOVLW  04
08C4C:  MOVLB  7
08C4E:  MOVWF  x42
08C50:  MOVLW  C1
08C52:  MOVWF  x41
08C54:  MOVLB  0
08C56:  CALL   566E
08C5A:  MOVFF  02,03
08C5E:  MOVF   01,W
08C60:  ADDLW  C1
08C62:  MOVLB  7
08C64:  MOVWF  x40
08C66:  MOVLW  04
08C68:  ADDWFC 02,W
08C6A:  MOVWF  x41
08C6C:  MOVFF  FE8,565
08C70:  MOVFF  740,564
08C74:  MOVLW  89
08C76:  MOVWF  FE9
08C78:  MOVFF  10E,746
08C7C:  MOVFF  10D,745
08C80:  MOVFF  10C,744
08C84:  MOVFF  10B,743
08C88:  MOVLW  03
08C8A:  MOVWF  x47
08C8C:  MOVLB  0
08C8E:  CALL   6582
08C92:  MOVLW  2C
08C94:  MOVLB  7
08C96:  MOVWF  x50
08C98:  MOVLB  0
08C9A:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08C9E:  MOVLW  04
08CA0:  MOVLB  7
08CA2:  MOVWF  x42
08CA4:  MOVLW  C1
08CA6:  MOVWF  x41
08CA8:  MOVLB  0
08CAA:  CALL   566E
08CAE:  MOVFF  02,03
08CB2:  MOVF   01,W
08CB4:  ADDLW  C1
08CB6:  MOVLB  7
08CB8:  MOVWF  x40
08CBA:  MOVLW  04
08CBC:  ADDWFC 02,W
08CBE:  MOVWF  x41
08CC0:  MOVFF  FE8,565
08CC4:  MOVFF  740,564
08CC8:  MOVLW  89
08CCA:  MOVWF  FE9
08CCC:  MOVFF  112,746
08CD0:  MOVFF  111,745
08CD4:  MOVFF  110,744
08CD8:  MOVFF  10F,743
08CDC:  MOVLW  03
08CDE:  MOVWF  x47
08CE0:  MOVLB  0
08CE2:  CALL   6582
08CE6:  MOVLW  2C
08CE8:  MOVLB  7
08CEA:  MOVWF  x50
08CEC:  MOVLB  0
08CEE:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08CF2:  MOVLW  04
08CF4:  MOVLB  7
08CF6:  MOVWF  x42
08CF8:  MOVLW  C1
08CFA:  MOVWF  x41
08CFC:  MOVLB  0
08CFE:  CALL   566E
08D02:  MOVFF  02,03
08D06:  MOVF   01,W
08D08:  ADDLW  C1
08D0A:  MOVLB  7
08D0C:  MOVWF  x40
08D0E:  MOVLW  04
08D10:  ADDWFC 02,W
08D12:  MOVWF  x41
08D14:  MOVFF  FE8,565
08D18:  MOVFF  740,564
08D1C:  MOVLW  89
08D1E:  MOVWF  FE9
08D20:  MOVFF  116,746
08D24:  MOVFF  115,745
08D28:  MOVFF  114,744
08D2C:  MOVFF  113,743
08D30:  MOVLW  03
08D32:  MOVWF  x47
08D34:  MOVLB  0
08D36:  CALL   6582
08D3A:  MOVLW  2C
08D3C:  MOVLB  7
08D3E:  MOVWF  x50
08D40:  MOVLB  0
08D42:  CALL   56A6
....................    }
08D46:  BRA    8D4E
....................    else return INV_PARAM;
08D48:  MOVLW  02
08D4A:  MOVWF  01
08D4C:  BRA    8D52
....................    
....................    return SUCCESS;
08D4E:  MOVLW  00
08D50:  MOVWF  01
08D52:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
08D54:  MOVLW  50
08D56:  MOVLB  7
08D58:  MOVWF  x10
08D5A:  MOVLW  56
08D5C:  MOVWF  x11
08D5E:  CLRF   x12
08D60:  MOVLW  07
08D62:  MOVWF  x0F
08D64:  MOVLW  10
08D66:  MOVWF  x0E
....................    char *s_CV = "CV";
08D68:  MOVLW  43
08D6A:  MOVWF  x15
08D6C:  MOVLW  56
08D6E:  MOVWF  x16
08D70:  CLRF   x17
08D72:  MOVLW  07
08D74:  MOVWF  x14
08D76:  MOVLW  15
08D78:  MOVWF  x13
....................    char *s_PVold = "PVold";
08D7A:  MOVLW  50
08D7C:  MOVWF  x1A
08D7E:  MOVLW  56
08D80:  MOVWF  x1B
08D82:  MOVLW  6F
08D84:  MOVWF  x1C
08D86:  MOVLW  6C
08D88:  MOVWF  x1D
08D8A:  MOVLW  64
08D8C:  MOVWF  x1E
08D8E:  CLRF   x1F
08D90:  MOVLW  07
08D92:  MOVWF  x19
08D94:  MOVLW  1A
08D96:  MOVWF  x18
....................    char *s_I = "I";
08D98:  MOVLW  49
08D9A:  MOVWF  x22
08D9C:  CLRF   x23
08D9E:  MOVLW  07
08DA0:  MOVWF  x21
08DA2:  MOVLW  22
08DA4:  MOVWF  x20
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08DA6:  CLRF   x42
08DA8:  MOVFF  690,741
08DAC:  CLRF   x44
08DAE:  MOVLW  B5
08DB0:  MOVWF  x43
08DB2:  MOVLB  0
08DB4:  CALL   08BA
08DB8:  MOVFF  02,725
08DBC:  MOVFF  01,724
08DC0:  MOVLW  06
08DC2:  MOVLB  7
08DC4:  ADDWF  x24,F
08DC6:  MOVLW  00
08DC8:  ADDWFC x25,F
08DCA:  MOVLW  32
08DCC:  ADDWF  x24,W
08DCE:  MOVWF  01
08DD0:  MOVLW  00
08DD2:  ADDWFC x25,W
08DD4:  MOVWF  03
08DD6:  MOVF   01,W
08DD8:  ADDLW  EB
08DDA:  MOVWF  01
08DDC:  MOVLW  01
08DDE:  ADDWFC 03,F
08DE0:  MOVFF  01,724
08DE4:  MOVFF  03,725
08DE8:  MOVFF  03,734
08DEC:  MOVFF  01,733
08DF0:  MOVLB  0
08DF2:  CALL   5844
08DF6:  MOVF   01,F
08DF8:  BNZ   8E02
08DFA:  MOVLW  02
08DFC:  MOVWF  01
08DFE:  BRA    9198
08E00:  BRA    8E60
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08E02:  MOVLB  7
08E04:  CLRF   x42
08E06:  MOVFF  690,741
08E0A:  CLRF   x44
08E0C:  MOVLW  B5
08E0E:  MOVWF  x43
08E10:  MOVLB  0
08E12:  CALL   08BA
08E16:  MOVFF  02,725
08E1A:  MOVFF  01,724
08E1E:  MOVLW  06
08E20:  MOVLB  7
08E22:  ADDWF  x24,F
08E24:  MOVLW  00
08E26:  ADDWFC x25,F
08E28:  MOVLW  32
08E2A:  ADDWF  x24,W
08E2C:  MOVWF  01
08E2E:  MOVLW  00
08E30:  ADDWFC x25,W
08E32:  MOVWF  03
08E34:  MOVF   01,W
08E36:  ADDLW  EB
08E38:  MOVWF  01
08E3A:  MOVLW  01
08E3C:  ADDWFC 03,F
08E3E:  MOVFF  01,724
08E42:  MOVFF  03,725
08E46:  MOVFF  03,734
08E4A:  MOVFF  01,733
08E4E:  CLRF   x36
08E50:  CLRF   x35
08E52:  MOVLW  0A
08E54:  MOVWF  x37
08E56:  MOVLB  0
08E58:  CALL   5934
08E5C:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
08E60:  MOVLB  7
08E62:  CLRF   x42
08E64:  MOVFF  690,741
08E68:  CLRF   x44
08E6A:  MOVLW  B5
08E6C:  MOVWF  x43
08E6E:  MOVLB  0
08E70:  CALL   08BA
08E74:  MOVFF  02,725
08E78:  MOVFF  01,724
08E7C:  MOVLW  06
08E7E:  MOVLB  7
08E80:  ADDWF  x24,F
08E82:  MOVLW  00
08E84:  ADDWFC x25,F
08E86:  MOVLW  4B
08E88:  ADDWF  x24,W
08E8A:  MOVWF  01
08E8C:  MOVLW  00
08E8E:  ADDWFC x25,W
08E90:  MOVWF  03
08E92:  MOVF   01,W
08E94:  ADDLW  EB
08E96:  MOVWF  01
08E98:  MOVLW  01
08E9A:  ADDWFC 03,F
08E9C:  MOVFF  01,70C
08EA0:  MOVFF  03,70D
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
08EA4:  MOVFF  70F,742
08EA8:  MOVFF  70E,741
08EAC:  MOVFF  70D,744
08EB0:  MOVFF  70C,743
08EB4:  MOVLB  0
08EB6:  CALL   5724
08EBA:  MOVF   01,F
08EBC:  BNZ   8F60
08EBE:  MOVLW  04
08EC0:  MOVLB  7
08EC2:  MOVWF  x42
08EC4:  MOVLW  C1
08EC6:  MOVWF  x41
08EC8:  MOVLB  0
08ECA:  CALL   566E
08ECE:  MOVF   01,W
08ED0:  ADDLW  C1
08ED2:  MOVLB  7
08ED4:  MOVWF  x24
08ED6:  MOVLW  04
08ED8:  ADDWFC 02,W
08EDA:  MOVWF  x25
08EDC:  MOVLW  01
08EDE:  SUBWF  x0B,W
08EE0:  MULLW  28
08EE2:  MOVF   FF3,W
08EE4:  CLRF   x27
08EE6:  MOVWF  x26
08EE8:  MOVLW  10
08EEA:  ADDWF  x26,W
08EEC:  MOVWF  01
08EEE:  MOVLW  00
08EF0:  ADDWFC x27,W
08EF2:  MOVWF  03
08EF4:  MOVF   01,W
08EF6:  ADDLW  20
08EF8:  MOVWF  FE9
08EFA:  MOVLW  00
08EFC:  ADDWFC 03,W
08EFE:  MOVWF  FEA
08F00:  MOVFF  FEF,726
08F04:  MOVFF  FEC,727
08F08:  MOVFF  FEC,728
08F0C:  MOVFF  FEC,729
08F10:  MOVFF  725,565
08F14:  MOVFF  724,564
08F18:  MOVFF  70B,734
08F1C:  MOVLW  18
08F1E:  MOVWF  x35
08F20:  MOVLB  0
08F22:  CALL   5C88
08F26:  MOVLW  2C
08F28:  MOVLB  7
08F2A:  MOVWF  x50
08F2C:  MOVLB  0
08F2E:  CALL   56A6
08F32:  MOVLW  89
08F34:  MOVWF  FE9
08F36:  MOVFF  729,746
08F3A:  MOVFF  728,745
08F3E:  MOVFF  727,744
08F42:  MOVFF  726,743
08F46:  MOVLW  02
08F48:  MOVLB  7
08F4A:  MOVWF  x47
08F4C:  MOVLB  0
08F4E:  CALL   6582
08F52:  MOVLW  2C
08F54:  MOVLB  7
08F56:  MOVWF  x50
08F58:  MOVLB  0
08F5A:  CALL   56A6
08F5E:  BRA    9194
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
08F60:  MOVFF  714,742
08F64:  MOVFF  713,741
08F68:  MOVFF  70D,744
08F6C:  MOVFF  70C,743
08F70:  CALL   5724
08F74:  MOVF   01,F
08F76:  BNZ   901A
08F78:  MOVLW  04
08F7A:  MOVLB  7
08F7C:  MOVWF  x42
08F7E:  MOVLW  C1
08F80:  MOVWF  x41
08F82:  MOVLB  0
08F84:  CALL   566E
08F88:  MOVF   01,W
08F8A:  ADDLW  C1
08F8C:  MOVLB  7
08F8E:  MOVWF  x24
08F90:  MOVLW  04
08F92:  ADDWFC 02,W
08F94:  MOVWF  x25
08F96:  MOVLW  01
08F98:  SUBWF  x0B,W
08F9A:  MULLW  28
08F9C:  MOVF   FF3,W
08F9E:  CLRF   x27
08FA0:  MOVWF  x26
08FA2:  MOVLW  18
08FA4:  ADDWF  x26,W
08FA6:  MOVWF  01
08FA8:  MOVLW  00
08FAA:  ADDWFC x27,W
08FAC:  MOVWF  03
08FAE:  MOVF   01,W
08FB0:  ADDLW  20
08FB2:  MOVWF  FE9
08FB4:  MOVLW  00
08FB6:  ADDWFC 03,W
08FB8:  MOVWF  FEA
08FBA:  MOVFF  FEF,726
08FBE:  MOVFF  FEC,727
08FC2:  MOVFF  FEC,728
08FC6:  MOVFF  FEC,729
08FCA:  MOVFF  725,565
08FCE:  MOVFF  724,564
08FD2:  MOVFF  70B,734
08FD6:  MOVLW  18
08FD8:  MOVWF  x35
08FDA:  MOVLB  0
08FDC:  CALL   5C88
08FE0:  MOVLW  2C
08FE2:  MOVLB  7
08FE4:  MOVWF  x50
08FE6:  MOVLB  0
08FE8:  CALL   56A6
08FEC:  MOVLW  89
08FEE:  MOVWF  FE9
08FF0:  MOVFF  729,746
08FF4:  MOVFF  728,745
08FF8:  MOVFF  727,744
08FFC:  MOVFF  726,743
09000:  MOVLW  02
09002:  MOVLB  7
09004:  MOVWF  x47
09006:  MOVLB  0
09008:  CALL   6582
0900C:  MOVLW  2C
0900E:  MOVLB  7
09010:  MOVWF  x50
09012:  MOVLB  0
09014:  CALL   56A6
09018:  BRA    9194
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
0901A:  MOVFF  719,742
0901E:  MOVFF  718,741
09022:  MOVFF  70D,744
09026:  MOVFF  70C,743
0902A:  CALL   5724
0902E:  MOVF   01,F
09030:  BNZ   90D4
09032:  MOVLW  04
09034:  MOVLB  7
09036:  MOVWF  x42
09038:  MOVLW  C1
0903A:  MOVWF  x41
0903C:  MOVLB  0
0903E:  CALL   566E
09042:  MOVF   01,W
09044:  ADDLW  C1
09046:  MOVLB  7
09048:  MOVWF  x24
0904A:  MOVLW  04
0904C:  ADDWFC 02,W
0904E:  MOVWF  x25
09050:  MOVLW  01
09052:  SUBWF  x0B,W
09054:  MULLW  28
09056:  MOVF   FF3,W
09058:  CLRF   x27
0905A:  MOVWF  x26
0905C:  MOVLW  14
0905E:  ADDWF  x26,W
09060:  MOVWF  01
09062:  MOVLW  00
09064:  ADDWFC x27,W
09066:  MOVWF  03
09068:  MOVF   01,W
0906A:  ADDLW  20
0906C:  MOVWF  FE9
0906E:  MOVLW  00
09070:  ADDWFC 03,W
09072:  MOVWF  FEA
09074:  MOVFF  FEF,726
09078:  MOVFF  FEC,727
0907C:  MOVFF  FEC,728
09080:  MOVFF  FEC,729
09084:  MOVFF  725,565
09088:  MOVFF  724,564
0908C:  MOVFF  70B,734
09090:  MOVLW  18
09092:  MOVWF  x35
09094:  MOVLB  0
09096:  CALL   5C88
0909A:  MOVLW  2C
0909C:  MOVLB  7
0909E:  MOVWF  x50
090A0:  MOVLB  0
090A2:  CALL   56A6
090A6:  MOVLW  89
090A8:  MOVWF  FE9
090AA:  MOVFF  729,746
090AE:  MOVFF  728,745
090B2:  MOVFF  727,744
090B6:  MOVFF  726,743
090BA:  MOVLW  02
090BC:  MOVLB  7
090BE:  MOVWF  x47
090C0:  MOVLB  0
090C2:  CALL   6582
090C6:  MOVLW  2C
090C8:  MOVLB  7
090CA:  MOVWF  x50
090CC:  MOVLB  0
090CE:  CALL   56A6
090D2:  BRA    9194
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
090D4:  MOVFF  721,742
090D8:  MOVFF  720,741
090DC:  MOVFF  70D,744
090E0:  MOVFF  70C,743
090E4:  CALL   5724
090E8:  MOVF   01,F
090EA:  BNZ   918E
090EC:  MOVLW  04
090EE:  MOVLB  7
090F0:  MOVWF  x42
090F2:  MOVLW  C1
090F4:  MOVWF  x41
090F6:  MOVLB  0
090F8:  CALL   566E
090FC:  MOVF   01,W
090FE:  ADDLW  C1
09100:  MOVLB  7
09102:  MOVWF  x24
09104:  MOVLW  04
09106:  ADDWFC 02,W
09108:  MOVWF  x25
0910A:  MOVLW  01
0910C:  SUBWF  x0B,W
0910E:  MULLW  28
09110:  MOVF   FF3,W
09112:  CLRF   x27
09114:  MOVWF  x26
09116:  MOVLW  1C
09118:  ADDWF  x26,W
0911A:  MOVWF  01
0911C:  MOVLW  00
0911E:  ADDWFC x27,W
09120:  MOVWF  03
09122:  MOVF   01,W
09124:  ADDLW  20
09126:  MOVWF  FE9
09128:  MOVLW  00
0912A:  ADDWFC 03,W
0912C:  MOVWF  FEA
0912E:  MOVFF  FEF,726
09132:  MOVFF  FEC,727
09136:  MOVFF  FEC,728
0913A:  MOVFF  FEC,729
0913E:  MOVFF  725,565
09142:  MOVFF  724,564
09146:  MOVFF  70B,734
0914A:  MOVLW  18
0914C:  MOVWF  x35
0914E:  MOVLB  0
09150:  CALL   5C88
09154:  MOVLW  2C
09156:  MOVLB  7
09158:  MOVWF  x50
0915A:  MOVLB  0
0915C:  CALL   56A6
09160:  MOVLW  89
09162:  MOVWF  FE9
09164:  MOVFF  729,746
09168:  MOVFF  728,745
0916C:  MOVFF  727,744
09170:  MOVFF  726,743
09174:  MOVLW  02
09176:  MOVLB  7
09178:  MOVWF  x47
0917A:  MOVLB  0
0917C:  CALL   6582
09180:  MOVLW  2C
09182:  MOVLB  7
09184:  MOVWF  x50
09186:  MOVLB  0
09188:  CALL   56A6
0918C:  BRA    9194
....................    else return INV_PARAM;
0918E:  MOVLW  02
09190:  MOVWF  01
09192:  BRA    9198
....................    
....................    return SUCCESS;
09194:  MOVLW  00
09196:  MOVWF  01
09198:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
092B8:  MOVLW  72
092BA:  MOVLB  7
092BC:  MOVWF  x10
092BE:  MOVLW  61
092C0:  MOVWF  x11
092C2:  MOVLW  77
092C4:  MOVWF  x12
092C6:  CLRF   x13
092C8:  MOVLW  07
092CA:  MOVWF  x0F
092CC:  MOVLW  10
092CE:  MOVWF  x0E
....................    char *s_calibrated = "calib";
092D0:  MOVLW  63
092D2:  MOVWF  x16
092D4:  MOVLW  61
092D6:  MOVWF  x17
092D8:  MOVLW  6C
092DA:  MOVWF  x18
092DC:  MOVLW  69
092DE:  MOVWF  x19
092E0:  MOVLW  62
092E2:  MOVWF  x1A
092E4:  CLRF   x1B
092E6:  MOVLW  07
092E8:  MOVWF  x15
092EA:  MOVLW  16
092EC:  MOVWF  x14
....................    char *s_p0 = "p0";
092EE:  MOVLW  70
092F0:  MOVWF  x1E
092F2:  MOVLW  30
092F4:  MOVWF  x1F
092F6:  CLRF   x20
092F8:  MOVLW  07
092FA:  MOVWF  x1D
092FC:  MOVLW  1E
092FE:  MOVWF  x1C
....................    char *s_poles = "poles";
09300:  MOVLW  70
09302:  MOVWF  x23
09304:  MOVLW  6F
09306:  MOVWF  x24
09308:  MOVLW  6C
0930A:  MOVWF  x25
0930C:  MOVLW  65
0930E:  MOVWF  x26
09310:  MOVLW  73
09312:  MOVWF  x27
09314:  CLRF   x28
09316:  MOVLW  07
09318:  MOVWF  x22
0931A:  MOVLW  23
0931C:  MOVWF  x21
....................    char *s_real = "real";
0931E:  MOVLW  72
09320:  MOVWF  x2B
09322:  MOVLW  65
09324:  MOVWF  x2C
09326:  MOVLW  61
09328:  MOVWF  x2D
0932A:  MOVLW  6C
0932C:  MOVWF  x2E
0932E:  CLRF   x2F
09330:  MOVLW  07
09332:  MOVWF  x2A
09334:  MOVLW  2B
09336:  MOVWF  x29
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09338:  CLRF   x42
0933A:  MOVFF  690,741
0933E:  CLRF   x44
09340:  MOVLW  B5
09342:  MOVWF  x43
09344:  MOVLB  0
09346:  CALL   08BA
0934A:  MOVFF  02,731
0934E:  MOVFF  01,730
09352:  MOVLW  06
09354:  MOVLB  7
09356:  ADDWF  x30,F
09358:  MOVLW  00
0935A:  ADDWFC x31,F
0935C:  MOVLW  32
0935E:  ADDWF  x30,W
09360:  MOVWF  01
09362:  MOVLW  00
09364:  ADDWFC x31,W
09366:  MOVWF  03
09368:  MOVF   01,W
0936A:  ADDLW  EB
0936C:  MOVWF  01
0936E:  MOVLW  01
09370:  ADDWFC 03,F
09372:  MOVFF  01,730
09376:  MOVFF  03,731
0937A:  MOVFF  03,734
0937E:  MOVFF  01,733
09382:  MOVLB  0
09384:  CALL   5844
09388:  MOVF   01,F
0938A:  BNZ   9394
0938C:  MOVLW  02
0938E:  MOVWF  01
09390:  BRA    99D8
09392:  BRA    93F2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09394:  MOVLB  7
09396:  CLRF   x42
09398:  MOVFF  690,741
0939C:  CLRF   x44
0939E:  MOVLW  B5
093A0:  MOVWF  x43
093A2:  MOVLB  0
093A4:  CALL   08BA
093A8:  MOVFF  02,731
093AC:  MOVFF  01,730
093B0:  MOVLW  06
093B2:  MOVLB  7
093B4:  ADDWF  x30,F
093B6:  MOVLW  00
093B8:  ADDWFC x31,F
093BA:  MOVLW  32
093BC:  ADDWF  x30,W
093BE:  MOVWF  01
093C0:  MOVLW  00
093C2:  ADDWFC x31,W
093C4:  MOVWF  03
093C6:  MOVF   01,W
093C8:  ADDLW  EB
093CA:  MOVWF  01
093CC:  MOVLW  01
093CE:  ADDWFC 03,F
093D0:  MOVFF  01,730
093D4:  MOVFF  03,731
093D8:  MOVFF  03,734
093DC:  MOVFF  01,733
093E0:  CLRF   x36
093E2:  CLRF   x35
093E4:  MOVLW  0A
093E6:  MOVWF  x37
093E8:  MOVLB  0
093EA:  CALL   5934
093EE:  MOVFF  01,70B
....................    
....................    arg2 = SERcmd[rec].p[3];
093F2:  MOVLB  7
093F4:  CLRF   x42
093F6:  MOVFF  690,741
093FA:  CLRF   x44
093FC:  MOVLW  B5
093FE:  MOVWF  x43
09400:  MOVLB  0
09402:  CALL   08BA
09406:  MOVFF  02,731
0940A:  MOVFF  01,730
0940E:  MOVLW  06
09410:  MOVLB  7
09412:  ADDWF  x30,F
09414:  MOVLW  00
09416:  ADDWFC x31,F
09418:  MOVLW  4B
0941A:  ADDWF  x30,W
0941C:  MOVWF  01
0941E:  MOVLW  00
09420:  ADDWFC x31,W
09422:  MOVWF  03
09424:  MOVF   01,W
09426:  ADDLW  EB
09428:  MOVWF  01
0942A:  MOVLW  01
0942C:  ADDWFC 03,F
0942E:  MOVFF  01,70C
09432:  MOVFF  03,70D
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
09436:  MOVFF  70F,742
0943A:  MOVFF  70E,741
0943E:  MOVFF  70D,744
09442:  MOVFF  70C,743
09446:  MOVLB  0
09448:  CALL   5724
0944C:  MOVF   01,F
0944E:  BTFSS  FD8.2
09450:  BRA    95CC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09452:  MOVLW  04
09454:  MOVLB  7
09456:  MOVWF  x42
09458:  MOVLW  C1
0945A:  MOVWF  x41
0945C:  MOVLB  0
0945E:  CALL   566E
09462:  MOVFF  02,03
09466:  MOVF   01,W
09468:  ADDLW  C1
0946A:  MOVLB  7
0946C:  MOVWF  x30
0946E:  MOVLW  04
09470:  ADDWFC 02,W
09472:  MOVWF  x31
09474:  MOVFF  FE8,565
09478:  MOVFF  730,564
0947C:  MOVFF  70B,734
09480:  MOVLW  18
09482:  MOVWF  x35
09484:  MOVLB  0
09486:  CALL   5C88
0948A:  MOVLW  2C
0948C:  MOVLB  7
0948E:  MOVWF  x50
09490:  MOVLB  0
09492:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
09496:  MOVLW  04
09498:  MOVLB  7
0949A:  MOVWF  x42
0949C:  MOVLW  C1
0949E:  MOVWF  x41
094A0:  MOVLB  0
094A2:  CALL   566E
094A6:  MOVFF  02,03
094AA:  MOVF   01,W
094AC:  ADDLW  C1
094AE:  MOVLB  7
094B0:  MOVWF  x30
094B2:  MOVLW  04
094B4:  ADDWFC 02,W
094B6:  MOVWF  x31
094B8:  MOVLW  01
094BA:  SUBWF  x0B,W
094BC:  MULLW  26
094BE:  MOVF   FF3,W
094C0:  CLRF   x33
094C2:  MOVWF  x32
094C4:  MOVLW  17
094C6:  ADDWF  x32,W
094C8:  MOVWF  FE9
094CA:  MOVLW  01
094CC:  ADDWFC x33,W
094CE:  MOVWF  FEA
094D0:  MOVFF  FEF,750
094D4:  MOVFF  FEC,01
094D8:  MOVFF  FEC,02
094DC:  MOVFF  FEC,03
094E0:  MOVFF  03,753
094E4:  MOVFF  02,752
094E8:  MOVFF  01,751
094EC:  MOVLB  0
094EE:  CALL   64AC
094F2:  MOVFF  03,737
094F6:  MOVFF  02,736
094FA:  MOVFF  01,735
094FE:  MOVFF  00,734
09502:  MOVFF  731,565
09506:  MOVFF  730,564
0950A:  MOVLW  41
0950C:  MOVWF  FE9
0950E:  MOVFF  03,73C
09512:  MOVFF  02,73B
09516:  MOVFF  01,73A
0951A:  MOVFF  00,739
0951E:  RCALL  919A
09520:  MOVLW  2C
09522:  MOVLB  7
09524:  MOVWF  x50
09526:  MOVLB  0
09528:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
0952C:  MOVLW  04
0952E:  MOVLB  7
09530:  MOVWF  x42
09532:  MOVLW  C1
09534:  MOVWF  x41
09536:  MOVLB  0
09538:  CALL   566E
0953C:  MOVF   01,W
0953E:  ADDLW  C1
09540:  MOVLB  7
09542:  MOVWF  x30
09544:  MOVLW  04
09546:  ADDWFC 02,W
09548:  MOVWF  x31
0954A:  MOVLW  01
0954C:  SUBWF  x0B,W
0954E:  MULLW  26
09550:  MOVF   FF3,W
09552:  CLRF   x33
09554:  MOVWF  x32
09556:  MOVLW  04
09558:  ADDWF  x32,W
0955A:  MOVWF  01
0955C:  MOVLW  00
0955E:  ADDWFC x33,W
09560:  MOVWF  03
09562:  MOVF   01,W
09564:  ADDLW  17
09566:  MOVWF  FE9
09568:  MOVLW  01
0956A:  ADDWFC 03,W
0956C:  MOVWF  FEA
0956E:  MOVFF  FEF,750
09572:  MOVFF  FEC,01
09576:  MOVFF  FEC,02
0957A:  MOVFF  FEC,03
0957E:  MOVFF  03,753
09582:  MOVFF  02,752
09586:  MOVFF  01,751
0958A:  MOVLB  0
0958C:  CALL   64AC
09590:  MOVFF  03,735
09594:  MOVFF  02,734
09598:  MOVFF  01,733
0959C:  MOVFF  00,732
095A0:  MOVFF  731,565
095A4:  MOVFF  730,564
095A8:  MOVLW  41
095AA:  MOVWF  FE9
095AC:  MOVFF  03,73C
095B0:  MOVFF  02,73B
095B4:  MOVFF  01,73A
095B8:  MOVFF  00,739
095BC:  RCALL  919A
095BE:  MOVLW  2C
095C0:  MOVLB  7
095C2:  MOVWF  x50
095C4:  MOVLB  0
095C6:  CALL   56A6
....................    }
095CA:  BRA    99D4
....................    else if (0 == strcmp(s_calibrated, arg2)) {
095CC:  MOVFF  715,742
095D0:  MOVFF  714,741
095D4:  MOVFF  70D,744
095D8:  MOVFF  70C,743
095DC:  CALL   5724
095E0:  MOVF   01,F
095E2:  BTFSS  FD8.2
095E4:  BRA    9768
....................       sprintf(retData+strlen(retData), "%d,", arg1);
095E6:  MOVLW  04
095E8:  MOVLB  7
095EA:  MOVWF  x42
095EC:  MOVLW  C1
095EE:  MOVWF  x41
095F0:  MOVLB  0
095F2:  CALL   566E
095F6:  MOVFF  02,03
095FA:  MOVF   01,W
095FC:  ADDLW  C1
095FE:  MOVLB  7
09600:  MOVWF  x30
09602:  MOVLW  04
09604:  ADDWFC 02,W
09606:  MOVWF  x31
09608:  MOVFF  FE8,565
0960C:  MOVFF  730,564
09610:  MOVFF  70B,734
09614:  MOVLW  18
09616:  MOVWF  x35
09618:  MOVLB  0
0961A:  CALL   5C88
0961E:  MOVLW  2C
09620:  MOVLB  7
09622:  MOVWF  x50
09624:  MOVLB  0
09626:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
0962A:  MOVLW  04
0962C:  MOVLB  7
0962E:  MOVWF  x42
09630:  MOVLW  C1
09632:  MOVWF  x41
09634:  MOVLB  0
09636:  CALL   566E
0963A:  MOVF   01,W
0963C:  ADDLW  C1
0963E:  MOVLB  7
09640:  MOVWF  x30
09642:  MOVLW  04
09644:  ADDWFC 02,W
09646:  MOVWF  x31
09648:  MOVLW  01
0964A:  SUBWF  x0B,W
0964C:  MULLW  26
0964E:  MOVF   FF3,W
09650:  CLRF   x33
09652:  MOVWF  x32
09654:  MOVLW  08
09656:  ADDWF  x32,W
09658:  MOVWF  01
0965A:  MOVLW  00
0965C:  ADDWFC x33,W
0965E:  MOVWF  03
09660:  MOVF   01,W
09662:  ADDLW  17
09664:  MOVWF  FE9
09666:  MOVLW  01
09668:  ADDWFC 03,W
0966A:  MOVWF  FEA
0966C:  MOVFF  FEF,750
09670:  MOVFF  FEC,01
09674:  MOVFF  FEC,02
09678:  MOVFF  FEC,03
0967C:  MOVFF  03,753
09680:  MOVFF  02,752
09684:  MOVFF  01,751
09688:  MOVLB  0
0968A:  CALL   64AC
0968E:  MOVFF  03,735
09692:  MOVFF  02,734
09696:  MOVFF  01,733
0969A:  MOVFF  00,732
0969E:  MOVFF  731,565
096A2:  MOVFF  730,564
096A6:  MOVLW  41
096A8:  MOVWF  FE9
096AA:  MOVFF  03,73C
096AE:  MOVFF  02,73B
096B2:  MOVFF  01,73A
096B6:  MOVFF  00,739
096BA:  RCALL  919A
096BC:  MOVLW  2C
096BE:  MOVLB  7
096C0:  MOVWF  x50
096C2:  MOVLB  0
096C4:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
096C8:  MOVLW  04
096CA:  MOVLB  7
096CC:  MOVWF  x42
096CE:  MOVLW  C1
096D0:  MOVWF  x41
096D2:  MOVLB  0
096D4:  CALL   566E
096D8:  MOVF   01,W
096DA:  ADDLW  C1
096DC:  MOVLB  7
096DE:  MOVWF  x30
096E0:  MOVLW  04
096E2:  ADDWFC 02,W
096E4:  MOVWF  x31
096E6:  MOVLW  01
096E8:  SUBWF  x0B,W
096EA:  MULLW  26
096EC:  MOVF   FF3,W
096EE:  CLRF   x33
096F0:  MOVWF  x32
096F2:  MOVLW  0C
096F4:  ADDWF  x32,W
096F6:  MOVWF  01
096F8:  MOVLW  00
096FA:  ADDWFC x33,W
096FC:  MOVWF  03
096FE:  MOVF   01,W
09700:  ADDLW  17
09702:  MOVWF  FE9
09704:  MOVLW  01
09706:  ADDWFC 03,W
09708:  MOVWF  FEA
0970A:  MOVFF  FEF,750
0970E:  MOVFF  FEC,01
09712:  MOVFF  FEC,02
09716:  MOVFF  FEC,03
0971A:  MOVFF  03,753
0971E:  MOVFF  02,752
09722:  MOVFF  01,751
09726:  MOVLB  0
09728:  CALL   64AC
0972C:  MOVFF  03,735
09730:  MOVFF  02,734
09734:  MOVFF  01,733
09738:  MOVFF  00,732
0973C:  MOVFF  731,565
09740:  MOVFF  730,564
09744:  MOVLW  41
09746:  MOVWF  FE9
09748:  MOVFF  03,73C
0974C:  MOVFF  02,73B
09750:  MOVFF  01,73A
09754:  MOVFF  00,739
09758:  RCALL  919A
0975A:  MOVLW  2C
0975C:  MOVLB  7
0975E:  MOVWF  x50
09760:  MOVLB  0
09762:  CALL   56A6
....................    }
09766:  BRA    99D4
....................    else if (0 == strcmp(s_p0, arg2)) {
09768:  MOVFF  71D,742
0976C:  MOVFF  71C,741
09770:  MOVFF  70D,744
09774:  MOVFF  70C,743
09778:  CALL   5724
0977C:  MOVF   01,F
0977E:  BNZ   983A
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09780:  MOVLW  04
09782:  MOVLB  7
09784:  MOVWF  x42
09786:  MOVLW  C1
09788:  MOVWF  x41
0978A:  MOVLB  0
0978C:  CALL   566E
09790:  MOVFF  02,03
09794:  MOVF   01,W
09796:  ADDLW  C1
09798:  MOVLB  7
0979A:  MOVWF  x30
0979C:  MOVLW  04
0979E:  ADDWFC 02,W
097A0:  MOVWF  x31
097A2:  MOVFF  FE8,565
097A6:  MOVFF  730,564
097AA:  MOVFF  70B,734
097AE:  MOVLW  18
097B0:  MOVWF  x35
097B2:  MOVLB  0
097B4:  CALL   5C88
097B8:  MOVLW  2C
097BA:  MOVLB  7
097BC:  MOVWF  x50
097BE:  MOVLB  0
097C0:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
097C4:  MOVLW  04
097C6:  MOVLB  7
097C8:  MOVWF  x42
097CA:  MOVLW  C1
097CC:  MOVWF  x41
097CE:  MOVLB  0
097D0:  CALL   566E
097D4:  MOVF   01,W
097D6:  ADDLW  C1
097D8:  MOVLB  7
097DA:  MOVWF  x30
097DC:  MOVLW  04
097DE:  ADDWFC 02,W
097E0:  MOVWF  x31
097E2:  MOVLW  01
097E4:  SUBWF  x0B,W
097E6:  MULLW  26
097E8:  MOVF   FF3,W
097EA:  CLRF   x33
097EC:  MOVWF  x32
097EE:  MOVLW  18
097F0:  ADDWF  x32,W
097F2:  MOVWF  01
097F4:  MOVLW  00
097F6:  ADDWFC x33,W
097F8:  MOVWF  03
097FA:  MOVF   01,W
097FC:  ADDLW  17
097FE:  MOVWF  FE9
09800:  MOVLW  01
09802:  ADDWFC 03,W
09804:  MOVWF  FEA
09806:  MOVFF  FEF,743
0980A:  MOVFF  FEC,744
0980E:  MOVFF  FEC,745
09812:  MOVFF  FEC,746
09816:  MOVFF  731,565
0981A:  MOVFF  730,564
0981E:  MOVLW  89
09820:  MOVWF  FE9
09822:  MOVLW  02
09824:  MOVWF  x47
09826:  MOVLB  0
09828:  CALL   6582
0982C:  MOVLW  2C
0982E:  MOVLB  7
09830:  MOVWF  x50
09832:  MOVLB  0
09834:  CALL   56A6
....................    }
09838:  BRA    99D4
....................    else if (0 == strcmp(s_poles, arg2)) {
0983A:  MOVFF  722,742
0983E:  MOVFF  721,741
09842:  MOVFF  70D,744
09846:  MOVFF  70C,743
0984A:  CALL   5724
0984E:  MOVF   01,F
09850:  BNZ   98FC
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09852:  MOVLW  04
09854:  MOVLB  7
09856:  MOVWF  x42
09858:  MOVLW  C1
0985A:  MOVWF  x41
0985C:  MOVLB  0
0985E:  CALL   566E
09862:  MOVFF  02,03
09866:  MOVF   01,W
09868:  ADDLW  C1
0986A:  MOVLB  7
0986C:  MOVWF  x30
0986E:  MOVLW  04
09870:  ADDWFC 02,W
09872:  MOVWF  x31
09874:  MOVFF  FE8,565
09878:  MOVFF  730,564
0987C:  MOVFF  70B,734
09880:  MOVLW  18
09882:  MOVWF  x35
09884:  MOVLB  0
09886:  CALL   5C88
0988A:  MOVLW  2C
0988C:  MOVLB  7
0988E:  MOVWF  x50
09890:  MOVLB  0
09892:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09896:  MOVLW  04
09898:  MOVLB  7
0989A:  MOVWF  x42
0989C:  MOVLW  C1
0989E:  MOVWF  x41
098A0:  MOVLB  0
098A2:  CALL   566E
098A6:  MOVF   01,W
098A8:  ADDLW  C1
098AA:  MOVLB  7
098AC:  MOVWF  x30
098AE:  MOVLW  04
098B0:  ADDWFC 02,W
098B2:  MOVWF  x31
098B4:  MOVLW  01
098B6:  SUBWF  x0B,W
098B8:  MULLW  26
098BA:  MOVF   FF3,W
098BC:  CLRF   x33
098BE:  MOVWF  x32
098C0:  MOVLW  1C
098C2:  ADDWF  x32,W
098C4:  MOVWF  01
098C6:  MOVLW  00
098C8:  ADDWFC x33,W
098CA:  MOVWF  03
098CC:  MOVF   01,W
098CE:  ADDLW  17
098D0:  MOVWF  FE9
098D2:  MOVLW  01
098D4:  ADDWFC 03,W
098D6:  MOVWF  FEA
098D8:  MOVFF  FEF,734
098DC:  MOVFF  731,565
098E0:  MOVFF  730,564
098E4:  MOVLW  18
098E6:  MOVWF  x35
098E8:  MOVLB  0
098EA:  CALL   5C88
098EE:  MOVLW  2C
098F0:  MOVLB  7
098F2:  MOVWF  x50
098F4:  MOVLB  0
098F6:  CALL   56A6
....................    }
098FA:  BRA    99D4
....................    else if (0 == strcmp(s_real, arg2)) {
098FC:  MOVFF  72A,742
09900:  MOVFF  729,741
09904:  MOVFF  70D,744
09908:  MOVFF  70C,743
0990C:  CALL   5724
09910:  MOVF   01,F
09912:  BNZ   99CE
....................       sprintf(retData+strlen(retData), "%d,", arg1);
09914:  MOVLW  04
09916:  MOVLB  7
09918:  MOVWF  x42
0991A:  MOVLW  C1
0991C:  MOVWF  x41
0991E:  MOVLB  0
09920:  CALL   566E
09924:  MOVFF  02,03
09928:  MOVF   01,W
0992A:  ADDLW  C1
0992C:  MOVLB  7
0992E:  MOVWF  x30
09930:  MOVLW  04
09932:  ADDWFC 02,W
09934:  MOVWF  x31
09936:  MOVFF  FE8,565
0993A:  MOVFF  730,564
0993E:  MOVFF  70B,734
09942:  MOVLW  18
09944:  MOVWF  x35
09946:  MOVLB  0
09948:  CALL   5C88
0994C:  MOVLW  2C
0994E:  MOVLB  7
09950:  MOVWF  x50
09952:  MOVLB  0
09954:  CALL   56A6
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
09958:  MOVLW  04
0995A:  MOVLB  7
0995C:  MOVWF  x42
0995E:  MOVLW  C1
09960:  MOVWF  x41
09962:  MOVLB  0
09964:  CALL   566E
09968:  MOVF   01,W
0996A:  ADDLW  C1
0996C:  MOVLB  7
0996E:  MOVWF  x30
09970:  MOVLW  04
09972:  ADDWFC 02,W
09974:  MOVWF  x31
09976:  MOVLW  01
09978:  SUBWF  x0B,W
0997A:  MULLW  26
0997C:  MOVF   FF3,W
0997E:  CLRF   x33
09980:  MOVWF  x32
09982:  MOVLW  1D
09984:  ADDWF  x32,W
09986:  MOVWF  01
09988:  MOVLW  00
0998A:  ADDWFC x33,W
0998C:  MOVWF  03
0998E:  MOVF   01,W
09990:  ADDLW  17
09992:  MOVWF  FE9
09994:  MOVLW  01
09996:  ADDWFC 03,W
09998:  MOVWF  FEA
0999A:  MOVFF  FEF,743
0999E:  MOVFF  FEC,744
099A2:  MOVFF  FEC,745
099A6:  MOVFF  FEC,746
099AA:  MOVFF  731,565
099AE:  MOVFF  730,564
099B2:  MOVLW  89
099B4:  MOVWF  FE9
099B6:  MOVLW  02
099B8:  MOVWF  x47
099BA:  MOVLB  0
099BC:  CALL   6582
099C0:  MOVLW  2C
099C2:  MOVLB  7
099C4:  MOVWF  x50
099C6:  MOVLB  0
099C8:  CALL   56A6
....................    }
099CC:  BRA    99D4
....................    else return INV_PARAM;
099CE:  MOVLW  02
099D0:  MOVWF  01
099D2:  BRA    99D8
....................    
....................    return SUCCESS;
099D4:  MOVLW  00
099D6:  MOVWF  01
099D8:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
099DA:  MOVLB  7
099DC:  CLRF   x42
099DE:  MOVFF  690,741
099E2:  CLRF   x44
099E4:  MOVLW  B5
099E6:  MOVWF  x43
099E8:  MOVLB  0
099EA:  CALL   08BA
099EE:  MOVFF  02,70D
099F2:  MOVFF  01,70C
099F6:  MOVLW  06
099F8:  MOVLB  7
099FA:  ADDWF  x0C,F
099FC:  MOVLW  00
099FE:  ADDWFC x0D,F
09A00:  MOVLW  32
09A02:  ADDWF  x0C,W
09A04:  MOVWF  01
09A06:  MOVLW  00
09A08:  ADDWFC x0D,W
09A0A:  MOVWF  03
09A0C:  MOVF   01,W
09A0E:  ADDLW  EB
09A10:  MOVWF  01
09A12:  MOVLW  01
09A14:  ADDWFC 03,F
09A16:  MOVFF  01,70C
09A1A:  MOVFF  03,70D
09A1E:  MOVFF  03,734
09A22:  MOVFF  01,733
09A26:  MOVLB  0
09A28:  CALL   5844
09A2C:  MOVF   01,F
09A2E:  BNZ   9A38
09A30:  MOVLW  02
09A32:  MOVWF  01
09A34:  BRA    9B3A
09A36:  BRA    9A96
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09A38:  MOVLB  7
09A3A:  CLRF   x42
09A3C:  MOVFF  690,741
09A40:  CLRF   x44
09A42:  MOVLW  B5
09A44:  MOVWF  x43
09A46:  MOVLB  0
09A48:  CALL   08BA
09A4C:  MOVFF  02,70D
09A50:  MOVFF  01,70C
09A54:  MOVLW  06
09A56:  MOVLB  7
09A58:  ADDWF  x0C,F
09A5A:  MOVLW  00
09A5C:  ADDWFC x0D,F
09A5E:  MOVLW  32
09A60:  ADDWF  x0C,W
09A62:  MOVWF  01
09A64:  MOVLW  00
09A66:  ADDWFC x0D,W
09A68:  MOVWF  03
09A6A:  MOVF   01,W
09A6C:  ADDLW  EB
09A6E:  MOVWF  01
09A70:  MOVLW  01
09A72:  ADDWFC 03,F
09A74:  MOVFF  01,70C
09A78:  MOVFF  03,70D
09A7C:  MOVFF  03,734
09A80:  MOVFF  01,733
09A84:  CLRF   x36
09A86:  CLRF   x35
09A88:  MOVLW  0A
09A8A:  MOVWF  x37
09A8C:  MOVLB  0
09A8E:  CALL   5934
09A92:  MOVFF  01,70B
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, dacVals[arg1-1].opPcnt);
09A96:  MOVLW  04
09A98:  MOVLB  7
09A9A:  MOVWF  x42
09A9C:  MOVLW  C1
09A9E:  MOVWF  x41
09AA0:  MOVLB  0
09AA2:  CALL   566E
09AA6:  MOVF   01,W
09AA8:  ADDLW  C1
09AAA:  MOVLB  7
09AAC:  MOVWF  x0C
09AAE:  MOVLW  04
09AB0:  ADDWFC 02,W
09AB2:  MOVWF  x0D
09AB4:  MOVLW  01
09AB6:  SUBWF  x0B,W
09AB8:  MULLW  07
09ABA:  MOVF   FF3,W
09ABC:  CLRF   x0F
09ABE:  MOVWF  x0E
09AC0:  MOVLW  03
09AC2:  ADDWF  x0E,W
09AC4:  MOVWF  01
09AC6:  MOVLW  00
09AC8:  ADDWFC x0F,W
09ACA:  MOVWF  03
09ACC:  MOVF   01,W
09ACE:  ADDLW  64
09AD0:  MOVWF  FE9
09AD2:  MOVLW  01
09AD4:  ADDWFC 03,W
09AD6:  MOVWF  FEA
09AD8:  MOVFF  FEF,70E
09ADC:  MOVFF  FEC,70F
09AE0:  MOVFF  FEC,710
09AE4:  MOVFF  FEC,711
09AE8:  MOVFF  70D,565
09AEC:  MOVFF  70C,564
09AF0:  MOVFF  70B,734
09AF4:  MOVLW  18
09AF6:  MOVWF  x35
09AF8:  MOVLB  0
09AFA:  CALL   5C88
09AFE:  MOVLW  2C
09B00:  MOVLB  7
09B02:  MOVWF  x50
09B04:  MOVLB  0
09B06:  CALL   56A6
09B0A:  MOVLW  89
09B0C:  MOVWF  FE9
09B0E:  MOVFF  711,746
09B12:  MOVFF  710,745
09B16:  MOVFF  70F,744
09B1A:  MOVFF  70E,743
09B1E:  MOVLW  02
09B20:  MOVLB  7
09B22:  MOVWF  x47
09B24:  MOVLB  0
09B26:  CALL   6582
09B2A:  MOVLW  2C
09B2C:  MOVLB  7
09B2E:  MOVWF  x50
09B30:  MOVLB  0
09B32:  CALL   56A6
....................    
....................    return SUCCESS;
09B36:  MOVLW  00
09B38:  MOVWF  01
09B3A:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09B3C:  MOVLB  7
09B3E:  CLRF   x42
09B40:  MOVFF  690,741
09B44:  CLRF   x44
09B46:  MOVLW  B5
09B48:  MOVWF  x43
09B4A:  MOVLB  0
09B4C:  CALL   08BA
09B50:  MOVFF  02,711
09B54:  MOVFF  01,710
09B58:  MOVLW  06
09B5A:  MOVLB  7
09B5C:  ADDWF  x10,F
09B5E:  MOVLW  00
09B60:  ADDWFC x11,F
09B62:  MOVLW  32
09B64:  ADDWF  x10,W
09B66:  MOVWF  01
09B68:  MOVLW  00
09B6A:  ADDWFC x11,W
09B6C:  MOVWF  03
09B6E:  MOVF   01,W
09B70:  ADDLW  EB
09B72:  MOVWF  01
09B74:  MOVLW  01
09B76:  ADDWFC 03,F
09B78:  MOVFF  01,710
09B7C:  MOVFF  03,711
09B80:  MOVFF  03,734
09B84:  MOVFF  01,733
09B88:  MOVLB  0
09B8A:  CALL   5844
09B8E:  MOVF   01,F
09B90:  BNZ   9B9A
09B92:  MOVLW  02
09B94:  MOVWF  01
09B96:  BRA    9DAC
09B98:  BRA    9BF8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09B9A:  MOVLB  7
09B9C:  CLRF   x42
09B9E:  MOVFF  690,741
09BA2:  CLRF   x44
09BA4:  MOVLW  B5
09BA6:  MOVWF  x43
09BA8:  MOVLB  0
09BAA:  CALL   08BA
09BAE:  MOVFF  02,711
09BB2:  MOVFF  01,710
09BB6:  MOVLW  06
09BB8:  MOVLB  7
09BBA:  ADDWF  x10,F
09BBC:  MOVLW  00
09BBE:  ADDWFC x11,F
09BC0:  MOVLW  32
09BC2:  ADDWF  x10,W
09BC4:  MOVWF  01
09BC6:  MOVLW  00
09BC8:  ADDWFC x11,W
09BCA:  MOVWF  03
09BCC:  MOVF   01,W
09BCE:  ADDLW  EB
09BD0:  MOVWF  01
09BD2:  MOVLW  01
09BD4:  ADDWFC 03,F
09BD6:  MOVFF  01,710
09BDA:  MOVFF  03,711
09BDE:  MOVFF  03,734
09BE2:  MOVFF  01,733
09BE6:  CLRF   x36
09BE8:  CLRF   x35
09BEA:  MOVLW  0A
09BEC:  MOVWF  x37
09BEE:  MOVLB  0
09BF0:  CALL   5934
09BF4:  MOVFF  01,70B
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09BF8:  MOVLB  7
09BFA:  CLRF   x42
09BFC:  MOVFF  690,741
09C00:  CLRF   x44
09C02:  MOVLW  B5
09C04:  MOVWF  x43
09C06:  MOVLB  0
09C08:  CALL   08BA
09C0C:  MOVFF  02,711
09C10:  MOVFF  01,710
09C14:  MOVLW  06
09C16:  MOVLB  7
09C18:  ADDWF  x10,F
09C1A:  MOVLW  00
09C1C:  ADDWFC x11,F
09C1E:  MOVLW  4B
09C20:  ADDWF  x10,W
09C22:  MOVWF  01
09C24:  MOVLW  00
09C26:  ADDWFC x11,W
09C28:  MOVWF  03
09C2A:  MOVF   01,W
09C2C:  ADDLW  EB
09C2E:  MOVWF  01
09C30:  MOVLW  01
09C32:  ADDWFC 03,F
09C34:  MOVFF  01,710
09C38:  MOVFF  03,711
09C3C:  MOVFF  03,715
09C40:  MOVFF  01,714
09C44:  MOVLB  0
09C46:  CALL   6BE8
09C4A:  MOVF   01,F
09C4C:  BNZ   9C56
09C4E:  MOVLW  02
09C50:  MOVWF  01
09C52:  BRA    9DAC
09C54:  BRA    9CBC
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
09C56:  MOVLB  7
09C58:  CLRF   x42
09C5A:  MOVFF  690,741
09C5E:  CLRF   x44
09C60:  MOVLW  B5
09C62:  MOVWF  x43
09C64:  MOVLB  0
09C66:  CALL   08BA
09C6A:  MOVFF  02,711
09C6E:  MOVFF  01,710
09C72:  MOVLW  06
09C74:  MOVLB  7
09C76:  ADDWF  x10,F
09C78:  MOVLW  00
09C7A:  ADDWFC x11,F
09C7C:  MOVLW  4B
09C7E:  ADDWF  x10,W
09C80:  MOVWF  01
09C82:  MOVLW  00
09C84:  ADDWFC x11,W
09C86:  MOVWF  03
09C88:  MOVF   01,W
09C8A:  ADDLW  EB
09C8C:  MOVWF  01
09C8E:  MOVLW  01
09C90:  ADDWFC 03,F
09C92:  MOVFF  01,710
09C96:  MOVFF  03,711
09C9A:  MOVFF  03,715
09C9E:  MOVFF  01,714
09CA2:  CLRF   x17
09CA4:  CLRF   x16
09CA6:  MOVLB  0
09CA8:  CALL   6CAA
09CAC:  MOVFF  03,70F
09CB0:  MOVFF  02,70E
09CB4:  MOVFF  01,70D
09CB8:  MOVFF  00,70C
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) dacVals[arg1-1].opPcnt = op_upper_bound;
09CBC:  MOVLB  7
09CBE:  CLRF   x49
09CC0:  CLRF   x48
09CC2:  MOVLW  7C
09CC4:  MOVWF  x47
09CC6:  MOVLW  84
09CC8:  MOVWF  x46
09CCA:  MOVFF  70F,74D
09CCE:  MOVFF  70E,74C
09CD2:  MOVFF  70D,74B
09CD6:  MOVFF  70C,74A
09CDA:  MOVLB  0
09CDC:  CALL   1D30
09CE0:  BNC   9D16
09CE2:  MOVLW  01
09CE4:  MOVLB  7
09CE6:  SUBWF  x0B,W
09CE8:  MULLW  07
09CEA:  MOVF   FF3,W
09CEC:  CLRF   x11
09CEE:  MOVWF  x10
09CF0:  MOVLW  03
09CF2:  ADDWF  x10,W
09CF4:  MOVWF  01
09CF6:  MOVLW  00
09CF8:  ADDWFC x11,W
09CFA:  MOVWF  03
09CFC:  MOVF   01,W
09CFE:  ADDLW  64
09D00:  MOVWF  FE9
09D02:  MOVLW  01
09D04:  ADDWFC 03,W
09D06:  MOVWF  FEA
09D08:  MOVLW  84
09D0A:  MOVWF  FEF
09D0C:  MOVLW  7C
09D0E:  MOVWF  FEC
09D10:  CLRF   FEC
09D12:  CLRF   FEC
09D14:  BRA    9DA6
....................    else if (arg2 < op_lower_bound) dacVals[arg1-1].opPcnt = op_lower_bound;  
09D16:  MOVFF  70F,749
09D1A:  MOVFF  70E,748
09D1E:  MOVFF  70D,747
09D22:  MOVFF  70C,746
09D26:  MOVLB  7
09D28:  CLRF   x4D
09D2A:  CLRF   x4C
09D2C:  MOVLW  C0
09D2E:  MOVWF  x4B
09D30:  MOVLW  82
09D32:  MOVWF  x4A
09D34:  MOVLB  0
09D36:  CALL   1D30
09D3A:  BNC   9D70
09D3C:  MOVLW  01
09D3E:  MOVLB  7
09D40:  SUBWF  x0B,W
09D42:  MULLW  07
09D44:  MOVF   FF3,W
09D46:  CLRF   x11
09D48:  MOVWF  x10
09D4A:  MOVLW  03
09D4C:  ADDWF  x10,W
09D4E:  MOVWF  01
09D50:  MOVLW  00
09D52:  ADDWFC x11,W
09D54:  MOVWF  03
09D56:  MOVF   01,W
09D58:  ADDLW  64
09D5A:  MOVWF  FE9
09D5C:  MOVLW  01
09D5E:  ADDWFC 03,W
09D60:  MOVWF  FEA
09D62:  MOVLW  82
09D64:  MOVWF  FEF
09D66:  MOVLW  C0
09D68:  MOVWF  FEC
09D6A:  CLRF   FEC
09D6C:  CLRF   FEC
09D6E:  BRA    9DA6
....................    else dacVals[arg1-1].opPcnt = arg2;
09D70:  MOVLW  01
09D72:  MOVLB  7
09D74:  SUBWF  x0B,W
09D76:  MULLW  07
09D78:  MOVF   FF3,W
09D7A:  CLRF   x11
09D7C:  MOVWF  x10
09D7E:  MOVLW  03
09D80:  ADDWF  x10,W
09D82:  MOVWF  01
09D84:  MOVLW  00
09D86:  ADDWFC x11,W
09D88:  MOVWF  03
09D8A:  MOVF   01,W
09D8C:  ADDLW  64
09D8E:  MOVWF  FE9
09D90:  MOVLW  01
09D92:  ADDWFC 03,W
09D94:  MOVWF  FEA
09D96:  MOVFF  70C,FEF
09D9A:  MOVFF  70D,FEC
09D9E:  MOVFF  70E,FEC
09DA2:  MOVFF  70F,FEC
....................    
....................    return SUCCESS;
09DA6:  MOVLW  00
09DA8:  MOVWF  01
09DAA:  MOVLB  0
09DAC:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOn(unsigned int8 rec){
....................    adcFilter = TRUE;
09DAE:  MOVLB  1
09DB0:  BSF    x63.0
....................    return SUCCESS;
09DB2:  MOVLW  00
09DB4:  MOVWF  01
09DB6:  MOVLB  0
09DB8:  RETURN 0
.................... }
.................... 
.................... int8 setFilterOff(unsigned int8 rec){
....................    adcFilter = FALSE;
09DBA:  MOVLB  1
09DBC:  BCF    x63.0
....................    return SUCCESS;
09DBE:  MOVLW  00
09DC0:  MOVWF  01
09DC2:  MOVLB  0
09DC4:  RETURN 0
.................... }
.................... 
.................... int8 setHomeAxis(unsigned int8 rec){
....................     /*** ARG CHECKS ********************/
....................     int8 arg1;
....................     
....................     if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09DC6:  MOVLB  7
09DC8:  CLRF   x42
09DCA:  MOVFF  690,741
09DCE:  CLRF   x44
09DD0:  MOVLW  B5
09DD2:  MOVWF  x43
09DD4:  MOVLB  0
09DD6:  CALL   08BA
09DDA:  MOVFF  02,70D
09DDE:  MOVFF  01,70C
09DE2:  MOVLW  06
09DE4:  MOVLB  7
09DE6:  ADDWF  x0C,F
09DE8:  MOVLW  00
09DEA:  ADDWFC x0D,F
09DEC:  MOVLW  32
09DEE:  ADDWF  x0C,W
09DF0:  MOVWF  01
09DF2:  MOVLW  00
09DF4:  ADDWFC x0D,W
09DF6:  MOVWF  03
09DF8:  MOVF   01,W
09DFA:  ADDLW  EB
09DFC:  MOVWF  01
09DFE:  MOVLW  01
09E00:  ADDWFC 03,F
09E02:  MOVFF  01,70C
09E06:  MOVFF  03,70D
09E0A:  MOVFF  03,734
09E0E:  MOVFF  01,733
09E12:  MOVLB  0
09E14:  CALL   5844
09E18:  MOVF   01,F
09E1A:  BNZ   9E24
09E1C:  MOVLW  02
09E1E:  MOVWF  01
09E20:  BRA    9EB0
09E22:  BRA    9E82
....................     else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09E24:  MOVLB  7
09E26:  CLRF   x42
09E28:  MOVFF  690,741
09E2C:  CLRF   x44
09E2E:  MOVLW  B5
09E30:  MOVWF  x43
09E32:  MOVLB  0
09E34:  CALL   08BA
09E38:  MOVFF  02,70D
09E3C:  MOVFF  01,70C
09E40:  MOVLW  06
09E42:  MOVLB  7
09E44:  ADDWF  x0C,F
09E46:  MOVLW  00
09E48:  ADDWFC x0D,F
09E4A:  MOVLW  32
09E4C:  ADDWF  x0C,W
09E4E:  MOVWF  01
09E50:  MOVLW  00
09E52:  ADDWFC x0D,W
09E54:  MOVWF  03
09E56:  MOVF   01,W
09E58:  ADDLW  EB
09E5A:  MOVWF  01
09E5C:  MOVLW  01
09E5E:  ADDWFC 03,F
09E60:  MOVFF  01,70C
09E64:  MOVFF  03,70D
09E68:  MOVFF  03,734
09E6C:  MOVFF  01,733
09E70:  CLRF   x36
09E72:  CLRF   x35
09E74:  MOVLW  0A
09E76:  MOVWF  x37
09E78:  MOVLB  0
09E7A:  CALL   5934
09E7E:  MOVFF  01,70B
....................     
....................     adcVals[arg1-1].homeFlag = TRUE;
09E82:  MOVLW  01
09E84:  MOVLB  7
09E86:  SUBWF  x0B,W
09E88:  MULLW  26
09E8A:  MOVF   FF3,W
09E8C:  CLRF   x0D
09E8E:  MOVWF  x0C
09E90:  MOVLW  25
09E92:  ADDWF  x0C,W
09E94:  MOVWF  01
09E96:  MOVLW  00
09E98:  ADDWFC x0D,W
09E9A:  MOVWF  03
09E9C:  MOVF   01,W
09E9E:  ADDLW  17
09EA0:  MOVWF  FE9
09EA2:  MOVLW  01
09EA4:  ADDWFC 03,W
09EA6:  MOVWF  FEA
09EA8:  BSF    FEF.0
....................     
....................     return SUCCESS;
09EAA:  MOVLW  00
09EAC:  MOVWF  01
09EAE:  MOVLB  0
09EB0:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
09EB2:  MOVLW  01
09EB4:  MOVWF  01
09EB6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
06BE8:  MOVLB  7
06BEA:  BCF    x16.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
06BEC:  CLRF   x17
06BEE:  MOVFF  715,742
06BF2:  MOVFF  714,741
06BF6:  MOVLB  0
06BF8:  CALL   566E
06BFC:  MOVFF  02,03
06C00:  MOVF   01,W
06C02:  MOVF   03,F
06C04:  BNZ   6C10
06C06:  MOVF   01,W
06C08:  MOVLB  7
06C0A:  SUBWF  x17,W
06C0C:  BC    6CA2
06C0E:  MOVLB  0
....................       if (!isdigit(arg[i])){
06C10:  MOVLB  7
06C12:  MOVF   x17,W
06C14:  ADDWF  x14,W
06C16:  MOVWF  FE9
06C18:  MOVLW  00
06C1A:  ADDWFC x15,W
06C1C:  MOVWF  FEA
06C1E:  MOVFF  FEF,718
06C22:  MOVF   x18,W
06C24:  SUBLW  2F
06C26:  BC    6C2E
06C28:  MOVF   x18,W
06C2A:  SUBLW  39
06C2C:  BC    6C9A
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06C2E:  MOVF   x17,W
06C30:  ADDWF  x14,W
06C32:  MOVWF  FE9
06C34:  MOVLW  00
06C36:  ADDWFC x15,W
06C38:  MOVWF  FEA
06C3A:  MOVF   FEF,W
06C3C:  SUBLW  2D
06C3E:  BZ    6C6A
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06C40:  MOVF   x17,W
06C42:  ADDWF  x14,W
06C44:  MOVWF  FE9
06C46:  MOVLW  00
06C48:  ADDWFC x15,W
06C4A:  MOVWF  FEA
06C4C:  MOVF   FEF,W
06C4E:  SUBLW  2E
06C50:  BZ    6C5A
06C52:  MOVLW  00
06C54:  MOVWF  01
06C56:  BRA    6CA6
06C58:  BRA    6C68
....................             else if  (decimal) return FALSE;
06C5A:  BTFSS  x16.0
06C5C:  BRA    6C66
06C5E:  MOVLW  00
06C60:  MOVWF  01
06C62:  BRA    6CA6
06C64:  BRA    6C68
....................             else decimal = TRUE;
06C66:  BSF    x16.0
....................          }
06C68:  BRA    6C9A
....................          else if (0 != i) return FALSE;
06C6A:  MOVF   x17,F
06C6C:  BZ    6C76
06C6E:  MOVLW  00
06C70:  MOVWF  01
06C72:  BRA    6CA6
06C74:  BRA    6C9A
....................          else if (1 == strlen(arg)) return FALSE;
06C76:  MOVFF  715,742
06C7A:  MOVFF  714,741
06C7E:  MOVLB  0
06C80:  CALL   566E
06C84:  MOVFF  02,03
06C88:  MOVF   01,W
06C8A:  SUBLW  01
06C8C:  BNZ   6C9C
06C8E:  MOVF   03,F
06C90:  BNZ   6C9C
06C92:  MOVLW  00
06C94:  MOVWF  01
06C96:  MOVLB  7
06C98:  BRA    6CA6
06C9A:  MOVLB  0
....................       }
06C9C:  MOVLB  7
06C9E:  INCF   x17,F
06CA0:  BRA    6BEE
....................    }
....................    return TRUE;
06CA2:  MOVLW  01
06CA4:  MOVWF  01
06CA6:  MOVLB  0
06CA8:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
05844:  MOVFF  734,742
05848:  MOVFF  733,741
0584C:  RCALL  566E
0584E:  MOVFF  02,03
05852:  MOVF   01,W
05854:  SUBLW  01
05856:  BNZ   585C
05858:  MOVF   03,F
0585A:  BZ    5864
0585C:  MOVLW  00
0585E:  MOVWF  01
05860:  BRA    5892
05862:  BRA    588A
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
05864:  MOVLB  7
05866:  MOVFF  733,FE9
0586A:  MOVFF  734,FEA
0586E:  MOVF   FEF,W
05870:  SUBLW  31
05872:  BZ    588C
05874:  MOVFF  733,FE9
05878:  MOVFF  734,FEA
0587C:  MOVF   FEF,W
0587E:  SUBLW  32
05880:  BZ    588C
05882:  MOVLW  00
05884:  MOVWF  01
05886:  MOVLB  0
05888:  BRA    5892
0588A:  MOVLB  7
....................     return TRUE;
0588C:  MOVLW  01
0588E:  MOVWF  01
05890:  MOVLB  0
05892:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
056EA:  MOVLB  7
056EC:  MOVF   x0A,W
056EE:  SUBLW  2F
056F0:  BC    5702
056F2:  MOVF   x0A,W
056F4:  SUBLW  39
056F6:  BNC   5702
056F8:  MOVLW  30
056FA:  SUBWF  x0A,W
056FC:  MOVWF  01
056FE:  BRA    571E
05700:  BRA    571E
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
05702:  MOVF   x0A,W
05704:  SUBLW  40
05706:  BC    571A
05708:  MOVF   x0A,W
0570A:  SUBLW  46
0570C:  BNC   571A
0570E:  MOVLW  41
05710:  SUBWF  x0A,W
05712:  ADDLW  0A
05714:  MOVWF  01
05716:  BRA    571E
05718:  BRA    571E
....................    else return 0xFF;
0571A:  MOVLW  FF
0571C:  MOVWF  01
0571E:  MOVLB  0
05720:  GOTO   9F5C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    /* NEEDS FIXING
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
....................    */
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09EB8:  MOVLB  7
09EBA:  CLRF   x42
09EBC:  MOVFF  701,741
09EC0:  CLRF   x44
09EC2:  MOVLW  B5
09EC4:  MOVWF  x43
09EC6:  MOVLB  0
09EC8:  CALL   08BA
09ECC:  MOVFF  02,70A
09ED0:  MOVFF  01,709
09ED4:  MOVLW  06
09ED6:  MOVLB  7
09ED8:  ADDWF  x09,F
09EDA:  MOVLW  00
09EDC:  ADDWFC x0A,F
09EDE:  MOVLW  EB
09EE0:  ADDWF  x09,W
09EE2:  MOVWF  01
09EE4:  MOVLW  01
09EE6:  ADDWFC x0A,W
09EE8:  MOVWF  03
09EEA:  MOVFF  01,702
09EEE:  MOVWF  x03
09EF0:  CLRF   x42
09EF2:  MOVFF  701,741
09EF6:  CLRF   x44
09EF8:  MOVLW  B5
09EFA:  MOVWF  x43
09EFC:  MOVLB  0
09EFE:  CALL   08BA
09F02:  MOVFF  02,70C
09F06:  MOVFF  01,70B
09F0A:  MOVLW  06
09F0C:  MOVLB  7
09F0E:  ADDWF  x0B,F
09F10:  MOVLW  00
09F12:  ADDWFC x0C,F
09F14:  MOVLW  19
09F16:  ADDWF  x0B,W
09F18:  MOVWF  01
09F1A:  MOVLW  00
09F1C:  ADDWFC x0C,W
09F1E:  MOVWF  03
09F20:  MOVF   01,W
09F22:  ADDLW  EB
09F24:  MOVWF  01
09F26:  MOVLW  01
09F28:  ADDWFC 03,F
09F2A:  MOVFF  01,704
09F2E:  MOVFF  03,705
09F32:  CLRF   x06
09F34:  CLRF   x07
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09F36:  MOVFF  702,FE9
09F3A:  MOVFF  703,FEA
09F3E:  MOVF   FEF,W
09F40:  SUBLW  44
09F42:  BTFSS  FD8.2
09F44:  BRA    A034
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
09F46:  MOVLW  01
09F48:  ADDWF  x02,W
09F4A:  MOVWF  FE9
09F4C:  MOVLW  00
09F4E:  ADDWFC x03,W
09F50:  MOVWF  FEA
09F52:  MOVFF  FEF,70A
09F56:  MOVLB  0
09F58:  GOTO   56EA
09F5C:  MOVFF  01,709
09F60:  MOVLB  7
09F62:  MOVF   x06,W
09F64:  ANDLW  0F
09F66:  SUBWF  01,W
09F68:  BNZ   A02C
....................          while (0 != strlen(cmd_list[i].cmd_name)){
09F6A:  MOVF   x07,W
09F6C:  MULLW  04
09F6E:  MOVF   FF3,W
09F70:  CLRF   x0A
09F72:  MOVWF  x09
09F74:  MOVLW  6A
09F76:  ADDWF  x09,W
09F78:  MOVWF  FE9
09F7A:  MOVLW  05
09F7C:  ADDWFC x0A,W
09F7E:  MOVWF  FEA
09F80:  MOVFF  FEC,742
09F84:  MOVF   FED,F
09F86:  MOVFF  FEF,741
09F8A:  MOVLB  0
09F8C:  CALL   566E
09F90:  MOVFF  02,03
09F94:  MOVF   01,W
09F96:  BNZ   9F9C
09F98:  MOVF   03,F
09F9A:  BZ    A022
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
09F9C:  MOVLB  7
09F9E:  MOVF   x07,W
09FA0:  MULLW  04
09FA2:  MOVF   FF3,W
09FA4:  CLRF   x0A
09FA6:  MOVWF  x09
09FA8:  MOVLW  6A
09FAA:  ADDWF  x09,W
09FAC:  MOVWF  FE9
09FAE:  MOVLW  05
09FB0:  ADDWFC x0A,W
09FB2:  MOVWF  FEA
09FB4:  MOVFF  FEC,744
09FB8:  MOVF   FED,F
09FBA:  MOVFF  FEF,743
09FBE:  MOVFF  705,742
09FC2:  MOVFF  704,741
09FC6:  MOVLB  0
09FC8:  CALL   5724
09FCC:  MOVF   01,F
09FCE:  BNZ   A01A
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
09FD0:  MOVLB  7
09FD2:  MOVF   x07,W
09FD4:  MULLW  04
09FD6:  MOVF   FF3,W
09FD8:  CLRF   x0A
09FDA:  MOVWF  x09
09FDC:  MOVLW  02
09FDE:  ADDWF  x09,W
09FE0:  MOVWF  01
09FE2:  MOVLW  00
09FE4:  ADDWFC x0A,W
09FE6:  MOVWF  03
09FE8:  MOVF   01,W
09FEA:  ADDLW  6A
09FEC:  MOVWF  01
09FEE:  MOVLW  05
09FF0:  ADDWFC 03,F
09FF2:  MOVFF  01,709
09FF6:  MOVFF  03,70A
09FFA:  MOVFF  03,FEA
09FFE:  MOVFF  01,FE9
0A002:  MOVFF  701,690
0A006:  MOVLB  0
0A008:  CALL   00BC
0A00C:  MOVFF  01,708
....................                return return_code;
0A010:  MOVLB  7
0A012:  MOVFF  708,01
0A016:  BRA    A038
0A018:  MOVLB  0
....................             }
....................             i++;
0A01A:  MOVLB  7
0A01C:  INCF   x07,F
0A01E:  BRA    9F6A
0A020:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0A022:  MOVLW  01
0A024:  MOVWF  01
0A026:  MOVLB  7
0A028:  BRA    A038
....................       } else return 254; // NOT THIS ADDRESS
0A02A:  BRA    A032
0A02C:  MOVLW  FE
0A02E:  MOVWF  01
0A030:  BRA    A038
....................    } else return 255; // NOT THIS DEVICE TYPE
0A032:  BRA    A038
0A034:  MOVLW  FF
0A036:  MOVWF  01
0A038:  MOVLB  0
0A03A:  GOTO   A0DA (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................     while (getNextSERReadIndex())
0A03E:  GOTO   5614
0A042:  MOVF   01,F
0A044:  BTFSC  FD8.2
0A046:  BRA    A166
....................     {
....................         int8 return_code;
....................         //echo_cmd(SRI);
....................         sprintf(retData + strlen(retData), "$%s,", SERcmd[SRI].p[0]);
0A048:  MOVLW  04
0A04A:  MOVLB  7
0A04C:  MOVWF  x42
0A04E:  MOVLW  C1
0A050:  MOVWF  x41
0A052:  MOVLB  0
0A054:  CALL   566E
0A058:  MOVFF  02,03
0A05C:  MOVF   01,W
0A05E:  ADDLW  C1
0A060:  MOVLB  7
0A062:  MOVWF  x00
0A064:  MOVLW  04
0A066:  ADDWFC 02,W
0A068:  MOVWF  x01
0A06A:  CLRF   x42
0A06C:  MOVFF  4BF,741
0A070:  CLRF   x44
0A072:  MOVLW  B5
0A074:  MOVWF  x43
0A076:  MOVLB  0
0A078:  CALL   08BA
0A07C:  MOVFF  02,703
0A080:  MOVFF  01,702
0A084:  MOVLW  06
0A086:  MOVLB  7
0A088:  ADDWF  x02,F
0A08A:  MOVLW  00
0A08C:  ADDWFC x03,F
0A08E:  MOVLW  EB
0A090:  ADDWF  x02,W
0A092:  MOVWF  01
0A094:  MOVLW  01
0A096:  ADDWFC x03,W
0A098:  MOVWF  03
0A09A:  MOVFF  01,704
0A09E:  MOVWF  x05
0A0A0:  MOVFF  701,565
0A0A4:  MOVFF  700,564
0A0A8:  MOVLW  24
0A0AA:  MOVWF  x50
0A0AC:  MOVLB  0
0A0AE:  CALL   56A6
0A0B2:  MOVFF  565,FEA
0A0B6:  MOVFF  564,FE9
0A0BA:  CLRF   FEF
0A0BC:  MOVFF  705,FEA
0A0C0:  MOVFF  704,FE9
0A0C4:  CALL   56C6
0A0C8:  MOVLW  2C
0A0CA:  MOVLB  7
0A0CC:  MOVWF  x50
0A0CE:  MOVLB  0
0A0D0:  CALL   56A6
....................         
....................         return_code = command_parser(SRI);
0A0D4:  MOVFF  4BF,701
0A0D8:  BRA    9EB8
0A0DA:  MOVFF  01,6FB
....................         
....................         sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
0A0DE:  MOVLW  04
0A0E0:  MOVLB  7
0A0E2:  MOVWF  x42
0A0E4:  MOVLW  C1
0A0E6:  MOVWF  x41
0A0E8:  MOVLB  0
0A0EA:  CALL   566E
0A0EE:  MOVF   01,W
0A0F0:  ADDLW  C1
0A0F2:  MOVLB  7
0A0F4:  MOVWF  x00
0A0F6:  MOVLW  04
0A0F8:  ADDWFC 02,W
0A0FA:  MOVWF  x01
0A0FC:  MOVLB  6
0A0FE:  MOVF   xFB,W
0A100:  MULLW  03
0A102:  MOVF   FF3,W
0A104:  MOVLB  7
0A106:  CLRF   x03
0A108:  MOVWF  x02
0A10A:  MOVLW  01
0A10C:  ADDWF  x02,W
0A10E:  MOVWF  01
0A110:  MOVLW  00
0A112:  ADDWFC x03,W
0A114:  MOVWF  03
0A116:  MOVF   01,W
0A118:  ADDLW  5C
0A11A:  MOVWF  FE9
0A11C:  MOVLW  06
0A11E:  ADDWFC 03,W
0A120:  MOVWF  FEA
0A122:  MOVFF  FEC,703
0A126:  MOVF   FED,F
0A128:  MOVFF  FEF,702
0A12C:  MOVFF  701,565
0A130:  MOVFF  700,564
0A134:  MOVFF  565,FEA
0A138:  MOVFF  564,FE9
0A13C:  CLRF   FEF
0A13E:  MOVFF  703,FEA
0A142:  MOVFF  702,FE9
0A146:  MOVLB  0
0A148:  CALL   56C6
....................         #ifdef DEBUG_ON_ICD
....................         serial_out(retData);
....................         #else
....................         icd_out(retData);
0A14C:  MOVLW  04
0A14E:  MOVLB  7
0A150:  MOVWF  x02
0A152:  MOVLW  C1
0A154:  MOVWF  x01
0A156:  MOVLB  0
0A158:  CALL   50D2
....................         #endif
....................         
....................         resetSERcmd(SRI);
0A15C:  MOVFF  4BF,701
0A160:  CALL   0B9E
0A164:  BRA    A03E
....................     }
0A166:  GOTO   A716 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... #define DEBUG_ON_ICD
.................... 
.................... void main()
*
0A2B8:  CLRF   FF8
0A2BA:  BCF    FF2.5
0A2BC:  BSF    07.7
0A2BE:  MOVLB  E
0A2C0:  MOVLW  55
0A2C2:  MOVWF  x9B
0A2C4:  MOVLW  AA
0A2C6:  MOVWF  x9B
0A2C8:  BCF    x9B.0
0A2CA:  MOVLW  17
0A2CC:  MOVWF  xB0
0A2CE:  MOVLW  13
0A2D0:  MOVWF  xB2
0A2D2:  MOVLW  09
0A2D4:  MOVWF  x8A
0A2D6:  MOVLW  0A
0A2D8:  MOVWF  x8B
0A2DA:  MOVLW  11
0A2DC:  MOVWF  xEB
0A2DE:  MOVLW  12
0A2E0:  MOVWF  xED
0A2E2:  MOVLW  10
0A2E4:  MOVWF  xF4
0A2E6:  MOVLW  0F
0A2E8:  MOVWF  xF5
0A2EA:  MOVLW  09
0A2EC:  MOVWF  xF8
0A2EE:  MOVLW  55
0A2F0:  MOVWF  x9B
0A2F2:  MOVLW  AA
0A2F4:  MOVWF  x9B
0A2F6:  BSF    x9B.0
0A2F8:  CLRF   xD8
0A2FA:  CLRF   xD5
0A2FC:  CLRF   xD7
0A2FE:  MOVLW  08
0A300:  MOVWF  xD9
0A302:  MOVLW  60
0A304:  MOVWF  xD3
0A306:  MOVLW  AA
0A308:  MOVLB  0
0A30A:  MOVWF  xFA
0A30C:  MOVLB  1
0A30E:  BCF    x63.0
0A310:  CLRF   x75
0A312:  CLRF   x74
0A314:  CLRF   x73
0A316:  CLRF   x72
0A318:  CLRF   x79
0A31A:  CLRF   x78
0A31C:  CLRF   x77
0A31E:  CLRF   x76
0A320:  CLRF   x7D
0A322:  CLRF   x7C
0A324:  CLRF   x7B
0A326:  CLRF   x7A
0A328:  CLRF   x7F
0A32A:  CLRF   x7E
0A32C:  MOVLB  E
0A32E:  BCF    x91.5
0A330:  MOVLW  00
0A332:  MOVWF  x90
0A334:  MOVLW  03
0A336:  MOVWF  x8E
0A338:  MOVLW  2A
0A33A:  MOVWF  x91
0A33C:  MOVLW  04
0A33E:  MOVWF  F88
0A340:  MOVWF  F88
0A342:  MOVWF  F88
0A344:  MOVLB  1
0A346:  CLRF   xD0
0A348:  CLRF   xD1
0A34A:  CLRF   xD2
0A34C:  CLRF   xD3
0A34E:  BCF    F95.5
0A350:  MOVLW  40
0A352:  MOVWF  F94
0A354:  MOVLW  9F
0A356:  MOVWF  F92
0A358:  MOVLW  3A
0A35A:  MOVWF  F95
0A35C:  MOVLW  93
0A35E:  MOVWF  F89
0A360:  MOVWF  F89
0A362:  MOVLB  4
0A364:  CLRF   xBF
0A366:  CLRF   xC0
0A368:  MOVLB  5
0A36A:  CLRF   x61
0A36C:  CLRF   x62
0A36E:  MOVLB  1
0A370:  BCF    x63.1
0A372:  MOVLW  04
0A374:  MOVWF  F88
0A376:  BSF    F83.7
0A378:  MOVLW  12
0A37A:  MOVWF  03
0A37C:  MOVLW  FA
0A37E:  MOVLB  7
0A380:  MOVWF  x01
0A382:  MOVLB  0
0A384:  CALL   03CC
0A388:  DECFSZ 03,F
0A38A:  BRA    A38E
0A38C:  BRA    A392
0A38E:  MOVLB  1
0A390:  BRA    A37C
0A392:  MOVLB  5
0A394:  CLRF   x63
0A396:  BSF    F9E.3
0A398:  MOVLW  7C
0A39A:  MOVWF  F9A
0A39C:  MOVLW  00
0A39E:  MOVWF  F9B
0A3A0:  MOVLW  A6
0A3A2:  MOVWF  F9D
0A3A4:  MOVLW  90
0A3A6:  MOVWF  F9C
0A3A8:  CLRF   x65
0A3AA:  CLRF   x64
0A3AC:  CLRF   x69
0A3AE:  CLRF   x68
0A3B0:  CLRF   x67
0A3B2:  CLRF   x66
0A3B4:  MOVLB  F
0A3B6:  CLRF   x0C
0A3B8:  CLRF   x14
0A3BA:  CLRF   x1C
0A3BC:  CLRF   x21
0A3BE:  CLRF   x29
0A3C0:  CLRF   x35
0A3C2:  CLRF   x36
0A3C4:  CLRF   x37
0A3C6:  CLRF   x34
0A3C8:  CLRF   x31
0A3CA:  CLRF   x32
0A3CC:  CLRF   x33
0A3CE:  CLRF   x30
0A3D0:  MOVLW  57
0A3D2:  MOVLB  5
0A3D4:  MOVWF  x6D
0A3D6:  MOVLW  BC
0A3D8:  MOVWF  x6C
0A3DA:  MOVLW  58
0A3DC:  MOVWF  x71
0A3DE:  MOVLW  00
0A3E0:  MOVWF  x70
0A3E2:  MOVLW  5D
0A3E4:  MOVWF  x75
0A3E6:  MOVLW  48
0A3E8:  MOVWF  x74
0A3EA:  MOVLW  5F
0A3EC:  MOVWF  x79
0A3EE:  MOVLW  2E
0A3F0:  MOVWF  x78
0A3F2:  MOVLW  61
0A3F4:  MOVWF  x7D
0A3F6:  MOVLW  06
0A3F8:  MOVWF  x7C
0A3FA:  MOVLW  62
0A3FC:  MOVWF  x81
0A3FE:  MOVLW  92
0A400:  MOVWF  x80
0A402:  MOVLW  67
0A404:  MOVWF  x85
0A406:  MOVLW  32
0A408:  MOVWF  x84
0A40A:  MOVLW  6F
0A40C:  MOVWF  x89
0A40E:  MOVLW  04
0A410:  MOVWF  x88
0A412:  MOVLW  71
0A414:  MOVWF  x8D
0A416:  MOVLW  E4
0A418:  MOVWF  x8C
0A41A:  MOVLW  73
0A41C:  MOVWF  x91
0A41E:  MOVLW  46
0A420:  MOVWF  x90
0A422:  MOVLW  75
0A424:  MOVWF  x95
0A426:  MOVLW  04
0A428:  MOVWF  x94
0A42A:  MOVLW  78
0A42C:  MOVWF  x99
0A42E:  MOVLW  BA
0A430:  MOVWF  x98
0A432:  MOVLW  7E
0A434:  MOVWF  x9D
0A436:  MOVLW  16
0A438:  MOVWF  x9C
0A43A:  MOVLW  81
0A43C:  MOVWF  xA1
0A43E:  MOVLW  AE
0A440:  MOVWF  xA0
0A442:  MOVLW  86
0A444:  MOVWF  xA5
0A446:  MOVLW  DA
0A448:  MOVWF  xA4
0A44A:  MOVLW  86
0A44C:  MOVWF  xA9
0A44E:  MOVLW  E0
0A450:  MOVWF  xA8
0A452:  MOVLW  8D
0A454:  MOVWF  xAD
0A456:  MOVLW  54
0A458:  MOVWF  xAC
0A45A:  MOVLW  92
0A45C:  MOVWF  xB1
0A45E:  MOVLW  B8
0A460:  MOVWF  xB0
0A462:  MOVLW  99
0A464:  MOVWF  xB5
0A466:  MOVLW  DA
0A468:  MOVWF  xB4
0A46A:  MOVLW  9B
0A46C:  MOVWF  xB9
0A46E:  MOVLW  3C
0A470:  MOVWF  xB8
0A472:  MOVLW  9D
0A474:  MOVWF  xBD
0A476:  MOVLW  AE
0A478:  MOVWF  xBC
0A47A:  MOVLW  9D
0A47C:  MOVWF  xC1
0A47E:  MOVLW  BA
0A480:  MOVWF  xC0
0A482:  MOVLW  9D
0A484:  MOVWF  xC5
0A486:  MOVLW  C6
0A488:  MOVWF  xC4
0A48A:  MOVLW  9E
0A48C:  MOVWF  xC9
0A48E:  MOVLW  B2
0A490:  MOVWF  xC8
0A492:  BRA    A672
0A494:  DATA 02,00
0A496:  DATA 1A,00
0A498:  DATA 00,0C
0A49A:  DATA 00,20
0A49C:  DATA 78,23
0A49E:  DATA D7,0A
0A4A0:  DATA 7D,19
0A4A2:  DATA 99,9A
0A4A4:  DATA 7B,4C
0A4A6:  DATA CC,CD
0A4A8:  DATA 1C,C0
0A4AA:  DATA 00,0C
0A4AC:  DATA 80,78
0A4AE:  DATA 23,D7
0A4B0:  DATA 0A,7D
0A4B2:  DATA 19,99
0A4B4:  DATA 9A,7B
0A4B6:  DATA 4C,CC
0A4B8:  DATA CD,1C
0A4BA:  DATA C0,00
0A4BC:  DATA 01,80
0A4BE:  DATA 02,09
0A4C0:  DATA C0,00
0A4C2:  DATA 05,80
0A4C4:  DATA 7F,00
0A4C6:  DATA 00,00
0A4C8:  DATA 7F,0B
0A4CA:  DATA C0,00
0A4CC:  DATA 05,80
0A4CE:  DATA 7F,00
0A4D0:  DATA 00,00
0A4D2:  DATA 7F,07
0A4D4:  DATA C0,00
0A4D6:  DATA 01,80
0A4D8:  DATA 7F,17
0A4DA:  DATA C0,00
0A4DC:  DATA 01,80
0A4DE:  DATA 7F,17
0A4E0:  DATA C0,00
0A4E2:  DATA 04,80
0A4E4:  DATA 79,B7
0A4E6:  DATA F3,BD
0A4E8:  DATA 04,C0
0A4EA:  DATA 00,04
0A4EC:  DATA 80,7C
0A4EE:  DATA 59,DF
0A4F0:  DATA 4E,04
0A4F2:  DATA C0,00
0A4F4:  DATA 04,80
0A4F6:  DATA 78,0A
0A4F8:  DATA 28,88
0A4FA:  DATA 04,C0
0A4FC:  DATA 00,04
0A4FE:  DATA 80,78
0A500:  DATA 05,EA
0A502:  DATA 16,04
0A504:  DATA C0,00
0A506:  DATA 04,80
0A508:  DATA 78,1E
0A50A:  DATA 33,D7
0A50C:  DATA 04,C0
0A50E:  DATA 00,04
0A510:  DATA 80,77
0A512:  DATA 68,7B
0A514:  DATA BB,04
0A516:  DATA C0,00
0A518:  DATA 04,80
0A51A:  DATA 77,68
0A51C:  DATA 0D,C6
0A51E:  DATA 68,40
0A520:  DATA FB,00
0A522:  DATA 0E,41
0A524:  DATA 64,00
0A526:  DATA 17,41
0A528:  DATA D4,00
0A52A:  DATA 3C,45
0A52C:  DATA 25,00
0A52E:  DATA 02,05
0A530:  DATA 6A,CA
0A532:  DATA 05,02
0A534:  DATA 05,6E
0A536:  DATA CD,05
0A538:  DATA 02,05
0A53A:  DATA 72,D0
0A53C:  DATA 05,02
0A53E:  DATA 05,76
0A540:  DATA D7,05
0A542:  DATA 02,05
0A544:  DATA 7A,DE
0A546:  DATA 05,02
0A548:  DATA 05,7E
0A54A:  DATA E6,05
0A54C:  DATA 02,05
0A54E:  DATA 82,EE
0A550:  DATA 05,02
0A552:  DATA 05,86
0A554:  DATA F3,05
0A556:  DATA 02,05
0A558:  DATA 8A,F8
0A55A:  DATA 05,02
0A55C:  DATA 05,8E
0A55E:  DATA FC,05
0A560:  DATA 02,05
0A562:  DATA 92,00
0A564:  DATA 06,02
0A566:  DATA 05,96
0A568:  DATA 07,06
0A56A:  DATA 02,05
0A56C:  DATA 9A,0D
0A56E:  DATA 06,02
0A570:  DATA 05,9E
0A572:  DATA 13,06
0A574:  DATA 02,05
0A576:  DATA A2,19
0A578:  DATA 06,02
0A57A:  DATA 05,A6
0A57C:  DATA 1F,06
0A57E:  DATA 02,05
0A580:  DATA AA,24
0A582:  DATA 06,02
0A584:  DATA 05,AE
0A586:  DATA 2D,06
0A588:  DATA 02,05
0A58A:  DATA B2,35
0A58C:  DATA 06,02
0A58E:  DATA 05,B6
0A590:  DATA 3C,06
0A592:  DATA 02,05
0A594:  DATA BA,43
0A596:  DATA 06,02
0A598:  DATA 05,BE
0A59A:  DATA 4B,06
0A59C:  DATA 02,05
0A59E:  DATA C2,54
0A5A0:  DATA 06,02
0A5A2:  DATA 05,C6
0A5A4:  DATA 5A,06
0A5A6:  DATA 8F,05
0A5A8:  DATA CA,67
0A5AA:  DATA 72,00
0A5AC:  DATA 67,73
0A5AE:  DATA 00,67
0A5B0:  DATA 43,68
0A5B2:  DATA 4D,61
0A5B4:  DATA 70,00
0A5B6:  DATA 73,43
0A5B8:  DATA 68,4D
0A5BA:  DATA 61,70
0A5BC:  DATA 00,67
0A5BE:  DATA 43,68
0A5C0:  DATA 4D,6F
0A5C2:  DATA 64,65
0A5C4:  DATA 00,73
0A5C6:  DATA 43,68
0A5C8:  DATA 4D,6F
0A5CA:  DATA 64,65
0A5CC:  DATA 00,67
0A5CE:  DATA 50,49
0A5D0:  DATA 44,00
0A5D2:  DATA 73,50
0A5D4:  DATA 49,44
0A5D6:  DATA 00,67
0A5D8:  DATA 53,50
0A5DA:  DATA 00,73
0A5DC:  DATA 53,50
0A5DE:  DATA 00,67
0A5E0:  DATA 53,43
0A5E2:  DATA 61,6C
0A5E4:  DATA 73,00
0A5E6:  DATA 67,53
0A5E8:  DATA 43,61
0A5EA:  DATA 6C,00
0A5EC:  DATA 73,53
0A5EE:  DATA 43,61
0A5F0:  DATA 6C,00
0A5F2:  DATA 67,4D
0A5F4:  DATA 43,61
0A5F6:  DATA 6C,00
0A5F8:  DATA 73,4D
0A5FA:  DATA 43,61
0A5FC:  DATA 6C,00
0A5FE:  DATA 67,4D
0A600:  DATA 6F,6E
0A602:  DATA 00,67
0A604:  DATA 50,49
0A606:  DATA 44,64
0A608:  DATA 61,74
0A60A:  DATA 61,00
0A60C:  DATA 67,49
0A60E:  DATA 50,64
0A610:  DATA 61,74
0A612:  DATA 61,00
0A614:  DATA 67,4D
0A616:  DATA 61,6E
0A618:  DATA 4F,50
0A61A:  DATA 00,73
0A61C:  DATA 4D,61
0A61E:  DATA 6E,4F
0A620:  DATA 50,00
0A622:  DATA 73,46
0A624:  DATA 69,6C
0A626:  DATA 74,4F
0A628:  DATA 6E,00
0A62A:  DATA 73,46
0A62C:  DATA 69,6C
0A62E:  DATA 74,4F
0A630:  DATA 66,66
0A632:  DATA 00,73
0A634:  DATA 48,6F
0A636:  DATA 6D,65
0A638:  DATA 04,C0
0A63A:  DATA 00,33
0A63C:  DATA 80,65
0A63E:  DATA 06,01
0A640:  DATA 6D,06
0A642:  DATA 02,7D
0A644:  DATA 06,53
0A646:  DATA 55,43
0A648:  DATA 43,45
0A64A:  DATA 53,53
0A64C:  DATA 00,49
0A64E:  DATA 4E,56
0A650:  DATA 41,4C
0A652:  DATA 49,44
0A654:  DATA 20,43
0A656:  DATA 4F,4D
0A658:  DATA 4D,41
0A65A:  DATA 4E,44
0A65C:  DATA 00,49
0A65E:  DATA 4E,56
0A660:  DATA 41,4C
0A662:  DATA 49,44
0A664:  DATA 20,50
0A666:  DATA 41,52
0A668:  DATA 41,4D
0A66A:  DATA 45,54
0A66C:  DATA 45,52
0A66E:  DATA 00,00
0A670:  DATA 00,00
0A672:  MOVLW  00
0A674:  MOVWF  FF8
0A676:  MOVLW  A4
0A678:  MOVWF  FF7
0A67A:  MOVLW  94
0A67C:  MOVWF  FF6
0A67E:  TBLRD*+
0A680:  MOVF   FF5,W
0A682:  MOVWF  00
0A684:  XORLW  00
0A686:  BZ    A6AE
0A688:  TBLRD*+
0A68A:  MOVF   FF5,W
0A68C:  MOVWF  01
0A68E:  BTFSC  FE8.7
0A690:  BRA    A69C
0A692:  ANDLW  3F
0A694:  MOVWF  FEA
0A696:  TBLRD*+
0A698:  MOVFF  FF5,FE9
0A69C:  BTFSC  01.6
0A69E:  TBLRD*+
0A6A0:  BTFSS  01.6
0A6A2:  TBLRD*+
0A6A4:  MOVFF  FF5,FEE
0A6A8:  DCFSNZ 00,F
0A6AA:  BRA    A67E
0A6AC:  BRA    A6A0
0A6AE:  CLRF   FF8
0A6B0:  MOVLW  03
0A6B2:  MOVLB  6
0A6B4:  MOVWF  x92
0A6B6:  MOVLW  E8
0A6B8:  MOVWF  x91
0A6BA:  CLRF   x94
0A6BC:  CLRF   x93
0A6BE:  CLRF   x96
0A6C0:  CLRF   x95
.................... {
....................     int16 loopDelay = 1000;
....................     int16 controlCounter = 0;
....................     int16 debugCounter = 0;
....................    
....................     char pBuff[100];
....................     
....................     IO_init();                    // set up IO 
0A6C2:  MOVLB  0
0A6C4:  GOTO   03F6
....................     params_init();                // load parameters
0A6C8:  GOTO   0692
....................     monitor_init();               // initialize internal ADC for voltage and current telemetry
0A6CC:  GOTO   0AE0
....................     control_init();               // initialize the output control DACs
0A6D0:  GOTO   0B78
....................     serial_init();                // setup the serial port
0A6D4:  GOTO   0D18
....................     event_timer_init();
0A6D8:  GOTO   0D3A
.................... //!    setup_wdt(WDT_512MS);
....................     enable_interrupts(GLOBAL);
0A6DC:  MOVLW  C0
0A6DE:  IORWF  FF2,F
....................     
....................     while(TRUE)
....................     {
.................... //!        restart_wdt();
....................         pBuff[0] = '\0';
0A6E0:  MOVLB  6
0A6E2:  CLRF   x97
....................         
.................... //!        if (adcVals[chX].homeFlag) home_axis(chX);
.................... //!        if (adcVals[chY].homeFlag) home_axis(chY);
....................                 
....................         internal_monitor_task();   //Update monitored voltage and currents etc
0A6E4:  MOVLB  0
0A6E6:  GOTO   1112
....................         sensor_monitor_task();     //get magnetoresistive sensor data
0A6EA:  GOTO   4462
....................       
....................         if (controlCounter >= 2){
0A6EE:  MOVLB  6
0A6F0:  MOVF   x94,F
0A6F2:  BNZ   A6FA
0A6F4:  MOVF   x93,W
0A6F6:  SUBLW  01
0A6F8:  BC    A708
....................             control_task();
0A6FA:  MOVLB  0
0A6FC:  GOTO   4FDA
....................             controlCounter = 0;
0A700:  MOVLB  6
0A702:  CLRF   x94
0A704:  CLRF   x93
....................         }else controlCounter++;
0A706:  BRA    A70E
0A708:  INCF   x93,F
0A70A:  BTFSC  FD8.2
0A70C:  INCF   x94,F
....................       
....................         serial_task();             
0A70E:  MOVLB  0
0A710:  GOTO   50E8
....................         command_handler_task();    //execute commands
0A714:  BRA    A03E
....................         
....................         #ifdef DEBUG_1
....................         if (debugCounter >= 0){
....................             static int8 ch = 0;
....................             sprintf(pBuff+strlen(pBuff), "CNT,%u,%.0f,%.0f;", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
0A716:  MOVLW  06
0A718:  MOVLB  7
0A71A:  MOVWF  x42
0A71C:  MOVLW  97
0A71E:  MOVWF  x41
0A720:  MOVLB  0
0A722:  CALL   566E
0A726:  MOVF   01,W
0A728:  ADDLW  97
0A72A:  MOVLB  6
0A72C:  MOVWF  xFB
0A72E:  MOVLW  06
0A730:  ADDWFC 02,W
0A732:  MOVWF  xFC
0A734:  MOVLW  01
0A736:  ADDWF  x8F,W
0A738:  MOVWF  xFD
0A73A:  MOVF   x8F,W
0A73C:  MULLW  26
0A73E:  MOVF   FF3,W
0A740:  CLRF   xFF
0A742:  MOVWF  xFE
0A744:  MOVLW  08
0A746:  ADDWF  xFE,W
0A748:  MOVWF  01
0A74A:  MOVLW  00
0A74C:  ADDWFC xFF,W
0A74E:  MOVWF  03
0A750:  MOVF   01,W
0A752:  ADDLW  17
0A754:  MOVWF  FE9
0A756:  MOVLW  01
0A758:  ADDWFC 03,W
0A75A:  MOVWF  FEA
0A75C:  MOVFF  FEF,6FE
0A760:  MOVFF  FEC,6FF
0A764:  MOVFF  FEC,700
0A768:  MOVFF  FEC,701
0A76C:  MOVF   x8F,W
0A76E:  MULLW  26
0A770:  MOVF   FF3,W
0A772:  MOVLB  7
0A774:  CLRF   x03
0A776:  MOVWF  x02
0A778:  MOVLW  0C
0A77A:  ADDWF  x02,W
0A77C:  MOVWF  01
0A77E:  MOVLW  00
0A780:  ADDWFC x03,W
0A782:  MOVWF  03
0A784:  MOVF   01,W
0A786:  ADDLW  17
0A788:  MOVWF  FE9
0A78A:  MOVLW  01
0A78C:  ADDWFC 03,W
0A78E:  MOVWF  FEA
0A790:  MOVFF  FEF,702
0A794:  MOVFF  FEC,703
0A798:  MOVFF  FEC,704
0A79C:  MOVFF  FEC,705
0A7A0:  MOVFF  6FC,565
0A7A4:  MOVFF  6FB,564
0A7A8:  MOVLW  90
0A7AA:  MOVWF  FF6
0A7AC:  MOVLW  03
0A7AE:  MOVWF  FF7
0A7B0:  MOVLW  04
0A7B2:  MOVWF  x0F
0A7B4:  MOVLB  0
0A7B6:  CALL   60DC
0A7BA:  MOVFF  6FD,706
0A7BE:  MOVLW  1B
0A7C0:  MOVLB  7
0A7C2:  MOVWF  x07
0A7C4:  MOVLB  0
0A7C6:  RCALL  A16A
0A7C8:  MOVLW  2C
0A7CA:  MOVLB  7
0A7CC:  MOVWF  x50
0A7CE:  MOVLB  0
0A7D0:  CALL   56A6
0A7D4:  MOVLW  89
0A7D6:  MOVWF  FE9
0A7D8:  MOVFF  701,746
0A7DC:  MOVFF  700,745
0A7E0:  MOVFF  6FF,744
0A7E4:  MOVFF  6FE,743
0A7E8:  MOVLB  7
0A7EA:  CLRF   x47
0A7EC:  MOVLB  0
0A7EE:  CALL   6582
0A7F2:  MOVLW  2C
0A7F4:  MOVLB  7
0A7F6:  MOVWF  x50
0A7F8:  MOVLB  0
0A7FA:  CALL   56A6
0A7FE:  MOVLW  89
0A800:  MOVWF  FE9
0A802:  MOVFF  705,746
0A806:  MOVFF  704,745
0A80A:  MOVFF  703,744
0A80E:  MOVFF  702,743
0A812:  MOVLB  7
0A814:  CLRF   x47
0A816:  MOVLB  0
0A818:  CALL   6582
0A81C:  MOVLW  3B
0A81E:  MOVLB  7
0A820:  MOVWF  x50
0A822:  MOVLB  0
0A824:  CALL   56A6
....................             sprintf(pBuff+strlen(pBuff), "POS,%u,%3.3f;", ch+1, adcVals[ch].pReal);
0A828:  MOVLW  06
0A82A:  MOVLB  7
0A82C:  MOVWF  x42
0A82E:  MOVLW  97
0A830:  MOVWF  x41
0A832:  MOVLB  0
0A834:  CALL   566E
0A838:  MOVF   01,W
0A83A:  ADDLW  97
0A83C:  MOVLB  6
0A83E:  MOVWF  xFB
0A840:  MOVLW  06
0A842:  ADDWFC 02,W
0A844:  MOVWF  xFC
0A846:  MOVLW  01
0A848:  ADDWF  x8F,W
0A84A:  MOVWF  xFD
0A84C:  MOVF   x8F,W
0A84E:  MULLW  26
0A850:  MOVF   FF3,W
0A852:  CLRF   xFF
0A854:  MOVWF  xFE
0A856:  MOVLW  1D
0A858:  ADDWF  xFE,W
0A85A:  MOVWF  01
0A85C:  MOVLW  00
0A85E:  ADDWFC xFF,W
0A860:  MOVWF  03
0A862:  MOVF   01,W
0A864:  ADDLW  17
0A866:  MOVWF  FE9
0A868:  MOVLW  01
0A86A:  ADDWFC 03,W
0A86C:  MOVWF  FEA
0A86E:  MOVFF  FEF,6FE
0A872:  MOVFF  FEC,6FF
0A876:  MOVFF  FEC,700
0A87A:  MOVFF  FEC,701
0A87E:  MOVFF  6FC,565
0A882:  MOVFF  6FB,564
0A886:  MOVLW  A2
0A888:  MOVWF  FF6
0A88A:  MOVLW  03
0A88C:  MOVWF  FF7
0A88E:  MOVLW  04
0A890:  MOVLB  7
0A892:  MOVWF  x0F
0A894:  MOVLB  0
0A896:  CALL   60DC
0A89A:  MOVFF  6FD,706
0A89E:  MOVLW  1B
0A8A0:  MOVLB  7
0A8A2:  MOVWF  x07
0A8A4:  MOVLB  0
0A8A6:  RCALL  A16A
0A8A8:  MOVLW  2C
0A8AA:  MOVLB  7
0A8AC:  MOVWF  x50
0A8AE:  MOVLB  0
0A8B0:  CALL   56A6
0A8B4:  MOVLW  89
0A8B6:  MOVWF  FE9
0A8B8:  MOVFF  701,746
0A8BC:  MOVFF  700,745
0A8C0:  MOVFF  6FF,744
0A8C4:  MOVFF  6FE,743
0A8C8:  MOVLW  03
0A8CA:  MOVLB  7
0A8CC:  MOVWF  x47
0A8CE:  MOVLB  0
0A8D0:  CALL   6582
0A8D4:  MOVLW  3B
0A8D6:  MOVLB  7
0A8D8:  MOVWF  x50
0A8DA:  MOVLB  0
0A8DC:  CALL   56A6
....................             if ( dacVals[ch].invV ) sprintf(pBuff+strlen(pBuff), "OUT,%u,-,%Lu;", ch+1, dacVals[ch].ipVal);
0A8E0:  MOVLB  6
0A8E2:  MOVF   x8F,W
0A8E4:  MULLW  07
0A8E6:  MOVF   FF3,W
0A8E8:  CLRF   xFC
0A8EA:  MOVWF  xFB
0A8EC:  MOVLW  64
0A8EE:  ADDWF  xFB,W
0A8F0:  MOVWF  FE9
0A8F2:  MOVLW  01
0A8F4:  ADDWFC xFC,W
0A8F6:  MOVWF  FEA
0A8F8:  BTFSS  FEF.0
0A8FA:  BRA    A9A8
0A8FC:  MOVLW  06
0A8FE:  MOVLB  7
0A900:  MOVWF  x42
0A902:  MOVLW  97
0A904:  MOVWF  x41
0A906:  MOVLB  0
0A908:  CALL   566E
0A90C:  MOVF   01,W
0A90E:  ADDLW  97
0A910:  MOVLB  6
0A912:  MOVWF  xFB
0A914:  MOVLW  06
0A916:  ADDWFC 02,W
0A918:  MOVWF  xFC
0A91A:  MOVLW  01
0A91C:  ADDWF  x8F,W
0A91E:  MOVWF  xFD
0A920:  MOVF   x8F,W
0A922:  MULLW  07
0A924:  MOVF   FF3,W
0A926:  CLRF   xFF
0A928:  MOVWF  xFE
0A92A:  MOVLW  01
0A92C:  ADDWF  xFE,W
0A92E:  MOVWF  01
0A930:  MOVLW  00
0A932:  ADDWFC xFF,W
0A934:  MOVWF  03
0A936:  MOVF   01,W
0A938:  ADDLW  64
0A93A:  MOVWF  FE9
0A93C:  MOVLW  01
0A93E:  ADDWFC 03,W
0A940:  MOVWF  FEA
0A942:  MOVFF  FEC,6FF
0A946:  MOVF   FED,F
0A948:  MOVFF  FEF,6FE
0A94C:  MOVFF  6FC,565
0A950:  MOVFF  6FB,564
0A954:  MOVLW  B0
0A956:  MOVWF  FF6
0A958:  MOVLW  03
0A95A:  MOVWF  FF7
0A95C:  MOVLW  04
0A95E:  MOVLB  7
0A960:  MOVWF  x0F
0A962:  MOVLB  0
0A964:  CALL   60DC
0A968:  MOVFF  6FD,706
0A96C:  MOVLW  1B
0A96E:  MOVLB  7
0A970:  MOVWF  x07
0A972:  MOVLB  0
0A974:  CALL   A16A
0A978:  MOVLW  B6
0A97A:  MOVWF  FF6
0A97C:  MOVLW  03
0A97E:  MOVWF  FF7
0A980:  MOVLW  03
0A982:  MOVLB  7
0A984:  MOVWF  x0F
0A986:  MOVLB  0
0A988:  CALL   60DC
0A98C:  MOVLW  10
0A98E:  MOVWF  FE9
0A990:  MOVFF  6FF,701
0A994:  MOVFF  6FE,700
0A998:  RCALL  A1F0
0A99A:  MOVLW  3B
0A99C:  MOVLB  7
0A99E:  MOVWF  x50
0A9A0:  MOVLB  0
0A9A2:  CALL   56A6
0A9A6:  BRA    AA54
....................             else                    sprintf(pBuff+strlen(pBuff), "OUT,%u,+,%Lu;", ch+1, dacVals[ch].ipVal);
0A9A8:  MOVLW  06
0A9AA:  MOVLB  7
0A9AC:  MOVWF  x42
0A9AE:  MOVLW  97
0A9B0:  MOVWF  x41
0A9B2:  MOVLB  0
0A9B4:  CALL   566E
0A9B8:  MOVF   01,W
0A9BA:  ADDLW  97
0A9BC:  MOVLB  6
0A9BE:  MOVWF  xFB
0A9C0:  MOVLW  06
0A9C2:  ADDWFC 02,W
0A9C4:  MOVWF  xFC
0A9C6:  MOVLW  01
0A9C8:  ADDWF  x8F,W
0A9CA:  MOVWF  xFD
0A9CC:  MOVF   x8F,W
0A9CE:  MULLW  07
0A9D0:  MOVF   FF3,W
0A9D2:  CLRF   xFF
0A9D4:  MOVWF  xFE
0A9D6:  MOVLW  01
0A9D8:  ADDWF  xFE,W
0A9DA:  MOVWF  01
0A9DC:  MOVLW  00
0A9DE:  ADDWFC xFF,W
0A9E0:  MOVWF  03
0A9E2:  MOVF   01,W
0A9E4:  ADDLW  64
0A9E6:  MOVWF  FE9
0A9E8:  MOVLW  01
0A9EA:  ADDWFC 03,W
0A9EC:  MOVWF  FEA
0A9EE:  MOVFF  FEC,6FF
0A9F2:  MOVF   FED,F
0A9F4:  MOVFF  FEF,6FE
0A9F8:  MOVFF  6FC,565
0A9FC:  MOVFF  6FB,564
0AA00:  MOVLW  BE
0AA02:  MOVWF  FF6
0AA04:  MOVLW  03
0AA06:  MOVWF  FF7
0AA08:  MOVLW  04
0AA0A:  MOVLB  7
0AA0C:  MOVWF  x0F
0AA0E:  MOVLB  0
0AA10:  CALL   60DC
0AA14:  MOVFF  6FD,706
0AA18:  MOVLW  1B
0AA1A:  MOVLB  7
0AA1C:  MOVWF  x07
0AA1E:  MOVLB  0
0AA20:  CALL   A16A
0AA24:  MOVLW  C4
0AA26:  MOVWF  FF6
0AA28:  MOVLW  03
0AA2A:  MOVWF  FF7
0AA2C:  MOVLW  03
0AA2E:  MOVLB  7
0AA30:  MOVWF  x0F
0AA32:  MOVLB  0
0AA34:  CALL   60DC
0AA38:  MOVLW  10
0AA3A:  MOVWF  FE9
0AA3C:  MOVFF  6FF,701
0AA40:  MOVFF  6FE,700
0AA44:  CALL   A1F0
0AA48:  MOVLW  3B
0AA4A:  MOVLB  7
0AA4C:  MOVWF  x50
0AA4E:  MOVLB  0
0AA50:  CALL   56A6
....................             ch = !ch;
0AA54:  MOVLB  6
0AA56:  MOVF   x8F,F
0AA58:  BTFSC  FD8.2
0AA5A:  BRA    AA60
0AA5C:  MOVLW  00
0AA5E:  BRA    AA62
0AA60:  MOVLW  01
0AA62:  MOVWF  x8F
....................             debugCounter = 0;
0AA64:  CLRF   x96
0AA66:  CLRF   x95
....................         }else debugCounter++;
....................         #ifdef DEBUG_ON_ICD
....................         icd_out(pBuff);
0AA68:  MOVLW  06
0AA6A:  MOVLB  7
0AA6C:  MOVWF  x02
0AA6E:  MOVLW  97
0AA70:  MOVWF  x01
0AA72:  MOVLB  0
0AA74:  CALL   50D2
....................         #else
....................         serial_out(pBuff);
....................         #endif
....................         #endif
....................       
....................         delay_ms(loopDelay);
0AA78:  MOVFF  692,6FB
0AA7C:  MOVLB  6
0AA7E:  INCF   xFB,F
0AA80:  DECF   xFB,F
0AA82:  BTFSC  FD8.2
0AA84:  BRA    AA94
0AA86:  MOVLB  7
0AA88:  SETF   x01
0AA8A:  MOVLB  0
0AA8C:  CALL   03CC
0AA90:  MOVLB  6
0AA92:  BRA    AA80
0AA94:  MOVFF  691,701
0AA98:  MOVLB  0
0AA9A:  CALL   03CC
0AA9E:  BRA    A6E0
....................     }
.................... }
0AAA0:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
