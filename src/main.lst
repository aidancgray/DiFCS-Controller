CCS PCH C Compiler, Version 5.117, 2138               19-Nov-25 20:15

               Filename:   C:\Users\Aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   41270 bytes (63%)
                           Largest free fragment is 24264
               RAM used:   1529 (42%) at main() level
                           1640 (45%) worst case
               Stack used: 6 locations (4 in main + 2 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   9ABC
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   0246
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
0031A:  DATA 32,30
0031C:  DATA 32,35
0031E:  DATA 31,31
00320:  DATA 30,34
00322:  DATA 00,00
00324:  DATA 30,30
00326:  DATA 30,30
00328:  DATA 00,00
0032A:  DATA 25,64
0032C:  DATA 2C,4D
0032E:  DATA 41,4E
00330:  DATA 55,41
00332:  DATA 4C,2C
00334:  DATA 00,00
00336:  DATA 25,64
00338:  DATA 2C,4D
0033A:  DATA 41,47
0033C:  DATA 53,4E
0033E:  DATA 53,2C
00340:  DATA 00,00
00342:  DATA 23,44
00344:  DATA 30,2C
00346:  DATA 43,4E
00348:  DATA 54,2C
0034A:  DATA 25,75
0034C:  DATA 2C,25
0034E:  DATA 2E,30
00350:  DATA 66,2C
00352:  DATA 25,2E
00354:  DATA 30,66
00356:  DATA 0A,00
00358:  DATA 23,44
0035A:  DATA 30,2C
0035C:  DATA 50,4F
0035E:  DATA 53,2C
00360:  DATA 25,75
00362:  DATA 2C,25
00364:  DATA 33,2E
00366:  DATA 33,66
00368:  DATA 0A,00
0036A:  DATA 23,44
0036C:  DATA 30,2C
0036E:  DATA 4F,55
00370:  DATA 54,2C
00372:  DATA 25,75
00374:  DATA 2C,2D
00376:  DATA 2C,25
00378:  DATA 4C,75
0037A:  DATA 0A,00
0037C:  DATA 23,44
0037E:  DATA 30,2C
00380:  DATA 4F,55
00382:  DATA 54,2C
00384:  DATA 25,75
00386:  DATA 2C,2B
00388:  DATA 2C,25
0038A:  DATA 4C,75
0038C:  DATA 0A,00
*
006B4:  ADDWF  FE8,W
006B6:  CLRF   FF7
006B8:  RLCF   FF7,F
006BA:  ADDLW  CF
006BC:  MOVWF  FF6
006BE:  MOVLW  06
006C0:  ADDWFC FF7,F
006C2:  TBLRD*-
006C4:  MOVF   FF5,W
006C6:  MOVWF  FFA
006C8:  TBLRD*
006CA:  MOVF   FF5,W
006CC:  MOVWF  FF9
006CE:  DATA 7E,06
006D0:  DATA 88,06
006D2:  DATA 92,06
006D4:  DATA 9C,06
*
008AC:  MOVLB  6
008AE:  MOVF   x31,W
008B0:  MULWF  x33
008B2:  MOVFF  FF3,01
008B6:  MOVFF  FF4,00
008BA:  MULWF  x34
008BC:  MOVF   FF3,W
008BE:  ADDWF  00,F
008C0:  MOVF   x32,W
008C2:  MULWF  x33
008C4:  MOVF   FF3,W
008C6:  ADDWFC 00,W
008C8:  MOVWF  02
008CA:  MOVLB  0
008CC:  RETURN 0
*
00AB4:  MOVLW  8E
00AB6:  MOVWF  00
00AB8:  MOVFF  650,01
00ABC:  MOVFF  64F,02
00AC0:  CLRF   03
00AC2:  MOVF   01,F
00AC4:  BNZ   0AD8
00AC6:  MOVFF  02,01
00ACA:  CLRF   02
00ACC:  MOVLW  08
00ACE:  SUBWF  00,F
00AD0:  MOVF   01,F
00AD2:  BNZ   0AD8
00AD4:  CLRF   00
00AD6:  BRA    0AE8
00AD8:  BCF    FD8.0
00ADA:  BTFSC  01.7
00ADC:  BRA    0AE6
00ADE:  RLCF   02,F
00AE0:  RLCF   01,F
00AE2:  DECF   00,F
00AE4:  BRA    0AD8
00AE6:  BCF    01.7
00AE8:  RETURN 0
00AEA:  MOVLB  6
00AEC:  MOVF   x4B,W
00AEE:  BTFSC  FD8.2
00AF0:  BRA    0BD4
00AF2:  MOVWF  00
00AF4:  MOVF   x4F,W
00AF6:  BTFSC  FD8.2
00AF8:  BRA    0BD4
00AFA:  ADDWF  00,F
00AFC:  BNC   0B06
00AFE:  MOVLW  81
00B00:  ADDWF  00,F
00B02:  BC    0BD4
00B04:  BRA    0B0E
00B06:  MOVLW  7F
00B08:  SUBWF  00,F
00B0A:  BNC   0BD4
00B0C:  BZ    0BD4
00B0E:  MOVFF  64C,653
00B12:  MOVF   x50,W
00B14:  XORWF  x53,F
00B16:  BSF    x4C.7
00B18:  BSF    x50.7
00B1A:  MOVF   x4E,W
00B1C:  MULWF  x52
00B1E:  MOVFF  FF4,655
00B22:  MOVF   x4D,W
00B24:  MULWF  x51
00B26:  MOVFF  FF4,03
00B2A:  MOVFF  FF3,654
00B2E:  MULWF  x52
00B30:  MOVF   FF3,W
00B32:  ADDWF  x55,F
00B34:  MOVF   FF4,W
00B36:  ADDWFC x54,F
00B38:  MOVLW  00
00B3A:  ADDWFC 03,F
00B3C:  MOVF   x4E,W
00B3E:  MULWF  x51
00B40:  MOVF   FF3,W
00B42:  ADDWF  x55,F
00B44:  MOVF   FF4,W
00B46:  ADDWFC x54,F
00B48:  MOVLW  00
00B4A:  CLRF   02
00B4C:  ADDWFC 03,F
00B4E:  ADDWFC 02,F
00B50:  MOVF   x4C,W
00B52:  MULWF  x52
00B54:  MOVF   FF3,W
00B56:  ADDWF  x54,F
00B58:  MOVF   FF4,W
00B5A:  ADDWFC 03,F
00B5C:  MOVLW  00
00B5E:  ADDWFC 02,F
00B60:  MOVF   x4C,W
00B62:  MULWF  x51
00B64:  MOVF   FF3,W
00B66:  ADDWF  03,F
00B68:  MOVF   FF4,W
00B6A:  ADDWFC 02,F
00B6C:  MOVLW  00
00B6E:  CLRF   01
00B70:  ADDWFC 01,F
00B72:  MOVF   x4E,W
00B74:  MULWF  x50
00B76:  MOVF   FF3,W
00B78:  ADDWF  x54,F
00B7A:  MOVF   FF4,W
00B7C:  ADDWFC 03,F
00B7E:  MOVLW  00
00B80:  ADDWFC 02,F
00B82:  ADDWFC 01,F
00B84:  MOVF   x4D,W
00B86:  MULWF  x50
00B88:  MOVF   FF3,W
00B8A:  ADDWF  03,F
00B8C:  MOVF   FF4,W
00B8E:  ADDWFC 02,F
00B90:  MOVLW  00
00B92:  ADDWFC 01,F
00B94:  MOVF   x4C,W
00B96:  MULWF  x50
00B98:  MOVF   FF3,W
00B9A:  ADDWF  02,F
00B9C:  MOVF   FF4,W
00B9E:  ADDWFC 01,F
00BA0:  INCF   00,F
00BA2:  BTFSC  01.7
00BA4:  BRA    0BB0
00BA6:  RLCF   x54,F
00BA8:  RLCF   03,F
00BAA:  RLCF   02,F
00BAC:  RLCF   01,F
00BAE:  DECF   00,F
00BB0:  MOVLW  00
00BB2:  BTFSS  x54.7
00BB4:  BRA    0BCA
00BB6:  INCF   03,F
00BB8:  ADDWFC 02,F
00BBA:  ADDWFC 01,F
00BBC:  MOVF   01,W
00BBE:  BNZ   0BCA
00BC0:  MOVF   02,W
00BC2:  BNZ   0BCA
00BC4:  MOVF   03,W
00BC6:  BNZ   0BCA
00BC8:  INCF   00,F
00BCA:  BTFSC  x53.7
00BCC:  BSF    01.7
00BCE:  BTFSS  x53.7
00BD0:  BCF    01.7
00BD2:  BRA    0BDC
00BD4:  CLRF   00
00BD6:  CLRF   01
00BD8:  CLRF   02
00BDA:  CLRF   03
00BDC:  MOVLB  0
00BDE:  RETURN 0
00BE0:  MOVLW  80
00BE2:  BTFSS  FD8.1
00BE4:  BRA    0BEA
00BE6:  MOVLB  6
00BE8:  XORWF  x54,F
00BEA:  MOVLB  6
00BEC:  CLRF   x59
00BEE:  CLRF   x5A
00BF0:  MOVFF  650,658
00BF4:  MOVF   x54,W
00BF6:  XORWF  x58,F
00BF8:  MOVF   x4F,W
00BFA:  BTFSC  FD8.2
00BFC:  BRA    0DBC
00BFE:  MOVWF  x57
00C00:  MOVWF  00
00C02:  MOVF   x53,W
00C04:  BTFSC  FD8.2
00C06:  BRA    0DCE
00C08:  SUBWF  x57,F
00C0A:  BTFSC  FD8.2
00C0C:  BRA    0D14
00C0E:  BNC   0C8C
00C10:  MOVFF  654,65D
00C14:  BSF    x5D.7
00C16:  MOVFF  655,65C
00C1A:  MOVFF  656,65B
00C1E:  CLRF   x5A
00C20:  BCF    FD8.0
00C22:  RRCF   x5D,F
00C24:  RRCF   x5C,F
00C26:  RRCF   x5B,F
00C28:  RRCF   x5A,F
00C2A:  DECFSZ x57,F
00C2C:  BRA    0C1E
00C2E:  BTFSS  x58.7
00C30:  BRA    0C38
00C32:  BSF    x59.0
00C34:  BRA    0DF6
00C36:  BCF    x59.0
00C38:  BCF    x57.0
00C3A:  BSF    x59.4
00C3C:  MOVLW  06
00C3E:  MOVWF  FEA
00C40:  MOVLW  52
00C42:  MOVWF  FE9
00C44:  BRA    0E1C
00C46:  BCF    x59.4
00C48:  BTFSC  x58.7
00C4A:  BRA    0C60
00C4C:  BTFSS  x57.0
00C4E:  BRA    0C76
00C50:  RRCF   x5D,F
00C52:  RRCF   x5C,F
00C54:  RRCF   x5B,F
00C56:  RRCF   x5A,F
00C58:  INCF   00,F
00C5A:  BTFSC  FD8.2
00C5C:  BRA    0DEC
00C5E:  BRA    0C76
00C60:  BTFSC  x5D.7
00C62:  BRA    0C7C
00C64:  BCF    FD8.0
00C66:  RLCF   x5A,F
00C68:  RLCF   x5B,F
00C6A:  RLCF   x5C,F
00C6C:  RLCF   x5D,F
00C6E:  DECF   00,F
00C70:  BTFSC  FD8.2
00C72:  BRA    0DEC
00C74:  BRA    0C60
00C76:  BSF    x59.6
00C78:  BRA    0D54
00C7A:  BCF    x59.6
00C7C:  MOVFF  650,658
00C80:  BTFSS  x50.7
00C82:  BRA    0C88
00C84:  BSF    x5D.7
00C86:  BRA    0DDE
00C88:  BCF    x5D.7
00C8A:  BRA    0DDE
00C8C:  MOVFF  653,657
00C90:  MOVFF  653,00
00C94:  MOVF   x4F,W
00C96:  SUBWF  x57,F
00C98:  MOVFF  650,65D
00C9C:  BSF    x5D.7
00C9E:  MOVFF  651,65C
00CA2:  MOVFF  652,65B
00CA6:  CLRF   x5A
00CA8:  BCF    FD8.0
00CAA:  RRCF   x5D,F
00CAC:  RRCF   x5C,F
00CAE:  RRCF   x5B,F
00CB0:  RRCF   x5A,F
00CB2:  DECFSZ x57,F
00CB4:  BRA    0CA6
00CB6:  BTFSS  x58.7
00CB8:  BRA    0CC0
00CBA:  BSF    x59.1
00CBC:  BRA    0DF6
00CBE:  BCF    x59.1
00CC0:  BCF    x57.0
00CC2:  BSF    x59.5
00CC4:  MOVLW  06
00CC6:  MOVWF  FEA
00CC8:  MOVLW  56
00CCA:  MOVWF  FE9
00CCC:  BRA    0E1C
00CCE:  BCF    x59.5
00CD0:  BTFSC  x58.7
00CD2:  BRA    0CE8
00CD4:  BTFSS  x57.0
00CD6:  BRA    0CFE
00CD8:  RRCF   x5D,F
00CDA:  RRCF   x5C,F
00CDC:  RRCF   x5B,F
00CDE:  RRCF   x5A,F
00CE0:  INCF   00,F
00CE2:  BTFSC  FD8.2
00CE4:  BRA    0DEC
00CE6:  BRA    0CFE
00CE8:  BTFSC  x5D.7
00CEA:  BRA    0D04
00CEC:  BCF    FD8.0
00CEE:  RLCF   x5A,F
00CF0:  RLCF   x5B,F
00CF2:  RLCF   x5C,F
00CF4:  RLCF   x5D,F
00CF6:  DECF   00,F
00CF8:  BTFSC  FD8.2
00CFA:  BRA    0DEC
00CFC:  BRA    0CE8
00CFE:  BSF    x59.7
00D00:  BRA    0D54
00D02:  BCF    x59.7
00D04:  MOVFF  654,658
00D08:  BTFSS  x54.7
00D0A:  BRA    0D10
00D0C:  BSF    x5D.7
00D0E:  BRA    0DDE
00D10:  BCF    x5D.7
00D12:  BRA    0DDE
00D14:  MOVFF  654,65D
00D18:  BSF    x5D.7
00D1A:  MOVFF  655,65C
00D1E:  MOVFF  656,65B
00D22:  BTFSS  x58.7
00D24:  BRA    0D2E
00D26:  BCF    x5D.7
00D28:  BSF    x59.2
00D2A:  BRA    0DF6
00D2C:  BCF    x59.2
00D2E:  CLRF   x5A
00D30:  BCF    x57.0
00D32:  MOVLW  06
00D34:  MOVWF  FEA
00D36:  MOVLW  52
00D38:  MOVWF  FE9
00D3A:  BRA    0E1C
00D3C:  BTFSC  x58.7
00D3E:  BRA    0D78
00D40:  MOVFF  650,658
00D44:  BTFSS  x57.0
00D46:  BRA    0D54
00D48:  RRCF   x5D,F
00D4A:  RRCF   x5C,F
00D4C:  RRCF   x5B,F
00D4E:  RRCF   x5A,F
00D50:  INCF   00,F
00D52:  BZ    0DEC
00D54:  BTFSS  x5A.7
00D56:  BRA    0D6E
00D58:  INCF   x5B,F
00D5A:  BNZ   0D6E
00D5C:  INCF   x5C,F
00D5E:  BNZ   0D6E
00D60:  INCF   x5D,F
00D62:  BNZ   0D6E
00D64:  RRCF   x5D,F
00D66:  RRCF   x5C,F
00D68:  RRCF   x5B,F
00D6A:  INCF   00,F
00D6C:  BZ    0DEC
00D6E:  BTFSC  x59.6
00D70:  BRA    0C7A
00D72:  BTFSC  x59.7
00D74:  BRA    0D02
00D76:  BRA    0DB0
00D78:  MOVLW  80
00D7A:  XORWF  x5D,F
00D7C:  BTFSS  x5D.7
00D7E:  BRA    0D88
00D80:  BRA    0DF6
00D82:  MOVFF  654,658
00D86:  BRA    0D9C
00D88:  MOVFF  650,658
00D8C:  MOVF   x5D,F
00D8E:  BNZ   0D9C
00D90:  MOVF   x5C,F
00D92:  BNZ   0D9C
00D94:  MOVF   x5B,F
00D96:  BNZ   0D9C
00D98:  CLRF   00
00D9A:  BRA    0DDE
00D9C:  BTFSC  x5D.7
00D9E:  BRA    0DB0
00DA0:  BCF    FD8.0
00DA2:  RLCF   x5A,F
00DA4:  RLCF   x5B,F
00DA6:  RLCF   x5C,F
00DA8:  RLCF   x5D,F
00DAA:  DECFSZ 00,F
00DAC:  BRA    0D9C
00DAE:  BRA    0DEC
00DB0:  BTFSS  x58.7
00DB2:  BRA    0DB8
00DB4:  BSF    x5D.7
00DB6:  BRA    0DDE
00DB8:  BCF    x5D.7
00DBA:  BRA    0DDE
00DBC:  MOVFF  653,00
00DC0:  MOVFF  654,65D
00DC4:  MOVFF  655,65C
00DC8:  MOVFF  656,65B
00DCC:  BRA    0DDE
00DCE:  MOVFF  64F,00
00DD2:  MOVFF  650,65D
00DD6:  MOVFF  651,65C
00DDA:  MOVFF  652,65B
00DDE:  MOVFF  65D,01
00DE2:  MOVFF  65C,02
00DE6:  MOVFF  65B,03
00DEA:  BRA    0E54
00DEC:  CLRF   00
00DEE:  CLRF   01
00DF0:  CLRF   02
00DF2:  CLRF   03
00DF4:  BRA    0E54
00DF6:  CLRF   x5A
00DF8:  COMF   x5B,F
00DFA:  COMF   x5C,F
00DFC:  COMF   x5D,F
00DFE:  COMF   x5A,F
00E00:  INCF   x5A,F
00E02:  BNZ   0E0E
00E04:  INCF   x5B,F
00E06:  BNZ   0E0E
00E08:  INCF   x5C,F
00E0A:  BNZ   0E0E
00E0C:  INCF   x5D,F
00E0E:  BTFSC  x59.0
00E10:  BRA    0C36
00E12:  BTFSC  x59.1
00E14:  BRA    0CBE
00E16:  BTFSC  x59.2
00E18:  BRA    0D2C
00E1A:  BRA    0D82
00E1C:  MOVF   FEF,W
00E1E:  ADDWF  x5B,F
00E20:  BNC   0E2C
00E22:  INCF   x5C,F
00E24:  BNZ   0E2C
00E26:  INCF   x5D,F
00E28:  BTFSC  FD8.2
00E2A:  BSF    x57.0
00E2C:  MOVF   FED,F
00E2E:  MOVF   FEF,W
00E30:  ADDWF  x5C,F
00E32:  BNC   0E3A
00E34:  INCF   x5D,F
00E36:  BTFSC  FD8.2
00E38:  BSF    x57.0
00E3A:  MOVF   FED,F
00E3C:  MOVF   FEF,W
00E3E:  BTFSC  FEF.7
00E40:  BRA    0E44
00E42:  XORLW  80
00E44:  ADDWF  x5D,F
00E46:  BTFSC  FD8.0
00E48:  BSF    x57.0
00E4A:  BTFSC  x59.4
00E4C:  BRA    0C46
00E4E:  BTFSC  x59.5
00E50:  BRA    0CCE
00E52:  BRA    0D3C
00E54:  MOVLB  0
00E56:  RETURN 0
*
013AE:  ADDWF  FE8,W
013B0:  CLRF   FF7
013B2:  RLCF   FF7,F
013B4:  ADDLW  C9
013B6:  MOVWF  FF6
013B8:  MOVLW  13
013BA:  ADDWFC FF7,F
013BC:  TBLRD*-
013BE:  MOVF   FF5,W
013C0:  MOVWF  FFA
013C2:  TBLRD*
013C4:  MOVF   FF5,W
013C6:  MOVWF  FF9
013C8:  DATA 70,0E
013CA:  DATA 30,0F
013CC:  DATA F0,0F
013CE:  DATA B0,10
013D0:  DATA 70,11
013D2:  DATA 30,12
013D4:  DATA F0,12
*
01440:  MOVLW  B6
01442:  MOVWF  00
01444:  CLRF   03
01446:  CLRF   02
01448:  CLRF   01
0144A:  MOVLB  6
0144C:  BCF    x19.0
0144E:  BTFSS  x18.7
01450:  BRA    146A
01452:  BSF    x19.0
01454:  COMF   x15,F
01456:  COMF   x16,F
01458:  COMF   x17,F
0145A:  COMF   x18,F
0145C:  INCF   x15,F
0145E:  BNZ   146A
01460:  INCF   x16,F
01462:  BNZ   146A
01464:  INCF   x17,F
01466:  BTFSC  FD8.2
01468:  INCF   x18,F
0146A:  MOVF   x15,W
0146C:  IORWF  x16,W
0146E:  IORWF  x17,W
01470:  IORWF  x18,W
01472:  BNZ   1478
01474:  CLRF   00
01476:  BRA    1496
01478:  BCF    FD8.0
0147A:  BTFSC  01.7
0147C:  BRA    1490
0147E:  RLCF   x15,F
01480:  RLCF   x16,F
01482:  RLCF   x17,F
01484:  RLCF   x18,F
01486:  RLCF   03,F
01488:  RLCF   02,F
0148A:  RLCF   01,F
0148C:  DECFSZ 00,F
0148E:  BRA    1478
01490:  BCF    01.7
01492:  BTFSC  x19.0
01494:  BSF    01.7
01496:  MOVLB  0
01498:  RETURN 0
0149A:  MOVFF  64C,653
0149E:  MOVLB  6
014A0:  MOVF   x50,W
014A2:  XORWF  x53,F
014A4:  BTFSS  x53.7
014A6:  BRA    14B2
014A8:  BCF    FD8.2
014AA:  BCF    FD8.0
014AC:  BTFSC  x4C.7
014AE:  BSF    FD8.0
014B0:  BRA    1510
014B2:  MOVFF  64C,653
014B6:  MOVFF  64F,654
014BA:  MOVF   x4B,W
014BC:  SUBWF  x54,F
014BE:  BZ    14CC
014C0:  BTFSS  x53.7
014C2:  BRA    1510
014C4:  MOVF   FD8,W
014C6:  XORLW  01
014C8:  MOVWF  FD8
014CA:  BRA    1510
014CC:  MOVFF  650,654
014D0:  MOVF   x4C,W
014D2:  SUBWF  x54,F
014D4:  BZ    14E2
014D6:  BTFSS  x53.7
014D8:  BRA    1510
014DA:  MOVF   FD8,W
014DC:  XORLW  01
014DE:  MOVWF  FD8
014E0:  BRA    1510
014E2:  MOVFF  651,654
014E6:  MOVF   x4D,W
014E8:  SUBWF  x54,F
014EA:  BZ    14F8
014EC:  BTFSS  x53.7
014EE:  BRA    1510
014F0:  MOVF   FD8,W
014F2:  XORLW  01
014F4:  MOVWF  FD8
014F6:  BRA    1510
014F8:  MOVFF  652,654
014FC:  MOVF   x4E,W
014FE:  SUBWF  x54,F
01500:  BZ    150E
01502:  BTFSS  x53.7
01504:  BRA    1510
01506:  MOVF   FD8,W
01508:  XORLW  01
0150A:  MOVWF  FD8
0150C:  BRA    1510
0150E:  BCF    FD8.0
01510:  MOVLB  0
01512:  RETURN 0
01514:  MOVLB  6
01516:  MOVF   x44,W
01518:  BTFSC  FD8.2
0151A:  BRA    1666
0151C:  MOVWF  x50
0151E:  MOVF   x48,W
01520:  BTFSC  FD8.2
01522:  BRA    1666
01524:  SUBWF  x50,F
01526:  BNC   1532
01528:  MOVLW  7F
0152A:  ADDWF  x50,F
0152C:  BTFSC  FD8.0
0152E:  BRA    1666
01530:  BRA    153E
01532:  MOVLW  81
01534:  SUBWF  x50,F
01536:  BTFSS  FD8.0
01538:  BRA    1666
0153A:  BTFSC  FD8.2
0153C:  BRA    1666
0153E:  MOVFF  650,00
01542:  CLRF   01
01544:  CLRF   02
01546:  CLRF   03
01548:  CLRF   x4F
0154A:  MOVFF  645,64E
0154E:  BSF    x4E.7
01550:  MOVFF  646,64D
01554:  MOVFF  647,64C
01558:  MOVLW  19
0155A:  MOVWF  x50
0155C:  MOVF   x4B,W
0155E:  SUBWF  x4C,F
01560:  BC    157C
01562:  MOVLW  01
01564:  SUBWF  x4D,F
01566:  BC    157C
01568:  SUBWF  x4E,F
0156A:  BC    157C
0156C:  SUBWF  x4F,F
0156E:  BC    157C
01570:  INCF   x4F,F
01572:  INCF   x4E,F
01574:  INCF   x4D,F
01576:  MOVF   x4B,W
01578:  ADDWF  x4C,F
0157A:  BRA    15CC
0157C:  MOVF   x4A,W
0157E:  SUBWF  x4D,F
01580:  BC    15A6
01582:  MOVLW  01
01584:  SUBWF  x4E,F
01586:  BC    15A6
01588:  SUBWF  x4F,F
0158A:  BC    15A6
0158C:  INCF   x4F,F
0158E:  INCF   x4E,F
01590:  MOVF   x4A,W
01592:  ADDWF  x4D,F
01594:  MOVF   x4B,W
01596:  ADDWF  x4C,F
01598:  BNC   15CC
0159A:  INCF   x4D,F
0159C:  BNZ   15CC
0159E:  INCF   x4E,F
015A0:  BNZ   15CC
015A2:  INCF   x4F,F
015A4:  BRA    15CC
015A6:  MOVF   x49,W
015A8:  IORLW  80
015AA:  SUBWF  x4E,F
015AC:  BC    15CA
015AE:  MOVLW  01
015B0:  SUBWF  x4F,F
015B2:  BC    15CA
015B4:  INCF   x4F,F
015B6:  MOVF   x49,W
015B8:  IORLW  80
015BA:  ADDWF  x4E,F
015BC:  MOVF   x4A,W
015BE:  ADDWF  x4D,F
015C0:  BNC   1594
015C2:  INCF   x4E,F
015C4:  BNZ   1594
015C6:  INCF   x4F,F
015C8:  BRA    1594
015CA:  BSF    03.0
015CC:  DECFSZ x50,F
015CE:  BRA    15D2
015D0:  BRA    15E8
015D2:  BCF    FD8.0
015D4:  RLCF   x4C,F
015D6:  RLCF   x4D,F
015D8:  RLCF   x4E,F
015DA:  RLCF   x4F,F
015DC:  BCF    FD8.0
015DE:  RLCF   03,F
015E0:  RLCF   02,F
015E2:  RLCF   01,F
015E4:  RLCF   x51,F
015E6:  BRA    155C
015E8:  BTFSS  x51.0
015EA:  BRA    15F8
015EC:  BCF    FD8.0
015EE:  RRCF   01,F
015F0:  RRCF   02,F
015F2:  RRCF   03,F
015F4:  RRCF   x51,F
015F6:  BRA    15FC
015F8:  DECF   00,F
015FA:  BZ    1666
015FC:  BTFSC  x51.7
015FE:  BRA    163C
01600:  BCF    FD8.0
01602:  RLCF   x4C,F
01604:  RLCF   x4D,F
01606:  RLCF   x4E,F
01608:  RLCF   x4F,F
0160A:  MOVF   x4B,W
0160C:  SUBWF  x4C,F
0160E:  BC    161E
01610:  MOVLW  01
01612:  SUBWF  x4D,F
01614:  BC    161E
01616:  SUBWF  x4E,F
01618:  BC    161E
0161A:  SUBWF  x4F,F
0161C:  BNC   1652
0161E:  MOVF   x4A,W
01620:  SUBWF  x4D,F
01622:  BC    162E
01624:  MOVLW  01
01626:  SUBWF  x4E,F
01628:  BC    162E
0162A:  SUBWF  x4F,F
0162C:  BNC   1652
0162E:  MOVF   x49,W
01630:  IORLW  80
01632:  SUBWF  x4E,F
01634:  BC    163C
01636:  MOVLW  01
01638:  SUBWF  x4F,F
0163A:  BNC   1652
0163C:  INCF   03,F
0163E:  BNZ   1652
01640:  INCF   02,F
01642:  BNZ   1652
01644:  INCF   01,F
01646:  BNZ   1652
01648:  INCF   00,F
0164A:  BZ    1666
0164C:  RRCF   01,F
0164E:  RRCF   02,F
01650:  RRCF   03,F
01652:  MOVFF  645,650
01656:  MOVF   x49,W
01658:  XORWF  x50,F
0165A:  BTFSS  x50.7
0165C:  BRA    1662
0165E:  BSF    01.7
01660:  BRA    166E
01662:  BCF    01.7
01664:  BRA    166E
01666:  CLRF   00
01668:  CLRF   01
0166A:  CLRF   02
0166C:  CLRF   03
0166E:  MOVLB  0
01670:  RETURN 0
*
01E1C:  ADDWF  FE8,W
01E1E:  CLRF   FF7
01E20:  RLCF   FF7,F
01E22:  ADDLW  37
01E24:  MOVWF  FF6
01E26:  MOVLW  1E
01E28:  ADDWFC FF7,F
01E2A:  TBLRD*-
01E2C:  MOVF   FF5,W
01E2E:  MOVWF  FFA
01E30:  TBLRD*
01E32:  MOVF   FF5,W
01E34:  MOVWF  FF9
01E36:  DATA 24,1D
01E38:  DATA 3E,1D
01E3A:  DATA 92,1D
01E3C:  DATA F6,1D
01E3E:  MOVLW  8E
01E40:  MOVWF  00
01E42:  MOVFF  642,01
01E46:  MOVFF  641,02
01E4A:  CLRF   03
01E4C:  BTFSS  01.7
01E4E:  BRA    1E5A
01E50:  COMF   01,F
01E52:  COMF   02,F
01E54:  INCF   02,F
01E56:  BNZ   1E5A
01E58:  INCF   01,F
01E5A:  MOVF   01,F
01E5C:  BNZ   1E70
01E5E:  MOVFF  02,01
01E62:  CLRF   02
01E64:  MOVLW  08
01E66:  SUBWF  00,F
01E68:  MOVF   01,F
01E6A:  BNZ   1E70
01E6C:  CLRF   00
01E6E:  BRA    1E8C
01E70:  BCF    FD8.0
01E72:  BTFSC  01.7
01E74:  BRA    1E7E
01E76:  RLCF   02,F
01E78:  RLCF   01,F
01E7A:  DECF   00,F
01E7C:  BRA    1E70
01E7E:  MOVLB  6
01E80:  BTFSS  x42.7
01E82:  BRA    1E88
01E84:  MOVLB  0
01E86:  BRA    1E8C
01E88:  BCF    01.7
01E8A:  MOVLB  0
01E8C:  RETURN 0
01E8E:  MOVLW  8E
01E90:  MOVWF  00
01E92:  MOVLB  6
01E94:  MOVF   x4B,W
01E96:  SUBWF  00,F
01E98:  MOVFF  64C,02
01E9C:  MOVFF  64D,01
01EA0:  BSF    02.7
01EA2:  MOVF   00,F
01EA4:  BZ    1EB8
01EA6:  BCF    FD8.0
01EA8:  MOVF   02,F
01EAA:  BNZ   1EB0
01EAC:  MOVF   01,F
01EAE:  BZ    1EB8
01EB0:  RRCF   02,F
01EB2:  RRCF   01,F
01EB4:  DECFSZ 00,F
01EB6:  BRA    1EA6
01EB8:  BTFSS  x4C.7
01EBA:  BRA    1EC6
01EBC:  COMF   01,F
01EBE:  COMF   02,F
01EC0:  INCF   01,F
01EC2:  BTFSC  FD8.2
01EC4:  INCF   02,F
01EC6:  MOVLB  0
01EC8:  RETURN 0
*
03CCE:  MOVLB  5
03CD0:  MOVF   xFD,W
03CD2:  ANDLW  07
03CD4:  MOVWF  00
03CD6:  RRCF   xFD,W
03CD8:  MOVWF  01
03CDA:  RRCF   01,F
03CDC:  RRCF   01,F
03CDE:  MOVLW  1F
03CE0:  ANDWF  01,F
03CE2:  MOVF   01,W
03CE4:  ADDWF  xFE,W
03CE6:  MOVWF  FE9
03CE8:  MOVLW  00
03CEA:  ADDWFC xFF,W
03CEC:  MOVWF  FEA
03CEE:  MOVFF  FEF,01
03CF2:  INCF   00,F
03CF4:  BRA    3CF8
03CF6:  RRCF   01,F
03CF8:  DECFSZ 00,F
03CFA:  BRA    3CF6
03CFC:  MOVLW  01
03CFE:  ANDWF  01,F
03D00:  MOVLB  0
03D02:  RETURN 0
*
0473C:  MOVF   FEF,F
0473E:  BZ    475E
04740:  MOVFF  FEA,5F6
04744:  MOVFF  FE9,5F5
04748:  MOVFF  FEF,60D
0474C:  RCALL  4714
0474E:  MOVFF  5F6,FEA
04752:  MOVFF  5F5,FE9
04756:  INCF   FE9,F
04758:  BTFSC  FD8.2
0475A:  INCF   FEA,F
0475C:  BRA    473C
0475E:  RETURN 0
*
04C78:  TBLRD*+
04C7A:  MOVFF  FF6,5FA
04C7E:  MOVFF  FF7,5FB
04C82:  MOVFF  FF5,60D
04C86:  RCALL  4714
04C88:  MOVFF  5FA,FF6
04C8C:  MOVFF  5FB,FF7
04C90:  MOVLB  5
04C92:  DECFSZ xF9,F
04C94:  BRA    4C98
04C96:  BRA    4C9C
04C98:  MOVLB  0
04C9A:  BRA    4C78
04C9C:  MOVLB  0
04C9E:  RETURN 0
04CA0:  MOVLB  6
04CA2:  MOVF   x30,W
04CA4:  CLRF   01
04CA6:  SUBWF  x2F,W
04CA8:  BC    4CB0
04CAA:  MOVFF  62F,00
04CAE:  BRA    4CC8
04CB0:  CLRF   00
04CB2:  MOVLW  08
04CB4:  MOVWF  x31
04CB6:  RLCF   x2F,F
04CB8:  RLCF   00,F
04CBA:  MOVF   x30,W
04CBC:  SUBWF  00,W
04CBE:  BTFSC  FD8.0
04CC0:  MOVWF  00
04CC2:  RLCF   01,F
04CC4:  DECFSZ x31,F
04CC6:  BRA    4CB6
04CC8:  MOVLB  0
04CCA:  RETURN 0
04CCC:  MOVF   01,W
04CCE:  MOVFF  5F9,62F
04CD2:  MOVLW  64
04CD4:  MOVLB  6
04CD6:  MOVWF  x30
04CD8:  MOVLB  0
04CDA:  RCALL  4CA0
04CDC:  MOVFF  00,5F9
04CE0:  MOVF   01,W
04CE2:  MOVLW  30
04CE4:  BNZ   4CF6
04CE6:  MOVLB  5
04CE8:  BTFSS  xFA.1
04CEA:  BRA    4D08
04CEC:  BTFSC  xFA.3
04CEE:  BRA    4D08
04CF0:  BTFSC  xFA.4
04CF2:  MOVLW  20
04CF4:  BRA    4CFE
04CF6:  MOVLB  5
04CF8:  BCF    xFA.3
04CFA:  BCF    xFA.4
04CFC:  BSF    xFA.0
04CFE:  ADDWF  01,F
04D00:  MOVFF  01,60D
04D04:  MOVLB  0
04D06:  RCALL  4714
04D08:  MOVFF  5F9,62F
04D0C:  MOVLW  0A
04D0E:  MOVLB  6
04D10:  MOVWF  x30
04D12:  MOVLB  0
04D14:  RCALL  4CA0
04D16:  MOVFF  00,5F9
04D1A:  MOVF   01,W
04D1C:  MOVLW  30
04D1E:  BNZ   4D30
04D20:  MOVLB  5
04D22:  BTFSC  xFA.3
04D24:  BRA    4D3A
04D26:  BTFSS  xFA.0
04D28:  BRA    4D3A
04D2A:  BTFSC  xFA.4
04D2C:  MOVLW  20
04D2E:  MOVLB  0
04D30:  ADDWF  01,F
04D32:  MOVFF  01,60D
04D36:  RCALL  4714
04D38:  MOVLB  5
04D3A:  MOVLW  30
04D3C:  ADDWF  xF9,F
04D3E:  MOVFF  5F9,60D
04D42:  MOVLB  0
04D44:  RCALL  4714
04D46:  RETURN 0
04D48:  MOVLB  6
04D4A:  MOVF   x40,W
04D4C:  SUBLW  B6
04D4E:  MOVWF  x40
04D50:  CLRF   03
04D52:  MOVFF  641,644
04D56:  BSF    x41.7
04D58:  BCF    FD8.0
04D5A:  RRCF   x41,F
04D5C:  RRCF   x42,F
04D5E:  RRCF   x43,F
04D60:  RRCF   03,F
04D62:  RRCF   02,F
04D64:  RRCF   01,F
04D66:  RRCF   00,F
04D68:  DECFSZ x40,F
04D6A:  BRA    4D58
04D6C:  BTFSS  x44.7
04D6E:  BRA    4D86
04D70:  COMF   00,F
04D72:  COMF   01,F
04D74:  COMF   02,F
04D76:  COMF   03,F
04D78:  INCF   00,F
04D7A:  BTFSC  FD8.2
04D7C:  INCF   01,F
04D7E:  BTFSC  FD8.2
04D80:  INCF   02,F
04D82:  BTFSC  FD8.2
04D84:  INCF   03,F
04D86:  MOVLB  0
04D88:  RETURN 0
04D8A:  BTFSC  FD8.1
04D8C:  BRA    4D96
04D8E:  MOVLW  06
04D90:  MOVWF  FEA
04D92:  MOVLW  48
04D94:  MOVWF  FE9
04D96:  CLRF   00
04D98:  CLRF   01
04D9A:  CLRF   02
04D9C:  CLRF   03
04D9E:  MOVLB  6
04DA0:  CLRF   x48
04DA2:  CLRF   x49
04DA4:  CLRF   x4A
04DA6:  CLRF   x4B
04DA8:  MOVF   x47,W
04DAA:  IORWF  x46,W
04DAC:  IORWF  x45,W
04DAE:  IORWF  x44,W
04DB0:  BZ    4E0A
04DB2:  MOVLW  20
04DB4:  MOVWF  x4C
04DB6:  BCF    FD8.0
04DB8:  RLCF   x40,F
04DBA:  RLCF   x41,F
04DBC:  RLCF   x42,F
04DBE:  RLCF   x43,F
04DC0:  RLCF   x48,F
04DC2:  RLCF   x49,F
04DC4:  RLCF   x4A,F
04DC6:  RLCF   x4B,F
04DC8:  MOVF   x47,W
04DCA:  SUBWF  x4B,W
04DCC:  BNZ   4DDE
04DCE:  MOVF   x46,W
04DD0:  SUBWF  x4A,W
04DD2:  BNZ   4DDE
04DD4:  MOVF   x45,W
04DD6:  SUBWF  x49,W
04DD8:  BNZ   4DDE
04DDA:  MOVF   x44,W
04DDC:  SUBWF  x48,W
04DDE:  BNC   4DFE
04DE0:  MOVF   x44,W
04DE2:  SUBWF  x48,F
04DE4:  MOVF   x45,W
04DE6:  BTFSS  FD8.0
04DE8:  INCFSZ x45,W
04DEA:  SUBWF  x49,F
04DEC:  MOVF   x46,W
04DEE:  BTFSS  FD8.0
04DF0:  INCFSZ x46,W
04DF2:  SUBWF  x4A,F
04DF4:  MOVF   x47,W
04DF6:  BTFSS  FD8.0
04DF8:  INCFSZ x47,W
04DFA:  SUBWF  x4B,F
04DFC:  BSF    FD8.0
04DFE:  RLCF   00,F
04E00:  RLCF   01,F
04E02:  RLCF   02,F
04E04:  RLCF   03,F
04E06:  DECFSZ x4C,F
04E08:  BRA    4DB6
04E0A:  MOVFF  648,FEF
04E0E:  MOVFF  649,FEC
04E12:  MOVFF  64A,FEC
04E16:  MOVFF  64B,FEC
04E1A:  MOVLB  0
04E1C:  RETURN 0
04E1E:  MOVF   FE9,W
04E20:  MOVLB  6
04E22:  MOVWF  x00
04E24:  MOVLB  5
04E26:  MOVF   xFD,W
04E28:  MOVLB  6
04E2A:  MOVWF  x02
04E2C:  BZ    4E66
04E2E:  MOVFF  5FC,64E
04E32:  MOVFF  5FB,64D
04E36:  MOVFF  5FA,64C
04E3A:  MOVFF  5F9,64B
04E3E:  CLRF   x52
04E40:  CLRF   x51
04E42:  MOVLW  20
04E44:  MOVWF  x50
04E46:  MOVLW  82
04E48:  MOVWF  x4F
04E4A:  MOVLB  0
04E4C:  CALL   0AEA
04E50:  MOVFF  03,5FC
04E54:  MOVFF  02,5FB
04E58:  MOVFF  01,5FA
04E5C:  MOVFF  00,5F9
04E60:  MOVLB  6
04E62:  DECFSZ x02,F
04E64:  BRA    4E2E
04E66:  MOVFF  5FC,643
04E6A:  MOVFF  5FB,642
04E6E:  MOVFF  5FA,641
04E72:  MOVFF  5F9,640
04E76:  MOVLB  0
04E78:  RCALL  4D48
04E7A:  MOVFF  03,5FC
04E7E:  MOVFF  02,5FB
04E82:  MOVFF  01,5FA
04E86:  MOVFF  00,5F9
04E8A:  MOVLB  5
04E8C:  BTFSS  xFC.7
04E8E:  BRA    4EAE
04E90:  MOVLB  6
04E92:  DECF   x00,F
04E94:  BSF    x00.5
04E96:  MOVLB  5
04E98:  COMF   xF9,F
04E9A:  COMF   xFA,F
04E9C:  COMF   xFB,F
04E9E:  COMF   xFC,F
04EA0:  INCF   xF9,F
04EA2:  BTFSC  FD8.2
04EA4:  INCF   xFA,F
04EA6:  BTFSC  FD8.2
04EA8:  INCF   xFB,F
04EAA:  BTFSC  FD8.2
04EAC:  INCF   xFC,F
04EAE:  MOVLW  3B
04EB0:  MOVLB  6
04EB2:  MOVWF  x07
04EB4:  MOVLW  9A
04EB6:  MOVWF  x06
04EB8:  MOVLW  CA
04EBA:  MOVWF  x05
04EBC:  CLRF   x04
04EBE:  MOVLW  0A
04EC0:  MOVWF  x02
04EC2:  MOVLB  5
04EC4:  MOVF   xFD,W
04EC6:  BTFSS  FD8.2
04EC8:  BRA    4ED0
04ECA:  MOVLB  6
04ECC:  INCF   x00,F
04ECE:  MOVLB  5
04ED0:  BSF    FD8.1
04ED2:  MOVLW  05
04ED4:  MOVWF  FEA
04ED6:  MOVLW  F9
04ED8:  MOVWF  FE9
04EDA:  MOVFF  5FC,643
04EDE:  MOVFF  5FB,642
04EE2:  MOVFF  5FA,641
04EE6:  MOVFF  5F9,640
04EEA:  MOVFF  607,647
04EEE:  MOVFF  606,646
04EF2:  MOVFF  605,645
04EF6:  MOVFF  604,644
04EFA:  MOVLB  0
04EFC:  RCALL  4D8A
04EFE:  MOVF   01,W
04F00:  MOVF   00,F
04F02:  BNZ   4F2C
04F04:  MOVLB  5
04F06:  INCF   xFD,W
04F08:  MOVLB  6
04F0A:  SUBWF  x02,W
04F0C:  BTFSS  FD8.2
04F0E:  BRA    4F14
04F10:  MOVLB  0
04F12:  BRA    4F2C
04F14:  MOVF   x00,W
04F16:  BZ    4F32
04F18:  ANDLW  0F
04F1A:  SUBWF  x02,W
04F1C:  BZ    4F20
04F1E:  BC    4FC0
04F20:  BTFSC  x00.7
04F22:  BRA    4FC0
04F24:  BTFSC  x00.6
04F26:  BRA    4F32
04F28:  MOVLW  20
04F2A:  BRA    4FB2
04F2C:  MOVLW  20
04F2E:  MOVLB  6
04F30:  ANDWF  x00,F
04F32:  BTFSS  x00.5
04F34:  BRA    4F5E
04F36:  BCF    x00.5
04F38:  MOVLB  5
04F3A:  MOVF   xFD,W
04F3C:  BTFSC  FD8.2
04F3E:  BRA    4F46
04F40:  MOVLB  6
04F42:  DECF   x00,F
04F44:  MOVLB  5
04F46:  MOVF   00,W
04F48:  MOVLB  6
04F4A:  MOVWF  x00
04F4C:  MOVLW  2D
04F4E:  MOVWF  x0D
04F50:  MOVLB  0
04F52:  CALL   4714
04F56:  MOVLB  6
04F58:  MOVF   x00,W
04F5A:  MOVWF  00
04F5C:  CLRF   x00
04F5E:  MOVLB  5
04F60:  MOVF   xFD,W
04F62:  MOVLB  6
04F64:  SUBWF  x02,W
04F66:  BNZ   4F82
04F68:  MOVF   00,W
04F6A:  MOVWF  x00
04F6C:  MOVLW  2E
04F6E:  MOVWF  x0D
04F70:  MOVLB  0
04F72:  CALL   4714
04F76:  MOVLB  6
04F78:  MOVF   x00,W
04F7A:  MOVWF  00
04F7C:  MOVLW  20
04F7E:  ANDWF  x00,F
04F80:  MOVLW  00
04F82:  MOVLW  30
04F84:  BTFSS  x00.5
04F86:  BRA    4FB2
04F88:  BCF    x00.5
04F8A:  MOVLB  5
04F8C:  MOVF   xFD,W
04F8E:  BTFSC  FD8.2
04F90:  BRA    4F98
04F92:  MOVLB  6
04F94:  DECF   x00,F
04F96:  MOVLB  5
04F98:  MOVF   00,W
04F9A:  MOVLB  6
04F9C:  MOVWF  x00
04F9E:  MOVLW  2D
04FA0:  MOVWF  x0D
04FA2:  MOVLB  0
04FA4:  CALL   4714
04FA8:  MOVLB  6
04FAA:  MOVF   x00,W
04FAC:  MOVWF  00
04FAE:  CLRF   x00
04FB0:  MOVLW  30
04FB2:  ADDWF  00,F
04FB4:  MOVFF  00,60D
04FB8:  MOVLB  0
04FBA:  CALL   4714
04FBE:  MOVLB  6
04FC0:  BCF    FD8.1
04FC2:  MOVFF  607,643
04FC6:  MOVFF  606,642
04FCA:  MOVFF  605,641
04FCE:  MOVFF  604,640
04FD2:  CLRF   x47
04FD4:  CLRF   x46
04FD6:  CLRF   x45
04FD8:  MOVLW  0A
04FDA:  MOVWF  x44
04FDC:  MOVLB  0
04FDE:  RCALL  4D8A
04FE0:  MOVFF  03,607
04FE4:  MOVFF  02,606
04FE8:  MOVFF  01,605
04FEC:  MOVFF  00,604
04FF0:  MOVLB  6
04FF2:  DECFSZ x02,F
04FF4:  BRA    4FF8
04FF6:  BRA    4FFC
04FF8:  MOVLB  5
04FFA:  BRA    4ED0
04FFC:  MOVLB  0
04FFE:  RETURN 0
05000:  MOVFF  FEA,5FD
05004:  MOVFF  FE9,5FC
05008:  MOVLB  5
0500A:  SWAPF  xF6,W
0500C:  IORLW  F0
0500E:  MOVWF  xF8
05010:  ADDWF  xF8,F
05012:  ADDLW  E2
05014:  MOVWF  xF9
05016:  ADDLW  32
05018:  MOVWF  xFB
0501A:  MOVF   xF6,W
0501C:  ANDLW  0F
0501E:  ADDWF  xF9,F
05020:  ADDWF  xF9,F
05022:  ADDWF  xFB,F
05024:  ADDLW  E9
05026:  MOVWF  xFA
05028:  ADDWF  xFA,F
0502A:  ADDWF  xFA,F
0502C:  SWAPF  xF5,W
0502E:  ANDLW  0F
05030:  ADDWF  xFA,F
05032:  ADDWF  xFB,F
05034:  RLCF   xFA,F
05036:  RLCF   xFB,F
05038:  COMF   xFB,F
0503A:  RLCF   xFB,F
0503C:  MOVF   xF5,W
0503E:  ANDLW  0F
05040:  ADDWF  xFB,F
05042:  RLCF   xF8,F
05044:  MOVLW  07
05046:  MOVWF  xF7
05048:  MOVLW  0A
0504A:  DECF   xFA,F
0504C:  ADDWF  xFB,F
0504E:  BNC   504A
05050:  DECF   xF9,F
05052:  ADDWF  xFA,F
05054:  BNC   5050
05056:  DECF   xF8,F
05058:  ADDWF  xF9,F
0505A:  BNC   5056
0505C:  DECF   xF7,F
0505E:  ADDWF  xF8,F
05060:  BNC   505C
05062:  MOVLW  05
05064:  MOVWF  FEA
05066:  MOVLW  F7
05068:  MOVWF  FE9
0506A:  MOVLW  07
0506C:  ANDWF  xFC,W
0506E:  BCF    xFC.6
05070:  ADDWF  FE9,F
05072:  MOVLW  00
05074:  ADDWFC FEA,F
05076:  MOVF   FE9,W
05078:  SUBLW  FB
0507A:  BNZ   5084
0507C:  MOVF   FEA,W
0507E:  SUBLW  05
05080:  BNZ   5084
05082:  BSF    xFC.6
05084:  MOVF   FEF,W
05086:  MOVWF  00
05088:  BNZ   509A
0508A:  BTFSC  xFC.6
0508C:  BRA    509A
0508E:  BTFSC  xFC.4
05090:  BRA    50BE
05092:  BTFSC  xFC.3
05094:  BRA    509A
05096:  MOVLW  20
05098:  BRA    50A0
0509A:  BSF    xFC.3
0509C:  BCF    xFC.4
0509E:  MOVLW  30
050A0:  ADDWF  00,F
050A2:  MOVFF  FEA,5F6
050A6:  MOVFF  FE9,5F5
050AA:  MOVFF  00,60D
050AE:  MOVLB  0
050B0:  CALL   4714
050B4:  MOVFF  5F6,FEA
050B8:  MOVFF  5F5,FE9
050BC:  MOVLB  5
050BE:  MOVF   FEE,W
050C0:  BTFSS  xFC.6
050C2:  BRA    5076
050C4:  MOVLB  0
050C6:  RETURN 0
*
0520C:  MOVFF  4E7,FEA
05210:  MOVFF  4E6,FE9
05214:  MOVFF  640,FEF
05218:  INCF   FE9,F
0521A:  BTFSC  FD8.2
0521C:  INCF   FEA,F
0521E:  CLRF   FEF
05220:  MOVLB  4
05222:  INCF   xE6,F
05224:  BTFSC  FD8.2
05226:  INCF   xE7,F
05228:  MOVLB  0
0522A:  RETURN 0
0522C:  TBLRD*+
0522E:  MOVF   FF5,F
05230:  BZ    524A
05232:  MOVFF  FF6,5FE
05236:  MOVFF  FF7,5FF
0523A:  MOVFF  FF5,640
0523E:  RCALL  520C
05240:  MOVFF  5FE,FF6
05244:  MOVFF  5FF,FF7
05248:  BRA    522C
0524A:  RETURN 0
*
0536E:  MOVLB  6
05370:  MOVF   x5D,W
05372:  XORWF  x5F,W
05374:  ANDLW  80
05376:  MOVWF  x61
05378:  BTFSS  x5D.7
0537A:  BRA    5386
0537C:  COMF   x5C,F
0537E:  COMF   x5D,F
05380:  INCF   x5C,F
05382:  BTFSC  FD8.2
05384:  INCF   x5D,F
05386:  BTFSS  x5F.7
05388:  BRA    5394
0538A:  COMF   x5E,F
0538C:  COMF   x5F,F
0538E:  INCF   x5E,F
05390:  BTFSC  FD8.2
05392:  INCF   x5F,F
05394:  MOVF   x5C,W
05396:  MULWF  x5E
05398:  MOVFF  FF3,01
0539C:  MOVFF  FF4,00
053A0:  MULWF  x5F
053A2:  MOVF   FF3,W
053A4:  ADDWF  00,F
053A6:  MOVF   x5D,W
053A8:  MULWF  x5E
053AA:  MOVF   FF3,W
053AC:  ADDWFC 00,W
053AE:  MOVWF  02
053B0:  BTFSS  x61.7
053B2:  BRA    53BE
053B4:  COMF   01,F
053B6:  COMF   02,F
053B8:  INCF   01,F
053BA:  BTFSC  FD8.2
053BC:  INCF   02,F
053BE:  MOVLB  0
053C0:  GOTO   5654 (RETURN)
*
05718:  MOVLW  20
0571A:  MOVLB  6
0571C:  BTFSS  x2A.4
0571E:  MOVLW  30
05720:  MOVWF  x2B
05722:  MOVFF  629,00
05726:  BTFSS  00.7
05728:  BRA    573A
0572A:  COMF   00,F
0572C:  INCF   00,F
0572E:  MOVFF  00,629
05732:  MOVLW  2D
05734:  MOVWF  x2B
05736:  BSF    x2A.7
05738:  BSF    x2A.0
0573A:  MOVF   01,W
0573C:  MOVFF  629,62F
05740:  MOVLW  64
05742:  MOVWF  x30
05744:  MOVLB  0
05746:  CALL   4CA0
0574A:  MOVFF  00,629
0574E:  MOVLW  30
05750:  ADDWF  01,W
05752:  MOVLB  6
05754:  MOVWF  x2C
05756:  MOVFF  629,62F
0575A:  MOVLW  0A
0575C:  MOVWF  x30
0575E:  MOVLB  0
05760:  CALL   4CA0
05764:  MOVLW  30
05766:  ADDWF  00,W
05768:  MOVLB  6
0576A:  MOVWF  x2E
0576C:  MOVLW  30
0576E:  ADDWF  01,W
05770:  MOVWF  x2D
05772:  MOVFF  62B,00
05776:  MOVLW  30
05778:  SUBWF  x2C,W
0577A:  BZ    5784
0577C:  BSF    x2A.1
0577E:  BTFSC  x2A.7
05780:  BSF    x2A.2
05782:  BRA    57A8
05784:  MOVFF  62B,62C
05788:  MOVLW  20
0578A:  MOVWF  x2B
0578C:  MOVLW  30
0578E:  SUBWF  x2D,W
05790:  BZ    579A
05792:  BSF    x2A.0
05794:  BTFSC  x2A.7
05796:  BSF    x2A.1
05798:  BRA    57A8
0579A:  BTFSS  FD8.2
0579C:  BSF    x2A.0
0579E:  BNZ   57A8
057A0:  MOVFF  62C,62D
057A4:  MOVLW  20
057A6:  MOVWF  x2C
057A8:  BTFSC  x2A.2
057AA:  BRA    57B6
057AC:  BTFSC  x2A.1
057AE:  BRA    57BE
057B0:  BTFSC  x2A.0
057B2:  BRA    57C6
057B4:  BRA    57CE
057B6:  MOVFF  62B,640
057BA:  MOVLB  0
057BC:  RCALL  520C
057BE:  MOVFF  62C,640
057C2:  MOVLB  0
057C4:  RCALL  520C
057C6:  MOVFF  62D,640
057CA:  MOVLB  0
057CC:  RCALL  520C
057CE:  MOVFF  62E,640
057D2:  MOVLB  0
057D4:  RCALL  520C
057D6:  RETURN 0
*
0597A:  MOVLB  6
0597C:  MOVF   x12,W
0597E:  ANDLW  07
05980:  MOVWF  00
05982:  RRCF   x12,W
05984:  MOVWF  01
05986:  RRCF   01,F
05988:  RRCF   01,F
0598A:  MOVLW  1F
0598C:  ANDWF  01,F
0598E:  MOVF   01,W
05990:  ADDWF  x14,W
05992:  MOVWF  FE9
05994:  MOVLW  00
05996:  ADDWFC x15,W
05998:  MOVWF  FEA
0599A:  CLRF   01
0599C:  INCF   01,F
0599E:  INCF   00,F
059A0:  BRA    59A4
059A2:  RLCF   01,F
059A4:  DECFSZ 00,F
059A6:  BRA    59A2
059A8:  MOVF   x13,F
059AA:  BZ    59B2
059AC:  MOVF   01,W
059AE:  IORWF  FEF,F
059B0:  BRA    59B8
059B2:  COMF   01,F
059B4:  MOVF   01,W
059B6:  ANDWF  FEF,F
059B8:  MOVLB  0
059BA:  RETURN 0
*
05B74:  TBLRD*+
05B76:  MOVFF  FF6,600
05B7A:  MOVFF  FF7,601
05B7E:  MOVFF  FF5,640
05B82:  CALL   520C
05B86:  MOVFF  600,FF6
05B8A:  MOVFF  601,FF7
05B8E:  MOVLB  5
05B90:  DECFSZ xFF,F
05B92:  BRA    5B96
05B94:  BRA    5B9A
05B96:  MOVLB  0
05B98:  BRA    5B74
05B9A:  MOVLB  0
05B9C:  RETURN 0
*
05F50:  MOVF   FE9,W
05F52:  MOVLB  6
05F54:  MOVWF  x38
05F56:  MOVF   x37,W
05F58:  MOVWF  x3A
05F5A:  BZ    5F94
05F5C:  MOVFF  636,64E
05F60:  MOVFF  635,64D
05F64:  MOVFF  634,64C
05F68:  MOVFF  633,64B
05F6C:  CLRF   x52
05F6E:  CLRF   x51
05F70:  MOVLW  20
05F72:  MOVWF  x50
05F74:  MOVLW  82
05F76:  MOVWF  x4F
05F78:  MOVLB  0
05F7A:  CALL   0AEA
05F7E:  MOVFF  03,636
05F82:  MOVFF  02,635
05F86:  MOVFF  01,634
05F8A:  MOVFF  00,633
05F8E:  MOVLB  6
05F90:  DECFSZ x3A,F
05F92:  BRA    5F5C
05F94:  MOVFF  636,643
05F98:  MOVFF  635,642
05F9C:  MOVFF  634,641
05FA0:  MOVFF  633,640
05FA4:  MOVLB  0
05FA6:  CALL   4D48
05FAA:  MOVFF  03,636
05FAE:  MOVFF  02,635
05FB2:  MOVFF  01,634
05FB6:  MOVFF  00,633
05FBA:  MOVLB  6
05FBC:  BTFSS  x36.7
05FBE:  BRA    5FDA
05FC0:  DECF   x38,F
05FC2:  BSF    x38.5
05FC4:  COMF   x33,F
05FC6:  COMF   x34,F
05FC8:  COMF   x35,F
05FCA:  COMF   x36,F
05FCC:  INCF   x33,F
05FCE:  BTFSC  FD8.2
05FD0:  INCF   x34,F
05FD2:  BTFSC  FD8.2
05FD4:  INCF   x35,F
05FD6:  BTFSC  FD8.2
05FD8:  INCF   x36,F
05FDA:  MOVLW  3B
05FDC:  MOVWF  x3F
05FDE:  MOVLW  9A
05FE0:  MOVWF  x3E
05FE2:  MOVLW  CA
05FE4:  MOVWF  x3D
05FE6:  CLRF   x3C
05FE8:  MOVLW  0A
05FEA:  MOVWF  x3A
05FEC:  MOVF   x37,W
05FEE:  BTFSC  FD8.2
05FF0:  INCF   x38,F
05FF2:  BSF    FD8.1
05FF4:  MOVLW  06
05FF6:  MOVWF  FEA
05FF8:  MOVLW  33
05FFA:  MOVWF  FE9
05FFC:  MOVFF  636,643
06000:  MOVFF  635,642
06004:  MOVFF  634,641
06008:  MOVFF  633,640
0600C:  MOVFF  63F,647
06010:  MOVFF  63E,646
06014:  MOVFF  63D,645
06018:  MOVFF  63C,644
0601C:  MOVLB  0
0601E:  CALL   4D8A
06022:  MOVF   01,W
06024:  MOVF   00,F
06026:  BNZ   604E
06028:  MOVLB  6
0602A:  INCF   x37,W
0602C:  SUBWF  x3A,W
0602E:  BTFSS  FD8.2
06030:  BRA    6036
06032:  MOVLB  0
06034:  BRA    604E
06036:  MOVF   x38,W
06038:  BZ    6054
0603A:  ANDLW  0F
0603C:  SUBWF  x3A,W
0603E:  BZ    6042
06040:  BC    60CA
06042:  BTFSC  x38.7
06044:  BRA    60CA
06046:  BTFSC  x38.6
06048:  BRA    6054
0604A:  MOVLW  20
0604C:  BRA    60BC
0604E:  MOVLW  20
06050:  MOVLB  6
06052:  ANDWF  x38,F
06054:  BTFSS  x38.5
06056:  BRA    6076
06058:  BCF    x38.5
0605A:  MOVF   x37,W
0605C:  BTFSS  FD8.2
0605E:  DECF   x38,F
06060:  MOVF   00,W
06062:  MOVWF  x38
06064:  MOVLW  2D
06066:  MOVWF  x40
06068:  MOVLB  0
0606A:  CALL   520C
0606E:  MOVLB  6
06070:  MOVF   x38,W
06072:  MOVWF  00
06074:  CLRF   x38
06076:  MOVF   x37,W
06078:  SUBWF  x3A,W
0607A:  BNZ   6096
0607C:  MOVF   00,W
0607E:  MOVWF  x38
06080:  MOVLW  2E
06082:  MOVWF  x40
06084:  MOVLB  0
06086:  CALL   520C
0608A:  MOVLB  6
0608C:  MOVF   x38,W
0608E:  MOVWF  00
06090:  MOVLW  20
06092:  ANDWF  x38,F
06094:  MOVLW  00
06096:  MOVLW  30
06098:  BTFSS  x38.5
0609A:  BRA    60BC
0609C:  BCF    x38.5
0609E:  MOVF   x37,W
060A0:  BTFSS  FD8.2
060A2:  DECF   x38,F
060A4:  MOVF   00,W
060A6:  MOVWF  x38
060A8:  MOVLW  2D
060AA:  MOVWF  x40
060AC:  MOVLB  0
060AE:  CALL   520C
060B2:  MOVLB  6
060B4:  MOVF   x38,W
060B6:  MOVWF  00
060B8:  CLRF   x38
060BA:  MOVLW  30
060BC:  ADDWF  00,F
060BE:  MOVFF  00,640
060C2:  MOVLB  0
060C4:  CALL   520C
060C8:  MOVLB  6
060CA:  BCF    FD8.1
060CC:  MOVFF  63F,643
060D0:  MOVFF  63E,642
060D4:  MOVFF  63D,641
060D8:  MOVFF  63C,640
060DC:  CLRF   x47
060DE:  CLRF   x46
060E0:  CLRF   x45
060E2:  MOVLW  0A
060E4:  MOVWF  x44
060E6:  MOVLB  0
060E8:  CALL   4D8A
060EC:  MOVFF  03,63F
060F0:  MOVFF  02,63E
060F4:  MOVFF  01,63D
060F8:  MOVFF  00,63C
060FC:  MOVLB  6
060FE:  DECFSZ x3A,F
06100:  BRA    5FF2
06102:  MOVLB  0
06104:  RETURN 0
*
08C14:  MOVF   FE9,W
08C16:  MOVLB  6
08C18:  MOVWF  x32
08C1A:  BTFSS  x31.7
08C1C:  BRA    8C38
08C1E:  DECF   x32,F
08C20:  BSF    x32.5
08C22:  COMF   x2E,F
08C24:  COMF   x2F,F
08C26:  COMF   x30,F
08C28:  COMF   x31,F
08C2A:  INCF   x2E,F
08C2C:  BTFSC  FD8.2
08C2E:  INCF   x2F,F
08C30:  BTFSC  FD8.2
08C32:  INCF   x30,F
08C34:  BTFSC  FD8.2
08C36:  INCF   x31,F
08C38:  MOVLW  3B
08C3A:  MOVWF  x39
08C3C:  MOVLW  9A
08C3E:  MOVWF  x38
08C40:  MOVLW  CA
08C42:  MOVWF  x37
08C44:  CLRF   x36
08C46:  MOVLW  0A
08C48:  MOVWF  x34
08C4A:  BSF    FD8.1
08C4C:  MOVLW  06
08C4E:  MOVWF  FEA
08C50:  MOVLW  2E
08C52:  MOVWF  FE9
08C54:  MOVFF  631,643
08C58:  MOVFF  630,642
08C5C:  MOVFF  62F,641
08C60:  MOVFF  62E,640
08C64:  MOVFF  639,647
08C68:  MOVFF  638,646
08C6C:  MOVFF  637,645
08C70:  MOVFF  636,644
08C74:  MOVLB  0
08C76:  CALL   4D8A
08C7A:  MOVF   01,W
08C7C:  MOVF   00,F
08C7E:  BNZ   8CA6
08C80:  MOVLB  6
08C82:  MOVF   x34,W
08C84:  XORLW  01
08C86:  BTFSS  FD8.2
08C88:  BRA    8C8E
08C8A:  MOVLB  0
08C8C:  BRA    8CA6
08C8E:  MOVF   x32,W
08C90:  BZ    8CAC
08C92:  ANDLW  0F
08C94:  SUBWF  x34,W
08C96:  BZ    8C9A
08C98:  BC    8CF6
08C9A:  BTFSC  x32.7
08C9C:  BRA    8CF6
08C9E:  BTFSC  x32.6
08CA0:  BRA    8CAC
08CA2:  MOVLW  20
08CA4:  BRA    8CE8
08CA6:  MOVLW  20
08CA8:  MOVLB  6
08CAA:  ANDWF  x32,F
08CAC:  BTFSS  x32.5
08CAE:  BRA    8CC8
08CB0:  BCF    x32.5
08CB2:  MOVFF  00,632
08CB6:  MOVLW  2D
08CB8:  MOVWF  x40
08CBA:  MOVLB  0
08CBC:  CALL   520C
08CC0:  MOVLB  6
08CC2:  MOVFF  632,00
08CC6:  CLRF   x32
08CC8:  MOVLW  30
08CCA:  BTFSS  x32.5
08CCC:  BRA    8CE8
08CCE:  BCF    x32.5
08CD0:  MOVFF  00,632
08CD4:  MOVLW  2D
08CD6:  MOVWF  x40
08CD8:  MOVLB  0
08CDA:  CALL   520C
08CDE:  MOVLB  6
08CE0:  MOVFF  632,00
08CE4:  CLRF   x32
08CE6:  MOVLW  30
08CE8:  ADDWF  00,F
08CEA:  MOVFF  00,640
08CEE:  MOVLB  0
08CF0:  CALL   520C
08CF4:  MOVLB  6
08CF6:  BCF    FD8.1
08CF8:  MOVFF  639,643
08CFC:  MOVFF  638,642
08D00:  MOVFF  637,641
08D04:  MOVFF  636,640
08D08:  CLRF   x47
08D0A:  CLRF   x46
08D0C:  CLRF   x45
08D0E:  MOVLW  0A
08D10:  MOVWF  x44
08D12:  MOVLB  0
08D14:  CALL   4D8A
08D18:  MOVFF  03,639
08D1C:  MOVFF  02,638
08D20:  MOVFF  01,637
08D24:  MOVFF  00,636
08D28:  MOVLB  6
08D2A:  DECFSZ x34,F
08D2C:  BRA    8C4A
08D2E:  MOVLB  0
08D30:  RETURN 0
*
09998:  MOVF   FEF,F
0999A:  BZ    99BC
0999C:  MOVFF  FEA,5F6
099A0:  MOVFF  FE9,5F5
099A4:  MOVFF  FEF,640
099A8:  CALL   520C
099AC:  MOVFF  5F6,FEA
099B0:  MOVFF  5F5,FE9
099B4:  INCF   FE9,F
099B6:  BTFSC  FD8.2
099B8:  INCF   FEA,F
099BA:  BRA    9998
099BC:  GOTO   9A3A (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
00424:  MOVLW  05
00426:  MOVWF  FEA
00428:  MOVLW  F5
0042A:  MOVWF  FE9
0042C:  MOVF   FEF,W
0042E:  BZ    044C
00430:  MOVLW  14
00432:  MOVWF  01
00434:  CLRF   00
00436:  DECFSZ 00,F
00438:  BRA    0436
0043A:  DECFSZ 01,F
0043C:  BRA    0434
0043E:  MOVLW  BF
00440:  MOVWF  00
00442:  DECFSZ 00,F
00444:  BRA    0442
00446:  BRA    0448
00448:  DECFSZ FEF,F
0044A:  BRA    0430
0044C:  RETURN 0
*
006EC:  MOVLW  01
006EE:  MOVLB  5
006F0:  SUBWF  xFB,F
006F2:  BNC   070C
006F4:  MOVLW  05
006F6:  MOVWF  FEA
006F8:  MOVLW  FB
006FA:  MOVWF  FE9
006FC:  MOVF   FEF,W
006FE:  BZ    070C
00700:  MOVLW  04
00702:  MOVWF  00
00704:  DECFSZ 00,F
00706:  BRA    0704
00708:  DECFSZ FEF,F
0070A:  BRA    0700
0070C:  MOVLB  0
0070E:  GOTO   0754 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20251104" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm   
.................... #define gainLvl 16          // 1, 2, 4, 8, 16, 32, 64, 128
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
0038E:  MOVLW  CF
00390:  MOVWF  F87
00392:  CLRF   F82
....................    output_b(portB_reset);
00394:  MOVLW  C4
00396:  MOVWF  F88
00398:  CLRF   F83
....................    output_c(portC_reset);
0039A:  MOVLW  93
0039C:  MOVWF  F89
0039E:  CLRF   F84
....................    output_d(portD_reset);
003A0:  MOVLW  1F
003A2:  MOVWF  F8A
003A4:  CLRF   F85
....................    output_e(portE_reset);
003A6:  BCF    F8B.0
003A8:  BCF    F8B.1
003AA:  BCF    F8B.2
003AC:  BCF    F8B.3
003AE:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
003B0:  MOVLB  F
003B2:  SETF   x0B
....................    port_b_pullups(portB_pullups);
003B4:  CLRF   x13
....................    port_c_pullups(portC_pullups);
003B6:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
003B8:  SETF   x20
....................    port_e_pullups(portE_pullups);
003BA:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
003BC:  MOVLW  40
003BE:  MOVWF  x0C
003C0:  CLRF   x14
003C2:  MOVLW  03
003C4:  MOVWF  x1C
003C6:  MOVLW  0F
003C8:  MOVWF  x21
003CA:  CLRF   x29
003CC:  MOVLB  0
003CE:  GOTO   9E50 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
05194:  MOVFF  632,FEA
05198:  MOVLB  6
0519A:  MOVFF  631,FE9
0519E:  MOVFF  FEF,635
051A2:  MOVFF  634,FEA
051A6:  MOVFF  633,FE9
051AA:  MOVF   FEF,W
051AC:  SUBWF  x35,W
051AE:  BNZ   51DE
....................       if (*s1 == '\0')
051B0:  MOVFF  632,03
051B4:  MOVFF  631,FE9
051B8:  MOVFF  03,FEA
051BC:  MOVF   FEF,F
051BE:  BNZ   51C6
....................          return(0);
051C0:  MOVLW  00
051C2:  MOVWF  01
051C4:  BRA    5208
051C6:  MOVFF  632,03
051CA:  MOVF   x31,W
051CC:  INCF   x31,F
051CE:  BTFSC  FD8.2
051D0:  INCF   x32,F
051D2:  INCF   x33,F
051D4:  BTFSC  FD8.2
051D6:  INCF   x34,F
051D8:  MOVLB  0
051DA:  BRA    5194
051DC:  MOVLB  6
....................    return((*s1 < *s2) ? -1: 1);
051DE:  MOVFF  632,03
051E2:  MOVFF  631,FE9
051E6:  MOVFF  03,FEA
051EA:  MOVFF  FEF,635
051EE:  MOVFF  634,03
051F2:  MOVFF  633,FE9
051F6:  MOVFF  03,FEA
051FA:  MOVF   FEF,W
051FC:  SUBWF  x35,W
051FE:  BC    5204
05200:  MOVLW  FF
05202:  BRA    5206
05204:  MOVLW  01
05206:  MOVWF  01
05208:  MOVLB  0
0520A:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
05324:  MOVFF  65D,660
....................    for(su=s;0<n;++su,--n)
05328:  MOVFF  65C,662
0532C:  MOVFF  65B,661
05330:  MOVLB  6
05332:  MOVF   x5F,F
05334:  BNZ   533C
05336:  MOVF   x5E,W
05338:  SUBLW  00
0533A:  BC    5364
....................       if(*su==uc)
0533C:  MOVFF  662,FEA
05340:  MOVFF  661,FE9
05344:  MOVF   x60,W
05346:  SUBWF  FEF,W
05348:  BNZ   5354
....................       return su;
0534A:  MOVFF  661,01
0534E:  MOVFF  662,02
05352:  BRA    536A
05354:  INCF   x61,F
05356:  BTFSC  FD8.2
05358:  INCF   x62,F
0535A:  MOVF   x5E,W
0535C:  BTFSC  FD8.2
0535E:  DECF   x5F,F
05360:  DECF   x5E,F
05362:  BRA    5332
....................    return NULL;
05364:  MOVLW  00
05366:  MOVWF  01
05368:  MOVWF  02
0536A:  MOVLB  0
0536C:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
0515C:  MOVFF  632,634
05160:  MOVFF  631,633
05164:  MOVFF  634,FEA
05168:  MOVLB  6
0516A:  MOVFF  633,FE9
0516E:  MOVF   FEF,F
05170:  BZ    517E
05172:  INCF   x33,F
05174:  BTFSC  FD8.2
05176:  INCF   x34,F
05178:  MOVLB  0
0517A:  BRA    5164
0517C:  MOVLB  6
....................    return(sc - s);
0517E:  MOVF   x31,W
05180:  SUBWF  x33,W
05182:  MOVWF  00
05184:  MOVF   x32,W
05186:  SUBWFB x34,W
05188:  MOVWF  03
0518A:  MOVFF  00,01
0518E:  MOVWF  02
05190:  MOVLB  0
05192:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
0669E:  MOVLB  6
066A0:  CLRF   x0B
066A2:  CLRF   x0A
066A4:  CLRF   x09
066A6:  MOVLW  7F
066A8:  MOVWF  x08
066AA:  CLRF   x0F
066AC:  CLRF   x0E
066AE:  CLRF   x0D
066B0:  CLRF   x0C
066B2:  BSF    x10.0
066B4:  BCF    x10.1
066B6:  BCF    x10.2
066B8:  CLRF   x12
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
066BA:  MOVF   x04,W
066BC:  IORWF  x05,W
066BE:  BNZ   66CA
....................       return 0;
066C0:  CLRF   00
066C2:  CLRF   01
066C4:  CLRF   02
066C6:  CLRF   03
066C8:  BRA    68F4
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
066CA:  MOVF   x12,W
066CC:  INCF   x12,F
066CE:  ADDWF  x04,W
066D0:  MOVWF  FE9
066D2:  MOVLW  00
066D4:  ADDWFC x05,W
066D6:  MOVWF  FEA
066D8:  MOVFF  FEF,611
066DC:  MOVF   x11,F
066DE:  BTFSC  FD8.2
066E0:  BRA    6878
....................    {
....................       if (skip && !isspace(c))
066E2:  BTFSS  x10.0
066E4:  BRA    6704
066E6:  MOVF   x11,W
066E8:  SUBLW  20
066EA:  BZ    6704
....................       {
....................          skip = 0;
066EC:  BCF    x10.0
....................          if (c == '+')
066EE:  MOVF   x11,W
066F0:  SUBLW  2B
066F2:  BNZ   66FA
....................          {
....................             sign = 0;
066F4:  BCF    x10.1
....................             continue;
066F6:  BRA    6860
....................          }            
066F8:  BRA    6704
....................          else if (c == '-')
066FA:  MOVF   x11,W
066FC:  SUBLW  2D
066FE:  BNZ   6704
....................          {
....................             sign = 1;
06700:  BSF    x10.1
....................             continue;
06702:  BRA    6860
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
06704:  BTFSC  x10.0
06706:  BRA    6716
06708:  MOVF   x11,W
0670A:  SUBLW  2E
0670C:  BNZ   6716
0670E:  BTFSC  x10.2
06710:  BRA    6716
....................          point = 1;
06712:  BSF    x10.2
06714:  BRA    6860
....................       else if (!skip && isdigit(c))
06716:  BTFSC  x10.0
06718:  BRA    685A
0671A:  MOVF   x11,W
0671C:  SUBLW  2F
0671E:  BTFSC  FD8.0
06720:  BRA    685A
06722:  MOVF   x11,W
06724:  SUBLW  39
06726:  BTFSS  FD8.0
06728:  BRA    685A
....................       {
....................          c -= '0';
0672A:  MOVLW  30
0672C:  SUBWF  x11,F
....................          if (point)
0672E:  BTFSS  x10.2
06730:  BRA    67E0
....................          {
....................             pow10 = pow10 * 10.0;
06732:  MOVFF  60B,64E
06736:  MOVFF  60A,64D
0673A:  MOVFF  609,64C
0673E:  MOVFF  608,64B
06742:  CLRF   x52
06744:  CLRF   x51
06746:  MOVLW  20
06748:  MOVWF  x50
0674A:  MOVLW  82
0674C:  MOVWF  x4F
0674E:  MOVLB  0
06750:  CALL   0AEA
06754:  MOVFF  03,60B
06758:  MOVFF  02,60A
0675C:  MOVFF  01,609
06760:  MOVFF  00,608
....................             result += (float)c / pow10;   
06764:  MOVLB  6
06766:  CLRF   x50
06768:  MOVFF  611,64F
0676C:  MOVLB  0
0676E:  CALL   0AB4
06772:  MOVFF  03,616
06776:  MOVFF  02,615
0677A:  MOVFF  01,614
0677E:  MOVFF  00,613
06782:  MOVFF  03,647
06786:  MOVFF  02,646
0678A:  MOVFF  01,645
0678E:  MOVFF  00,644
06792:  MOVFF  60B,64B
06796:  MOVFF  60A,64A
0679A:  MOVFF  609,649
0679E:  MOVFF  608,648
067A2:  CALL   1514
067A6:  BCF    FD8.1
067A8:  MOVFF  60F,652
067AC:  MOVFF  60E,651
067B0:  MOVFF  60D,650
067B4:  MOVFF  60C,64F
067B8:  MOVFF  03,656
067BC:  MOVFF  02,655
067C0:  MOVFF  01,654
067C4:  MOVFF  00,653
067C8:  CALL   0BE0
067CC:  MOVFF  03,60F
067D0:  MOVFF  02,60E
067D4:  MOVFF  01,60D
067D8:  MOVFF  00,60C
....................          }
067DC:  BRA    6856
067DE:  MOVLB  6
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
067E0:  CLRF   x4E
067E2:  CLRF   x4D
067E4:  MOVLW  20
067E6:  MOVWF  x4C
067E8:  MOVLW  82
067EA:  MOVWF  x4B
067EC:  MOVFF  60F,652
067F0:  MOVFF  60E,651
067F4:  MOVFF  60D,650
067F8:  MOVFF  60C,64F
067FC:  MOVLB  0
067FE:  CALL   0AEA
06802:  MOVFF  03,616
06806:  MOVFF  02,615
0680A:  MOVFF  01,614
0680E:  MOVFF  00,613
06812:  MOVLB  6
06814:  CLRF   x50
06816:  MOVFF  611,64F
0681A:  MOVLB  0
0681C:  CALL   0AB4
06820:  BCF    FD8.1
06822:  MOVFF  616,652
06826:  MOVFF  615,651
0682A:  MOVFF  614,650
0682E:  MOVFF  613,64F
06832:  MOVFF  03,656
06836:  MOVFF  02,655
0683A:  MOVFF  01,654
0683E:  MOVFF  00,653
06842:  CALL   0BE0
06846:  MOVFF  03,60F
0684A:  MOVFF  02,60E
0684E:  MOVFF  01,60D
06852:  MOVFF  00,60C
....................          }
....................       }
06856:  BRA    6862
06858:  MOVLB  6
....................       else if (!skip)
0685A:  BTFSC  x10.0
0685C:  BRA    6860
....................          break;
0685E:  BRA    6878
06860:  MOVLB  0
06862:  MOVLB  6
06864:  MOVF   x12,W
06866:  INCF   x12,F
06868:  ADDWF  x04,W
0686A:  MOVWF  FE9
0686C:  MOVLW  00
0686E:  ADDWFC x05,W
06870:  MOVWF  FEA
06872:  MOVFF  FEF,611
06876:  BRA    66DC
....................    }
.................... 
....................    if (sign)
06878:  BTFSS  x10.1
0687A:  BRA    68B0
....................       result = -1*result;
0687C:  CLRF   x4E
0687E:  CLRF   x4D
06880:  MOVLW  80
06882:  MOVWF  x4C
06884:  MOVLW  7F
06886:  MOVWF  x4B
06888:  MOVFF  60F,652
0688C:  MOVFF  60E,651
06890:  MOVFF  60D,650
06894:  MOVFF  60C,64F
06898:  MOVLB  0
0689A:  CALL   0AEA
0689E:  MOVFF  03,60F
068A2:  MOVFF  02,60E
068A6:  MOVFF  01,60D
068AA:  MOVFF  00,60C
068AE:  MOVLB  6
....................       
....................    if(endptr)
068B0:  MOVF   x06,W
068B2:  IORWF  x07,W
068B4:  BZ    68E4
....................    {
....................       if (ptr) {
068B6:  MOVF   x12,F
068B8:  BZ    68D2
....................          ptr--;
068BA:  DECF   x12,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
068BC:  MOVFF  607,FEA
068C0:  MOVFF  606,FE9
068C4:  MOVF   x12,W
068C6:  ADDWF  x04,W
068C8:  MOVWF  FEF
068CA:  MOVLW  00
068CC:  ADDWFC x05,W
068CE:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
068D0:  BRA    68E4
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
068D2:  MOVFF  607,FEA
068D6:  MOVFF  606,FE9
068DA:  MOVFF  605,FEC
068DE:  MOVF   FED,F
068E0:  MOVFF  604,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
068E4:  MOVFF  60C,00
068E8:  MOVFF  60D,01
068EC:  MOVFF  60E,02
068F0:  MOVFF  60F,03
068F4:  MOVLB  0
068F6:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
053C4:  MOVLB  6
053C6:  CLRF   x34
053C8:  CLRF   x33
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
053CA:  MOVLW  30
053CC:  MOVWF  x36
053CE:  MOVLW  31
053D0:  MOVWF  x37
053D2:  MOVLW  32
053D4:  MOVWF  x38
053D6:  MOVLW  33
053D8:  MOVWF  x39
053DA:  MOVLW  34
053DC:  MOVWF  x3A
053DE:  MOVLW  35
053E0:  MOVWF  x3B
053E2:  MOVLW  36
053E4:  MOVWF  x3C
053E6:  MOVLW  37
053E8:  MOVWF  x3D
053EA:  MOVLW  38
053EC:  MOVWF  x3E
053EE:  MOVLW  39
053F0:  MOVWF  x3F
053F2:  MOVLW  61
053F4:  MOVWF  x40
053F6:  MOVLW  62
053F8:  MOVWF  x41
053FA:  MOVLW  63
053FC:  MOVWF  x42
053FE:  MOVLW  64
05400:  MOVWF  x43
05402:  MOVLW  65
05404:  MOVWF  x44
05406:  MOVLW  66
05408:  MOVWF  x45
0540A:  MOVLW  67
0540C:  MOVWF  x46
0540E:  MOVLW  68
05410:  MOVWF  x47
05412:  MOVLW  69
05414:  MOVWF  x48
05416:  MOVLW  6A
05418:  MOVWF  x49
0541A:  MOVLW  6B
0541C:  MOVWF  x4A
0541E:  MOVLW  6C
05420:  MOVWF  x4B
05422:  MOVLW  6D
05424:  MOVWF  x4C
05426:  MOVLW  6E
05428:  MOVWF  x4D
0542A:  MOVLW  6F
0542C:  MOVWF  x4E
0542E:  MOVLW  70
05430:  MOVWF  x4F
05432:  MOVLW  71
05434:  MOVWF  x50
05436:  MOVLW  73
05438:  MOVWF  x51
0543A:  MOVLW  74
0543C:  MOVWF  x52
0543E:  MOVLW  75
05440:  MOVWF  x53
05442:  MOVLW  76
05444:  MOVWF  x54
05446:  MOVLW  77
05448:  MOVWF  x55
0544A:  MOVLW  78
0544C:  MOVWF  x56
0544E:  MOVLW  79
05450:  MOVWF  x57
05452:  MOVLW  7A
05454:  MOVWF  x58
05456:  CLRF   x59
....................    for(sc=s;isspace(*sc);++sc);
05458:  MOVFF  629,62E
0545C:  MOVFF  628,62D
05460:  MOVFF  62E,FEA
05464:  MOVFF  62D,FE9
05468:  MOVF   FEF,W
0546A:  SUBLW  20
0546C:  BNZ   5476
0546E:  INCF   x2D,F
05470:  BTFSC  FD8.2
05472:  INCF   x2E,F
05474:  BRA    5460
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
05476:  MOVFF  62E,03
0547A:  MOVFF  62D,FE9
0547E:  MOVFF  03,FEA
05482:  MOVF   FEF,W
05484:  SUBLW  2D
05486:  BZ    5496
05488:  MOVFF  62E,FEA
0548C:  MOVFF  62D,FE9
05490:  MOVF   FEF,W
05492:  SUBLW  2B
05494:  BNZ   54A8
05496:  MOVFF  62E,FEA
0549A:  MOVF   x2D,W
0549C:  INCF   x2D,F
0549E:  BTFSC  FD8.2
054A0:  INCF   x2E,F
054A2:  MOVWF  FE9
054A4:  MOVF   FEF,W
054A6:  BRA    54AA
054A8:  MOVLW  2B
054AA:  MOVWF  x35
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
054AC:  MOVF   x35,W
054AE:  SUBLW  2D
054B0:  BZ    54C6
054B2:  BTFSC  x2C.7
054B4:  BRA    54C6
054B6:  DECFSZ x2C,W
054B8:  BRA    54BC
054BA:  BRA    54C6
054BC:  BTFSC  x2C.7
054BE:  BRA    54CA
054C0:  MOVF   x2C,W
054C2:  SUBLW  24
054C4:  BC    54CA
....................    goto StrtoulGO;
054C6:  BRA    56D2
054C8:  BRA    55C2
.................... 
....................    else if (base)
054CA:  MOVF   x2C,F
054CC:  BZ    555A
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
054CE:  MOVF   x2C,W
054D0:  SUBLW  10
054D2:  BNZ   550E
054D4:  MOVFF  62E,FEA
054D8:  MOVFF  62D,FE9
054DC:  MOVF   FEF,W
054DE:  SUBLW  30
054E0:  BNZ   550E
054E2:  MOVLW  01
054E4:  ADDWF  x2D,W
054E6:  MOVWF  FE9
054E8:  MOVLW  00
054EA:  ADDWFC x2E,W
054EC:  MOVWF  FEA
054EE:  MOVF   FEF,W
054F0:  SUBLW  78
054F2:  BZ    5506
054F4:  MOVLW  01
054F6:  ADDWF  x2D,W
054F8:  MOVWF  FE9
054FA:  MOVLW  00
054FC:  ADDWFC x2E,W
054FE:  MOVWF  FEA
05500:  MOVF   FEF,W
05502:  SUBLW  58
05504:  BNZ   550E
....................          sc+=2;
05506:  MOVLW  02
05508:  ADDWF  x2D,F
0550A:  MOVLW  00
0550C:  ADDWFC x2E,F
....................       if(base==8 && *sc =='0')
0550E:  MOVF   x2C,W
05510:  SUBLW  08
05512:  BNZ   552A
05514:  MOVFF  62E,FEA
05518:  MOVFF  62D,FE9
0551C:  MOVF   FEF,W
0551E:  SUBLW  30
05520:  BNZ   552A
....................          sc+=1;
05522:  MOVLW  01
05524:  ADDWF  x2D,F
05526:  MOVLW  00
05528:  ADDWFC x2E,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
0552A:  MOVF   x2C,W
0552C:  SUBLW  02
0552E:  BNZ   5558
05530:  MOVFF  62E,FEA
05534:  MOVFF  62D,FE9
05538:  MOVF   FEF,W
0553A:  SUBLW  30
0553C:  BNZ   5558
0553E:  MOVLW  01
05540:  ADDWF  x2D,W
05542:  MOVWF  FE9
05544:  MOVLW  00
05546:  ADDWFC x2E,W
05548:  MOVWF  FEA
0554A:  MOVF   FEF,W
0554C:  SUBLW  62
0554E:  BNZ   5558
....................          sc+=2;
05550:  MOVLW  02
05552:  ADDWF  x2D,F
05554:  MOVLW  00
05556:  ADDWFC x2E,F
.................... 
....................    }
05558:  BRA    55C2
....................    else if(*sc!='0') // base is 0, find base
0555A:  MOVFF  62E,FEA
0555E:  MOVFF  62D,FE9
05562:  MOVF   FEF,W
05564:  SUBLW  30
05566:  BZ    556E
....................       base=10;
05568:  MOVLW  0A
0556A:  MOVWF  x2C
0556C:  BRA    55C2
....................    else if (sc[1]=='x' || sc[1]=='X')
0556E:  MOVLW  01
05570:  ADDWF  x2D,W
05572:  MOVWF  FE9
05574:  MOVLW  00
05576:  ADDWFC x2E,W
05578:  MOVWF  FEA
0557A:  MOVF   FEF,W
0557C:  SUBLW  78
0557E:  BZ    5592
05580:  MOVLW  01
05582:  ADDWF  x2D,W
05584:  MOVWF  FE9
05586:  MOVLW  00
05588:  ADDWFC x2E,W
0558A:  MOVWF  FEA
0558C:  MOVF   FEF,W
0558E:  SUBLW  58
05590:  BNZ   55A0
....................       base =16,sc+=2;
05592:  MOVLW  10
05594:  MOVWF  x2C
05596:  MOVLW  02
05598:  ADDWF  x2D,F
0559A:  MOVLW  00
0559C:  ADDWFC x2E,F
0559E:  BRA    55C2
....................    else if(sc[1]=='b')
055A0:  MOVLW  01
055A2:  ADDWF  x2D,W
055A4:  MOVWF  FE9
055A6:  MOVLW  00
055A8:  ADDWFC x2E,W
055AA:  MOVWF  FEA
055AC:  MOVF   FEF,W
055AE:  SUBLW  62
055B0:  BNZ   55BE
....................       base=2,sc+=2;
055B2:  MOVLW  02
055B4:  MOVWF  x2C
055B6:  ADDWF  x2D,F
055B8:  MOVLW  00
055BA:  ADDWFC x2E,F
055BC:  BRA    55C2
....................    else
....................       base=8;
055BE:  MOVLW  08
055C0:  MOVWF  x2C
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
055C2:  MOVFF  62E,630
055C6:  MOVFF  62D,62F
055CA:  MOVFF  62E,FEA
055CE:  MOVFF  62D,FE9
055D2:  MOVF   FEF,W
055D4:  SUBLW  30
055D6:  BNZ   55E0
055D8:  INCF   x2D,F
055DA:  BTFSC  FD8.2
055DC:  INCF   x2E,F
055DE:  BRA    55CA
....................    sd=memchr(digits,tolower(*sc),base);
055E0:  MOVFF  62E,03
055E4:  MOVFF  62D,FE9
055E8:  MOVFF  03,FEA
055EC:  MOVFF  FEF,65A
055F0:  MOVF   x5A,W
055F2:  SUBLW  40
055F4:  BC    5602
055F6:  MOVF   x5A,W
055F8:  SUBLW  5A
055FA:  BNC   5602
055FC:  MOVF   x5A,W
055FE:  IORLW  20
05600:  BRA    5604
05602:  MOVF   x5A,W
05604:  MOVWF  x5A
05606:  MOVLW  06
05608:  MOVWF  x5C
0560A:  MOVLW  36
0560C:  MOVWF  x5B
0560E:  MOVFF  65A,65D
05612:  CLRF   x5F
05614:  MOVFF  62C,65E
05618:  BTFSC  x5E.7
0561A:  DECF   x5F,F
0561C:  MOVLB  0
0561E:  RCALL  5324
05620:  MOVFF  02,632
05624:  MOVFF  01,631
....................    for(; sd!=0; )
05628:  MOVLB  6
0562A:  MOVF   x31,F
0562C:  BNZ   5632
0562E:  MOVF   x32,F
05630:  BZ    56C6
....................    {
....................       x=x*base+(int16)(sd-digits);
05632:  CLRF   03
05634:  MOVF   x2C,W
05636:  MOVWF  00
05638:  BTFSC  FE8.7
0563A:  DECF   03,F
0563C:  MOVWF  x5A
0563E:  MOVFF  03,65B
05642:  MOVFF  634,65D
05646:  MOVFF  633,65C
0564A:  MOVFF  03,65F
0564E:  MOVWF  x5E
05650:  MOVLB  0
05652:  BRA    536E
05654:  MOVFF  01,65A
05658:  MOVLW  36
0565A:  MOVLB  6
0565C:  SUBWF  x31,W
0565E:  MOVWF  00
05660:  MOVLW  06
05662:  SUBWFB x32,W
05664:  MOVWF  03
05666:  MOVF   00,W
05668:  ADDWF  01,W
0566A:  MOVWF  01
0566C:  MOVF   02,W
0566E:  ADDWFC 03,F
05670:  MOVFF  01,633
05674:  MOVFF  03,634
....................       ++sc;
05678:  INCF   x2D,F
0567A:  BTFSC  FD8.2
0567C:  INCF   x2E,F
....................       sd=memchr(digits,tolower(*sc),base);
0567E:  MOVFF  62E,FEA
05682:  MOVFF  62D,FE9
05686:  MOVFF  FEF,65A
0568A:  MOVF   x5A,W
0568C:  SUBLW  40
0568E:  BC    569C
05690:  MOVF   x5A,W
05692:  SUBLW  5A
05694:  BNC   569C
05696:  MOVF   x5A,W
05698:  IORLW  20
0569A:  BRA    569E
0569C:  MOVF   x5A,W
0569E:  MOVWF  x5A
056A0:  MOVLW  06
056A2:  MOVWF  x5C
056A4:  MOVLW  36
056A6:  MOVWF  x5B
056A8:  MOVFF  65A,65D
056AC:  CLRF   x5F
056AE:  MOVFF  62C,65E
056B2:  BTFSC  x5E.7
056B4:  DECF   x5F,F
056B6:  MOVLB  0
056B8:  RCALL  5324
056BA:  MOVFF  02,632
056BE:  MOVFF  01,631
056C2:  BRA    5628
056C4:  MOVLB  6
....................    }
....................    if(s1==sc)
056C6:  MOVF   x2D,W
056C8:  SUBWF  x2F,W
056CA:  BNZ   56F4
056CC:  MOVF   x2E,W
056CE:  SUBWF  x30,W
056D0:  BNZ   56F4
....................    {
....................    StrtoulGO:
....................       if (endptr)
056D2:  MOVLB  6
056D4:  MOVF   x2A,W
056D6:  IORWF  x2B,W
056D8:  BZ    56EC
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
056DA:  MOVFF  62B,FEA
056DE:  MOVFF  62A,FE9
056E2:  MOVFF  629,FEC
056E6:  MOVF   FED,F
056E8:  MOVFF  628,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
056EC:  MOVLW  00
056EE:  MOVWF  01
056F0:  MOVWF  02
056F2:  BRA    5714
....................    }
....................    if (endptr)
056F4:  MOVF   x2A,W
056F6:  IORWF  x2B,W
056F8:  BZ    570C
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
056FA:  MOVFF  62B,FEA
056FE:  MOVFF  62A,FE9
05702:  MOVFF  62E,FEC
05706:  MOVF   FED,F
05708:  MOVFF  62D,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0570C:  MOVFF  633,01
05710:  MOVFF  634,02
05714:  MOVLB  0
05716:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0044E:  MOVLB  5
00450:  CLRF   xF5
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
00452:  CLRF   xF5
00454:  MOVF   xF4,W
00456:  SUBWF  xF5,W
00458:  BC    04B0
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
0045A:  MOVF   xF5,W
0045C:  ADDWF  xF2,W
0045E:  MOVWF  xF6
00460:  MOVLW  00
00462:  ADDWFC xF3,W
00464:  MOVWF  xF7
00466:  MOVF   xF5,W
00468:  ADDWF  xF0,W
0046A:  MOVWF  01
0046C:  MOVLW  00
0046E:  ADDWFC xF1,W
00470:  MOVWF  03
00472:  MOVF   01,W
00474:  MOVWF  FE9
00476:  MOVFF  03,FEA
0047A:  MOVFF  FEF,5F8
0047E:  BSF    F7F.7
00480:  MOVF   FF2,W
00482:  MOVWF  00
00484:  BCF    FF2.7
00486:  MOVFF  5F7,F7A
0048A:  MOVFF  5F6,F79
0048E:  MOVLW  31
00490:  MOVWF  F7B
00492:  MOVFF  5F8,F7C
00496:  MOVLB  F
00498:  MOVLW  55
0049A:  MOVWF  F81
0049C:  MOVLW  AA
0049E:  MOVWF  F81
004A0:  BSF    F80.4
004A2:  BTFSC  F80.4
004A4:  BRA    04A2
004A6:  MOVF   00,W
004A8:  IORWF  FF2,F
004AA:  MOVLB  5
004AC:  INCF   xF5,F
004AE:  BRA    0454
....................    }
004B0:  MOVLB  0
004B2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D2:  MOVLB  5
003D4:  CLRF   xF5
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003D6:  CLRF   xF5
003D8:  MOVF   xF4,W
003DA:  SUBWF  xF5,W
003DC:  BC    0420
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
003DE:  MOVF   xF5,W
003E0:  ADDWF  xF0,W
003E2:  MOVWF  01
003E4:  MOVLW  00
003E6:  ADDWFC xF1,W
003E8:  MOVWF  03
003EA:  MOVF   01,W
003EC:  MOVWF  FE9
003EE:  MOVFF  03,FEA
003F2:  MOVF   xF5,W
003F4:  ADDWF  xF2,W
003F6:  MOVWF  xF8
003F8:  MOVLW  00
003FA:  ADDWFC xF3,W
003FC:  MOVWF  xF9
003FE:  BSF    F7F.7
00400:  MOVFF  FF2,5FA
00404:  BCF    FF2.7
00406:  MOVFF  5F9,F7A
0040A:  MOVFF  5F8,F79
0040E:  MOVLW  31
00410:  MOVWF  F7B
00412:  BSF    F80.0
00414:  MOVF   F7C,W
00416:  BTFSC  xFA.7
00418:  BSF    FF2.7
0041A:  MOVWF  FEF
0041C:  INCF   xF5,F
0041E:  BRA    03D8
....................    }
00420:  MOVLB  0
00422:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
004B4:  MOVLB  5
004B6:  CLRF   xF1
004B8:  MOVLW  20
004BA:  MOVWF  xF0
004BC:  CLRF   xF3
004BE:  CLRF   xF2
004C0:  MOVLW  80
004C2:  MOVWF  xF4
004C4:  MOVLB  0
004C6:  RCALL  044E
....................    delay_ms(1);
004C8:  MOVLW  01
004CA:  MOVLB  5
004CC:  MOVWF  xF5
004CE:  MOVLB  0
004D0:  RCALL  0424
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
004D2:  MOVLB  5
004D4:  CLRF   xF1
004D6:  MOVLW  60
004D8:  MOVWF  xF0
004DA:  CLRF   xF3
004DC:  MOVLW  80
004DE:  MOVWF  xF2
004E0:  MOVLW  02
004E2:  MOVWF  xF4
004E4:  MOVLB  0
004E6:  RCALL  044E
....................    delay_ms(1);
004E8:  MOVLW  01
004EA:  MOVLB  5
004EC:  MOVWF  xF5
004EE:  MOVLB  0
004F0:  RCALL  0424
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
004F2:  MOVLB  5
004F4:  CLRF   xF1
004F6:  MOVLW  61
004F8:  MOVWF  xF0
004FA:  CLRF   xF3
004FC:  MOVLW  90
004FE:  MOVWF  xF2
00500:  MOVLW  02
00502:  MOVWF  xF4
00504:  MOVLB  0
00506:  RCALL  044E
....................    delay_ms(1);
00508:  MOVLW  01
0050A:  MOVLB  5
0050C:  MOVWF  xF5
0050E:  MOVLB  0
00510:  RCALL  0424
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00512:  MOVLB  5
00514:  CLRF   xF1
00516:  MOVLW  62
00518:  MOVWF  xF0
0051A:  CLRF   xF3
0051C:  MOVLW  A0
0051E:  MOVWF  xF2
00520:  MOVLW  20
00522:  MOVWF  xF4
00524:  MOVLB  0
00526:  RCALL  044E
....................    delay_ms(1);
00528:  MOVLW  01
0052A:  MOVLB  5
0052C:  MOVWF  xF5
0052E:  MOVLB  0
00530:  RCALL  0424
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00532:  MOVLB  5
00534:  CLRF   xF1
00536:  MOVLW  82
00538:  MOVWF  xF0
0053A:  CLRF   xF3
0053C:  MOVLW  C0
0053E:  MOVWF  xF2
00540:  MOVLW  30
00542:  MOVWF  xF4
00544:  MOVLB  0
00546:  RCALL  044E
....................    delay_ms(1);
00548:  MOVLW  01
0054A:  MOVLB  5
0054C:  MOVWF  xF5
0054E:  MOVLB  0
00550:  RCALL  0424
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00552:  MOVLB  5
00554:  CLRF   xF1
00556:  MOVLW  B2
00558:  MOVWF  xF0
0055A:  CLRF   xF3
0055C:  MOVLW  F0
0055E:  MOVWF  xF2
00560:  MOVLW  38
00562:  MOVWF  xF4
00564:  MOVLB  0
00566:  RCALL  044E
....................    delay_ms(1);
00568:  MOVLW  01
0056A:  MOVLB  5
0056C:  MOVWF  xF5
0056E:  MOVLB  0
00570:  RCALL  0424
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00572:  MOVLB  5
00574:  CLRF   xF1
00576:  MOVLW  F2
00578:  MOVWF  xF0
0057A:  MOVLW  01
0057C:  MOVWF  xF3
0057E:  MOVLW  40
00580:  MOVWF  xF2
00582:  MOVLW  01
00584:  MOVWF  xF4
00586:  MOVLB  0
00588:  RCALL  044E
....................    delay_ms(1);
0058A:  MOVLW  01
0058C:  MOVLB  5
0058E:  MOVWF  xF5
00590:  MOVLB  0
00592:  RCALL  0424
00594:  GOTO   0664 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00598:  MOVLB  5
0059A:  CLRF   xF1
0059C:  MOVLW  20
0059E:  MOVWF  xF0
005A0:  CLRF   xF3
005A2:  CLRF   xF2
005A4:  MOVLW  80
005A6:  MOVWF  xF4
005A8:  MOVLB  0
005AA:  RCALL  03D2
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
005AC:  MOVLB  5
005AE:  CLRF   xF1
005B0:  MOVLW  60
005B2:  MOVWF  xF0
005B4:  CLRF   xF3
005B6:  MOVLW  80
005B8:  MOVWF  xF2
005BA:  MOVLW  02
005BC:  MOVWF  xF4
005BE:  MOVLB  0
005C0:  RCALL  03D2
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
005C2:  MOVLB  5
005C4:  CLRF   xF1
005C6:  MOVLW  61
005C8:  MOVWF  xF0
005CA:  CLRF   xF3
005CC:  MOVLW  90
005CE:  MOVWF  xF2
005D0:  MOVLW  02
005D2:  MOVWF  xF4
005D4:  MOVLB  0
005D6:  RCALL  03D2
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
005D8:  MOVLB  5
005DA:  CLRF   xF1
005DC:  MOVLW  62
005DE:  MOVWF  xF0
005E0:  CLRF   xF3
005E2:  MOVLW  A0
005E4:  MOVWF  xF2
005E6:  MOVLW  20
005E8:  MOVWF  xF4
005EA:  MOVLB  0
005EC:  RCALL  03D2
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
005EE:  MOVLB  5
005F0:  CLRF   xF1
005F2:  MOVLW  82
005F4:  MOVWF  xF0
005F6:  CLRF   xF3
005F8:  MOVLW  C0
005FA:  MOVWF  xF2
005FC:  MOVLW  30
005FE:  MOVWF  xF4
00600:  MOVLB  0
00602:  RCALL  03D2
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
00604:  MOVLB  5
00606:  CLRF   xF1
00608:  MOVLW  B2
0060A:  MOVWF  xF0
0060C:  CLRF   xF3
0060E:  MOVLW  F0
00610:  MOVWF  xF2
00612:  MOVLW  38
00614:  MOVWF  xF4
00616:  MOVLB  0
00618:  RCALL  03D2
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
0061A:  MOVLB  5
0061C:  CLRF   xF1
0061E:  MOVLW  F2
00620:  MOVWF  xF0
00622:  MOVLW  01
00624:  MOVWF  xF3
00626:  MOVLW  40
00628:  MOVWF  xF2
0062A:  MOVLW  01
0062C:  MOVWF  xF4
0062E:  MOVLB  0
00630:  RCALL  03D2
00632:  GOTO   0668 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
00636:  MOVLB  5
00638:  CLRF   xF1
0063A:  MOVLW  F2
0063C:  MOVWF  xF0
0063E:  MOVLW  01
00640:  MOVWF  xF3
00642:  MOVLW  40
00644:  MOVWF  xF2
00646:  MOVLW  01
00648:  MOVWF  xF4
0064A:  MOVLB  0
0064C:  RCALL  03D2
....................    delay_ms(1);
0064E:  MOVLW  01
00650:  MOVLB  5
00652:  MOVWF  xF5
00654:  MOVLB  0
00656:  RCALL  0424
....................    if (paramsValid != isValid)
00658:  MOVF   xF2,W
0065A:  SUBLW  AA
0065C:  BZ    0666
....................    {
....................       paramsValid = isValid;
0065E:  MOVLW  AA
00660:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
00662:  BRA    04B4
....................    }
00664:  BRA    0668
....................    else
....................    {
....................       params_load_from_ee();
00666:  BRA    0598
....................    }
00668:  GOTO   9E54 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
.................... //!setup_spi2(SPI_MASTER | SPI_SCK_IDLE_LOW | SPI_XMIT_H_TO_L | SPI_CLK_DIV_64);
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g1|PGAenabled // 0x30//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x10
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {   
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3); 
00144:  MOVLW  C4
00146:  MOVWF  F88
00148:  BSF    F83.0
....................    delay_us(10);
0014A:  MOVLW  35
0014C:  MOVWF  00
0014E:  DECFSZ 00,F
00150:  BRA    014E
00152:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
0066C:  RCALL  0136
....................    switch(ch)
0066E:  MOVLB  6
00670:  MOVF   x00,W
00672:  ADDLW  FC
00674:  BC    06A8
00676:  ADDLW  04
00678:  MOVLB  0
0067A:  GOTO   06B4
....................    {
....................       case 0:
....................          output_low(_CS0);
0067E:  MOVLW  1F
00680:  MOVWF  F8A
00682:  BCF    F85.5
....................       break; 
00684:  MOVLB  6
00686:  BRA    06A8
....................       case 1:
....................          output_low(_CS1);
00688:  MOVLW  1F
0068A:  MOVWF  F8A
0068C:  BCF    F85.6
....................       break;   
0068E:  MOVLB  6
00690:  BRA    06A8
....................       case 2:
....................          output_low(_CS2);
00692:  MOVLW  1F
00694:  MOVWF  F8A
00696:  BCF    F85.7
....................       break;
00698:  MOVLB  6
0069A:  BRA    06A8
....................       case 3:
....................          output_low(_CS3);
0069C:  MOVLW  C4
0069E:  MOVWF  F88
006A0:  BCF    F83.0
....................       break;              
006A2:  MOVLB  6
006A4:  BRA    06A8
006A6:  MOVLB  6
....................    }
....................    delay_us(10);
006A8:  MOVLW  35
006AA:  MOVWF  00
006AC:  DECFSZ 00,F
006AE:  BRA    06AC
006B0:  MOVLB  0
006B2:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
00154:  RCALL  0136
....................    switch(block)
00156:  MOVLB  6
00158:  MOVF   x67,W
0015A:  XORLW  00
0015C:  MOVLB  0
0015E:  BZ    0166
00160:  XORLW  01
00162:  BZ    0172
00164:  BRA    017E
....................    {
....................       case 0:
....................          output_low(_CS0);
00166:  MOVLW  1F
00168:  MOVWF  F8A
0016A:  BCF    F85.5
....................          output_low(_CS1);
0016C:  MOVWF  F8A
0016E:  BCF    F85.6
....................       break; 
00170:  BRA    017E
....................       case 1:         
....................          output_low(_CS2);
00172:  MOVLW  1F
00174:  MOVWF  F8A
00176:  BCF    F85.7
....................          output_low(_CS3);
00178:  MOVLW  C4
0017A:  MOVWF  F88
0017C:  BCF    F83.0
....................       break;         
....................    }
....................    delay_us(10);
0017E:  MOVLW  35
00180:  MOVWF  00
00182:  DECFSZ 00,F
00184:  BRA    0182
00186:  GOTO   0190 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO AN ADC                                          */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
006D6:  MOVFF  5FE,600
006DA:  RCALL  066C
....................    spi_write2(command);
006DC:  MOVLB  E
006DE:  MOVF   x8D,W
006E0:  MOVFF  5FF,E8D
006E4:  RRCF   x90,W
006E6:  BNC   06E4
006E8:  MOVLB  0
006EA:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
0018A:  MOVFF  665,667
0018E:  BRA    0154
....................    spi_write2(command);
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  666,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVLB  0
0019E:  GOTO   01B0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PREPARE TO READ FROM AN ADC                                               */
.................... /*****************************************************************************/
.................... void ads_read_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
013D6:  MOVFF  5FE,600
013DA:  CALL   066C
....................    spi_read2(command);
013DE:  MOVLB  E
013E0:  MOVF   x8D,W
013E2:  MOVFF  5FF,E8D
013E6:  RRCF   x90,W
013E8:  BNC   13E6
013EA:  MOVLB  0
013EC:  GOTO   13FE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE TO THE CONFIGURATION REGISTERS                                      */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00712:  MOVLB  5
00714:  MOVF   xFB,W
00716:  IORLW  40
00718:  MOVWF  xFD
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0071A:  MOVFF  5FA,5FE
0071E:  MOVFF  5FD,5FF
00722:  MOVLB  0
00724:  RCALL  06D6
....................    spi_write2(data);
00726:  MOVLB  E
00728:  MOVF   x8D,W
0072A:  MOVFF  5FC,E8D
0072E:  RRCF   x90,W
00730:  BNC   072E
....................    ads_deselect_all();
00732:  MOVLB  0
00734:  RCALL  0136
00736:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ FROM THE CONFIGURATION REGISTERS                                     */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_read_command(ch, command);
....................    unsigned int8 data = spi_read2(0);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* START BLOCK CONVERSION                                                    */
.................... /*****************************************************************************/
.................... void ads_start_conv_block(int8 block)
.................... {
....................    ads_write_command_block(block, ADSstart);
*
001A2:  MOVFF  664,665
001A6:  MOVLW  08
001A8:  MOVLB  6
001AA:  MOVWF  x66
001AC:  MOVLB  0
001AE:  BRA    018A
....................    delay_us(20);
001B0:  MOVLW  6A
001B2:  MOVWF  00
001B4:  DECFSZ 00,F
001B6:  BRA    01B4
001B8:  NOP   
....................    ads_deselect_all();
001BA:  RCALL  0136
001BC:  GOTO   01F4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ THE MOST RECENT CONVERSION                                           */
.................... /*****************************************************************************/
.................... signed int32 ads_read_data(int8 ch)
.................... {
....................    union Data
....................    {
....................       unsigned int8 dBytes[4];
....................       signed int32 dWord;
....................    }data;
....................    
....................    ads_read_command(ch, ADSreadData);
*
013F0:  MOVFF  5F9,5FE
013F4:  MOVLW  10
013F6:  MOVLB  5
013F8:  MOVWF  xFF
013FA:  MOVLB  0
013FC:  BRA    13D6
....................    data.dBytes[0] = 0;
013FE:  MOVLB  5
01400:  CLRF   xFA
....................    data.dBytes[3] = spi_read2(0);
01402:  MOVLB  E
01404:  MOVF   x8D,W
01406:  CLRF   x8D
01408:  RRCF   x90,W
0140A:  BNC   1408
0140C:  MOVFF  E8D,5FD
....................    data.dBytes[2] = spi_read2(0);
01410:  MOVF   x8D,W
01412:  CLRF   x8D
01414:  RRCF   x90,W
01416:  BNC   1414
01418:  MOVFF  E8D,5FC
....................    data.dBytes[1] = spi_read2(0);
0141C:  MOVF   x8D,W
0141E:  CLRF   x8D
01420:  RRCF   x90,W
01422:  BNC   1420
01424:  MOVFF  E8D,5FB
....................    
....................    ads_deselect_all();
01428:  MOVLB  0
0142A:  CALL   0136
....................    return data.dWord;
0142E:  MOVFF  5FA,00
01432:  MOVFF  5FB,01
01436:  MOVFF  5FC,02
0143A:  MOVFF  5FD,03
0143E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
00738:  MOVFF  5F5,5FE
0073C:  MOVLW  06
0073E:  MOVLB  5
00740:  MOVWF  xFF
00742:  MOVLB  0
00744:  RCALL  06D6
....................    delay_us(300);                    
00746:  MOVLW  02
00748:  MOVLB  5
0074A:  MOVWF  xFA
0074C:  MOVLW  96
0074E:  MOVWF  xFB
00750:  MOVLB  0
00752:  BRA    06EC
00754:  MOVLB  5
00756:  DECFSZ xFA,F
00758:  BRA    074C
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
0075A:  MOVFF  5F5,5FA
0075E:  CLRF   xFB
00760:  MOVFF  5F6,5FC
00764:  MOVLB  0
00766:  RCALL  0712
....................    ads_write_reg(ch, reg1, rc1);
00768:  MOVFF  5F5,5FA
0076C:  MOVLW  04
0076E:  MOVLB  5
00770:  MOVWF  xFB
00772:  MOVFF  5F7,5FC
00776:  MOVLB  0
00778:  RCALL  0712
....................    ads_write_reg(ch, reg2, rc2);
0077A:  MOVFF  5F5,5FA
0077E:  MOVLW  08
00780:  MOVLB  5
00782:  MOVWF  xFB
00784:  MOVFF  5F8,5FC
00788:  MOVLB  0
0078A:  RCALL  0712
....................    ads_write_reg(ch, reg3, rc3);  
0078C:  MOVFF  5F5,5FA
00790:  MOVLW  0C
00792:  MOVLB  5
00794:  MOVWF  xFB
00796:  MOVFF  5F9,5FC
0079A:  MOVLB  0
0079C:  RCALL  0712
0079E:  GOTO   07DA (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01ECA:  MOVLB  6
01ECC:  BCF    x4A.0
....................    y = x;
01ECE:  MOVFF  63E,643
01ED2:  MOVFF  63D,642
01ED6:  MOVFF  63C,641
01EDA:  MOVFF  63B,640
.................... 
....................    if (x < 0)
01EDE:  MOVFF  63E,64E
01EE2:  MOVFF  63D,64D
01EE6:  MOVFF  63C,64C
01EEA:  MOVFF  63B,64B
01EEE:  CLRF   x52
01EF0:  CLRF   x51
01EF2:  CLRF   x50
01EF4:  CLRF   x4F
01EF6:  MOVLB  0
01EF8:  CALL   149A
01EFC:  BNC   1F0A
....................    {
....................       s = 1;
01EFE:  MOVLB  6
01F00:  BSF    x4A.0
....................       y = -y;
01F02:  MOVF   x41,W
01F04:  XORLW  80
01F06:  MOVWF  x41
01F08:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01F0A:  MOVFF  643,64E
01F0E:  MOVFF  642,64D
01F12:  MOVFF  641,64C
01F16:  MOVFF  640,64B
01F1A:  MOVLB  6
01F1C:  CLRF   x52
01F1E:  CLRF   x51
01F20:  CLRF   x50
01F22:  MOVLW  8E
01F24:  MOVWF  x4F
01F26:  MOVLB  0
01F28:  CALL   149A
01F2C:  BC    1F30
01F2E:  BNZ   1F60
....................       res = (float32)(unsigned int16)y;
01F30:  MOVFF  643,64E
01F34:  MOVFF  642,64D
01F38:  MOVFF  641,64C
01F3C:  MOVFF  640,64B
01F40:  RCALL  1E8E
01F42:  MOVFF  02,650
01F46:  MOVFF  01,64F
01F4A:  CALL   0AB4
01F4E:  MOVFF  03,647
01F52:  MOVFF  02,646
01F56:  MOVFF  01,645
01F5A:  MOVFF  00,644
01F5E:  BRA    2102
.................... 
....................  else if (y < 10000000.0)
01F60:  MOVFF  643,64E
01F64:  MOVFF  642,64D
01F68:  MOVFF  641,64C
01F6C:  MOVFF  640,64B
01F70:  MOVLW  80
01F72:  MOVLB  6
01F74:  MOVWF  x52
01F76:  MOVLW  96
01F78:  MOVWF  x51
01F7A:  MOVLW  18
01F7C:  MOVWF  x50
01F7E:  MOVLW  96
01F80:  MOVWF  x4F
01F82:  MOVLB  0
01F84:  CALL   149A
01F88:  BTFSS  FD8.0
01F8A:  BRA    20F2
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01F8C:  MOVFF  643,64E
01F90:  MOVFF  642,64D
01F94:  MOVFF  641,64C
01F98:  MOVFF  640,64B
01F9C:  MOVLB  6
01F9E:  CLRF   x52
01FA0:  CLRF   x51
01FA2:  CLRF   x50
01FA4:  MOVLW  70
01FA6:  MOVWF  x4F
01FA8:  MOVLB  0
01FAA:  CALL   0AEA
01FAE:  MOVFF  03,64E
01FB2:  MOVFF  02,64D
01FB6:  MOVFF  01,64C
01FBA:  MOVFF  00,64B
01FBE:  RCALL  1E8E
01FC0:  MOVFF  02,649
01FC4:  MOVFF  01,648
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01FC8:  MOVFF  643,64E
01FCC:  MOVFF  642,64D
01FD0:  MOVFF  641,64C
01FD4:  MOVFF  640,64B
01FD8:  MOVLB  6
01FDA:  CLRF   x52
01FDC:  CLRF   x51
01FDE:  CLRF   x50
01FE0:  MOVLW  70
01FE2:  MOVWF  x4F
01FE4:  MOVLB  0
01FE6:  CALL   0AEA
01FEA:  MOVFF  03,64E
01FEE:  MOVFF  02,64D
01FF2:  MOVFF  01,64C
01FF6:  MOVFF  00,64B
01FFA:  MOVFF  649,650
01FFE:  MOVFF  648,64F
02002:  CALL   0AB4
02006:  BSF    FD8.1
02008:  MOVFF  64E,652
0200C:  MOVFF  64D,651
02010:  MOVFF  64C,650
02014:  MOVFF  64B,64F
02018:  MOVFF  03,656
0201C:  MOVFF  02,655
02020:  MOVFF  01,654
02024:  MOVFF  00,653
02028:  CALL   0BE0
0202C:  MOVLB  6
0202E:  CLRF   x4E
02030:  CLRF   x4D
02032:  CLRF   x4C
02034:  MOVLW  8E
02036:  MOVWF  x4B
02038:  MOVFF  03,652
0203C:  MOVFF  02,651
02040:  MOVFF  01,650
02044:  MOVFF  00,64F
02048:  MOVLB  0
0204A:  CALL   0AEA
0204E:  MOVFF  03,643
02052:  MOVFF  02,642
02056:  MOVFF  01,641
0205A:  MOVFF  00,640
....................       res = 32768.0*(float32)l;
0205E:  MOVFF  649,650
02062:  MOVFF  648,64F
02066:  CALL   0AB4
0206A:  MOVLB  6
0206C:  CLRF   x4E
0206E:  CLRF   x4D
02070:  CLRF   x4C
02072:  MOVLW  8E
02074:  MOVWF  x4B
02076:  MOVFF  03,652
0207A:  MOVFF  02,651
0207E:  MOVFF  01,650
02082:  MOVFF  00,64F
02086:  MOVLB  0
02088:  CALL   0AEA
0208C:  MOVFF  03,647
02090:  MOVFF  02,646
02094:  MOVFF  01,645
02098:  MOVFF  00,644
....................       res += (float32)(unsigned int16)y;
0209C:  MOVFF  643,64E
020A0:  MOVFF  642,64D
020A4:  MOVFF  641,64C
020A8:  MOVFF  640,64B
020AC:  RCALL  1E8E
020AE:  MOVFF  02,650
020B2:  MOVFF  01,64F
020B6:  CALL   0AB4
020BA:  BCF    FD8.1
020BC:  MOVFF  647,652
020C0:  MOVFF  646,651
020C4:  MOVFF  645,650
020C8:  MOVFF  644,64F
020CC:  MOVFF  03,656
020D0:  MOVFF  02,655
020D4:  MOVFF  01,654
020D8:  MOVFF  00,653
020DC:  CALL   0BE0
020E0:  MOVFF  03,647
020E4:  MOVFF  02,646
020E8:  MOVFF  01,645
020EC:  MOVFF  00,644
....................    }
020F0:  BRA    2102
.................... 
....................  else
....................   res = y;
020F2:  MOVFF  643,647
020F6:  MOVFF  642,646
020FA:  MOVFF  641,645
020FE:  MOVFF  640,644
.................... 
....................  y = y - (float32)(unsigned int16)y;
02102:  MOVFF  643,64E
02106:  MOVFF  642,64D
0210A:  MOVFF  641,64C
0210E:  MOVFF  640,64B
02112:  RCALL  1E8E
02114:  MOVFF  02,650
02118:  MOVFF  01,64F
0211C:  CALL   0AB4
02120:  BSF    FD8.1
02122:  MOVFF  643,652
02126:  MOVFF  642,651
0212A:  MOVFF  641,650
0212E:  MOVFF  640,64F
02132:  MOVFF  03,656
02136:  MOVFF  02,655
0213A:  MOVFF  01,654
0213E:  MOVFF  00,653
02142:  CALL   0BE0
02146:  MOVFF  03,643
0214A:  MOVFF  02,642
0214E:  MOVFF  01,641
02152:  MOVFF  00,640
.................... 
....................  if (s)
02156:  MOVLB  6
02158:  BTFSS  x4A.0
0215A:  BRA    2162
....................   res = -res;
0215C:  MOVF   x45,W
0215E:  XORLW  80
02160:  MOVWF  x45
.................... 
....................  if (y != 0)
02162:  MOVFF  643,64E
02166:  MOVFF  642,64D
0216A:  MOVFF  641,64C
0216E:  MOVFF  640,64B
02172:  CLRF   x52
02174:  CLRF   x51
02176:  CLRF   x50
02178:  CLRF   x4F
0217A:  MOVLB  0
0217C:  CALL   149A
02180:  BZ    21FA
....................  {
....................   if (s == 1 && n == 0)
02182:  MOVLB  6
02184:  BTFSS  x4A.0
02186:  BRA    21C0
02188:  MOVF   x3F,F
0218A:  BNZ   21C0
....................    res -= 1.0;
0218C:  BSF    FD8.1
0218E:  MOVFF  647,652
02192:  MOVFF  646,651
02196:  MOVFF  645,650
0219A:  MOVFF  644,64F
0219E:  CLRF   x56
021A0:  CLRF   x55
021A2:  CLRF   x54
021A4:  MOVLW  7F
021A6:  MOVWF  x53
021A8:  MOVLB  0
021AA:  CALL   0BE0
021AE:  MOVFF  03,647
021B2:  MOVFF  02,646
021B6:  MOVFF  01,645
021BA:  MOVFF  00,644
021BE:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
021C0:  BTFSC  x4A.0
021C2:  BRA    21FC
021C4:  DECFSZ x3F,W
021C6:  BRA    21FC
....................    res += 1.0;
021C8:  BCF    FD8.1
021CA:  MOVFF  647,652
021CE:  MOVFF  646,651
021D2:  MOVFF  645,650
021D6:  MOVFF  644,64F
021DA:  CLRF   x56
021DC:  CLRF   x55
021DE:  CLRF   x54
021E0:  MOVLW  7F
021E2:  MOVWF  x53
021E4:  MOVLB  0
021E6:  CALL   0BE0
021EA:  MOVFF  03,647
021EE:  MOVFF  02,646
021F2:  MOVFF  01,645
021F6:  MOVFF  00,644
021FA:  MOVLB  6
....................  }
....................  if (x == 0)
021FC:  MOVFF  63E,64E
02200:  MOVFF  63D,64D
02204:  MOVFF  63C,64C
02208:  MOVFF  63B,64B
0220C:  CLRF   x52
0220E:  CLRF   x51
02210:  CLRF   x50
02212:  CLRF   x4F
02214:  MOVLB  0
02216:  CALL   149A
0221A:  BNZ   2228
....................     res = 0;
0221C:  MOVLB  6
0221E:  CLRF   x47
02220:  CLRF   x46
02222:  CLRF   x45
02224:  CLRF   x44
02226:  MOVLB  0
.................... 
....................  return (res);
02228:  MOVFF  644,00
0222C:  MOVFF  645,01
02230:  MOVFF  646,02
02234:  MOVFF  647,03
02238:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
02258:  MOVFF  63A,63E
0225C:  MOVFF  639,63D
02260:  MOVFF  638,63C
02264:  MOVFF  637,63B
02268:  MOVLB  6
0226A:  CLRF   x3F
0226C:  MOVLB  0
0226E:  RCALL  1ECA
02270:  GOTO   237C (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
0223A:  MOVFF  63A,63E
0223E:  MOVFF  639,63D
02242:  MOVFF  638,63C
02246:  MOVFF  637,63B
0224A:  MOVLW  01
0224C:  MOVLB  6
0224E:  MOVWF  x3F
02250:  MOVLB  0
02252:  RCALL  1ECA
02254:  GOTO   2334 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
02274:  MOVFF  62E,64E
02278:  MOVFF  62D,64D
0227C:  MOVFF  62C,64C
02280:  MOVFF  62B,64B
02284:  MOVLB  6
02286:  CLRF   x52
02288:  CLRF   x51
0228A:  CLRF   x50
0228C:  CLRF   x4F
0228E:  MOVLB  0
02290:  CALL   149A
02294:  BTFSC  FD8.2
02296:  BRA    23D8
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
02298:  MOVFF  62A,647
0229C:  MOVFF  629,646
022A0:  MOVFF  628,645
022A4:  MOVFF  627,644
022A8:  MOVFF  62E,64B
022AC:  MOVFF  62D,64A
022B0:  MOVFF  62C,649
022B4:  MOVFF  62B,648
022B8:  CALL   1514
022BC:  MOVFF  03,636
022C0:  MOVFF  02,635
022C4:  MOVFF  01,634
022C8:  MOVFF  00,633
022CC:  MOVFF  03,64E
022D0:  MOVFF  02,64D
022D4:  MOVFF  01,64C
022D8:  MOVFF  00,64B
022DC:  MOVLB  6
022DE:  CLRF   x52
022E0:  CLRF   x51
022E2:  CLRF   x50
022E4:  CLRF   x4F
022E6:  MOVLB  0
022E8:  CALL   149A
022EC:  BNC   2336
022EE:  MOVFF  62A,647
022F2:  MOVFF  629,646
022F6:  MOVFF  628,645
022FA:  MOVFF  627,644
022FE:  MOVFF  62E,64B
02302:  MOVFF  62D,64A
02306:  MOVFF  62C,649
0230A:  MOVFF  62B,648
0230E:  CALL   1514
02312:  MOVFF  03,636
02316:  MOVFF  02,635
0231A:  MOVFF  01,634
0231E:  MOVFF  00,633
02322:  MOVFF  03,63A
02326:  MOVFF  02,639
0232A:  MOVFF  01,638
0232E:  MOVFF  00,637
02332:  BRA    223A
02334:  BRA    237C
02336:  MOVFF  62A,647
0233A:  MOVFF  629,646
0233E:  MOVFF  628,645
02342:  MOVFF  627,644
02346:  MOVFF  62E,64B
0234A:  MOVFF  62D,64A
0234E:  MOVFF  62C,649
02352:  MOVFF  62B,648
02356:  CALL   1514
0235A:  MOVFF  03,636
0235E:  MOVFF  02,635
02362:  MOVFF  01,634
02366:  MOVFF  00,633
0236A:  MOVFF  03,63A
0236E:  MOVFF  02,639
02372:  MOVFF  01,638
02376:  MOVFF  00,637
0237A:  BRA    2258
0237C:  MOVFF  03,632
02380:  MOVFF  02,631
02384:  MOVFF  01,630
02388:  MOVFF  00,62F
....................       return(x-(i*y));
0238C:  MOVFF  632,64E
02390:  MOVFF  631,64D
02394:  MOVFF  630,64C
02398:  MOVFF  62F,64B
0239C:  MOVFF  62E,652
023A0:  MOVFF  62D,651
023A4:  MOVFF  62C,650
023A8:  MOVFF  62B,64F
023AC:  CALL   0AEA
023B0:  BSF    FD8.1
023B2:  MOVFF  62A,652
023B6:  MOVFF  629,651
023BA:  MOVFF  628,650
023BE:  MOVFF  627,64F
023C2:  MOVFF  03,656
023C6:  MOVFF  02,655
023CA:  MOVFF  01,654
023CE:  MOVFF  00,653
023D2:  CALL   0BE0
023D6:  BRA    23D8
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
023D8:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
0276E:  MOVFF  62E,64E
02772:  MOVFF  62D,64D
02776:  MOVFF  62C,64C
0277A:  MOVFF  62B,64B
0277E:  MOVLW  3B
02780:  MOVLB  6
02782:  MOVWF  x52
02784:  MOVLW  AA
02786:  MOVWF  x51
02788:  MOVLW  38
0278A:  MOVWF  x50
0278C:  MOVLW  7F
0278E:  MOVWF  x4F
02790:  MOVLB  0
02792:  CALL   0AEA
02796:  MOVFF  03,64E
0279A:  MOVFF  02,64D
0279E:  MOVFF  01,64C
027A2:  MOVFF  00,64B
027A6:  CALL   1E8E
027AA:  MOVFF  01,63B
....................    s = 0;
027AE:  MOVLB  6
027B0:  BCF    x3C.0
....................    y = x;
027B2:  MOVFF  62E,632
027B6:  MOVFF  62D,631
027BA:  MOVFF  62C,630
027BE:  MOVFF  62B,62F
.................... 
....................    if (x < 0)
027C2:  MOVFF  62E,64E
027C6:  MOVFF  62D,64D
027CA:  MOVFF  62C,64C
027CE:  MOVFF  62B,64B
027D2:  CLRF   x52
027D4:  CLRF   x51
027D6:  CLRF   x50
027D8:  CLRF   x4F
027DA:  MOVLB  0
027DC:  CALL   149A
027E0:  BNC   27F0
....................    {
....................       s = 1;
027E2:  MOVLB  6
027E4:  BSF    x3C.0
....................       n = -n;
027E6:  NEGF   x3B
....................       y = -y;
027E8:  MOVF   x30,W
027EA:  XORLW  80
027EC:  MOVWF  x30
027EE:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
027F0:  MOVLB  6
027F2:  CLRF   x36
027F4:  CLRF   x35
027F6:  CLRF   x34
027F8:  CLRF   x33
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
027FA:  MOVLW  06
027FC:  MOVWF  x3E
027FE:  MOVLW  33
02800:  MOVFF  63E,FEA
02804:  MOVWF  FE9
02806:  MOVLW  7F
02808:  ADDWF  x3B,W
0280A:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
0280C:  MOVFF  632,64E
02810:  MOVFF  631,64D
02814:  MOVFF  630,64C
02818:  MOVFF  62F,64B
0281C:  MOVLW  3B
0281E:  MOVWF  x52
02820:  MOVLW  AA
02822:  MOVWF  x51
02824:  MOVLW  38
02826:  MOVWF  x50
02828:  MOVLW  7F
0282A:  MOVWF  x4F
0282C:  MOVLB  0
0282E:  CALL   0AEA
02832:  MOVFF  03,640
02836:  MOVFF  02,63F
0283A:  MOVFF  01,63E
0283E:  MOVFF  00,63D
02842:  MOVLB  6
02844:  CLRF   x42
02846:  MOVFF  63B,641
0284A:  BTFSC  x41.7
0284C:  DECF   x42,F
0284E:  MOVLB  0
02850:  CALL   1E3E
02854:  BSF    FD8.1
02856:  MOVFF  640,652
0285A:  MOVFF  63F,651
0285E:  MOVFF  63E,650
02862:  MOVFF  63D,64F
02866:  MOVFF  03,656
0286A:  MOVFF  02,655
0286E:  MOVFF  01,654
02872:  MOVFF  00,653
02876:  CALL   0BE0
0287A:  MOVFF  03,632
0287E:  MOVFF  02,631
02882:  MOVFF  01,630
02886:  MOVFF  00,62F
.................... 
....................    r = pe[0]*y + pe[1];
0288A:  MOVLW  7C
0288C:  MOVLB  6
0288E:  MOVWF  x4E
02890:  MOVLW  88
02892:  MOVWF  x4D
02894:  MOVLW  59
02896:  MOVWF  x4C
02898:  MOVLW  72
0289A:  MOVWF  x4B
0289C:  MOVFF  632,652
028A0:  MOVFF  631,651
028A4:  MOVFF  630,650
028A8:  MOVFF  62F,64F
028AC:  MOVLB  0
028AE:  CALL   0AEA
028B2:  MOVFF  03,640
028B6:  MOVFF  02,63F
028BA:  MOVFF  01,63E
028BE:  MOVFF  00,63D
028C2:  BCF    FD8.1
028C4:  MOVFF  03,652
028C8:  MOVFF  02,651
028CC:  MOVFF  01,650
028D0:  MOVFF  00,64F
028D4:  MOVLW  E0
028D6:  MOVLB  6
028D8:  MOVWF  x56
028DA:  MOVLW  97
028DC:  MOVWF  x55
028DE:  MOVLW  26
028E0:  MOVWF  x54
028E2:  MOVLW  75
028E4:  MOVWF  x53
028E6:  MOVLB  0
028E8:  CALL   0BE0
028EC:  MOVFF  03,63A
028F0:  MOVFF  02,639
028F4:  MOVFF  01,638
028F8:  MOVFF  00,637
....................    r = r*y + pe[2];
028FC:  MOVFF  63A,64E
02900:  MOVFF  639,64D
02904:  MOVFF  638,64C
02908:  MOVFF  637,64B
0290C:  MOVFF  632,652
02910:  MOVFF  631,651
02914:  MOVFF  630,650
02918:  MOVFF  62F,64F
0291C:  CALL   0AEA
02920:  MOVFF  03,640
02924:  MOVFF  02,63F
02928:  MOVFF  01,63E
0292C:  MOVFF  00,63D
02930:  BCF    FD8.1
02932:  MOVFF  03,652
02936:  MOVFF  02,651
0293A:  MOVFF  01,650
0293E:  MOVFF  00,64F
02942:  MOVLW  C4
02944:  MOVLB  6
02946:  MOVWF  x56
02948:  MOVLW  1D
0294A:  MOVWF  x55
0294C:  MOVLW  1E
0294E:  MOVWF  x54
02950:  MOVLW  78
02952:  MOVWF  x53
02954:  MOVLB  0
02956:  CALL   0BE0
0295A:  MOVFF  03,63A
0295E:  MOVFF  02,639
02962:  MOVFF  01,638
02966:  MOVFF  00,637
....................    r = r*y + pe[3];
0296A:  MOVFF  63A,64E
0296E:  MOVFF  639,64D
02972:  MOVFF  638,64C
02976:  MOVFF  637,64B
0297A:  MOVFF  632,652
0297E:  MOVFF  631,651
02982:  MOVFF  630,650
02986:  MOVFF  62F,64F
0298A:  CALL   0AEA
0298E:  MOVFF  03,640
02992:  MOVFF  02,63F
02996:  MOVFF  01,63E
0299A:  MOVFF  00,63D
0299E:  BCF    FD8.1
029A0:  MOVFF  03,652
029A4:  MOVFF  02,651
029A8:  MOVFF  01,650
029AC:  MOVFF  00,64F
029B0:  MOVLW  5E
029B2:  MOVLB  6
029B4:  MOVWF  x56
029B6:  MOVLW  50
029B8:  MOVWF  x55
029BA:  MOVLW  63
029BC:  MOVWF  x54
029BE:  MOVLW  7A
029C0:  MOVWF  x53
029C2:  MOVLB  0
029C4:  CALL   0BE0
029C8:  MOVFF  03,63A
029CC:  MOVFF  02,639
029D0:  MOVFF  01,638
029D4:  MOVFF  00,637
....................    r = r*y + pe[4];
029D8:  MOVFF  63A,64E
029DC:  MOVFF  639,64D
029E0:  MOVFF  638,64C
029E4:  MOVFF  637,64B
029E8:  MOVFF  632,652
029EC:  MOVFF  631,651
029F0:  MOVFF  630,650
029F4:  MOVFF  62F,64F
029F8:  CALL   0AEA
029FC:  MOVFF  03,640
02A00:  MOVFF  02,63F
02A04:  MOVFF  01,63E
02A08:  MOVFF  00,63D
02A0C:  BCF    FD8.1
02A0E:  MOVFF  03,652
02A12:  MOVFF  02,651
02A16:  MOVFF  01,650
02A1A:  MOVFF  00,64F
02A1E:  MOVLW  1A
02A20:  MOVLB  6
02A22:  MOVWF  x56
02A24:  MOVLW  FE
02A26:  MOVWF  x55
02A28:  MOVLW  75
02A2A:  MOVWF  x54
02A2C:  MOVLW  7C
02A2E:  MOVWF  x53
02A30:  MOVLB  0
02A32:  CALL   0BE0
02A36:  MOVFF  03,63A
02A3A:  MOVFF  02,639
02A3E:  MOVFF  01,638
02A42:  MOVFF  00,637
....................    r = r*y + pe[5];
02A46:  MOVFF  63A,64E
02A4A:  MOVFF  639,64D
02A4E:  MOVFF  638,64C
02A52:  MOVFF  637,64B
02A56:  MOVFF  632,652
02A5A:  MOVFF  631,651
02A5E:  MOVFF  630,650
02A62:  MOVFF  62F,64F
02A66:  CALL   0AEA
02A6A:  MOVFF  03,640
02A6E:  MOVFF  02,63F
02A72:  MOVFF  01,63E
02A76:  MOVFF  00,63D
02A7A:  BCF    FD8.1
02A7C:  MOVFF  03,652
02A80:  MOVFF  02,651
02A84:  MOVFF  01,650
02A88:  MOVFF  00,64F
02A8C:  MOVLW  18
02A8E:  MOVLB  6
02A90:  MOVWF  x56
02A92:  MOVLW  72
02A94:  MOVWF  x55
02A96:  MOVLW  31
02A98:  MOVWF  x54
02A9A:  MOVLW  7E
02A9C:  MOVWF  x53
02A9E:  MOVLB  0
02AA0:  CALL   0BE0
02AA4:  MOVFF  03,63A
02AA8:  MOVFF  02,639
02AAC:  MOVFF  01,638
02AB0:  MOVFF  00,637
.................... 
....................    res = res*(1.0 + y*r);
02AB4:  MOVFF  632,64E
02AB8:  MOVFF  631,64D
02ABC:  MOVFF  630,64C
02AC0:  MOVFF  62F,64B
02AC4:  MOVFF  63A,652
02AC8:  MOVFF  639,651
02ACC:  MOVFF  638,650
02AD0:  MOVFF  637,64F
02AD4:  CALL   0AEA
02AD8:  BCF    FD8.1
02ADA:  MOVLB  6
02ADC:  CLRF   x52
02ADE:  CLRF   x51
02AE0:  CLRF   x50
02AE2:  MOVLW  7F
02AE4:  MOVWF  x4F
02AE6:  MOVFF  03,656
02AEA:  MOVFF  02,655
02AEE:  MOVFF  01,654
02AF2:  MOVFF  00,653
02AF6:  MOVLB  0
02AF8:  CALL   0BE0
02AFC:  MOVFF  636,64E
02B00:  MOVFF  635,64D
02B04:  MOVFF  634,64C
02B08:  MOVFF  633,64B
02B0C:  MOVFF  03,652
02B10:  MOVFF  02,651
02B14:  MOVFF  01,650
02B18:  MOVFF  00,64F
02B1C:  CALL   0AEA
02B20:  MOVFF  03,636
02B24:  MOVFF  02,635
02B28:  MOVFF  01,634
02B2C:  MOVFF  00,633
.................... 
....................    if (s)
02B30:  MOVLB  6
02B32:  BTFSS  x3C.0
02B34:  BRA    2B68
....................       res = 1.0/res;
02B36:  CLRF   x47
02B38:  CLRF   x46
02B3A:  CLRF   x45
02B3C:  MOVLW  7F
02B3E:  MOVWF  x44
02B40:  MOVFF  636,64B
02B44:  MOVFF  635,64A
02B48:  MOVFF  634,649
02B4C:  MOVFF  633,648
02B50:  MOVLB  0
02B52:  CALL   1514
02B56:  MOVFF  03,636
02B5A:  MOVFF  02,635
02B5E:  MOVFF  01,634
02B62:  MOVFF  00,633
02B66:  MOVLB  6
....................    return(res);
02B68:  MOVFF  633,00
02B6C:  MOVFF  634,01
02B70:  MOVFF  635,02
02B74:  MOVFF  636,03
02B78:  MOVLB  0
02B7A:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
023DA:  MOVFF  62E,632
023DE:  MOVFF  62D,631
023E2:  MOVFF  62C,630
023E6:  MOVFF  62B,62F
.................... 
....................    if (y != 1.0)
023EA:  MOVFF  632,64E
023EE:  MOVFF  631,64D
023F2:  MOVFF  630,64C
023F6:  MOVFF  62F,64B
023FA:  MOVLB  6
023FC:  CLRF   x52
023FE:  CLRF   x51
02400:  CLRF   x50
02402:  MOVLW  7F
02404:  MOVWF  x4F
02406:  MOVLB  0
02408:  CALL   149A
0240C:  BTFSC  FD8.2
0240E:  BRA    2750
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
02410:  MOVLW  06
02412:  MOVLB  6
02414:  MOVWF  x41
02416:  MOVLW  2F
02418:  MOVFF  641,FEA
0241C:  MOVWF  FE9
0241E:  MOVLW  7E
02420:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02422:  BSF    FD8.1
02424:  MOVFF  632,652
02428:  MOVFF  631,651
0242C:  MOVFF  630,650
02430:  MOVFF  62F,64F
02434:  CLRF   x56
02436:  CLRF   x55
02438:  CLRF   x54
0243A:  MOVLW  7F
0243C:  MOVWF  x53
0243E:  MOVLB  0
02440:  CALL   0BE0
02444:  MOVFF  03,643
02448:  MOVFF  02,642
0244C:  MOVFF  01,641
02450:  MOVFF  00,640
02454:  BCF    FD8.1
02456:  MOVFF  632,652
0245A:  MOVFF  631,651
0245E:  MOVFF  630,650
02462:  MOVFF  62F,64F
02466:  MOVLB  6
02468:  CLRF   x56
0246A:  CLRF   x55
0246C:  CLRF   x54
0246E:  MOVLW  7F
02470:  MOVWF  x53
02472:  MOVLB  0
02474:  CALL   0BE0
02478:  MOVFF  643,647
0247C:  MOVFF  642,646
02480:  MOVFF  641,645
02484:  MOVFF  640,644
02488:  MOVFF  03,64B
0248C:  MOVFF  02,64A
02490:  MOVFF  01,649
02494:  MOVFF  00,648
02498:  CALL   1514
0249C:  MOVFF  03,632
024A0:  MOVFF  02,631
024A4:  MOVFF  01,630
024A8:  MOVFF  00,62F
.................... 
....................       y2=y*y;
024AC:  MOVFF  632,64E
024B0:  MOVFF  631,64D
024B4:  MOVFF  630,64C
024B8:  MOVFF  62F,64B
024BC:  MOVFF  632,652
024C0:  MOVFF  631,651
024C4:  MOVFF  630,650
024C8:  MOVFF  62F,64F
024CC:  CALL   0AEA
024D0:  MOVFF  03,63E
024D4:  MOVFF  02,63D
024D8:  MOVFF  01,63C
024DC:  MOVFF  00,63B
.................... 
....................       res = pl[0]*y2 + pl[1];
024E0:  MOVLW  99
024E2:  MOVLB  6
024E4:  MOVWF  x4E
024E6:  MOVLW  47
024E8:  MOVWF  x4D
024EA:  MOVLW  8A
024EC:  MOVWF  x4C
024EE:  MOVLW  7F
024F0:  MOVWF  x4B
024F2:  MOVFF  63E,652
024F6:  MOVFF  63D,651
024FA:  MOVFF  63C,650
024FE:  MOVFF  63B,64F
02502:  MOVLB  0
02504:  CALL   0AEA
02508:  MOVFF  03,643
0250C:  MOVFF  02,642
02510:  MOVFF  01,641
02514:  MOVFF  00,640
02518:  BCF    FD8.1
0251A:  MOVFF  03,652
0251E:  MOVFF  02,651
02522:  MOVFF  01,650
02526:  MOVFF  00,64F
0252A:  MOVLB  6
0252C:  CLRF   x56
0252E:  CLRF   x55
02530:  CLRF   x54
02532:  MOVLW  80
02534:  MOVWF  x53
02536:  MOVLB  0
02538:  CALL   0BE0
0253C:  MOVFF  03,636
02540:  MOVFF  02,635
02544:  MOVFF  01,634
02548:  MOVFF  00,633
.................... 
....................       r = ql[0]*y2 + ql[1];
0254C:  MOVLW  4C
0254E:  MOVLB  6
02550:  MOVWF  x4E
02552:  MOVLW  F3
02554:  MOVWF  x4D
02556:  MOVLW  3A
02558:  MOVWF  x4C
0255A:  MOVLW  7B
0255C:  MOVWF  x4B
0255E:  MOVFF  63E,652
02562:  MOVFF  63D,651
02566:  MOVFF  63C,650
0256A:  MOVFF  63B,64F
0256E:  MOVLB  0
02570:  CALL   0AEA
02574:  MOVFF  03,643
02578:  MOVFF  02,642
0257C:  MOVFF  01,641
02580:  MOVFF  00,640
02584:  BCF    FD8.1
02586:  MOVFF  03,652
0258A:  MOVFF  02,651
0258E:  MOVFF  01,650
02592:  MOVFF  00,64F
02596:  MOVLW  2B
02598:  MOVLB  6
0259A:  MOVWF  x56
0259C:  MOVLW  9D
0259E:  MOVWF  x55
025A0:  MOVLW  DF
025A2:  MOVWF  x54
025A4:  MOVLW  7E
025A6:  MOVWF  x53
025A8:  MOVLB  0
025AA:  CALL   0BE0
025AE:  MOVFF  03,63A
025B2:  MOVFF  02,639
025B6:  MOVFF  01,638
025BA:  MOVFF  00,637
....................       r = r*y2 + 1.0;
025BE:  MOVFF  63A,64E
025C2:  MOVFF  639,64D
025C6:  MOVFF  638,64C
025CA:  MOVFF  637,64B
025CE:  MOVFF  63E,652
025D2:  MOVFF  63D,651
025D6:  MOVFF  63C,650
025DA:  MOVFF  63B,64F
025DE:  CALL   0AEA
025E2:  MOVFF  03,643
025E6:  MOVFF  02,642
025EA:  MOVFF  01,641
025EE:  MOVFF  00,640
025F2:  BCF    FD8.1
025F4:  MOVFF  03,652
025F8:  MOVFF  02,651
025FC:  MOVFF  01,650
02600:  MOVFF  00,64F
02604:  MOVLB  6
02606:  CLRF   x56
02608:  CLRF   x55
0260A:  CLRF   x54
0260C:  MOVLW  7F
0260E:  MOVWF  x53
02610:  MOVLB  0
02612:  CALL   0BE0
02616:  MOVFF  03,63A
0261A:  MOVFF  02,639
0261E:  MOVFF  01,638
02622:  MOVFF  00,637
.................... 
....................       res = y*res/r;
02626:  MOVFF  632,64E
0262A:  MOVFF  631,64D
0262E:  MOVFF  630,64C
02632:  MOVFF  62F,64B
02636:  MOVFF  636,652
0263A:  MOVFF  635,651
0263E:  MOVFF  634,650
02642:  MOVFF  633,64F
02646:  CALL   0AEA
0264A:  MOVFF  03,643
0264E:  MOVFF  02,642
02652:  MOVFF  01,641
02656:  MOVFF  00,640
0265A:  MOVFF  03,647
0265E:  MOVFF  02,646
02662:  MOVFF  01,645
02666:  MOVFF  00,644
0266A:  MOVFF  63A,64B
0266E:  MOVFF  639,64A
02672:  MOVFF  638,649
02676:  MOVFF  637,648
0267A:  CALL   1514
0267E:  MOVFF  03,636
02682:  MOVFF  02,635
02686:  MOVFF  01,634
0268A:  MOVFF  00,633
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
0268E:  MOVLW  06
02690:  MOVLB  6
02692:  MOVWF  x41
02694:  MOVLW  2B
02696:  MOVFF  641,FEA
0269A:  MOVWF  FE9
0269C:  MOVLW  7E
0269E:  SUBWF  FEF,W
026A0:  MOVWF  x3F
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
026A2:  BTFSS  x3F.7
026A4:  BRA    26D0
....................          r = -(float32)-n;
026A6:  MOVLW  00
026A8:  BSF    FD8.0
026AA:  SUBFWB x3F,W
026AC:  CLRF   x42
026AE:  MOVWF  x41
026B0:  BTFSC  x41.7
026B2:  DECF   x42,F
026B4:  MOVLB  0
026B6:  CALL   1E3E
026BA:  MOVFF  00,637
026BE:  MOVF   01,W
026C0:  XORLW  80
026C2:  MOVLB  6
026C4:  MOVWF  x38
026C6:  MOVFF  02,639
026CA:  MOVFF  03,63A
026CE:  BRA    26F2
....................       else
....................          r = (float32)n;
026D0:  CLRF   x42
026D2:  MOVFF  63F,641
026D6:  BTFSC  x41.7
026D8:  DECF   x42,F
026DA:  MOVLB  0
026DC:  CALL   1E3E
026E0:  MOVFF  03,63A
026E4:  MOVFF  02,639
026E8:  MOVFF  01,638
026EC:  MOVFF  00,637
026F0:  MOVLB  6
.................... 
....................       res += r*LN2;
026F2:  MOVFF  63A,64E
026F6:  MOVFF  639,64D
026FA:  MOVFF  638,64C
026FE:  MOVFF  637,64B
02702:  MOVLW  18
02704:  MOVWF  x52
02706:  MOVLW  72
02708:  MOVWF  x51
0270A:  MOVLW  31
0270C:  MOVWF  x50
0270E:  MOVLW  7E
02710:  MOVWF  x4F
02712:  MOVLB  0
02714:  CALL   0AEA
02718:  BCF    FD8.1
0271A:  MOVFF  636,652
0271E:  MOVFF  635,651
02722:  MOVFF  634,650
02726:  MOVFF  633,64F
0272A:  MOVFF  03,656
0272E:  MOVFF  02,655
02732:  MOVFF  01,654
02736:  MOVFF  00,653
0273A:  CALL   0BE0
0273E:  MOVFF  03,636
02742:  MOVFF  02,635
02746:  MOVFF  01,634
0274A:  MOVFF  00,633
....................    }
0274E:  BRA    275C
.................... 
....................    else
....................       res = 0.0;
02750:  MOVLB  6
02752:  CLRF   x36
02754:  CLRF   x35
02756:  CLRF   x34
02758:  CLRF   x33
0275A:  MOVLB  0
.................... 
....................    return(res);
0275C:  MOVFF  633,00
02760:  MOVFF  634,01
02764:  MOVFF  635,02
02768:  MOVFF  636,03
0276C:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02B7C:  MOVFF  622,64E
02B80:  MOVFF  621,64D
02B84:  MOVFF  620,64C
02B88:  MOVFF  61F,64B
02B8C:  MOVLB  6
02B8E:  CLRF   x52
02B90:  CLRF   x51
02B92:  CLRF   x50
02B94:  CLRF   x4F
02B96:  MOVLB  0
02B98:  CALL   149A
02B9C:  BTFSS  FD8.0
02B9E:  BRA    2D3A
02BA0:  MOVFF  626,62A
02BA4:  MOVFF  625,629
02BA8:  MOVFF  624,628
02BAC:  MOVFF  623,627
02BB0:  MOVLB  6
02BB2:  CLRF   x2E
02BB4:  CLRF   x2D
02BB6:  CLRF   x2C
02BB8:  MOVLW  7F
02BBA:  MOVWF  x2B
02BBC:  MOVLB  0
02BBE:  CALL   2274
02BC2:  MOVFF  03,62A
02BC6:  MOVFF  02,629
02BCA:  MOVFF  01,628
02BCE:  MOVFF  00,627
02BD2:  MOVFF  03,64E
02BD6:  MOVFF  02,64D
02BDA:  MOVFF  01,64C
02BDE:  MOVFF  00,64B
02BE2:  MOVLB  6
02BE4:  CLRF   x52
02BE6:  CLRF   x51
02BE8:  CLRF   x50
02BEA:  CLRF   x4F
02BEC:  MOVLB  0
02BEE:  CALL   149A
02BF2:  BTFSS  FD8.2
02BF4:  BRA    2D3A
....................       if(fmod(y, 2) == 0) {
02BF6:  MOVFF  626,62A
02BFA:  MOVFF  625,629
02BFE:  MOVFF  624,628
02C02:  MOVFF  623,627
02C06:  MOVLB  6
02C08:  CLRF   x2E
02C0A:  CLRF   x2D
02C0C:  CLRF   x2C
02C0E:  MOVLW  80
02C10:  MOVWF  x2B
02C12:  MOVLB  0
02C14:  CALL   2274
02C18:  MOVFF  03,62A
02C1C:  MOVFF  02,629
02C20:  MOVFF  01,628
02C24:  MOVFF  00,627
02C28:  MOVFF  03,64E
02C2C:  MOVFF  02,64D
02C30:  MOVFF  01,64C
02C34:  MOVFF  00,64B
02C38:  MOVLB  6
02C3A:  CLRF   x52
02C3C:  CLRF   x51
02C3E:  CLRF   x50
02C40:  CLRF   x4F
02C42:  MOVLB  0
02C44:  CALL   149A
02C48:  BNZ   2CC0
....................          return (exp(log(-x) * y));
02C4A:  MOVLB  6
02C4C:  MOVF   x20,W
02C4E:  XORLW  80
02C50:  MOVWF  x28
02C52:  MOVFF  622,62E
02C56:  MOVFF  621,62D
02C5A:  MOVWF  x2C
02C5C:  MOVFF  61F,62B
02C60:  MOVLB  0
02C62:  CALL   23DA
02C66:  MOVFF  03,62A
02C6A:  MOVFF  02,629
02C6E:  MOVFF  01,628
02C72:  MOVFF  00,627
02C76:  MOVFF  03,64E
02C7A:  MOVFF  02,64D
02C7E:  MOVFF  01,64C
02C82:  MOVFF  00,64B
02C86:  MOVFF  626,652
02C8A:  MOVFF  625,651
02C8E:  MOVFF  624,650
02C92:  MOVFF  623,64F
02C96:  CALL   0AEA
02C9A:  MOVFF  03,62A
02C9E:  MOVFF  02,629
02CA2:  MOVFF  01,628
02CA6:  MOVFF  00,627
02CAA:  MOVFF  03,62E
02CAE:  MOVFF  02,62D
02CB2:  MOVFF  01,62C
02CB6:  MOVFF  00,62B
02CBA:  RCALL  276E
02CBC:  BRA    2E78
....................       } else {
02CBE:  BRA    2D38
....................          return (-exp(log(-x) * y));
02CC0:  MOVLB  6
02CC2:  MOVF   x20,W
02CC4:  XORLW  80
02CC6:  MOVWF  x28
02CC8:  MOVFF  622,62E
02CCC:  MOVFF  621,62D
02CD0:  MOVWF  x2C
02CD2:  MOVFF  61F,62B
02CD6:  MOVLB  0
02CD8:  CALL   23DA
02CDC:  MOVFF  03,62A
02CE0:  MOVFF  02,629
02CE4:  MOVFF  01,628
02CE8:  MOVFF  00,627
02CEC:  MOVFF  03,64E
02CF0:  MOVFF  02,64D
02CF4:  MOVFF  01,64C
02CF8:  MOVFF  00,64B
02CFC:  MOVFF  626,652
02D00:  MOVFF  625,651
02D04:  MOVFF  624,650
02D08:  MOVFF  623,64F
02D0C:  CALL   0AEA
02D10:  MOVFF  03,62A
02D14:  MOVFF  02,629
02D18:  MOVFF  01,628
02D1C:  MOVFF  00,627
02D20:  MOVFF  03,62E
02D24:  MOVFF  02,62D
02D28:  MOVFF  01,62C
02D2C:  MOVFF  00,62B
02D30:  RCALL  276E
02D32:  MOVLW  80
02D34:  XORWF  01,F
02D36:  BRA    2E78
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02D38:  BRA    2E78
02D3A:  MOVFF  622,64E
02D3E:  MOVFF  621,64D
02D42:  MOVFF  620,64C
02D46:  MOVFF  61F,64B
02D4A:  MOVLB  6
02D4C:  CLRF   x52
02D4E:  CLRF   x51
02D50:  CLRF   x50
02D52:  CLRF   x4F
02D54:  MOVLB  0
02D56:  CALL   149A
02D5A:  BNC   2DBC
02D5C:  MOVFF  626,62A
02D60:  MOVFF  625,629
02D64:  MOVFF  624,628
02D68:  MOVFF  623,627
02D6C:  MOVLB  6
02D6E:  CLRF   x2E
02D70:  CLRF   x2D
02D72:  CLRF   x2C
02D74:  MOVLW  7F
02D76:  MOVWF  x2B
02D78:  MOVLB  0
02D7A:  CALL   2274
02D7E:  MOVFF  03,62A
02D82:  MOVFF  02,629
02D86:  MOVFF  01,628
02D8A:  MOVFF  00,627
02D8E:  MOVFF  03,64E
02D92:  MOVFF  02,64D
02D96:  MOVFF  01,64C
02D9A:  MOVFF  00,64B
02D9E:  MOVLB  6
02DA0:  CLRF   x52
02DA2:  CLRF   x51
02DA4:  CLRF   x50
02DA6:  CLRF   x4F
02DA8:  MOVLB  0
02DAA:  CALL   149A
02DAE:  BZ    2DBC
....................       return 0;
02DB0:  CLRF   00
02DB2:  CLRF   01
02DB4:  CLRF   02
02DB6:  CLRF   03
02DB8:  BRA    2E78
....................    } else {
02DBA:  BRA    2E78
....................       if(x != 0 || 0 >= y) {
02DBC:  MOVFF  622,64E
02DC0:  MOVFF  621,64D
02DC4:  MOVFF  620,64C
02DC8:  MOVFF  61F,64B
02DCC:  MOVLB  6
02DCE:  CLRF   x52
02DD0:  CLRF   x51
02DD2:  CLRF   x50
02DD4:  CLRF   x4F
02DD6:  MOVLB  0
02DD8:  CALL   149A
02DDC:  BNZ   2E02
02DDE:  MOVFF  626,64E
02DE2:  MOVFF  625,64D
02DE6:  MOVFF  624,64C
02DEA:  MOVFF  623,64B
02DEE:  MOVLB  6
02DF0:  CLRF   x52
02DF2:  CLRF   x51
02DF4:  CLRF   x50
02DF6:  CLRF   x4F
02DF8:  MOVLB  0
02DFA:  CALL   149A
02DFE:  BC    2E02
02E00:  BNZ   2E70
....................          return (exp(log(x) * y));
02E02:  MOVFF  622,62E
02E06:  MOVFF  621,62D
02E0A:  MOVFF  620,62C
02E0E:  MOVFF  61F,62B
02E12:  CALL   23DA
02E16:  MOVFF  03,62A
02E1A:  MOVFF  02,629
02E1E:  MOVFF  01,628
02E22:  MOVFF  00,627
02E26:  MOVFF  03,64E
02E2A:  MOVFF  02,64D
02E2E:  MOVFF  01,64C
02E32:  MOVFF  00,64B
02E36:  MOVFF  626,652
02E3A:  MOVFF  625,651
02E3E:  MOVFF  624,650
02E42:  MOVFF  623,64F
02E46:  CALL   0AEA
02E4A:  MOVFF  03,62A
02E4E:  MOVFF  02,629
02E52:  MOVFF  01,628
02E56:  MOVFF  00,627
02E5A:  MOVFF  03,62E
02E5E:  MOVFF  02,62D
02E62:  MOVFF  01,62C
02E66:  MOVFF  00,62B
02E6A:  RCALL  276E
02E6C:  BRA    2E78
....................       } else return 0;
02E6E:  BRA    2E78
02E70:  CLRF   00
02E72:  CLRF   01
02E74:  CLRF   02
02E76:  CLRF   03
....................    }
02E78:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01672:  MOVLB  6
01674:  BCF    x3D.0
....................    flag = 0;
01676:  BCF    x3D.1
....................    y = x;
01678:  MOVFF  630,634
0167C:  MOVFF  62F,633
01680:  MOVFF  62E,632
01684:  MOVFF  62D,631
.................... 
....................    if (x < 0)
01688:  MOVFF  630,64E
0168C:  MOVFF  62F,64D
01690:  MOVFF  62E,64C
01694:  MOVFF  62D,64B
01698:  CLRF   x52
0169A:  CLRF   x51
0169C:  CLRF   x50
0169E:  CLRF   x4F
016A0:  MOVLB  0
016A2:  RCALL  149A
016A4:  BNC   16B2
....................    {
....................       s = 1;
016A6:  MOVLB  6
016A8:  BSF    x3D.0
....................       y = -y;
016AA:  MOVF   x32,W
016AC:  XORLW  80
016AE:  MOVWF  x32
016B0:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
016B2:  MOVLB  6
016B4:  CLRF   x4E
016B6:  CLRF   x4D
016B8:  CLRF   x4C
016BA:  MOVLW  7F
016BC:  MOVWF  x4B
016BE:  MOVFF  634,652
016C2:  MOVFF  633,651
016C6:  MOVFF  632,650
016CA:  MOVFF  631,64F
016CE:  MOVLB  0
016D0:  RCALL  149A
016D2:  BNC   170A
....................    {
....................       y = 1.0/y;
016D4:  MOVLB  6
016D6:  CLRF   x47
016D8:  CLRF   x46
016DA:  CLRF   x45
016DC:  MOVLW  7F
016DE:  MOVWF  x44
016E0:  MOVFF  634,64B
016E4:  MOVFF  633,64A
016E8:  MOVFF  632,649
016EC:  MOVFF  631,648
016F0:  MOVLB  0
016F2:  RCALL  1514
016F4:  MOVFF  03,634
016F8:  MOVFF  02,633
016FC:  MOVFF  01,632
01700:  MOVFF  00,631
....................       flag = 1;
01704:  MOVLB  6
01706:  BSF    x3D.1
01708:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
0170A:  MOVLW  0A
0170C:  MOVLB  6
0170E:  MOVWF  x4E
01710:  MOVLW  89
01712:  MOVWF  x4D
01714:  MOVLW  34
01716:  MOVWF  x4C
01718:  MOVLW  7C
0171A:  MOVWF  x4B
0171C:  MOVFF  634,652
01720:  MOVFF  633,651
01724:  MOVFF  632,650
01728:  MOVFF  631,64F
0172C:  MOVLB  0
0172E:  CALL   0AEA
01732:  MOVFF  03,641
01736:  MOVFF  02,640
0173A:  MOVFF  01,63F
0173E:  MOVFF  00,63E
01742:  MOVFF  03,64E
01746:  MOVFF  02,64D
0174A:  MOVFF  01,64C
0174E:  MOVFF  00,64B
01752:  MOVFF  634,652
01756:  MOVFF  633,651
0175A:  MOVFF  632,650
0175E:  MOVFF  631,64F
01762:  CALL   0AEA
01766:  MOVFF  03,641
0176A:  MOVFF  02,640
0176E:  MOVFF  01,63F
01772:  MOVFF  00,63E
01776:  BCF    FD8.1
01778:  MOVFF  03,652
0177C:  MOVFF  02,651
01780:  MOVFF  01,650
01784:  MOVFF  00,64F
01788:  MOVLW  7C
0178A:  MOVLB  6
0178C:  MOVWF  x56
0178E:  MOVLW  79
01790:  MOVWF  x55
01792:  MOVLW  35
01794:  MOVWF  x54
01796:  MOVLW  81
01798:  MOVWF  x53
0179A:  MOVLB  0
0179C:  CALL   0BE0
017A0:  MOVFF  03,638
017A4:  MOVFF  02,637
017A8:  MOVFF  01,636
017AC:  MOVFF  00,635
....................    res = res*y*y + pat[2];
017B0:  MOVFF  638,64E
017B4:  MOVFF  637,64D
017B8:  MOVFF  636,64C
017BC:  MOVFF  635,64B
017C0:  MOVFF  634,652
017C4:  MOVFF  633,651
017C8:  MOVFF  632,650
017CC:  MOVFF  631,64F
017D0:  CALL   0AEA
017D4:  MOVFF  03,641
017D8:  MOVFF  02,640
017DC:  MOVFF  01,63F
017E0:  MOVFF  00,63E
017E4:  MOVFF  03,64E
017E8:  MOVFF  02,64D
017EC:  MOVFF  01,64C
017F0:  MOVFF  00,64B
017F4:  MOVFF  634,652
017F8:  MOVFF  633,651
017FC:  MOVFF  632,650
01800:  MOVFF  631,64F
01804:  CALL   0AEA
01808:  MOVFF  03,641
0180C:  MOVFF  02,640
01810:  MOVFF  01,63F
01814:  MOVFF  00,63E
01818:  BCF    FD8.1
0181A:  MOVFF  03,652
0181E:  MOVFF  02,651
01822:  MOVFF  01,650
01826:  MOVFF  00,64F
0182A:  MOVLW  3F
0182C:  MOVLB  6
0182E:  MOVWF  x56
01830:  MOVLW  02
01832:  MOVWF  x55
01834:  MOVLW  33
01836:  MOVWF  x54
01838:  MOVLW  83
0183A:  MOVWF  x53
0183C:  MOVLB  0
0183E:  CALL   0BE0
01842:  MOVFF  03,638
01846:  MOVFF  02,637
0184A:  MOVFF  01,636
0184E:  MOVFF  00,635
....................    res = res*y*y + pat[3];
01852:  MOVFF  638,64E
01856:  MOVFF  637,64D
0185A:  MOVFF  636,64C
0185E:  MOVFF  635,64B
01862:  MOVFF  634,652
01866:  MOVFF  633,651
0186A:  MOVFF  632,650
0186E:  MOVFF  631,64F
01872:  CALL   0AEA
01876:  MOVFF  03,641
0187A:  MOVFF  02,640
0187E:  MOVFF  01,63F
01882:  MOVFF  00,63E
01886:  MOVFF  03,64E
0188A:  MOVFF  02,64D
0188E:  MOVFF  01,64C
01892:  MOVFF  00,64B
01896:  MOVFF  634,652
0189A:  MOVFF  633,651
0189E:  MOVFF  632,650
018A2:  MOVFF  631,64F
018A6:  CALL   0AEA
018AA:  MOVFF  03,641
018AE:  MOVFF  02,640
018B2:  MOVFF  01,63F
018B6:  MOVFF  00,63E
018BA:  BCF    FD8.1
018BC:  MOVFF  03,652
018C0:  MOVFF  02,651
018C4:  MOVFF  01,650
018C8:  MOVFF  00,64F
018CC:  MOVLW  33
018CE:  MOVLB  6
018D0:  MOVWF  x56
018D2:  MOVLW  8C
018D4:  MOVWF  x55
018D6:  MOVLW  1E
018D8:  MOVWF  x54
018DA:  MOVLW  83
018DC:  MOVWF  x53
018DE:  MOVLB  0
018E0:  CALL   0BE0
018E4:  MOVFF  03,638
018E8:  MOVFF  02,637
018EC:  MOVFF  01,636
018F0:  MOVFF  00,635
.................... 
....................    r = qat[0]*y*y + qat[1];
018F4:  MOVLB  6
018F6:  CLRF   x4E
018F8:  CLRF   x4D
018FA:  CLRF   x4C
018FC:  MOVLW  7F
018FE:  MOVWF  x4B
01900:  MOVFF  634,652
01904:  MOVFF  633,651
01908:  MOVFF  632,650
0190C:  MOVFF  631,64F
01910:  MOVLB  0
01912:  CALL   0AEA
01916:  MOVFF  03,641
0191A:  MOVFF  02,640
0191E:  MOVFF  01,63F
01922:  MOVFF  00,63E
01926:  MOVFF  03,64E
0192A:  MOVFF  02,64D
0192E:  MOVFF  01,64C
01932:  MOVFF  00,64B
01936:  MOVFF  634,652
0193A:  MOVFF  633,651
0193E:  MOVFF  632,650
01942:  MOVFF  631,64F
01946:  CALL   0AEA
0194A:  MOVFF  03,641
0194E:  MOVFF  02,640
01952:  MOVFF  01,63F
01956:  MOVFF  00,63E
0195A:  BCF    FD8.1
0195C:  MOVFF  03,652
01960:  MOVFF  02,651
01964:  MOVFF  01,650
01968:  MOVFF  00,64F
0196C:  MOVLW  1B
0196E:  MOVLB  6
01970:  MOVWF  x56
01972:  MOVLW  E4
01974:  MOVWF  x55
01976:  MOVLW  35
01978:  MOVWF  x54
0197A:  MOVLW  82
0197C:  MOVWF  x53
0197E:  MOVLB  0
01980:  CALL   0BE0
01984:  MOVFF  03,63C
01988:  MOVFF  02,63B
0198C:  MOVFF  01,63A
01990:  MOVFF  00,639
....................    r = r*y*y + qat[2];
01994:  MOVFF  63C,64E
01998:  MOVFF  63B,64D
0199C:  MOVFF  63A,64C
019A0:  MOVFF  639,64B
019A4:  MOVFF  634,652
019A8:  MOVFF  633,651
019AC:  MOVFF  632,650
019B0:  MOVFF  631,64F
019B4:  CALL   0AEA
019B8:  MOVFF  03,641
019BC:  MOVFF  02,640
019C0:  MOVFF  01,63F
019C4:  MOVFF  00,63E
019C8:  MOVFF  03,64E
019CC:  MOVFF  02,64D
019D0:  MOVFF  01,64C
019D4:  MOVFF  00,64B
019D8:  MOVFF  634,652
019DC:  MOVFF  633,651
019E0:  MOVFF  632,650
019E4:  MOVFF  631,64F
019E8:  CALL   0AEA
019EC:  MOVFF  03,641
019F0:  MOVFF  02,640
019F4:  MOVFF  01,63F
019F8:  MOVFF  00,63E
019FC:  BCF    FD8.1
019FE:  MOVFF  03,652
01A02:  MOVFF  02,651
01A06:  MOVFF  01,650
01A0A:  MOVFF  00,64F
01A0E:  MOVLW  A4
01A10:  MOVLB  6
01A12:  MOVWF  x56
01A14:  MOVLW  DB
01A16:  MOVWF  x55
01A18:  MOVLW  67
01A1A:  MOVWF  x54
01A1C:  MOVLW  83
01A1E:  MOVWF  x53
01A20:  MOVLB  0
01A22:  CALL   0BE0
01A26:  MOVFF  03,63C
01A2A:  MOVFF  02,63B
01A2E:  MOVFF  01,63A
01A32:  MOVFF  00,639
....................    r = r*y*y + qat[3];
01A36:  MOVFF  63C,64E
01A3A:  MOVFF  63B,64D
01A3E:  MOVFF  63A,64C
01A42:  MOVFF  639,64B
01A46:  MOVFF  634,652
01A4A:  MOVFF  633,651
01A4E:  MOVFF  632,650
01A52:  MOVFF  631,64F
01A56:  CALL   0AEA
01A5A:  MOVFF  03,641
01A5E:  MOVFF  02,640
01A62:  MOVFF  01,63F
01A66:  MOVFF  00,63E
01A6A:  MOVFF  03,64E
01A6E:  MOVFF  02,64D
01A72:  MOVFF  01,64C
01A76:  MOVFF  00,64B
01A7A:  MOVFF  634,652
01A7E:  MOVFF  633,651
01A82:  MOVFF  632,650
01A86:  MOVFF  631,64F
01A8A:  CALL   0AEA
01A8E:  MOVFF  03,641
01A92:  MOVFF  02,640
01A96:  MOVFF  01,63F
01A9A:  MOVFF  00,63E
01A9E:  BCF    FD8.1
01AA0:  MOVFF  03,652
01AA4:  MOVFF  02,651
01AA8:  MOVFF  01,650
01AAC:  MOVFF  00,64F
01AB0:  MOVLW  33
01AB2:  MOVLB  6
01AB4:  MOVWF  x56
01AB6:  MOVLW  8C
01AB8:  MOVWF  x55
01ABA:  MOVLW  1E
01ABC:  MOVWF  x54
01ABE:  MOVLW  83
01AC0:  MOVWF  x53
01AC2:  MOVLB  0
01AC4:  CALL   0BE0
01AC8:  MOVFF  03,63C
01ACC:  MOVFF  02,63B
01AD0:  MOVFF  01,63A
01AD4:  MOVFF  00,639
.................... 
....................    res = y*res/r;
01AD8:  MOVFF  634,64E
01ADC:  MOVFF  633,64D
01AE0:  MOVFF  632,64C
01AE4:  MOVFF  631,64B
01AE8:  MOVFF  638,652
01AEC:  MOVFF  637,651
01AF0:  MOVFF  636,650
01AF4:  MOVFF  635,64F
01AF8:  CALL   0AEA
01AFC:  MOVFF  03,641
01B00:  MOVFF  02,640
01B04:  MOVFF  01,63F
01B08:  MOVFF  00,63E
01B0C:  MOVFF  03,647
01B10:  MOVFF  02,646
01B14:  MOVFF  01,645
01B18:  MOVFF  00,644
01B1C:  MOVFF  63C,64B
01B20:  MOVFF  63B,64A
01B24:  MOVFF  63A,649
01B28:  MOVFF  639,648
01B2C:  RCALL  1514
01B2E:  MOVFF  03,638
01B32:  MOVFF  02,637
01B36:  MOVFF  01,636
01B3A:  MOVFF  00,635
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01B3E:  MOVLB  6
01B40:  BTFSS  x3D.1
01B42:  BRA    1B7E
....................       res = PI_DIV_BY_TWO - res;
01B44:  BSF    FD8.1
01B46:  MOVLW  DB
01B48:  MOVWF  x52
01B4A:  MOVLW  0F
01B4C:  MOVWF  x51
01B4E:  MOVLW  49
01B50:  MOVWF  x50
01B52:  MOVLW  7F
01B54:  MOVWF  x4F
01B56:  MOVFF  638,656
01B5A:  MOVFF  637,655
01B5E:  MOVFF  636,654
01B62:  MOVFF  635,653
01B66:  MOVLB  0
01B68:  CALL   0BE0
01B6C:  MOVFF  03,638
01B70:  MOVFF  02,637
01B74:  MOVFF  01,636
01B78:  MOVFF  00,635
01B7C:  MOVLB  6
....................    if (s)
01B7E:  BTFSS  x3D.0
01B80:  BRA    1B88
....................       res = -res;
01B82:  MOVF   x36,W
01B84:  XORLW  80
01B86:  MOVWF  x36
.................... 
....................    return(res);
01B88:  MOVFF  635,00
01B8C:  MOVFF  636,01
01B90:  MOVFF  637,02
01B94:  MOVFF  638,03
01B98:  MOVLB  0
01B9A:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01B9C:  MOVLB  6
01B9E:  BCF    x2B.0
....................    quad=0; //quadrant
01BA0:  CLRF   x2C
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01BA2:  MOVFF  622,64E
01BA6:  MOVFF  621,64D
01BAA:  MOVFF  620,64C
01BAE:  MOVFF  61F,64B
01BB2:  CLRF   x52
01BB4:  CLRF   x51
01BB6:  CLRF   x50
01BB8:  CLRF   x4F
01BBA:  MOVLB  0
01BBC:  RCALL  149A
01BBE:  BC    1BC2
01BC0:  BNZ   1BEC
01BC2:  MOVFF  626,64E
01BC6:  MOVFF  625,64D
01BCA:  MOVFF  624,64C
01BCE:  MOVFF  623,64B
01BD2:  MOVLB  6
01BD4:  CLRF   x52
01BD6:  CLRF   x51
01BD8:  CLRF   x50
01BDA:  CLRF   x4F
01BDC:  MOVLB  0
01BDE:  RCALL  149A
01BE0:  BC    1BE4
01BE2:  BNZ   1BE8
01BE4:  MOVLW  03
01BE6:  BRA    1BEA
01BE8:  MOVLW  04
01BEA:  BRA    1C12
01BEC:  MOVFF  626,64E
01BF0:  MOVFF  625,64D
01BF4:  MOVFF  624,64C
01BF8:  MOVFF  623,64B
01BFC:  MOVLB  6
01BFE:  CLRF   x52
01C00:  CLRF   x51
01C02:  CLRF   x50
01C04:  CLRF   x4F
01C06:  MOVLB  0
01C08:  RCALL  149A
01C0A:  BNC   1C10
01C0C:  MOVLW  02
01C0E:  BRA    1C12
01C10:  MOVLW  01
01C12:  MOVLB  6
01C14:  MOVWF  x2C
....................    if(y<0.0)
01C16:  MOVFF  622,64E
01C1A:  MOVFF  621,64D
01C1E:  MOVFF  620,64C
01C22:  MOVFF  61F,64B
01C26:  CLRF   x52
01C28:  CLRF   x51
01C2A:  CLRF   x50
01C2C:  CLRF   x4F
01C2E:  MOVLB  0
01C30:  RCALL  149A
01C32:  BNC   1C40
....................    {
....................       sign=1;
01C34:  MOVLB  6
01C36:  BSF    x2B.0
....................       y=-y;
01C38:  MOVF   x20,W
01C3A:  XORLW  80
01C3C:  MOVWF  x20
01C3E:  MOVLB  0
....................    }
....................    if(x<0.0)
01C40:  MOVFF  626,64E
01C44:  MOVFF  625,64D
01C48:  MOVFF  624,64C
01C4C:  MOVFF  623,64B
01C50:  MOVLB  6
01C52:  CLRF   x52
01C54:  CLRF   x51
01C56:  CLRF   x50
01C58:  CLRF   x4F
01C5A:  MOVLB  0
01C5C:  RCALL  149A
01C5E:  BNC   1C6A
....................    {
....................       x=-x;
01C60:  MOVLB  6
01C62:  MOVF   x24,W
01C64:  XORLW  80
01C66:  MOVWF  x24
01C68:  MOVLB  0
....................    }
....................    if (x==0.0)
01C6A:  MOVFF  626,64E
01C6E:  MOVFF  625,64D
01C72:  MOVFF  624,64C
01C76:  MOVFF  623,64B
01C7A:  MOVLB  6
01C7C:  CLRF   x52
01C7E:  CLRF   x51
01C80:  CLRF   x50
01C82:  CLRF   x4F
01C84:  MOVLB  0
01C86:  RCALL  149A
01C88:  BNZ   1CDE
....................    {
....................       if(y==0.0)
01C8A:  MOVFF  622,64E
01C8E:  MOVFF  621,64D
01C92:  MOVFF  620,64C
01C96:  MOVFF  61F,64B
01C9A:  MOVLB  6
01C9C:  CLRF   x52
01C9E:  CLRF   x51
01CA0:  CLRF   x50
01CA2:  CLRF   x4F
01CA4:  MOVLB  0
01CA6:  CALL   149A
01CAA:  BNZ   1CAE
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01CAC:  BRA    1CDC
....................       else
....................       {
....................          if(sign)
01CAE:  MOVLB  6
01CB0:  BTFSS  x2B.0
01CB2:  BRA    1CC8
....................          {
....................          return (-(PI_DIV_BY_TWO));
01CB4:  MOVLW  7F
01CB6:  MOVWF  00
01CB8:  MOVLW  C9
01CBA:  MOVWF  01
01CBC:  MOVLW  0F
01CBE:  MOVWF  02
01CC0:  MOVLW  DB
01CC2:  MOVWF  03
01CC4:  BRA    1E16
....................          }
01CC6:  BRA    1CDA
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01CC8:  MOVLW  7F
01CCA:  MOVWF  00
01CCC:  MOVLW  49
01CCE:  MOVWF  01
01CD0:  MOVLW  0F
01CD2:  MOVWF  02
01CD4:  MOVLW  DB
01CD6:  MOVWF  03
01CD8:  BRA    1E16
01CDA:  MOVLB  0
....................          }
....................       }
....................    }
01CDC:  BRA    1E14
....................    else
....................    {
....................       z=y/x;
01CDE:  MOVFF  622,647
01CE2:  MOVFF  621,646
01CE6:  MOVFF  620,645
01CEA:  MOVFF  61F,644
01CEE:  MOVFF  626,64B
01CF2:  MOVFF  625,64A
01CF6:  MOVFF  624,649
01CFA:  MOVFF  623,648
01CFE:  RCALL  1514
01D00:  MOVFF  03,62A
01D04:  MOVFF  02,629
01D08:  MOVFF  01,628
01D0C:  MOVFF  00,627
....................       switch(quad)
01D10:  MOVLW  01
01D12:  MOVLB  6
01D14:  SUBWF  x2C,W
01D16:  ADDLW  FC
01D18:  BTFSC  FD8.0
01D1A:  BRA    1E16
01D1C:  ADDLW  04
01D1E:  MOVLB  0
01D20:  GOTO   1E1C
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01D24:  MOVFF  62A,630
01D28:  MOVFF  629,62F
01D2C:  MOVFF  628,62E
01D30:  MOVFF  627,62D
01D34:  RCALL  1672
01D36:  MOVLB  6
01D38:  BRA    1E16
....................             break;
01D3A:  BRA    1E16
01D3C:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01D3E:  MOVFF  62A,630
01D42:  MOVFF  629,62F
01D46:  MOVFF  628,62E
01D4A:  MOVFF  627,62D
01D4E:  RCALL  1672
01D50:  MOVFF  FEA,62E
01D54:  MOVFF  FE9,62D
01D58:  BSF    FD8.1
01D5A:  MOVLW  DB
01D5C:  MOVLB  6
01D5E:  MOVWF  x52
01D60:  MOVLW  0F
01D62:  MOVWF  x51
01D64:  MOVLW  49
01D66:  MOVWF  x50
01D68:  MOVLW  80
01D6A:  MOVWF  x4F
01D6C:  MOVFF  03,656
01D70:  MOVFF  02,655
01D74:  MOVFF  01,654
01D78:  MOVFF  00,653
01D7C:  MOVLB  0
01D7E:  CALL   0BE0
01D82:  MOVFF  62E,FEA
01D86:  MOVFF  62D,FE9
01D8A:  MOVLB  6
01D8C:  BRA    1E16
....................             break;
01D8E:  BRA    1E16
01D90:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01D92:  MOVFF  62A,630
01D96:  MOVFF  629,62F
01D9A:  MOVFF  628,62E
01D9E:  MOVFF  627,62D
01DA2:  RCALL  1672
01DA4:  MOVFF  03,630
01DA8:  MOVFF  02,62F
01DAC:  MOVFF  01,62E
01DB0:  MOVFF  00,62D
01DB4:  MOVFF  FEA,632
01DB8:  MOVFF  FE9,631
01DBC:  BSF    FD8.1
01DBE:  MOVFF  03,652
01DC2:  MOVFF  02,651
01DC6:  MOVFF  01,650
01DCA:  MOVFF  00,64F
01DCE:  MOVLW  DB
01DD0:  MOVLB  6
01DD2:  MOVWF  x56
01DD4:  MOVLW  0F
01DD6:  MOVWF  x55
01DD8:  MOVLW  49
01DDA:  MOVWF  x54
01DDC:  MOVLW  80
01DDE:  MOVWF  x53
01DE0:  MOVLB  0
01DE2:  CALL   0BE0
01DE6:  MOVFF  632,FEA
01DEA:  MOVFF  631,FE9
01DEE:  MOVLB  6
01DF0:  BRA    1E16
....................             break;
01DF2:  BRA    1E16
01DF4:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01DF6:  MOVFF  62A,630
01DFA:  MOVFF  629,62F
01DFE:  MOVFF  628,62E
01E02:  MOVFF  627,62D
01E06:  RCALL  1672
01E08:  MOVLW  80
01E0A:  XORWF  01,F
01E0C:  MOVLB  6
01E0E:  BRA    1E16
....................             break;
01E10:  BRA    1E16
01E12:  MOVLB  0
01E14:  MOVLB  6
....................          }
....................       }
....................    }
01E16:  MOVLB  0
01E18:  GOTO   34EE (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... #define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
.................... } smData[2] = 
.................... {
....................    {false, false},
....................    {false, false}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00E58:  MOVLB  F
00E5A:  BTFSC  x5B.0
00E5C:  BRA    13A8
....................    {
....................       switch (state)
00E5E:  MOVLB  1
00E60:  MOVF   x67,W
00E62:  ADDLW  F9
00E64:  BTFSC  FD8.0
00E66:  BRA    13A6
00E68:  ADDLW  07
00E6A:  MOVLB  0
00E6C:  GOTO   13AE
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00E70:  MOVLB  F
00E72:  BTFSC  x5B.0
00E74:  BRA    0E72
00E76:  MOVFF  F5F,02
00E7A:  MOVFF  F5E,01
00E7E:  MOVFF  02,5F1
00E82:  MOVFF  01,5F0
00E86:  MOVFF  02,650
00E8A:  MOVFF  01,64F
00E8E:  MOVLB  0
00E90:  RCALL  0AB4
00E92:  MOVFF  03,64E
00E96:  MOVFF  02,64D
00E9A:  MOVFF  01,64C
00E9E:  MOVFF  00,64B
00EA2:  MOVFF  B9,652
00EA6:  MOVFF  B8,651
00EAA:  MOVFF  B7,650
00EAE:  MOVFF  B6,64F
00EB2:  RCALL  0AEA
00EB4:  MOVFF  03,5F3
00EB8:  MOVFF  02,5F2
00EBC:  MOVFF  01,5F1
00EC0:  MOVFF  00,5F0
00EC4:  BCF    FD8.1
00EC6:  MOVFF  03,652
00ECA:  MOVFF  02,651
00ECE:  MOVFF  01,650
00ED2:  MOVFF  00,64F
00ED6:  MOVFF  B5,656
00EDA:  MOVFF  B4,655
00EDE:  MOVFF  B3,654
00EE2:  MOVFF  B2,653
00EE6:  RCALL  0BE0
00EE8:  MOVFF  03,F6
00EEC:  MOVFF  02,F5
00EF0:  MOVFF  01,F4
00EF4:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00EF8:  MOVLB  F
00EFA:  MOVF   x5A,W
00EFC:  ANDLW  3F
00EFE:  MOVWF  01
00F00:  MOVLW  10
00F02:  MOVWF  x5A
00F04:  BTFSS  x5B.7
00F06:  BRA    0F16
00F08:  MOVF   01,W
00F0A:  SUBLW  10
00F0C:  BZ    0F16
00F0E:  BSF    x5B.0
00F10:  NOP   
00F12:  BTFSC  x5B.0
00F14:  BRA    0F12
....................             delay_ms(10);
00F16:  MOVLW  0A
00F18:  MOVLB  5
00F1A:  MOVWF  xF5
00F1C:  MOVLB  0
00F1E:  CALL   0424
....................             read_adc(ADC_START_ONLY);
00F22:  MOVLB  F
00F24:  BSF    x5B.0
00F26:  NOP   
....................             state = 1;
00F28:  MOVLW  01
00F2A:  MOVLB  1
00F2C:  MOVWF  x67
....................          break;
00F2E:  BRA    13A6
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00F30:  MOVLB  F
00F32:  BTFSC  x5B.0
00F34:  BRA    0F32
00F36:  MOVFF  F5F,02
00F3A:  MOVFF  F5E,01
00F3E:  MOVFF  02,5F1
00F42:  MOVFF  01,5F0
00F46:  MOVFF  02,650
00F4A:  MOVFF  01,64F
00F4E:  MOVLB  0
00F50:  RCALL  0AB4
00F52:  MOVFF  03,64E
00F56:  MOVFF  02,64D
00F5A:  MOVFF  01,64C
00F5E:  MOVFF  00,64B
00F62:  MOVFF  C1,652
00F66:  MOVFF  C0,651
00F6A:  MOVFF  BF,650
00F6E:  MOVFF  BE,64F
00F72:  RCALL  0AEA
00F74:  MOVFF  03,5F3
00F78:  MOVFF  02,5F2
00F7C:  MOVFF  01,5F1
00F80:  MOVFF  00,5F0
00F84:  BCF    FD8.1
00F86:  MOVFF  03,652
00F8A:  MOVFF  02,651
00F8E:  MOVFF  01,650
00F92:  MOVFF  00,64F
00F96:  MOVFF  BD,656
00F9A:  MOVFF  BC,655
00F9E:  MOVFF  BB,654
00FA2:  MOVFF  BA,653
00FA6:  RCALL  0BE0
00FA8:  MOVFF  03,FA
00FAC:  MOVFF  02,F9
00FB0:  MOVFF  01,F8
00FB4:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00FB8:  MOVLB  F
00FBA:  MOVF   x5A,W
00FBC:  ANDLW  3F
00FBE:  MOVWF  01
00FC0:  MOVLW  18
00FC2:  MOVWF  x5A
00FC4:  BTFSS  x5B.7
00FC6:  BRA    0FD6
00FC8:  MOVF   01,W
00FCA:  SUBLW  18
00FCC:  BZ    0FD6
00FCE:  BSF    x5B.0
00FD0:  NOP   
00FD2:  BTFSC  x5B.0
00FD4:  BRA    0FD2
....................             delay_ms(10);
00FD6:  MOVLW  0A
00FD8:  MOVLB  5
00FDA:  MOVWF  xF5
00FDC:  MOVLB  0
00FDE:  CALL   0424
....................             read_adc(ADC_START_ONLY);
00FE2:  MOVLB  F
00FE4:  BSF    x5B.0
00FE6:  NOP   
....................             state = 2;
00FE8:  MOVLW  02
00FEA:  MOVLB  1
00FEC:  MOVWF  x67
....................          break;
00FEE:  BRA    13A6
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00FF0:  MOVLB  F
00FF2:  BTFSC  x5B.0
00FF4:  BRA    0FF2
00FF6:  MOVFF  F5F,02
00FFA:  MOVFF  F5E,01
00FFE:  MOVFF  02,5F1
01002:  MOVFF  01,5F0
01006:  MOVFF  02,650
0100A:  MOVFF  01,64F
0100E:  MOVLB  0
01010:  RCALL  0AB4
01012:  MOVFF  03,64E
01016:  MOVFF  02,64D
0101A:  MOVFF  01,64C
0101E:  MOVFF  00,64B
01022:  MOVFF  C9,652
01026:  MOVFF  C8,651
0102A:  MOVFF  C7,650
0102E:  MOVFF  C6,64F
01032:  RCALL  0AEA
01034:  MOVFF  03,5F3
01038:  MOVFF  02,5F2
0103C:  MOVFF  01,5F1
01040:  MOVFF  00,5F0
01044:  BCF    FD8.1
01046:  MOVFF  03,652
0104A:  MOVFF  02,651
0104E:  MOVFF  01,650
01052:  MOVFF  00,64F
01056:  MOVFF  C5,656
0105A:  MOVFF  C4,655
0105E:  MOVFF  C3,654
01062:  MOVFF  C2,653
01066:  RCALL  0BE0
01068:  MOVFF  03,FE
0106C:  MOVFF  02,FD
01070:  MOVFF  01,FC
01074:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
01078:  MOVLB  F
0107A:  MOVF   x5A,W
0107C:  ANDLW  3F
0107E:  MOVWF  01
01080:  MOVLW  19
01082:  MOVWF  x5A
01084:  BTFSS  x5B.7
01086:  BRA    1096
01088:  MOVF   01,W
0108A:  SUBLW  19
0108C:  BZ    1096
0108E:  BSF    x5B.0
01090:  NOP   
01092:  BTFSC  x5B.0
01094:  BRA    1092
....................             delay_ms(10);
01096:  MOVLW  0A
01098:  MOVLB  5
0109A:  MOVWF  xF5
0109C:  MOVLB  0
0109E:  CALL   0424
....................             read_adc(ADC_START_ONLY);
010A2:  MOVLB  F
010A4:  BSF    x5B.0
010A6:  NOP   
....................             state = 3;
010A8:  MOVLW  03
010AA:  MOVLB  1
010AC:  MOVWF  x67
....................          break;
010AE:  BRA    13A6
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
010B0:  MOVLB  F
010B2:  BTFSC  x5B.0
010B4:  BRA    10B2
010B6:  MOVFF  F5F,02
010BA:  MOVFF  F5E,01
010BE:  MOVFF  02,5F1
010C2:  MOVFF  01,5F0
010C6:  MOVFF  02,650
010CA:  MOVFF  01,64F
010CE:  MOVLB  0
010D0:  RCALL  0AB4
010D2:  MOVFF  03,64E
010D6:  MOVFF  02,64D
010DA:  MOVFF  01,64C
010DE:  MOVFF  00,64B
010E2:  MOVFF  D1,652
010E6:  MOVFF  D0,651
010EA:  MOVFF  CF,650
010EE:  MOVFF  CE,64F
010F2:  RCALL  0AEA
010F4:  MOVFF  03,5F3
010F8:  MOVFF  02,5F2
010FC:  MOVFF  01,5F1
01100:  MOVFF  00,5F0
01104:  BCF    FD8.1
01106:  MOVFF  03,652
0110A:  MOVFF  02,651
0110E:  MOVFF  01,650
01112:  MOVFF  00,64F
01116:  MOVFF  CD,656
0111A:  MOVFF  CC,655
0111E:  MOVFF  CB,654
01122:  MOVFF  CA,653
01126:  RCALL  0BE0
01128:  MOVFF  03,102
0112C:  MOVFF  02,101
01130:  MOVFF  01,100
01134:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01138:  MOVLB  F
0113A:  MOVF   x5A,W
0113C:  ANDLW  3F
0113E:  MOVWF  01
01140:  MOVLW  11
01142:  MOVWF  x5A
01144:  BTFSS  x5B.7
01146:  BRA    1156
01148:  MOVF   01,W
0114A:  SUBLW  11
0114C:  BZ    1156
0114E:  BSF    x5B.0
01150:  NOP   
01152:  BTFSC  x5B.0
01154:  BRA    1152
....................             delay_ms(10);
01156:  MOVLW  0A
01158:  MOVLB  5
0115A:  MOVWF  xF5
0115C:  MOVLB  0
0115E:  CALL   0424
....................             read_adc(ADC_START_ONLY);
01162:  MOVLB  F
01164:  BSF    x5B.0
01166:  NOP   
....................             state = 4;
01168:  MOVLW  04
0116A:  MOVLB  1
0116C:  MOVWF  x67
....................          break;
0116E:  BRA    13A6
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
01170:  MOVLB  F
01172:  BTFSC  x5B.0
01174:  BRA    1172
01176:  MOVFF  F5F,02
0117A:  MOVFF  F5E,01
0117E:  MOVFF  02,5F1
01182:  MOVFF  01,5F0
01186:  MOVFF  02,650
0118A:  MOVFF  01,64F
0118E:  MOVLB  0
01190:  RCALL  0AB4
01192:  MOVFF  03,64E
01196:  MOVFF  02,64D
0119A:  MOVFF  01,64C
0119E:  MOVFF  00,64B
011A2:  MOVFF  D9,652
011A6:  MOVFF  D8,651
011AA:  MOVFF  D7,650
011AE:  MOVFF  D6,64F
011B2:  RCALL  0AEA
011B4:  MOVFF  03,5F3
011B8:  MOVFF  02,5F2
011BC:  MOVFF  01,5F1
011C0:  MOVFF  00,5F0
011C4:  BCF    FD8.1
011C6:  MOVFF  03,652
011CA:  MOVFF  02,651
011CE:  MOVFF  01,650
011D2:  MOVFF  00,64F
011D6:  MOVFF  D5,656
011DA:  MOVFF  D4,655
011DE:  MOVFF  D3,654
011E2:  MOVFF  D2,653
011E6:  RCALL  0BE0
011E8:  MOVFF  03,106
011EC:  MOVFF  02,105
011F0:  MOVFF  01,104
011F4:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
011F8:  MOVLB  F
011FA:  MOVF   x5A,W
011FC:  ANDLW  3F
011FE:  MOVWF  01
01200:  MOVLW  1B
01202:  MOVWF  x5A
01204:  BTFSS  x5B.7
01206:  BRA    1216
01208:  MOVF   01,W
0120A:  SUBLW  1B
0120C:  BZ    1216
0120E:  BSF    x5B.0
01210:  NOP   
01212:  BTFSC  x5B.0
01214:  BRA    1212
....................             delay_ms(10);
01216:  MOVLW  0A
01218:  MOVLB  5
0121A:  MOVWF  xF5
0121C:  MOVLB  0
0121E:  CALL   0424
....................             read_adc(ADC_START_ONLY);
01222:  MOVLB  F
01224:  BSF    x5B.0
01226:  NOP   
....................             state = 5;
01228:  MOVLW  05
0122A:  MOVLB  1
0122C:  MOVWF  x67
....................          break;
0122E:  BRA    13A6
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
01230:  MOVLB  F
01232:  BTFSC  x5B.0
01234:  BRA    1232
01236:  MOVFF  F5F,02
0123A:  MOVFF  F5E,01
0123E:  MOVFF  02,5F1
01242:  MOVFF  01,5F0
01246:  MOVFF  02,650
0124A:  MOVFF  01,64F
0124E:  MOVLB  0
01250:  RCALL  0AB4
01252:  MOVFF  03,64E
01256:  MOVFF  02,64D
0125A:  MOVFF  01,64C
0125E:  MOVFF  00,64B
01262:  MOVFF  E1,652
01266:  MOVFF  E0,651
0126A:  MOVFF  DF,650
0126E:  MOVFF  DE,64F
01272:  RCALL  0AEA
01274:  MOVFF  03,5F3
01278:  MOVFF  02,5F2
0127C:  MOVFF  01,5F1
01280:  MOVFF  00,5F0
01284:  BCF    FD8.1
01286:  MOVFF  03,652
0128A:  MOVFF  02,651
0128E:  MOVFF  01,650
01292:  MOVFF  00,64F
01296:  MOVFF  DD,656
0129A:  MOVFF  DC,655
0129E:  MOVFF  DB,654
012A2:  MOVFF  DA,653
012A6:  RCALL  0BE0
012A8:  MOVFF  03,10A
012AC:  MOVFF  02,109
012B0:  MOVFF  01,108
012B4:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
012B8:  MOVLB  F
012BA:  MOVF   x5A,W
012BC:  ANDLW  3F
012BE:  MOVWF  01
012C0:  MOVLW  1A
012C2:  MOVWF  x5A
012C4:  BTFSS  x5B.7
012C6:  BRA    12D6
012C8:  MOVF   01,W
012CA:  SUBLW  1A
012CC:  BZ    12D6
012CE:  BSF    x5B.0
012D0:  NOP   
012D2:  BTFSC  x5B.0
012D4:  BRA    12D2
....................             delay_ms(10);
012D6:  MOVLW  0A
012D8:  MOVLB  5
012DA:  MOVWF  xF5
012DC:  MOVLB  0
012DE:  CALL   0424
....................             read_adc(ADC_START_ONLY);
012E2:  MOVLB  F
012E4:  BSF    x5B.0
012E6:  NOP   
....................             state = 6;
012E8:  MOVLW  06
012EA:  MOVLB  1
012EC:  MOVWF  x67
....................          break;
012EE:  BRA    13A6
....................          
....................          case 6:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
012F0:  MOVLB  F
012F2:  BTFSC  x5B.0
012F4:  BRA    12F2
012F6:  MOVFF  F5F,02
012FA:  MOVFF  F5E,01
012FE:  MOVFF  02,5F1
01302:  MOVFF  01,5F0
01306:  MOVFF  02,650
0130A:  MOVFF  01,64F
0130E:  MOVLB  0
01310:  CALL   0AB4
01314:  MOVFF  03,64E
01318:  MOVFF  02,64D
0131C:  MOVFF  01,64C
01320:  MOVFF  00,64B
01324:  MOVFF  E9,652
01328:  MOVFF  E8,651
0132C:  MOVFF  E7,650
01330:  MOVFF  E6,64F
01334:  CALL   0AEA
01338:  MOVFF  03,5F3
0133C:  MOVFF  02,5F2
01340:  MOVFF  01,5F1
01344:  MOVFF  00,5F0
01348:  BCF    FD8.1
0134A:  MOVFF  03,652
0134E:  MOVFF  02,651
01352:  MOVFF  01,650
01356:  MOVFF  00,64F
0135A:  MOVFF  E5,656
0135E:  MOVFF  E4,655
01362:  MOVFF  E3,654
01366:  MOVFF  E2,653
0136A:  RCALL  0BE0
0136C:  MOVFF  03,10E
01370:  MOVFF  02,10D
01374:  MOVFF  01,10C
01378:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
0137C:  MOVLB  F
0137E:  MOVF   x5A,W
01380:  ANDLW  3F
01382:  MOVWF  01
01384:  MOVLW  06
01386:  MOVWF  x5A
01388:  BTFSS  x5B.7
0138A:  BRA    139A
0138C:  MOVF   01,W
0138E:  SUBLW  06
01390:  BZ    139A
01392:  BSF    x5B.0
01394:  NOP   
01396:  BTFSC  x5B.0
01398:  BRA    1396
....................             read_adc(ADC_START_ONLY);
0139A:  BSF    x5B.0
0139C:  NOP   
....................             state = 0;
0139E:  MOVLB  1
013A0:  CLRF   x67
....................          break;   
013A2:  BRA    13A6
013A4:  MOVLB  1
013A6:  MOVLB  F
....................       }
....................    }
013A8:  MOVLB  0
013AA:  GOTO   9E6C (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, signed int32 sinRawCounts, signed int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinLast = adcVals[ch].sinCounts;
*
02E7A:  MOVLB  5
02E7C:  MOVF   xF8,W
02E7E:  MULLW  21
02E80:  MOVF   FF3,W
02E82:  MOVLB  6
02E84:  CLRF   x0A
02E86:  MOVWF  x09
02E88:  MOVLW  10
02E8A:  ADDWF  x09,W
02E8C:  MOVWF  01
02E8E:  MOVLW  00
02E90:  ADDWFC x0A,W
02E92:  MOVWF  03
02E94:  MOVF   01,W
02E96:  ADDLW  0F
02E98:  MOVWF  01
02E9A:  MOVLW  01
02E9C:  ADDWFC 03,F
02E9E:  MOVFF  01,609
02EA2:  MOVFF  03,60A
02EA6:  MOVLB  5
02EA8:  MOVF   xF8,W
02EAA:  MULLW  21
02EAC:  MOVF   FF3,W
02EAE:  MOVLB  6
02EB0:  CLRF   x0C
02EB2:  MOVWF  x0B
02EB4:  MOVLW  08
02EB6:  ADDWF  x0B,W
02EB8:  MOVWF  01
02EBA:  MOVLW  00
02EBC:  ADDWFC x0C,W
02EBE:  MOVWF  03
02EC0:  MOVF   01,W
02EC2:  ADDLW  0F
02EC4:  MOVWF  FE9
02EC6:  MOVLW  01
02EC8:  ADDWFC 03,W
02ECA:  MOVWF  FEA
02ECC:  MOVFF  FEF,00
02ED0:  MOVFF  FEC,01
02ED4:  MOVFF  FEC,02
02ED8:  MOVFF  FEC,03
02EDC:  MOVFF  60A,FEA
02EE0:  MOVFF  609,FE9
02EE4:  MOVFF  00,FEF
02EE8:  MOVFF  01,FEC
02EEC:  MOVFF  02,FEC
02EF0:  MOVFF  03,FEC
....................    adcVals[ch].cosLast = adcVals[ch].cosCounts;
02EF4:  MOVLB  5
02EF6:  MOVF   xF8,W
02EF8:  MULLW  21
02EFA:  MOVF   FF3,W
02EFC:  MOVLB  6
02EFE:  CLRF   x0A
02F00:  MOVWF  x09
02F02:  MOVLW  14
02F04:  ADDWF  x09,W
02F06:  MOVWF  01
02F08:  MOVLW  00
02F0A:  ADDWFC x0A,W
02F0C:  MOVWF  03
02F0E:  MOVF   01,W
02F10:  ADDLW  0F
02F12:  MOVWF  01
02F14:  MOVLW  01
02F16:  ADDWFC 03,F
02F18:  MOVFF  01,609
02F1C:  MOVFF  03,60A
02F20:  MOVLB  5
02F22:  MOVF   xF8,W
02F24:  MULLW  21
02F26:  MOVF   FF3,W
02F28:  MOVLB  6
02F2A:  CLRF   x0C
02F2C:  MOVWF  x0B
02F2E:  MOVLW  0C
02F30:  ADDWF  x0B,W
02F32:  MOVWF  01
02F34:  MOVLW  00
02F36:  ADDWFC x0C,W
02F38:  MOVWF  03
02F3A:  MOVF   01,W
02F3C:  ADDLW  0F
02F3E:  MOVWF  FE9
02F40:  MOVLW  01
02F42:  ADDWFC 03,W
02F44:  MOVWF  FEA
02F46:  MOVFF  FEF,00
02F4A:  MOVFF  FEC,01
02F4E:  MOVFF  FEC,02
02F52:  MOVFF  FEC,03
02F56:  MOVFF  60A,FEA
02F5A:  MOVFF  609,FE9
02F5E:  MOVFF  00,FEF
02F62:  MOVFF  01,FEC
02F66:  MOVFF  02,FEC
02F6A:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
02F6E:  MOVLB  5
02F70:  MOVF   xF8,W
02F72:  MULLW  21
02F74:  MOVF   FF3,W
02F76:  MOVLB  6
02F78:  CLRF   x0A
02F7A:  MOVWF  x09
02F7C:  MOVLW  0F
02F7E:  ADDWF  x09,W
02F80:  MOVWF  FE9
02F82:  MOVLW  01
02F84:  ADDWFC x0A,W
02F86:  MOVWF  FEA
02F88:  MOVFF  5FC,618
02F8C:  MOVFF  5FB,617
02F90:  MOVFF  5FA,616
02F94:  MOVFF  5F9,615
02F98:  MOVLB  0
02F9A:  CALL   1440
02F9E:  MOVFF  00,FEF
02FA2:  MOVFF  01,FEC
02FA6:  MOVFF  02,FEC
02FAA:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02FAE:  MOVLB  5
02FB0:  MOVF   xF8,W
02FB2:  MULLW  21
02FB4:  MOVF   FF3,W
02FB6:  MOVLB  6
02FB8:  CLRF   x0A
02FBA:  MOVWF  x09
02FBC:  MOVLW  04
02FBE:  ADDWF  x09,W
02FC0:  MOVWF  01
02FC2:  MOVLW  00
02FC4:  ADDWFC x0A,W
02FC6:  MOVWF  03
02FC8:  MOVF   01,W
02FCA:  ADDLW  0F
02FCC:  MOVWF  FE9
02FCE:  MOVLW  01
02FD0:  ADDWFC 03,W
02FD2:  MOVWF  FEA
02FD4:  MOVFF  600,618
02FD8:  MOVFF  5FF,617
02FDC:  MOVFF  5FE,616
02FE0:  MOVFF  5FD,615
02FE4:  MOVLB  0
02FE6:  CALL   1440
02FEA:  MOVFF  00,FEF
02FEE:  MOVFF  01,FEC
02FF2:  MOVFF  02,FEC
02FF6:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02FFA:  MOVLB  5
02FFC:  MOVF   xF8,W
02FFE:  MULLW  21
03000:  MOVF   FF3,W
03002:  MOVLB  6
03004:  CLRF   x0A
03006:  MOVWF  x09
03008:  MOVLW  08
0300A:  ADDWF  x09,W
0300C:  MOVWF  01
0300E:  MOVLW  00
03010:  ADDWFC x0A,W
03012:  MOVWF  03
03014:  MOVF   01,W
03016:  ADDLW  0F
03018:  MOVWF  01
0301A:  MOVLW  01
0301C:  ADDWFC 03,F
0301E:  MOVFF  01,609
03022:  MOVFF  03,60A
03026:  MOVLB  5
03028:  MOVF   xF8,W
0302A:  MULLW  21
0302C:  MOVF   FF3,W
0302E:  MOVLB  6
03030:  CLRF   x0C
03032:  MOVWF  x0B
03034:  MOVLW  0F
03036:  ADDWF  x0B,W
03038:  MOVWF  FE9
0303A:  MOVLW  01
0303C:  ADDWFC x0C,W
0303E:  MOVWF  FEA
03040:  MOVFF  FEF,64B
03044:  MOVFF  FEC,64C
03048:  MOVFF  FEC,64D
0304C:  MOVFF  FEC,64E
03050:  MOVLB  5
03052:  MOVF   xF8,W
03054:  MULLW  10
03056:  MOVF   FF3,W
03058:  MOVLB  6
0305A:  CLRF   x12
0305C:  MOVWF  x11
0305E:  MOVLW  08
03060:  ADDWF  x11,W
03062:  MOVWF  01
03064:  MOVLW  00
03066:  ADDWFC x12,W
03068:  MOVWF  03
0306A:  MOVF   01,W
0306C:  ADDLW  62
0306E:  MOVWF  FE9
03070:  MOVLW  00
03072:  ADDWFC 03,W
03074:  MOVWF  FEA
03076:  MOVFF  FEF,64F
0307A:  MOVFF  FEC,01
0307E:  MOVFF  FEC,02
03082:  MOVFF  FEC,03
03086:  MOVFF  03,652
0308A:  MOVFF  02,651
0308E:  MOVFF  01,650
03092:  MOVLB  0
03094:  CALL   0AEA
03098:  MOVFF  03,652
0309C:  MOVFF  02,651
030A0:  MOVFF  01,650
030A4:  MOVFF  00,64F
030A8:  MOVLB  5
030AA:  MOVF   xF8,W
030AC:  MULLW  10
030AE:  MOVF   FF3,W
030B0:  MOVLB  6
030B2:  CLRF   x12
030B4:  MOVWF  x11
030B6:  MOVLW  62
030B8:  ADDWF  x11,W
030BA:  MOVWF  FE9
030BC:  MOVLW  00
030BE:  ADDWFC x12,W
030C0:  MOVWF  FEA
030C2:  MOVFF  FEF,653
030C6:  MOVFF  FEC,01
030CA:  MOVFF  FEC,02
030CE:  MOVFF  FEC,03
030D2:  BCF    FD8.1
030D4:  MOVFF  03,656
030D8:  MOVFF  02,655
030DC:  MOVFF  01,654
030E0:  MOVLB  0
030E2:  CALL   0BE0
030E6:  MOVFF  60A,FEA
030EA:  MOVFF  609,FE9
030EE:  MOVFF  00,FEF
030F2:  MOVFF  01,FEC
030F6:  MOVFF  02,FEC
030FA:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
030FE:  MOVLB  5
03100:  MOVF   xF8,W
03102:  MULLW  21
03104:  MOVF   FF3,W
03106:  MOVLB  6
03108:  CLRF   x0A
0310A:  MOVWF  x09
0310C:  MOVLW  0C
0310E:  ADDWF  x09,W
03110:  MOVWF  01
03112:  MOVLW  00
03114:  ADDWFC x0A,W
03116:  MOVWF  03
03118:  MOVF   01,W
0311A:  ADDLW  0F
0311C:  MOVWF  01
0311E:  MOVLW  01
03120:  ADDWFC 03,F
03122:  MOVFF  01,609
03126:  MOVFF  03,60A
0312A:  MOVLB  5
0312C:  MOVF   xF8,W
0312E:  MULLW  21
03130:  MOVF   FF3,W
03132:  MOVLB  6
03134:  CLRF   x0C
03136:  MOVWF  x0B
03138:  MOVLW  04
0313A:  ADDWF  x0B,W
0313C:  MOVWF  01
0313E:  MOVLW  00
03140:  ADDWFC x0C,W
03142:  MOVWF  03
03144:  MOVF   01,W
03146:  ADDLW  0F
03148:  MOVWF  FE9
0314A:  MOVLW  01
0314C:  ADDWFC 03,W
0314E:  MOVWF  FEA
03150:  MOVFF  FEF,64B
03154:  MOVFF  FEC,64C
03158:  MOVFF  FEC,64D
0315C:  MOVFF  FEC,64E
03160:  MOVLB  5
03162:  MOVF   xF8,W
03164:  MULLW  10
03166:  MOVF   FF3,W
03168:  MOVLB  6
0316A:  CLRF   x10
0316C:  MOVWF  x0F
0316E:  MOVLW  0C
03170:  ADDWF  x0F,W
03172:  MOVWF  01
03174:  MOVLW  00
03176:  ADDWFC x10,W
03178:  MOVWF  03
0317A:  MOVF   01,W
0317C:  ADDLW  62
0317E:  MOVWF  FE9
03180:  MOVLW  00
03182:  ADDWFC 03,W
03184:  MOVWF  FEA
03186:  MOVFF  FEF,64F
0318A:  MOVFF  FEC,01
0318E:  MOVFF  FEC,02
03192:  MOVFF  FEC,03
03196:  MOVFF  03,652
0319A:  MOVFF  02,651
0319E:  MOVFF  01,650
031A2:  MOVLB  0
031A4:  CALL   0AEA
031A8:  MOVFF  03,652
031AC:  MOVFF  02,651
031B0:  MOVFF  01,650
031B4:  MOVFF  00,64F
031B8:  MOVLB  5
031BA:  MOVF   xF8,W
031BC:  MULLW  10
031BE:  MOVF   FF3,W
031C0:  MOVLB  6
031C2:  CLRF   x10
031C4:  MOVWF  x0F
031C6:  MOVLW  04
031C8:  ADDWF  x0F,W
031CA:  MOVWF  01
031CC:  MOVLW  00
031CE:  ADDWFC x10,W
031D0:  MOVWF  03
031D2:  MOVF   01,W
031D4:  ADDLW  62
031D6:  MOVWF  FE9
031D8:  MOVLW  00
031DA:  ADDWFC 03,W
031DC:  MOVWF  FEA
031DE:  MOVFF  FEF,653
031E2:  MOVFF  FEC,01
031E6:  MOVFF  FEC,02
031EA:  MOVFF  FEC,03
031EE:  BCF    FD8.1
031F0:  MOVFF  03,656
031F4:  MOVFF  02,655
031F8:  MOVFF  01,654
031FC:  MOVLB  0
031FE:  CALL   0BE0
03202:  MOVFF  60A,FEA
03206:  MOVFF  609,FE9
0320A:  MOVFF  00,FEF
0320E:  MOVFF  01,FEC
03212:  MOVFF  02,FEC
03216:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
0321A:  MOVLB  6
0321C:  CLRF   x04
0321E:  CLRF   x03
03220:  CLRF   x02
03222:  CLRF   x01
03224:  CLRF   x08
03226:  CLRF   x07
03228:  CLRF   x06
0322A:  MOVLW  7F
0322C:  MOVWF  x05
....................    
....................    if (adcVals[ch].cosCounts < 0){
0322E:  MOVLB  5
03230:  MOVF   xF8,W
03232:  MULLW  21
03234:  MOVF   FF3,W
03236:  MOVLB  6
03238:  CLRF   x0A
0323A:  MOVWF  x09
0323C:  MOVLW  0C
0323E:  ADDWF  x09,W
03240:  MOVWF  01
03242:  MOVLW  00
03244:  ADDWFC x0A,W
03246:  MOVWF  03
03248:  MOVF   01,W
0324A:  ADDLW  0F
0324C:  MOVWF  FE9
0324E:  MOVLW  01
03250:  ADDWFC 03,W
03252:  MOVWF  FEA
03254:  MOVFF  FEF,64B
03258:  MOVFF  FEC,64C
0325C:  MOVFF  FEC,64D
03260:  MOVFF  FEC,64E
03264:  CLRF   x52
03266:  CLRF   x51
03268:  CLRF   x50
0326A:  CLRF   x4F
0326C:  MOVLB  0
0326E:  CALL   149A
03272:  BTFSS  FD8.0
03274:  BRA    33EA
....................       if ((adcVals[ch].sinCounts > 0) && (adcVals[ch].sinLast < 0)){
03276:  MOVLB  5
03278:  MOVF   xF8,W
0327A:  MULLW  21
0327C:  MOVF   FF3,W
0327E:  MOVLB  6
03280:  CLRF   x0A
03282:  MOVWF  x09
03284:  MOVLW  08
03286:  ADDWF  x09,W
03288:  MOVWF  01
0328A:  MOVLW  00
0328C:  ADDWFC x0A,W
0328E:  MOVWF  03
03290:  MOVF   01,W
03292:  ADDLW  0F
03294:  MOVWF  FE9
03296:  MOVLW  01
03298:  ADDWFC 03,W
0329A:  MOVWF  FEA
0329C:  MOVFF  FEF,64F
032A0:  MOVFF  FEC,60A
032A4:  MOVFF  FEC,651
032A8:  MOVFF  FEC,652
032AC:  CLRF   x4E
032AE:  CLRF   x4D
032B0:  CLRF   x4C
032B2:  CLRF   x4B
032B4:  MOVFF  60A,650
032B8:  MOVLB  0
032BA:  CALL   149A
032BE:  BNC   3330
032C0:  MOVLB  5
032C2:  MOVF   xF8,W
032C4:  MULLW  21
032C6:  MOVF   FF3,W
032C8:  MOVLB  6
032CA:  CLRF   x0A
032CC:  MOVWF  x09
032CE:  MOVLW  10
032D0:  ADDWF  x09,W
032D2:  MOVWF  01
032D4:  MOVLW  00
032D6:  ADDWFC x0A,W
032D8:  MOVWF  03
032DA:  MOVF   01,W
032DC:  ADDLW  0F
032DE:  MOVWF  FE9
032E0:  MOVLW  01
032E2:  ADDWFC 03,W
032E4:  MOVWF  FEA
032E6:  MOVFF  FEF,64B
032EA:  MOVFF  FEC,64C
032EE:  MOVFF  FEC,64D
032F2:  MOVFF  FEC,64E
032F6:  CLRF   x52
032F8:  CLRF   x51
032FA:  CLRF   x50
032FC:  CLRF   x4F
032FE:  MOVLB  0
03300:  CALL   149A
03304:  BNC   3330
....................          adcVals[ch].npoles--;
03306:  MOVLB  5
03308:  MOVF   xF8,W
0330A:  MULLW  21
0330C:  MOVF   FF3,W
0330E:  MOVLB  6
03310:  CLRF   x0A
03312:  MOVWF  x09
03314:  MOVLW  1C
03316:  ADDWF  x09,W
03318:  MOVWF  01
0331A:  MOVLW  00
0331C:  ADDWFC x0A,W
0331E:  MOVWF  03
03320:  MOVF   01,W
03322:  ADDLW  0F
03324:  MOVWF  FE9
03326:  MOVLW  01
03328:  ADDWFC 03,W
0332A:  MOVWF  FEA
0332C:  DECF   FEF,F
....................       }
0332E:  BRA    33E8
....................       else if ((adcVals[ch].sinCounts < 0) && (adcVals[ch].sinLast > 0)){
03330:  MOVLB  5
03332:  MOVF   xF8,W
03334:  MULLW  21
03336:  MOVF   FF3,W
03338:  MOVLB  6
0333A:  CLRF   x0A
0333C:  MOVWF  x09
0333E:  MOVLW  08
03340:  ADDWF  x09,W
03342:  MOVWF  01
03344:  MOVLW  00
03346:  ADDWFC x0A,W
03348:  MOVWF  03
0334A:  MOVF   01,W
0334C:  ADDLW  0F
0334E:  MOVWF  FE9
03350:  MOVLW  01
03352:  ADDWFC 03,W
03354:  MOVWF  FEA
03356:  MOVFF  FEF,64B
0335A:  MOVFF  FEC,60A
0335E:  MOVFF  FEC,64D
03362:  MOVFF  FEC,64E
03366:  MOVFF  60A,64C
0336A:  CLRF   x52
0336C:  CLRF   x51
0336E:  CLRF   x50
03370:  CLRF   x4F
03372:  MOVLB  0
03374:  CALL   149A
03378:  BNC   33EA
0337A:  MOVLB  5
0337C:  MOVF   xF8,W
0337E:  MULLW  21
03380:  MOVF   FF3,W
03382:  MOVLB  6
03384:  CLRF   x0A
03386:  MOVWF  x09
03388:  MOVLW  10
0338A:  ADDWF  x09,W
0338C:  MOVWF  01
0338E:  MOVLW  00
03390:  ADDWFC x0A,W
03392:  MOVWF  03
03394:  MOVF   01,W
03396:  ADDLW  0F
03398:  MOVWF  FE9
0339A:  MOVLW  01
0339C:  ADDWFC 03,W
0339E:  MOVWF  FEA
033A0:  MOVFF  FEF,64F
033A4:  MOVFF  FEC,650
033A8:  MOVFF  FEC,651
033AC:  MOVFF  FEC,652
033B0:  CLRF   x4E
033B2:  CLRF   x4D
033B4:  CLRF   x4C
033B6:  CLRF   x4B
033B8:  MOVLB  0
033BA:  CALL   149A
033BE:  BNC   33EA
....................          adcVals[ch].npoles++;
033C0:  MOVLB  5
033C2:  MOVF   xF8,W
033C4:  MULLW  21
033C6:  MOVF   FF3,W
033C8:  MOVLB  6
033CA:  CLRF   x0A
033CC:  MOVWF  x09
033CE:  MOVLW  1C
033D0:  ADDWF  x09,W
033D2:  MOVWF  01
033D4:  MOVLW  00
033D6:  ADDWFC x0A,W
033D8:  MOVWF  03
033DA:  MOVF   01,W
033DC:  ADDLW  0F
033DE:  MOVWF  FE9
033E0:  MOVLW  01
033E2:  ADDWFC 03,W
033E4:  MOVWF  FEA
033E6:  INCF   FEF,F
033E8:  MOVLB  0
....................       }
....................    }
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
033EA:  MOVLB  5
033EC:  MOVF   xF8,W
033EE:  MULLW  21
033F0:  MOVF   FF3,W
033F2:  MOVLB  6
033F4:  CLRF   x0A
033F6:  MOVWF  x09
033F8:  MOVLW  18
033FA:  ADDWF  x09,W
033FC:  MOVWF  01
033FE:  MOVLW  00
03400:  ADDWFC x0A,W
03402:  MOVWF  03
03404:  MOVF   01,W
03406:  ADDLW  0F
03408:  MOVWF  01
0340A:  MOVLW  01
0340C:  ADDWFC 03,F
0340E:  MOVFF  01,609
03412:  MOVFF  03,60A
03416:  MOVFF  608,64E
0341A:  MOVFF  607,64D
0341E:  MOVFF  606,64C
03422:  MOVFF  605,64B
03426:  MOVLW  AA
03428:  MOVWF  x52
0342A:  MOVLW  27
0342C:  MOVWF  x51
0342E:  MOVLW  1F
03430:  MOVWF  x50
03432:  MOVLW  86
03434:  MOVWF  x4F
03436:  MOVLB  0
03438:  CALL   0AEA
0343C:  MOVFF  03,60E
03440:  MOVFF  02,60D
03444:  MOVFF  01,60C
03448:  MOVFF  00,60B
0344C:  MOVLB  5
0344E:  MOVF   xF8,W
03450:  MULLW  21
03452:  MOVF   FF3,W
03454:  MOVLB  6
03456:  CLRF   x10
03458:  MOVWF  x0F
0345A:  MOVLW  08
0345C:  ADDWF  x0F,W
0345E:  MOVWF  01
03460:  MOVLW  00
03462:  ADDWFC x10,W
03464:  MOVWF  03
03466:  MOVF   01,W
03468:  ADDLW  0F
0346A:  MOVWF  FE9
0346C:  MOVLW  01
0346E:  ADDWFC 03,W
03470:  MOVWF  FEA
03472:  MOVFF  FEF,60F
03476:  MOVFF  FEC,610
0347A:  MOVFF  FEC,611
0347E:  MOVFF  FEC,612
03482:  MOVLB  5
03484:  MOVF   xF8,W
03486:  MULLW  21
03488:  MOVF   FF3,W
0348A:  MOVLB  6
0348C:  CLRF   x14
0348E:  MOVWF  x13
03490:  MOVLW  0C
03492:  ADDWF  x13,W
03494:  MOVWF  01
03496:  MOVLW  00
03498:  ADDWFC x14,W
0349A:  MOVWF  03
0349C:  MOVF   01,W
0349E:  ADDLW  0F
034A0:  MOVWF  FE9
034A2:  MOVLW  01
034A4:  ADDWFC 03,W
034A6:  MOVWF  FEA
034A8:  MOVFF  FEF,00
034AC:  MOVFF  FEC,01
034B0:  MOVFF  FEC,02
034B4:  MOVFF  FEC,03
034B8:  MOVFF  03,616
034BC:  MOVFF  02,615
034C0:  MOVFF  01,614
034C4:  MOVFF  00,613
034C8:  MOVFF  612,622
034CC:  MOVFF  611,621
034D0:  MOVFF  610,620
034D4:  MOVFF  60F,61F
034D8:  MOVFF  03,626
034DC:  MOVFF  02,625
034E0:  MOVFF  01,624
034E4:  MOVFF  00,623
034E8:  MOVLB  0
034EA:  GOTO   1B9C
034EE:  MOVFF  60E,64E
034F2:  MOVFF  60D,64D
034F6:  MOVFF  60C,64C
034FA:  MOVFF  60B,64B
034FE:  MOVFF  03,652
03502:  MOVFF  02,651
03506:  MOVFF  01,650
0350A:  MOVFF  00,64F
0350E:  CALL   0AEA
03512:  MOVFF  60A,FEA
03516:  MOVFF  609,FE9
0351A:  MOVFF  00,FEF
0351E:  MOVFF  01,FEC
03522:  MOVFF  02,FEC
03526:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( 1000 * polePitch * (float)adcVals[ch].npoles );
0352A:  MOVLB  5
0352C:  MOVF   xF8,W
0352E:  MULLW  21
03530:  MOVF   FF3,W
03532:  MOVLB  6
03534:  CLRF   x0A
03536:  MOVWF  x09
03538:  MOVLW  18
0353A:  ADDWF  x09,W
0353C:  MOVWF  01
0353E:  MOVLW  00
03540:  ADDWFC x0A,W
03542:  MOVWF  03
03544:  MOVF   01,W
03546:  ADDLW  0F
03548:  MOVWF  FE9
0354A:  MOVLW  01
0354C:  ADDWFC 03,W
0354E:  MOVWF  FEA
03550:  MOVFF  FEF,609
03554:  MOVFF  FEC,60A
03558:  MOVFF  FEC,60B
0355C:  MOVFF  FEC,60C
03560:  CLRF   x4E
03562:  CLRF   x4D
03564:  MOVLW  7A
03566:  MOVWF  x4C
03568:  MOVLW  88
0356A:  MOVWF  x4B
0356C:  MOVFF  608,652
03570:  MOVFF  607,651
03574:  MOVFF  606,650
03578:  MOVFF  605,64F
0357C:  MOVLB  0
0357E:  CALL   0AEA
03582:  MOVFF  03,610
03586:  MOVFF  02,60F
0358A:  MOVFF  01,60E
0358E:  MOVFF  00,60D
03592:  MOVLB  5
03594:  MOVF   xF8,W
03596:  MULLW  21
03598:  MOVF   FF3,W
0359A:  MOVLB  6
0359C:  CLRF   x12
0359E:  MOVWF  x11
035A0:  MOVLW  1C
035A2:  ADDWF  x11,W
035A4:  MOVWF  01
035A6:  MOVLW  00
035A8:  ADDWFC x12,W
035AA:  MOVWF  03
035AC:  MOVF   01,W
035AE:  ADDLW  0F
035B0:  MOVWF  FE9
035B2:  MOVLW  01
035B4:  ADDWFC 03,W
035B6:  MOVWF  FEA
035B8:  MOVF   FEF,W
035BA:  CLRF   x42
035BC:  MOVWF  x41
035BE:  BTFSC  x41.7
035C0:  DECF   x42,F
035C2:  MOVLB  0
035C4:  CALL   1E3E
035C8:  MOVFF  610,64E
035CC:  MOVFF  60F,64D
035D0:  MOVFF  60E,64C
035D4:  MOVFF  60D,64B
035D8:  MOVFF  03,652
035DC:  MOVFF  02,651
035E0:  MOVFF  01,650
035E4:  MOVFF  00,64F
035E8:  CALL   0AEA
035EC:  MOVFF  FEA,60E
035F0:  MOVFF  FE9,60D
035F4:  BCF    FD8.1
035F6:  MOVFF  60C,652
035FA:  MOVFF  60B,651
035FE:  MOVFF  60A,650
03602:  MOVFF  609,64F
03606:  MOVFF  03,656
0360A:  MOVFF  02,655
0360E:  MOVFF  01,654
03612:  MOVFF  00,653
03616:  CALL   0BE0
0361A:  MOVFF  60E,FEA
0361E:  MOVFF  60D,FE9
03622:  MOVFF  03,604
03626:  MOVFF  02,603
0362A:  MOVFF  01,602
0362E:  MOVFF  00,601
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
03632:  MOVLB  5
03634:  MOVF   xF8,W
03636:  MULLW  21
03638:  MOVF   FF3,W
0363A:  MOVLB  6
0363C:  CLRF   x0A
0363E:  MOVWF  x09
03640:  MOVLW  1D
03642:  ADDWF  x09,W
03644:  MOVWF  01
03646:  MOVLW  00
03648:  ADDWFC x0A,W
0364A:  MOVWF  03
0364C:  MOVF   01,W
0364E:  ADDLW  0F
03650:  MOVWF  01
03652:  MOVLW  01
03654:  ADDWFC 03,F
03656:  MOVFF  01,609
0365A:  MOVFF  03,60A
0365E:  MOVLB  5
03660:  MOVF   xF8,W
03662:  MULLW  18
03664:  MOVF   FF3,W
03666:  MOVLB  6
03668:  CLRF   x0C
0366A:  MOVWF  x0B
0366C:  MOVLW  14
0366E:  ADDWF  x0B,W
03670:  MOVWF  01
03672:  MOVLW  00
03674:  ADDWFC x0C,W
03676:  MOVWF  03
03678:  MOVF   01,W
0367A:  ADDLW  82
0367C:  MOVWF  FE9
0367E:  MOVLW  00
03680:  ADDWFC 03,W
03682:  MOVWF  FEA
03684:  MOVFF  FEF,64F
03688:  MOVFF  FEC,01
0368C:  MOVFF  FEC,02
03690:  MOVFF  FEC,03
03694:  MOVFF  604,64E
03698:  MOVFF  603,64D
0369C:  MOVFF  602,64C
036A0:  MOVFF  601,64B
036A4:  MOVFF  03,652
036A8:  MOVFF  02,651
036AC:  MOVFF  01,650
036B0:  MOVLB  0
036B2:  CALL   0AEA
036B6:  MOVFF  03,60E
036BA:  MOVFF  02,60D
036BE:  MOVFF  01,60C
036C2:  MOVFF  00,60B
036C6:  MOVFF  03,622
036CA:  MOVFF  02,621
036CE:  MOVFF  01,620
036D2:  MOVFF  00,61F
036D6:  MOVLB  6
036D8:  CLRF   x26
036DA:  CLRF   x25
036DC:  MOVLW  20
036DE:  MOVWF  x24
036E0:  MOVLW  81
036E2:  MOVWF  x23
036E4:  MOVLB  0
036E6:  CALL   2B7C
036EA:  MOVFF  03,60E
036EE:  MOVFF  02,60D
036F2:  MOVFF  01,60C
036F6:  MOVFF  00,60B
036FA:  MOVLB  5
036FC:  MOVF   xF8,W
036FE:  MULLW  18
03700:  MOVF   FF3,W
03702:  MOVLB  6
03704:  CLRF   x10
03706:  MOVWF  x0F
03708:  MOVLW  10
0370A:  ADDWF  x0F,W
0370C:  MOVWF  01
0370E:  MOVLW  00
03710:  ADDWFC x10,W
03712:  MOVWF  03
03714:  MOVF   01,W
03716:  ADDLW  82
03718:  MOVWF  FE9
0371A:  MOVLW  00
0371C:  ADDWFC 03,W
0371E:  MOVWF  FEA
03720:  MOVFF  FEF,64F
03724:  MOVFF  FEC,01
03728:  MOVFF  FEC,02
0372C:  MOVFF  FEC,03
03730:  MOVFF  604,64E
03734:  MOVFF  603,64D
03738:  MOVFF  602,64C
0373C:  MOVFF  601,64B
03740:  MOVFF  03,652
03744:  MOVFF  02,651
03748:  MOVFF  01,650
0374C:  MOVLB  0
0374E:  CALL   0AEA
03752:  MOVFF  03,612
03756:  MOVFF  02,611
0375A:  MOVFF  01,610
0375E:  MOVFF  00,60F
03762:  MOVFF  03,622
03766:  MOVFF  02,621
0376A:  MOVFF  01,620
0376E:  MOVFF  00,61F
03772:  MOVLB  6
03774:  CLRF   x26
03776:  CLRF   x25
03778:  CLRF   x24
0377A:  MOVLW  81
0377C:  MOVWF  x23
0377E:  MOVLB  0
03780:  CALL   2B7C
03784:  MOVFF  FEA,610
03788:  MOVFF  FE9,60F
0378C:  BCF    FD8.1
0378E:  MOVFF  60E,652
03792:  MOVFF  60D,651
03796:  MOVFF  60C,650
0379A:  MOVFF  60B,64F
0379E:  MOVFF  03,656
037A2:  MOVFF  02,655
037A6:  MOVFF  01,654
037AA:  MOVFF  00,653
037AE:  CALL   0BE0
037B2:  MOVFF  610,FEA
037B6:  MOVFF  60F,FE9
037BA:  MOVFF  03,60E
037BE:  MOVFF  02,60D
037C2:  MOVFF  01,60C
037C6:  MOVFF  00,60B
037CA:  MOVLB  5
037CC:  MOVF   xF8,W
037CE:  MULLW  18
037D0:  MOVF   FF3,W
037D2:  MOVLB  6
037D4:  CLRF   x12
037D6:  MOVWF  x11
037D8:  MOVLW  0C
037DA:  ADDWF  x11,W
037DC:  MOVWF  01
037DE:  MOVLW  00
037E0:  ADDWFC x12,W
037E2:  MOVWF  03
037E4:  MOVF   01,W
037E6:  ADDLW  82
037E8:  MOVWF  FE9
037EA:  MOVLW  00
037EC:  ADDWFC 03,W
037EE:  MOVWF  FEA
037F0:  MOVFF  FEF,64F
037F4:  MOVFF  FEC,01
037F8:  MOVFF  FEC,02
037FC:  MOVFF  FEC,03
03800:  MOVFF  604,64E
03804:  MOVFF  603,64D
03808:  MOVFF  602,64C
0380C:  MOVFF  601,64B
03810:  MOVFF  03,652
03814:  MOVFF  02,651
03818:  MOVFF  01,650
0381C:  MOVLB  0
0381E:  CALL   0AEA
03822:  MOVFF  03,614
03826:  MOVFF  02,613
0382A:  MOVFF  01,612
0382E:  MOVFF  00,611
03832:  MOVFF  03,622
03836:  MOVFF  02,621
0383A:  MOVFF  01,620
0383E:  MOVFF  00,61F
03842:  MOVLB  6
03844:  CLRF   x26
03846:  CLRF   x25
03848:  MOVLW  40
0384A:  MOVWF  x24
0384C:  MOVLW  80
0384E:  MOVWF  x23
03850:  MOVLB  0
03852:  CALL   2B7C
03856:  MOVFF  FEA,612
0385A:  MOVFF  FE9,611
0385E:  BCF    FD8.1
03860:  MOVFF  60E,652
03864:  MOVFF  60D,651
03868:  MOVFF  60C,650
0386C:  MOVFF  60B,64F
03870:  MOVFF  03,656
03874:  MOVFF  02,655
03878:  MOVFF  01,654
0387C:  MOVFF  00,653
03880:  CALL   0BE0
03884:  MOVFF  612,FEA
03888:  MOVFF  611,FE9
0388C:  MOVFF  03,60E
03890:  MOVFF  02,60D
03894:  MOVFF  01,60C
03898:  MOVFF  00,60B
0389C:  MOVLB  5
0389E:  MOVF   xF8,W
038A0:  MULLW  18
038A2:  MOVF   FF3,W
038A4:  MOVLB  6
038A6:  CLRF   x14
038A8:  MOVWF  x13
038AA:  MOVLW  08
038AC:  ADDWF  x13,W
038AE:  MOVWF  01
038B0:  MOVLW  00
038B2:  ADDWFC x14,W
038B4:  MOVWF  03
038B6:  MOVF   01,W
038B8:  ADDLW  82
038BA:  MOVWF  FE9
038BC:  MOVLW  00
038BE:  ADDWFC 03,W
038C0:  MOVWF  FEA
038C2:  MOVFF  FEF,64F
038C6:  MOVFF  FEC,01
038CA:  MOVFF  FEC,02
038CE:  MOVFF  FEC,03
038D2:  MOVFF  604,64E
038D6:  MOVFF  603,64D
038DA:  MOVFF  602,64C
038DE:  MOVFF  601,64B
038E2:  MOVFF  03,652
038E6:  MOVFF  02,651
038EA:  MOVFF  01,650
038EE:  MOVLB  0
038F0:  CALL   0AEA
038F4:  MOVFF  03,616
038F8:  MOVFF  02,615
038FC:  MOVFF  01,614
03900:  MOVFF  00,613
03904:  MOVFF  03,622
03908:  MOVFF  02,621
0390C:  MOVFF  01,620
03910:  MOVFF  00,61F
03914:  MOVLB  6
03916:  CLRF   x26
03918:  CLRF   x25
0391A:  CLRF   x24
0391C:  MOVLW  80
0391E:  MOVWF  x23
03920:  MOVLB  0
03922:  CALL   2B7C
03926:  MOVFF  FEA,614
0392A:  MOVFF  FE9,613
0392E:  BCF    FD8.1
03930:  MOVFF  60E,652
03934:  MOVFF  60D,651
03938:  MOVFF  60C,650
0393C:  MOVFF  60B,64F
03940:  MOVFF  03,656
03944:  MOVFF  02,655
03948:  MOVFF  01,654
0394C:  MOVFF  00,653
03950:  CALL   0BE0
03954:  MOVFF  614,FEA
03958:  MOVFF  613,FE9
0395C:  MOVFF  03,60E
03960:  MOVFF  02,60D
03964:  MOVFF  01,60C
03968:  MOVFF  00,60B
0396C:  MOVLB  5
0396E:  MOVF   xF8,W
03970:  MULLW  18
03972:  MOVF   FF3,W
03974:  MOVLB  6
03976:  CLRF   x16
03978:  MOVWF  x15
0397A:  MOVLW  04
0397C:  ADDWF  x15,W
0397E:  MOVWF  01
03980:  MOVLW  00
03982:  ADDWFC x16,W
03984:  MOVWF  03
03986:  MOVF   01,W
03988:  ADDLW  82
0398A:  MOVWF  FE9
0398C:  MOVLW  00
0398E:  ADDWFC 03,W
03990:  MOVWF  FEA
03992:  MOVFF  FEF,64F
03996:  MOVFF  FEC,01
0399A:  MOVFF  FEC,02
0399E:  MOVFF  FEC,03
039A2:  MOVFF  604,64E
039A6:  MOVFF  603,64D
039AA:  MOVFF  602,64C
039AE:  MOVFF  601,64B
039B2:  MOVFF  03,652
039B6:  MOVFF  02,651
039BA:  MOVFF  01,650
039BE:  MOVLB  0
039C0:  CALL   0AEA
039C4:  MOVFF  FEA,616
039C8:  MOVFF  FE9,615
039CC:  BCF    FD8.1
039CE:  MOVFF  60E,652
039D2:  MOVFF  60D,651
039D6:  MOVFF  60C,650
039DA:  MOVFF  60B,64F
039DE:  MOVFF  03,656
039E2:  MOVFF  02,655
039E6:  MOVFF  01,654
039EA:  MOVFF  00,653
039EE:  CALL   0BE0
039F2:  MOVFF  616,FEA
039F6:  MOVFF  615,FE9
039FA:  MOVFF  03,652
039FE:  MOVFF  02,651
03A02:  MOVFF  01,650
03A06:  MOVFF  00,64F
03A0A:  MOVLB  5
03A0C:  MOVF   xF8,W
03A0E:  MULLW  18
03A10:  MOVF   FF3,W
03A12:  MOVLB  6
03A14:  CLRF   x18
03A16:  MOVWF  x17
03A18:  MOVLW  82
03A1A:  ADDWF  x17,W
03A1C:  MOVWF  FE9
03A1E:  MOVLW  00
03A20:  ADDWFC x18,W
03A22:  MOVWF  FEA
03A24:  MOVFF  FEF,653
03A28:  MOVFF  FEC,01
03A2C:  MOVFF  FEC,02
03A30:  MOVFF  FEC,03
03A34:  BCF    FD8.1
03A36:  MOVFF  03,656
03A3A:  MOVFF  02,655
03A3E:  MOVFF  01,654
03A42:  MOVLB  0
03A44:  CALL   0BE0
03A48:  MOVFF  60A,FEA
03A4C:  MOVFF  609,FE9
03A50:  MOVFF  00,FEF
03A54:  MOVFF  01,FEC
03A58:  MOVFF  02,FEC
03A5C:  MOVFF  03,FEC
....................    if (ch == chX) adcVals[ch].pReal *= -1;
03A60:  MOVLB  5
03A62:  MOVF   xF8,F
03A64:  BNZ   3AC4
03A66:  MOVF   xF8,W
03A68:  MULLW  21
03A6A:  MOVF   FF3,W
03A6C:  MOVLB  6
03A6E:  CLRF   x0A
03A70:  MOVWF  x09
03A72:  MOVLW  1D
03A74:  ADDWF  x09,W
03A76:  MOVWF  01
03A78:  MOVLW  00
03A7A:  ADDWFC x0A,W
03A7C:  MOVWF  03
03A7E:  MOVF   01,W
03A80:  ADDLW  0F
03A82:  MOVWF  FE9
03A84:  MOVLW  01
03A86:  ADDWFC 03,W
03A88:  MOVWF  FEA
03A8A:  MOVFF  FEF,64B
03A8E:  MOVFF  FEC,64C
03A92:  MOVFF  FEC,64D
03A96:  MOVFF  FEC,64E
03A9A:  MOVF   FED,F
03A9C:  MOVF   FED,F
03A9E:  MOVF   FED,F
03AA0:  CLRF   x52
03AA2:  CLRF   x51
03AA4:  MOVLW  80
03AA6:  MOVWF  x50
03AA8:  MOVLW  7F
03AAA:  MOVWF  x4F
03AAC:  MOVLB  0
03AAE:  CALL   0AEA
03AB2:  MOVFF  00,FEF
03AB6:  MOVFF  01,FEC
03ABA:  MOVFF  02,FEC
03ABE:  MOVFF  03,FEC
03AC2:  MOVLB  5
....................    PID[ch].PVold = PID[ch].PV;
03AC4:  MOVF   xF8,W
03AC6:  MULLW  20
03AC8:  MOVF   FF3,W
03ACA:  MOVLB  6
03ACC:  CLRF   x0A
03ACE:  MOVWF  x09
03AD0:  MOVLW  14
03AD2:  ADDWF  x09,W
03AD4:  MOVWF  01
03AD6:  MOVLW  00
03AD8:  ADDWFC x0A,W
03ADA:  MOVWF  03
03ADC:  MOVF   01,W
03ADE:  ADDLW  20
03AE0:  MOVWF  01
03AE2:  MOVLW  00
03AE4:  ADDWFC 03,F
03AE6:  MOVFF  01,609
03AEA:  MOVFF  03,60A
03AEE:  MOVLB  5
03AF0:  MOVF   xF8,W
03AF2:  MULLW  20
03AF4:  MOVF   FF3,W
03AF6:  MOVLB  6
03AF8:  CLRF   x0C
03AFA:  MOVWF  x0B
03AFC:  MOVLW  10
03AFE:  ADDWF  x0B,W
03B00:  MOVWF  01
03B02:  MOVLW  00
03B04:  ADDWFC x0C,W
03B06:  MOVWF  03
03B08:  MOVF   01,W
03B0A:  ADDLW  20
03B0C:  MOVWF  FE9
03B0E:  MOVLW  00
03B10:  ADDWFC 03,W
03B12:  MOVWF  FEA
03B14:  MOVFF  FEF,00
03B18:  MOVFF  FEC,01
03B1C:  MOVFF  FEC,02
03B20:  MOVFF  FEC,03
03B24:  MOVFF  60A,FEA
03B28:  MOVFF  609,FE9
03B2C:  MOVFF  00,FEF
03B30:  MOVFF  01,FEC
03B34:  MOVFF  02,FEC
03B38:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
03B3C:  MOVLB  5
03B3E:  MOVF   xF8,W
03B40:  MULLW  20
03B42:  MOVF   FF3,W
03B44:  MOVLB  6
03B46:  CLRF   x0A
03B48:  MOVWF  x09
03B4A:  MOVLW  10
03B4C:  ADDWF  x09,W
03B4E:  MOVWF  01
03B50:  MOVLW  00
03B52:  ADDWFC x0A,W
03B54:  MOVWF  03
03B56:  MOVF   01,W
03B58:  ADDLW  20
03B5A:  MOVWF  01
03B5C:  MOVLW  00
03B5E:  ADDWFC 03,F
03B60:  MOVFF  01,609
03B64:  MOVFF  03,60A
03B68:  MOVLB  5
03B6A:  MOVF   xF8,W
03B6C:  MULLW  21
03B6E:  MOVF   FF3,W
03B70:  MOVLB  6
03B72:  CLRF   x0C
03B74:  MOVWF  x0B
03B76:  MOVLW  1D
03B78:  ADDWF  x0B,W
03B7A:  MOVWF  01
03B7C:  MOVLW  00
03B7E:  ADDWFC x0C,W
03B80:  MOVWF  03
03B82:  MOVF   01,W
03B84:  ADDLW  0F
03B86:  MOVWF  FE9
03B88:  MOVLW  01
03B8A:  ADDWFC 03,W
03B8C:  MOVWF  FEA
03B8E:  MOVFF  FEF,00
03B92:  MOVFF  FEC,01
03B96:  MOVFF  FEC,02
03B9A:  MOVFF  FEC,03
03B9E:  MOVFF  60A,FEA
03BA2:  MOVFF  609,FE9
03BA6:  MOVFF  00,FEF
03BAA:  MOVFF  01,FEC
03BAE:  MOVFF  02,FEC
03BB2:  MOVFF  03,FEC
03BB6:  MOVLB  0
03BB8:  GOTO   3C7C (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    static int8 ch = 0;
....................    
....................    if (!smData[ch].adcBusy)
*
001C0:  MOVLB  6
001C2:  CLRF   x65
001C4:  MOVFF  168,664
001C8:  MOVLW  65
001CA:  ADDWF  x64,W
001CC:  MOVWF  FE9
001CE:  MOVLW  01
001D0:  ADDWFC x65,W
001D2:  MOVWF  FEA
001D4:  BTFSC  FEF.1
001D6:  BRA    0240
....................    {
....................       smData[ch].adcBusy = true;
001D8:  CLRF   x65
001DA:  MOVFF  168,664
001DE:  MOVLW  65
001E0:  ADDWF  x64,W
001E2:  MOVWF  FE9
001E4:  MOVLW  01
001E6:  ADDWFC x65,W
001E8:  MOVWF  FEA
001EA:  BSF    FEF.1
....................       
....................       ads_start_conv_block(ch);
001EC:  MOVFF  168,664
001F0:  MOVLB  0
001F2:  BRA    01A2
....................       ch = !ch;
001F4:  MOVLB  1
001F6:  MOVF   x68,F
001F8:  BZ    01FE
001FA:  MOVLW  00
001FC:  BRA    0200
001FE:  MOVLW  01
00200:  MOVWF  x68
....................       
....................       smData[!ch].dataReady = true;
00202:  MOVF   x68,F
00204:  BZ    020A
00206:  MOVLW  00
00208:  BRA    020C
0020A:  MOVLW  01
0020C:  MOVLB  6
0020E:  CLRF   x65
00210:  MOVWF  x64
00212:  MOVLW  65
00214:  ADDWF  x64,W
00216:  MOVWF  FE9
00218:  MOVLW  01
0021A:  ADDWFC x65,W
0021C:  MOVWF  FEA
0021E:  BSF    FEF.0
....................       smData[!ch].adcBusy = false;
00220:  MOVLB  1
00222:  MOVF   x68,F
00224:  BZ    022A
00226:  MOVLW  00
00228:  BRA    022C
0022A:  MOVLW  01
0022C:  MOVLB  6
0022E:  CLRF   x65
00230:  MOVWF  x64
00232:  MOVLW  65
00234:  ADDWF  x64,W
00236:  MOVWF  FE9
00238:  MOVLW  01
0023A:  ADDWFC x65,W
0023C:  MOVWF  FEA
0023E:  BCF    FEF.1
....................    }
00240:  MOVLB  0
00242:  GOTO   0304 (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
*
03BBC:  MOVLB  5
03BBE:  CLRF   xF3
03BC0:  CLRF   xF2
03BC2:  CLRF   xF1
03BC4:  CLRF   xF0
03BC6:  CLRF   xF7
03BC8:  CLRF   xF6
03BCA:  CLRF   xF5
03BCC:  CLRF   xF4
.................... {
....................    static int8 ch = 0;
....................    signed int32 sinRaw = 0;
....................    signed int32 cosRaw = 0;
....................    
....................    if ( (!smData[ch].adcBusy) && smData[ch].dataReady ){
03BCE:  CLRF   xF9
03BD0:  MOVFF  169,5F8
03BD4:  MOVLW  65
03BD6:  ADDWF  xF8,W
03BD8:  MOVWF  FE9
03BDA:  MOVLW  01
03BDC:  ADDWFC xF9,W
03BDE:  MOVWF  FEA
03BE0:  BTFSC  FEF.1
03BE2:  BRA    3CC8
03BE4:  CLRF   xFB
03BE6:  MOVFF  169,5FA
03BEA:  MOVLW  65
03BEC:  ADDWF  xFA,W
03BEE:  MOVWF  FE9
03BF0:  MOVLW  01
03BF2:  ADDWFC xFB,W
03BF4:  MOVWF  FEA
03BF6:  BTFSS  FEF.0
03BF8:  BRA    3CC8
....................       smData[ch].adcBusy = true;
03BFA:  CLRF   xF9
03BFC:  MOVFF  169,5F8
03C00:  MOVLW  65
03C02:  ADDWF  xF8,W
03C04:  MOVWF  FE9
03C06:  MOVLW  01
03C08:  ADDWFC xF9,W
03C0A:  MOVWF  FEA
03C0C:  BSF    FEF.1
....................       
....................       sinRaw = ads_read_data(ch*2);
03C0E:  BCF    FD8.0
03C10:  MOVLB  1
03C12:  RLCF   x69,W
03C14:  MOVLB  5
03C16:  MOVWF  xF8
03C18:  MOVWF  xF9
03C1A:  MOVLB  0
03C1C:  CALL   13F0
03C20:  MOVFF  03,5F3
03C24:  MOVFF  02,5F2
03C28:  MOVFF  01,5F1
03C2C:  MOVFF  00,5F0
....................       cosRaw = ads_read_data(ch*2+1);      
03C30:  BCF    FD8.0
03C32:  MOVLB  1
03C34:  RLCF   x69,W
03C36:  ADDLW  01
03C38:  MOVLB  5
03C3A:  MOVWF  xF8
03C3C:  MOVWF  xF9
03C3E:  MOVLB  0
03C40:  CALL   13F0
03C44:  MOVFF  03,5F7
03C48:  MOVFF  02,5F6
03C4C:  MOVFF  01,5F5
03C50:  MOVFF  00,5F4
....................       
....................       sensor_process_data(ch, sinRaw, cosRaw);
03C54:  MOVFF  169,5F8
03C58:  MOVFF  5F3,5FC
03C5C:  MOVFF  5F2,5FB
03C60:  MOVFF  5F1,5FA
03C64:  MOVFF  5F0,5F9
03C68:  MOVFF  5F7,600
03C6C:  MOVFF  5F6,5FF
03C70:  MOVFF  5F5,5FE
03C74:  MOVFF  5F4,5FD
03C78:  GOTO   2E7A
....................       ch = !ch;
03C7C:  MOVLB  1
03C7E:  MOVF   x69,F
03C80:  BZ    3C86
03C82:  MOVLW  00
03C84:  BRA    3C88
03C86:  MOVLW  01
03C88:  MOVWF  x69
....................       
....................       smData[!ch].dataReady = false;
03C8A:  MOVF   x69,F
03C8C:  BZ    3C92
03C8E:  MOVLW  00
03C90:  BRA    3C94
03C92:  MOVLW  01
03C94:  MOVLB  5
03C96:  CLRF   xF9
03C98:  MOVWF  xF8
03C9A:  MOVLW  65
03C9C:  ADDWF  xF8,W
03C9E:  MOVWF  FE9
03CA0:  MOVLW  01
03CA2:  ADDWFC xF9,W
03CA4:  MOVWF  FEA
03CA6:  BCF    FEF.0
....................       smData[!ch].adcBusy = false;
03CA8:  MOVLB  1
03CAA:  MOVF   x69,F
03CAC:  BZ    3CB2
03CAE:  MOVLW  00
03CB0:  BRA    3CB4
03CB2:  MOVLW  01
03CB4:  MOVLB  5
03CB6:  CLRF   xF9
03CB8:  MOVWF  xF8
03CBA:  MOVLW  65
03CBC:  ADDWF  xF8,W
03CBE:  MOVWF  FE9
03CC0:  MOVLW  01
03CC2:  ADDWFC xF9,W
03CC4:  MOVWF  FEA
03CC6:  BCF    FEF.1
....................    }
03CC8:  MOVLB  0
03CCA:  GOTO   9E70 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
007A2:  MOVLB  5
007A4:  CLRF   xF0
007A6:  CLRF   xF1
007A8:  CLRF   xF2
007AA:  CLRF   xF3
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
007AC:  CLRF   xF4
007AE:  MOVF   xF4,W
007B0:  SUBLW  03
007B2:  BNC   07EA
....................    {
....................       rc0=reg0config;
007B4:  MOVLW  30
007B6:  MOVWF  xF0
....................       rc1=reg1config;
007B8:  MOVLW  10
007BA:  MOVWF  xF1
....................       rc2=reg2config;
007BC:  MOVLW  30
007BE:  MOVWF  xF2
....................       rc3=reg3config;
007C0:  CLRF   xF3
....................       
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
007C2:  MOVFF  5F4,5F5
007C6:  MOVFF  5F0,5F6
007CA:  MOVFF  5F1,5F7
007CE:  MOVFF  5F2,5F8
007D2:  MOVFF  5F3,5F9
007D6:  MOVLB  0
007D8:  BRA    0738
....................       delay_ms(1);
007DA:  MOVLW  01
007DC:  MOVLB  5
007DE:  MOVWF  xF5
007E0:  MOVLB  0
007E2:  RCALL  0424
007E4:  MOVLB  5
007E6:  INCF   xF4,F
007E8:  BRA    07AE
....................    }   
007EA:  MOVLB  0
007EC:  GOTO   0850 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
007F0:  MOVLW  00
007F2:  MOVLB  F
007F4:  MOVWF  x53
007F6:  MOVLW  40
007F8:  MOVWF  x0C
007FA:  MOVLW  00
007FC:  MOVWF  x14
007FE:  MOVLW  03
00800:  MOVWF  x1C
00802:  MOVLW  0F
00804:  MOVWF  x21
00806:  MOVLW  00
00808:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
0080A:  MOVLW  08
0080C:  MOVWF  x55
0080E:  CLRF   x56
00810:  CLRF   x52
00812:  SETF   x57
00814:  CLRF   F61
00816:  MOVLW  94
00818:  MOVWF  x5B
....................    output_high(EN_EXC);
0081A:  MOVLW  E8
0081C:  MOVWF  F8B
0081E:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
00820:  MOVF   x5A,W
00822:  ANDLW  3F
00824:  MOVWF  01
00826:  MOVLW  06
00828:  MOVWF  x5A
0082A:  BTFSS  x5B.7
0082C:  BRA    083C
0082E:  MOVF   01,W
00830:  SUBLW  06
00832:  BZ    083C
00834:  BSF    x5B.0
00836:  NOP   
00838:  BTFSC  x5B.0
0083A:  BRA    0838
....................    delay_ms(10);
0083C:  MOVLW  0A
0083E:  MOVLB  5
00840:  MOVWF  xF5
00842:  MOVLB  0
00844:  RCALL  0424
....................    read_adc(ADC_START_ONLY);
00846:  MOVLB  F
00848:  BSF    x5B.0
0084A:  NOP   
....................    setup_external_ADCs();
0084C:  MOVLB  0
0084E:  BRA    07A2
....................    intTimeoutReg = sensorSampleRate;
00850:  MOVLB  1
00852:  CLRF   x64
00854:  MOVLW  32
00856:  MOVWF  x63
00858:  MOVLB  0
0085A:  GOTO   9E58 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
*
03DA8:  MOVLB  5
03DAA:  MOVF   xF4,W
03DAC:  MULLW  20
03DAE:  MOVF   FF3,W
03DB0:  MOVLB  6
03DB2:  CLRF   x02
03DB4:  MOVWF  x01
03DB6:  MOVLW  0C
03DB8:  ADDWF  x01,W
03DBA:  MOVWF  01
03DBC:  MOVLW  00
03DBE:  ADDWFC x02,W
03DC0:  MOVWF  03
03DC2:  MOVF   01,W
03DC4:  ADDLW  20
03DC6:  MOVWF  FE9
03DC8:  MOVLW  00
03DCA:  ADDWFC 03,W
03DCC:  MOVWF  FEA
03DCE:  MOVFF  FEF,64F
03DD2:  MOVFF  FEC,650
03DD6:  MOVFF  FEC,651
03DDA:  MOVFF  FEC,652
03DDE:  MOVLB  5
03DE0:  MOVF   xF4,W
03DE2:  MULLW  20
03DE4:  MOVF   FF3,W
03DE6:  MOVLB  6
03DE8:  CLRF   x06
03DEA:  MOVWF  x05
03DEC:  MOVLW  10
03DEE:  ADDWF  x05,W
03DF0:  MOVWF  01
03DF2:  MOVLW  00
03DF4:  ADDWFC x06,W
03DF6:  MOVWF  03
03DF8:  MOVF   01,W
03DFA:  ADDLW  20
03DFC:  MOVWF  FE9
03DFE:  MOVLW  00
03E00:  ADDWFC 03,W
03E02:  MOVWF  FEA
03E04:  MOVFF  FEF,653
03E08:  MOVFF  FEC,01
03E0C:  MOVFF  FEC,02
03E10:  MOVFF  FEC,03
03E14:  MOVFF  FEA,606
03E18:  MOVFF  FE9,605
03E1C:  BSF    FD8.1
03E1E:  MOVFF  03,656
03E22:  MOVFF  02,655
03E26:  MOVFF  01,654
03E2A:  MOVLB  0
03E2C:  CALL   0BE0
03E30:  MOVFF  606,FEA
03E34:  MOVFF  605,FE9
03E38:  MOVFF  03,5F8
03E3C:  MOVFF  02,5F7
03E40:  MOVFF  01,5F6
03E44:  MOVFF  00,5F5
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
03E48:  MOVLB  5
03E4A:  MOVF   xF4,W
03E4C:  MULLW  20
03E4E:  MOVF   FF3,W
03E50:  MOVLB  6
03E52:  CLRF   x02
03E54:  MOVWF  x01
03E56:  MOVLW  1C
03E58:  ADDWF  x01,W
03E5A:  MOVWF  01
03E5C:  MOVLW  00
03E5E:  ADDWFC x02,W
03E60:  MOVWF  03
03E62:  MOVF   01,W
03E64:  ADDLW  20
03E66:  MOVWF  01
03E68:  MOVLW  00
03E6A:  ADDWFC 03,F
03E6C:  MOVFF  01,601
03E70:  MOVFF  03,602
03E74:  MOVFF  03,FEA
03E78:  MOVFF  01,FE9
03E7C:  MOVFF  FEF,603
03E80:  MOVFF  FEC,604
03E84:  MOVFF  FEC,605
03E88:  MOVFF  FEC,606
03E8C:  MOVLB  5
03E8E:  MOVF   xF4,W
03E90:  MULLW  20
03E92:  MOVF   FF3,W
03E94:  MOVLB  6
03E96:  CLRF   x08
03E98:  MOVWF  x07
03E9A:  MOVLW  04
03E9C:  ADDWF  x07,W
03E9E:  MOVWF  01
03EA0:  MOVLW  00
03EA2:  ADDWFC x08,W
03EA4:  MOVWF  03
03EA6:  MOVF   01,W
03EA8:  ADDLW  20
03EAA:  MOVWF  FE9
03EAC:  MOVLW  00
03EAE:  ADDWFC 03,W
03EB0:  MOVWF  FEA
03EB2:  MOVFF  FEF,64F
03EB6:  MOVFF  FEC,01
03EBA:  MOVFF  FEC,02
03EBE:  MOVFF  FEC,03
03EC2:  MOVFF  5F8,64E
03EC6:  MOVFF  5F7,64D
03ECA:  MOVFF  5F6,64C
03ECE:  MOVFF  5F5,64B
03ED2:  MOVFF  03,652
03ED6:  MOVFF  02,651
03EDA:  MOVFF  01,650
03EDE:  MOVLB  0
03EE0:  CALL   0AEA
03EE4:  BCF    FD8.1
03EE6:  MOVFF  606,652
03EEA:  MOVFF  605,651
03EEE:  MOVFF  604,650
03EF2:  MOVFF  603,64F
03EF6:  MOVFF  03,656
03EFA:  MOVFF  02,655
03EFE:  MOVFF  01,654
03F02:  MOVFF  00,653
03F06:  CALL   0BE0
03F0A:  MOVFF  602,FEA
03F0E:  MOVFF  601,FE9
03F12:  MOVFF  00,FEF
03F16:  MOVFF  01,FEC
03F1A:  MOVFF  02,FEC
03F1E:  MOVFF  03,FEC
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
03F22:  MOVLB  5
03F24:  MOVF   xF4,W
03F26:  MULLW  20
03F28:  MOVF   FF3,W
03F2A:  MOVLB  6
03F2C:  CLRF   x02
03F2E:  MOVWF  x01
03F30:  MOVLW  1C
03F32:  ADDWF  x01,W
03F34:  MOVWF  01
03F36:  MOVLW  00
03F38:  ADDWFC x02,W
03F3A:  MOVWF  03
03F3C:  MOVF   01,W
03F3E:  ADDLW  20
03F40:  MOVWF  FE9
03F42:  MOVLW  00
03F44:  ADDWFC 03,W
03F46:  MOVWF  FEA
03F48:  MOVFF  FEF,64F
03F4C:  MOVFF  FEC,602
03F50:  MOVFF  FEC,651
03F54:  MOVFF  FEC,652
03F58:  CLRF   x4E
03F5A:  CLRF   x4D
03F5C:  MOVLW  7C
03F5E:  MOVWF  x4C
03F60:  MOVLW  84
03F62:  MOVWF  x4B
03F64:  MOVFF  602,650
03F68:  MOVLB  0
03F6A:  CALL   149A
03F6E:  BNC   3FA4
03F70:  MOVLB  5
03F72:  MOVF   xF4,W
03F74:  MULLW  20
03F76:  MOVF   FF3,W
03F78:  MOVLB  6
03F7A:  CLRF   x02
03F7C:  MOVWF  x01
03F7E:  MOVLW  1C
03F80:  ADDWF  x01,W
03F82:  MOVWF  01
03F84:  MOVLW  00
03F86:  ADDWFC x02,W
03F88:  MOVWF  03
03F8A:  MOVF   01,W
03F8C:  ADDLW  20
03F8E:  MOVWF  FE9
03F90:  MOVLW  00
03F92:  ADDWFC 03,W
03F94:  MOVWF  FEA
03F96:  MOVLW  84
03F98:  MOVWF  FEF
03F9A:  MOVLW  7C
03F9C:  MOVWF  FEC
03F9E:  CLRF   FEC
03FA0:  CLRF   FEC
03FA2:  BRA    4024
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
03FA4:  MOVLB  5
03FA6:  MOVF   xF4,W
03FA8:  MULLW  20
03FAA:  MOVF   FF3,W
03FAC:  MOVLB  6
03FAE:  CLRF   x02
03FB0:  MOVWF  x01
03FB2:  MOVLW  1C
03FB4:  ADDWF  x01,W
03FB6:  MOVWF  01
03FB8:  MOVLW  00
03FBA:  ADDWFC x02,W
03FBC:  MOVWF  03
03FBE:  MOVF   01,W
03FC0:  ADDLW  20
03FC2:  MOVWF  FE9
03FC4:  MOVLW  00
03FC6:  ADDWFC 03,W
03FC8:  MOVWF  FEA
03FCA:  MOVFF  FEF,64B
03FCE:  MOVFF  FEC,602
03FD2:  MOVFF  FEC,64D
03FD6:  MOVFF  FEC,64E
03FDA:  MOVFF  602,64C
03FDE:  CLRF   x52
03FE0:  CLRF   x51
03FE2:  MOVLW  FC
03FE4:  MOVWF  x50
03FE6:  MOVLW  84
03FE8:  MOVWF  x4F
03FEA:  MOVLB  0
03FEC:  CALL   149A
03FF0:  BNC   4026
03FF2:  MOVLB  5
03FF4:  MOVF   xF4,W
03FF6:  MULLW  20
03FF8:  MOVF   FF3,W
03FFA:  MOVLB  6
03FFC:  CLRF   x02
03FFE:  MOVWF  x01
04000:  MOVLW  1C
04002:  ADDWF  x01,W
04004:  MOVWF  01
04006:  MOVLW  00
04008:  ADDWFC x02,W
0400A:  MOVWF  03
0400C:  MOVF   01,W
0400E:  ADDLW  20
04010:  MOVWF  FE9
04012:  MOVLW  00
04014:  ADDWFC 03,W
04016:  MOVWF  FEA
04018:  MOVLW  84
0401A:  MOVWF  FEF
0401C:  MOVLW  FC
0401E:  MOVWF  FEC
04020:  CLRF   FEC
04022:  CLRF   FEC
04024:  MOVLB  0
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
04026:  MOVLB  5
04028:  MOVF   xF4,W
0402A:  MULLW  20
0402C:  MOVF   FF3,W
0402E:  MOVLB  6
04030:  CLRF   x02
04032:  MOVWF  x01
04034:  MOVLW  20
04036:  ADDWF  x01,W
04038:  MOVWF  FE9
0403A:  MOVLW  00
0403C:  ADDWFC x02,W
0403E:  MOVWF  FEA
04040:  MOVFF  FEF,64F
04044:  MOVFF  FEC,01
04048:  MOVFF  FEC,02
0404C:  MOVFF  FEC,03
04050:  MOVFF  5F8,64E
04054:  MOVFF  5F7,64D
04058:  MOVFF  5F6,64C
0405C:  MOVFF  5F5,64B
04060:  MOVFF  03,652
04064:  MOVFF  02,651
04068:  MOVFF  01,650
0406C:  MOVLB  0
0406E:  CALL   0AEA
04072:  MOVFF  03,5FC
04076:  MOVFF  02,5FB
0407A:  MOVFF  01,5FA
0407E:  MOVFF  00,5F9
04082:  MOVLB  5
04084:  MOVF   xF4,W
04086:  MULLW  20
04088:  MOVF   FF3,W
0408A:  MOVLB  6
0408C:  CLRF   x04
0408E:  MOVWF  x03
04090:  MOVLW  08
04092:  ADDWF  x03,W
04094:  MOVWF  01
04096:  MOVLW  00
04098:  ADDWFC x04,W
0409A:  MOVWF  03
0409C:  MOVF   01,W
0409E:  ADDLW  20
040A0:  MOVWF  FE9
040A2:  MOVLW  00
040A4:  ADDWFC 03,W
040A6:  MOVWF  FEA
040A8:  MOVFF  FEF,603
040AC:  MOVFF  FEC,604
040B0:  MOVFF  FEC,605
040B4:  MOVFF  FEC,606
040B8:  MOVLB  5
040BA:  MOVF   xF4,W
040BC:  MULLW  20
040BE:  MOVF   FF3,W
040C0:  MOVLB  6
040C2:  CLRF   x08
040C4:  MOVWF  x07
040C6:  MOVLW  10
040C8:  ADDWF  x07,W
040CA:  MOVWF  01
040CC:  MOVLW  00
040CE:  ADDWFC x08,W
040D0:  MOVWF  03
040D2:  MOVF   01,W
040D4:  ADDLW  20
040D6:  MOVWF  FE9
040D8:  MOVLW  00
040DA:  ADDWFC 03,W
040DC:  MOVWF  FEA
040DE:  MOVFF  FEF,64F
040E2:  MOVFF  FEC,650
040E6:  MOVFF  FEC,651
040EA:  MOVFF  FEC,652
040EE:  MOVLB  5
040F0:  MOVF   xF4,W
040F2:  MULLW  20
040F4:  MOVF   FF3,W
040F6:  MOVLB  6
040F8:  CLRF   x0C
040FA:  MOVWF  x0B
040FC:  MOVLW  14
040FE:  ADDWF  x0B,W
04100:  MOVWF  01
04102:  MOVLW  00
04104:  ADDWFC x0C,W
04106:  MOVWF  03
04108:  MOVF   01,W
0410A:  ADDLW  20
0410C:  MOVWF  FE9
0410E:  MOVLW  00
04110:  ADDWFC 03,W
04112:  MOVWF  FEA
04114:  MOVFF  FEF,653
04118:  MOVFF  FEC,01
0411C:  MOVFF  FEC,02
04120:  MOVFF  FEC,03
04124:  MOVFF  FEA,60C
04128:  MOVFF  FE9,60B
0412C:  BSF    FD8.1
0412E:  MOVFF  03,656
04132:  MOVFF  02,655
04136:  MOVFF  01,654
0413A:  MOVLB  0
0413C:  CALL   0BE0
04140:  MOVFF  60C,FEA
04144:  MOVFF  60B,FE9
04148:  MOVFF  606,64E
0414C:  MOVFF  605,64D
04150:  MOVFF  604,64C
04154:  MOVFF  603,64B
04158:  MOVFF  03,652
0415C:  MOVFF  02,651
04160:  MOVFF  01,650
04164:  MOVFF  00,64F
04168:  CALL   0AEA
0416C:  MOVFF  03,600
04170:  MOVFF  02,5FF
04174:  MOVFF  01,5FE
04178:  MOVFF  00,5FD
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
0417C:  MOVLB  5
0417E:  MOVF   xF4,W
04180:  MULLW  20
04182:  MOVF   FF3,W
04184:  MOVLB  6
04186:  CLRF   x02
04188:  MOVWF  x01
0418A:  MOVLW  18
0418C:  ADDWF  x01,W
0418E:  MOVWF  01
04190:  MOVLW  00
04192:  ADDWFC x02,W
04194:  MOVWF  03
04196:  MOVF   01,W
04198:  ADDLW  20
0419A:  MOVWF  01
0419C:  MOVLW  00
0419E:  ADDWFC 03,F
041A0:  MOVFF  01,601
041A4:  MOVFF  03,602
041A8:  MOVLB  5
041AA:  MOVF   xF4,W
041AC:  MULLW  20
041AE:  MOVF   FF3,W
041B0:  MOVLB  6
041B2:  CLRF   x04
041B4:  MOVWF  x03
041B6:  MOVLW  1C
041B8:  ADDWF  x03,W
041BA:  MOVWF  01
041BC:  MOVLW  00
041BE:  ADDWFC x04,W
041C0:  MOVWF  03
041C2:  MOVF   01,W
041C4:  ADDLW  20
041C6:  MOVWF  FE9
041C8:  MOVLW  00
041CA:  ADDWFC 03,W
041CC:  MOVWF  FEA
041CE:  MOVFF  FEF,653
041D2:  MOVFF  FEC,01
041D6:  MOVFF  FEC,02
041DA:  MOVFF  FEC,03
041DE:  MOVFF  FEA,604
041E2:  MOVFF  FE9,603
041E6:  BCF    FD8.1
041E8:  MOVFF  5FC,652
041EC:  MOVFF  5FB,651
041F0:  MOVFF  5FA,650
041F4:  MOVFF  5F9,64F
041F8:  MOVFF  03,656
041FC:  MOVFF  02,655
04200:  MOVFF  01,654
04204:  MOVLB  0
04206:  CALL   0BE0
0420A:  MOVFF  604,FEA
0420E:  MOVFF  603,FE9
04212:  MOVFF  03,608
04216:  MOVFF  02,607
0421A:  MOVFF  01,606
0421E:  MOVFF  00,605
04222:  BCF    FD8.1
04224:  MOVFF  03,652
04228:  MOVFF  02,651
0422C:  MOVFF  01,650
04230:  MOVFF  00,64F
04234:  MOVFF  600,656
04238:  MOVFF  5FF,655
0423C:  MOVFF  5FE,654
04240:  MOVFF  5FD,653
04244:  CALL   0BE0
04248:  MOVFF  602,FEA
0424C:  MOVFF  601,FE9
04250:  MOVFF  00,FEF
04254:  MOVFF  01,FEC
04258:  MOVFF  02,FEC
0425C:  MOVFF  03,FEC
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
04260:  MOVLB  5
04262:  MOVF   xF4,W
04264:  MULLW  20
04266:  MOVF   FF3,W
04268:  MOVLB  6
0426A:  CLRF   x02
0426C:  MOVWF  x01
0426E:  MOVLW  18
04270:  ADDWF  x01,W
04272:  MOVWF  01
04274:  MOVLW  00
04276:  ADDWFC x02,W
04278:  MOVWF  03
0427A:  MOVF   01,W
0427C:  ADDLW  20
0427E:  MOVWF  FE9
04280:  MOVLW  00
04282:  ADDWFC 03,W
04284:  MOVWF  FEA
04286:  MOVFF  FEF,64F
0428A:  MOVFF  FEC,602
0428E:  MOVFF  FEC,651
04292:  MOVFF  FEC,652
04296:  CLRF   x4E
04298:  CLRF   x4D
0429A:  MOVLW  7C
0429C:  MOVWF  x4C
0429E:  MOVLW  84
042A0:  MOVWF  x4B
042A2:  MOVFF  602,650
042A6:  MOVLB  0
042A8:  CALL   149A
042AC:  BNC   42E2
042AE:  MOVLB  5
042B0:  MOVF   xF4,W
042B2:  MULLW  20
042B4:  MOVF   FF3,W
042B6:  MOVLB  6
042B8:  CLRF   x02
042BA:  MOVWF  x01
042BC:  MOVLW  18
042BE:  ADDWF  x01,W
042C0:  MOVWF  01
042C2:  MOVLW  00
042C4:  ADDWFC x02,W
042C6:  MOVWF  03
042C8:  MOVF   01,W
042CA:  ADDLW  20
042CC:  MOVWF  FE9
042CE:  MOVLW  00
042D0:  ADDWFC 03,W
042D2:  MOVWF  FEA
042D4:  MOVLW  84
042D6:  MOVWF  FEF
042D8:  MOVLW  7C
042DA:  MOVWF  FEC
042DC:  CLRF   FEC
042DE:  CLRF   FEC
042E0:  BRA    4362
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
042E2:  MOVLB  5
042E4:  MOVF   xF4,W
042E6:  MULLW  20
042E8:  MOVF   FF3,W
042EA:  MOVLB  6
042EC:  CLRF   x02
042EE:  MOVWF  x01
042F0:  MOVLW  18
042F2:  ADDWF  x01,W
042F4:  MOVWF  01
042F6:  MOVLW  00
042F8:  ADDWFC x02,W
042FA:  MOVWF  03
042FC:  MOVF   01,W
042FE:  ADDLW  20
04300:  MOVWF  FE9
04302:  MOVLW  00
04304:  ADDWFC 03,W
04306:  MOVWF  FEA
04308:  MOVFF  FEF,64B
0430C:  MOVFF  FEC,602
04310:  MOVFF  FEC,64D
04314:  MOVFF  FEC,64E
04318:  MOVFF  602,64C
0431C:  CLRF   x52
0431E:  CLRF   x51
04320:  MOVLW  FC
04322:  MOVWF  x50
04324:  MOVLW  84
04326:  MOVWF  x4F
04328:  MOVLB  0
0432A:  CALL   149A
0432E:  BNC   4362
04330:  MOVLB  5
04332:  MOVF   xF4,W
04334:  MULLW  20
04336:  MOVF   FF3,W
04338:  MOVLB  6
0433A:  CLRF   x02
0433C:  MOVWF  x01
0433E:  MOVLW  18
04340:  ADDWF  x01,W
04342:  MOVWF  01
04344:  MOVLW  00
04346:  ADDWFC x02,W
04348:  MOVWF  03
0434A:  MOVF   01,W
0434C:  ADDLW  20
0434E:  MOVWF  FE9
04350:  MOVLW  00
04352:  ADDWFC 03,W
04354:  MOVWF  FEA
04356:  MOVLW  84
04358:  MOVWF  FEF
0435A:  MOVLW  FC
0435C:  MOVWF  FEC
0435E:  CLRF   FEC
04360:  CLRF   FEC
04362:  MOVLB  0
04364:  GOTO   43DC (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
04368:  MOVLB  5
0436A:  MOVF   xF3,W
0436C:  MULLW  20
0436E:  MOVF   FF3,W
04370:  CLRF   xF5
04372:  MOVWF  xF4
04374:  MOVLW  0C
04376:  ADDWF  xF4,W
04378:  MOVWF  01
0437A:  MOVLW  00
0437C:  ADDWFC xF5,W
0437E:  MOVWF  03
04380:  MOVF   01,W
04382:  ADDLW  20
04384:  MOVWF  FE9
04386:  MOVLW  00
04388:  ADDWFC 03,W
0438A:  MOVWF  FEA
0438C:  MOVFF  FEF,64B
04390:  MOVFF  FEC,64C
04394:  MOVFF  FEC,64D
04398:  MOVFF  FEC,64E
0439C:  MOVF   xF3,W
0439E:  MULLW  20
043A0:  MOVF   FF3,W
043A2:  CLRF   xF9
043A4:  MOVWF  xF8
043A6:  MOVLW  10
043A8:  ADDWF  xF8,W
043AA:  MOVWF  01
043AC:  MOVLW  00
043AE:  ADDWFC xF9,W
043B0:  MOVWF  03
043B2:  MOVF   01,W
043B4:  ADDLW  20
043B6:  MOVWF  FE9
043B8:  MOVLW  00
043BA:  ADDWFC 03,W
043BC:  MOVWF  FEA
043BE:  MOVFF  FEF,64F
043C2:  MOVFF  FEC,650
043C6:  MOVFF  FEC,651
043CA:  MOVFF  FEC,652
043CE:  MOVLB  0
043D0:  CALL   149A
043D4:  BZ    43DC
043D6:  MOVFF  5F3,5F4
043DA:  BRA    3DA8
....................    if ((index++) >= numChannels) index = 0;
043DC:  MOVLB  1
043DE:  MOVF   x6A,W
043E0:  INCF   x6A,F
043E2:  SUBLW  01
043E4:  BC    43E8
043E6:  CLRF   x6A
043E8:  MOVLB  0
043EA:  GOTO   44DA (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=2, STREAM=SPI_ctrl)
*
0085E:  CLRF   03
00860:  MOVF   F91,W
00862:  MOVFF  5F5,F91
00866:  RRCF   F94,W
00868:  BNC   0866
0086A:  MOVF   F91,W
0086C:  MOVWF  02
0086E:  MOVFF  5F4,F91
00872:  RRCF   F94,W
00874:  BNC   0872
00876:  MOVF   F91,W
00878:  MOVWF  01
0087A:  MOVFF  5F3,F91
0087E:  RRCF   F94,W
00880:  BNC   087E
00882:  MOVFF  F91,00
00886:  RETURN 0
.................... 
.................... #define DACfullScale 655.35 // full scale/100 because CV = %
.................... 
.................... /*****************************************************************************/
.................... /*  Inverts the output voltage ( -180V - 0V )                                */ 
.................... /*****************************************************************************/
.................... void invert_voltage(channelMap ch, BOOLEAN inv_v){
....................    if ( inv_v ) {
*
03D04:  MOVLB  5
03D06:  MOVF   xF4,F
03D08:  BZ    3D58
....................       if (chMap[0] == ch) output_low(INV_HVX);
03D0A:  MOVLW  00
03D0C:  MOVLB  0
03D0E:  BTFSC  x60.0
03D10:  MOVLW  01
03D12:  MOVLB  5
03D14:  SUBWF  xF3,W
03D16:  BNZ   3D1E
03D18:  MOVLW  C4
03D1A:  MOVWF  F88
03D1C:  BCF    F83.4
....................       if (chMap[1] == ch) output_low(INV_HVY);
03D1E:  MOVLW  00
03D20:  MOVLB  0
03D22:  BTFSC  x60.1
03D24:  MOVLW  01
03D26:  MOVLB  5
03D28:  SUBWF  xF3,W
03D2A:  BNZ   3D32
03D2C:  MOVLW  C4
03D2E:  MOVWF  F88
03D30:  BCF    F83.5
....................       dacVals[ch].invV = TRUE;
03D32:  MOVF   xF3,W
03D34:  MULLW  03
03D36:  MOVF   FF3,W
03D38:  CLRF   xF6
03D3A:  MOVWF  xF5
03D3C:  MOVLW  02
03D3E:  ADDWF  xF5,W
03D40:  MOVWF  01
03D42:  MOVLW  00
03D44:  ADDWFC xF6,W
03D46:  MOVWF  03
03D48:  MOVF   01,W
03D4A:  ADDLW  51
03D4C:  MOVWF  FE9
03D4E:  MOVLW  01
03D50:  ADDWFC 03,W
03D52:  MOVWF  FEA
03D54:  BSF    FEF.0
....................    }
03D56:  BRA    3DA4
....................    else {
....................       if (chMap[0] == ch) output_high(INV_HVX);
03D58:  MOVLW  00
03D5A:  MOVLB  0
03D5C:  BTFSC  x60.0
03D5E:  MOVLW  01
03D60:  MOVLB  5
03D62:  SUBWF  xF3,W
03D64:  BNZ   3D6C
03D66:  MOVLW  C4
03D68:  MOVWF  F88
03D6A:  BSF    F83.4
....................       if (chMap[1] == ch) output_high(INV_HVY);
03D6C:  MOVLW  00
03D6E:  MOVLB  0
03D70:  BTFSC  x60.1
03D72:  MOVLW  01
03D74:  MOVLB  5
03D76:  SUBWF  xF3,W
03D78:  BNZ   3D80
03D7A:  MOVLW  C4
03D7C:  MOVWF  F88
03D7E:  BSF    F83.5
....................       dacVals[ch].invV = FALSE;
03D80:  MOVF   xF3,W
03D82:  MULLW  03
03D84:  MOVF   FF3,W
03D86:  CLRF   xF6
03D88:  MOVWF  xF5
03D8A:  MOVLW  02
03D8C:  ADDWF  xF5,W
03D8E:  MOVWF  01
03D90:  MOVLW  00
03D92:  ADDWFC xF6,W
03D94:  MOVWF  03
03D96:  MOVF   01,W
03D98:  ADDLW  51
03D9A:  MOVWF  FE9
03D9C:  MOVLW  01
03D9E:  ADDWFC 03,W
03DA0:  MOVWF  FEA
03DA2:  BCF    FEF.0
....................    }
03DA4:  MOVLB  0
03DA6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... void set_nanoDAC_outputs(channelMap ch){
*
043EE:  MOVLB  5
043F0:  CLRF   xF2
043F2:  CLRF   xF1
....................    unsigned int16 txData = 0;
....................    
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL){
043F4:  MOVFF  5F0,5FD
043F8:  CLRF   xFF
043FA:  MOVLW  61
043FC:  MOVWF  xFE
043FE:  MOVLB  0
04400:  RCALL  3CCE
04402:  MOVF   01,F
04404:  BNZ   44D4
....................       if ( manualOutputValues[ch] < 0) invert_voltage(ch, TRUE); 
04406:  MOVLB  5
04408:  MOVF   xF0,W
0440A:  MULLW  04
0440C:  MOVF   FF3,W
0440E:  CLRF   03
04410:  ADDLW  EA
04412:  MOVWF  FE9
04414:  MOVLW  00
04416:  ADDWFC 03,W
04418:  MOVWF  FEA
0441A:  MOVFF  FEF,64B
0441E:  MOVFF  FEC,64C
04422:  MOVFF  FEC,64D
04426:  MOVFF  FEC,64E
0442A:  MOVLB  6
0442C:  CLRF   x52
0442E:  CLRF   x51
04430:  CLRF   x50
04432:  CLRF   x4F
04434:  MOVLB  0
04436:  CALL   149A
0443A:  BNC   444C
0443C:  MOVFF  5F0,5F3
04440:  MOVLW  01
04442:  MOVLB  5
04444:  MOVWF  xF4
04446:  MOVLB  0
04448:  RCALL  3D04
0444A:  BRA    4458
....................       else                             invert_voltage(ch, FALSE);
0444C:  MOVFF  5F0,5F3
04450:  MOVLB  5
04452:  CLRF   xF4
04454:  MOVLB  0
04456:  RCALL  3D04
....................       
....................       txData = (unsigned int16)(abs(manualOutputValues[ch]) * DACfullScale);
04458:  MOVLB  5
0445A:  MOVF   xF0,W
0445C:  MULLW  04
0445E:  MOVF   FF3,W
04460:  CLRF   03
04462:  ADDLW  EA
04464:  MOVWF  FE9
04466:  MOVLW  00
04468:  ADDWFC 03,W
0446A:  MOVWF  FEA
0446C:  MOVFF  FEF,00
04470:  MOVFF  FEC,01
04474:  MOVFF  FEC,02
04478:  MOVFF  FEC,03
0447C:  BCF    01.7
0447E:  MOVFF  03,5F6
04482:  MOVFF  02,5F5
04486:  MOVFF  01,5F4
0448A:  MOVFF  00,5F3
0448E:  MOVFF  03,64E
04492:  MOVFF  02,64D
04496:  MOVFF  01,64C
0449A:  MOVFF  00,64B
0449E:  MOVLW  66
044A0:  MOVLB  6
044A2:  MOVWF  x52
044A4:  MOVLW  D6
044A6:  MOVWF  x51
044A8:  MOVLW  23
044AA:  MOVWF  x50
044AC:  MOVLW  88
044AE:  MOVWF  x4F
044B0:  MOVLB  0
044B2:  CALL   0AEA
044B6:  MOVFF  03,64E
044BA:  MOVFF  02,64D
044BE:  MOVFF  01,64C
044C2:  MOVFF  00,64B
044C6:  CALL   1E8E
044CA:  MOVFF  02,5F2
044CE:  MOVFF  01,5F1
....................    }
044D2:  BRA    45CA
....................    else {
....................       pid_task(ch);
044D4:  MOVFF  5F0,5F3
044D8:  BRA    4368
....................       if ( PID[(int)ch].CV < 0 ) invert_voltage(ch, TRUE); 
044DA:  MOVLB  5
044DC:  MOVF   xF0,W
044DE:  MULLW  20
044E0:  MOVF   FF3,W
044E2:  CLRF   xF4
044E4:  MOVWF  xF3
044E6:  MOVLW  18
044E8:  ADDWF  xF3,W
044EA:  MOVWF  01
044EC:  MOVLW  00
044EE:  ADDWFC xF4,W
044F0:  MOVWF  03
044F2:  MOVF   01,W
044F4:  ADDLW  20
044F6:  MOVWF  FE9
044F8:  MOVLW  00
044FA:  ADDWFC 03,W
044FC:  MOVWF  FEA
044FE:  MOVFF  FEF,64B
04502:  MOVFF  FEC,64C
04506:  MOVFF  FEC,64D
0450A:  MOVFF  FEC,64E
0450E:  MOVLB  6
04510:  CLRF   x52
04512:  CLRF   x51
04514:  CLRF   x50
04516:  CLRF   x4F
04518:  MOVLB  0
0451A:  CALL   149A
0451E:  BNC   4532
04520:  MOVFF  5F0,5F3
04524:  MOVLW  01
04526:  MOVLB  5
04528:  MOVWF  xF4
0452A:  MOVLB  0
0452C:  CALL   3D04
04530:  BRA    4540
....................       else                       invert_voltage(ch, FALSE);
04532:  MOVFF  5F0,5F3
04536:  MOVLB  5
04538:  CLRF   xF4
0453A:  MOVLB  0
0453C:  CALL   3D04
....................       
....................       txData = (unsigned int16)(abs(PID[(int)ch].CV) * DACfullScale);
04540:  MOVLB  5
04542:  MOVF   xF0,W
04544:  MULLW  20
04546:  MOVF   FF3,W
04548:  CLRF   xF4
0454A:  MOVWF  xF3
0454C:  MOVLW  18
0454E:  ADDWF  xF3,W
04550:  MOVWF  01
04552:  MOVLW  00
04554:  ADDWFC xF4,W
04556:  MOVWF  03
04558:  MOVF   01,W
0455A:  ADDLW  20
0455C:  MOVWF  FE9
0455E:  MOVLW  00
04560:  ADDWFC 03,W
04562:  MOVWF  FEA
04564:  MOVFF  FEF,00
04568:  MOVFF  FEC,01
0456C:  MOVFF  FEC,02
04570:  MOVFF  FEC,03
04574:  BCF    01.7
04576:  MOVFF  03,5F6
0457A:  MOVFF  02,5F5
0457E:  MOVFF  01,5F4
04582:  MOVFF  00,5F3
04586:  MOVFF  03,64E
0458A:  MOVFF  02,64D
0458E:  MOVFF  01,64C
04592:  MOVFF  00,64B
04596:  MOVLW  66
04598:  MOVLB  6
0459A:  MOVWF  x52
0459C:  MOVLW  D6
0459E:  MOVWF  x51
045A0:  MOVLW  23
045A2:  MOVWF  x50
045A4:  MOVLW  88
045A6:  MOVWF  x4F
045A8:  MOVLB  0
045AA:  CALL   0AEA
045AE:  MOVFF  03,64E
045B2:  MOVFF  02,64D
045B6:  MOVFF  01,64C
045BA:  MOVFF  00,64B
045BE:  CALL   1E8E
045C2:  MOVFF  02,5F2
045C6:  MOVFF  01,5F1
....................    }
....................    
....................    dacVals[ch].val = txData;
045CA:  MOVLB  5
045CC:  MOVF   xF0,W
045CE:  MULLW  03
045D0:  MOVF   FF3,W
045D2:  CLRF   xF4
045D4:  MOVWF  xF3
045D6:  MOVLW  51
045D8:  ADDWF  xF3,W
045DA:  MOVWF  FE9
045DC:  MOVLW  01
045DE:  ADDWFC xF4,W
045E0:  MOVWF  FEA
045E2:  MOVFF  5F2,FEC
045E6:  MOVF   FED,F
045E8:  MOVFF  5F1,FEF
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    if (chMap[0] == ch) output_high(_SYNC_X);
045EC:  MOVLW  00
045EE:  MOVLB  0
045F0:  BTFSC  x60.0
045F2:  MOVLW  01
045F4:  MOVLB  5
045F6:  SUBWF  xF0,W
045F8:  BNZ   4600
045FA:  MOVLW  E8
045FC:  MOVWF  F8B
045FE:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04600:  MOVLW  00
04602:  MOVLB  0
04604:  BTFSC  x60.1
04606:  MOVLW  01
04608:  MOVLB  5
0460A:  SUBWF  xF0,W
0460C:  BNZ   4614
0460E:  MOVLW  E8
04610:  MOVWF  F8B
04612:  BSF    F86.1
....................    
....................    delay_ms(1);
04614:  MOVLW  01
04616:  MOVWF  xF5
04618:  MOVLB  0
0461A:  CALL   0424
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
0461E:  MOVLW  00
04620:  BTFSC  x60.0
04622:  MOVLW  01
04624:  MOVLB  5
04626:  SUBWF  xF0,W
04628:  BNZ   4630
0462A:  MOVLW  E8
0462C:  MOVWF  F8B
0462E:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
04630:  MOVLW  00
04632:  MOVLB  0
04634:  BTFSC  x60.1
04636:  MOVLW  01
04638:  MOVLB  5
0463A:  SUBWF  xF0,W
0463C:  BNZ   4644
0463E:  MOVLW  E8
04640:  MOVWF  F8B
04642:  BCF    F86.1
....................    delay_ms(1);
04644:  MOVLW  01
04646:  MOVWF  xF5
04648:  MOVLB  0
0464A:  CALL   0424
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
0464E:  MOVLB  5
04650:  CLRF   xF6
04652:  CLRF   xF5
04654:  MOVFF  5F2,5F4
04658:  MOVFF  5F1,5F3
0465C:  MOVLB  0
0465E:  CALL   085E
....................    delay_ms(1);
04662:  MOVLW  01
04664:  MOVLB  5
04666:  MOVWF  xF5
04668:  MOVLB  0
0466A:  CALL   0424
....................    
....................    if (chMap[0] == ch) output_high(_SYNC_X);
0466E:  MOVLW  00
04670:  BTFSC  x60.0
04672:  MOVLW  01
04674:  MOVLB  5
04676:  SUBWF  xF0,W
04678:  BNZ   4680
0467A:  MOVLW  E8
0467C:  MOVWF  F8B
0467E:  BSF    F86.2
....................    if (chMap[1] == ch) output_high(_SYNC_Y);
04680:  MOVLW  00
04682:  MOVLB  0
04684:  BTFSC  x60.1
04686:  MOVLW  01
04688:  MOVLB  5
0468A:  SUBWF  xF0,W
0468C:  BNZ   4694
0468E:  MOVLW  E8
04690:  MOVWF  F8B
04692:  BSF    F86.1
04694:  MOVLB  0
04696:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task(){
....................    static int state = 0;
....................    
....................    switch (state)
04698:  MOVLB  1
0469A:  MOVF   x6B,W
0469C:  XORLW  00
0469E:  MOVLB  0
046A0:  BZ    46A8
046A2:  XORLW  01
046A4:  BZ    46BA
046A6:  BRA    46CA
....................    {
....................       case 0:
....................          set_nanoDAC_outputs(chX);
046A8:  MOVLB  5
046AA:  CLRF   xF0
046AC:  MOVLB  0
046AE:  RCALL  43EE
....................          state = 1;
046B0:  MOVLW  01
046B2:  MOVLB  1
046B4:  MOVWF  x6B
....................       break;
046B6:  MOVLB  0
046B8:  BRA    46CA
....................       case 1:
....................          set_nanoDAC_outputs(chY);
046BA:  MOVLW  01
046BC:  MOVLB  5
046BE:  MOVWF  xF0
046C0:  MOVLB  0
046C2:  RCALL  43EE
....................          state = 0;
046C4:  MOVLB  1
046C6:  CLRF   x6B
....................       break;
046C8:  MOVLB  0
....................    }
046CA:  GOTO   9E74 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init(){
....................    spi_xfer(SPI_ctrl, 0, 24);
*
00888:  MOVLB  5
0088A:  CLRF   xF6
0088C:  CLRF   xF5
0088E:  CLRF   xF4
00890:  CLRF   xF3
00892:  MOVLB  0
00894:  RCALL  085E
....................    output_low(_SYNC_X);
00896:  MOVLW  E8
00898:  MOVWF  F8B
0089A:  BCF    F86.2
....................    output_low(_SYNC_Y);
0089C:  MOVWF  F8B
0089E:  BCF    F86.1
....................    output_high(_SYNC_X);
008A0:  MOVWF  F8B
008A2:  BSF    F86.2
....................    output_high(_SYNC_Y);
008A4:  MOVWF  F8B
008A6:  BSF    F86.1
008A8:  GOTO   9E5C (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
008CE:  MOVLB  5
008D0:  MOVF   xF1,W
008D2:  SUBLW  03
008D4:  BTFSS  FD8.0
008D6:  BRA    0A54
....................    {
....................       for (int i = 0; i <numParam; i ++)
008D8:  CLRF   xF2
008DA:  MOVF   xF2,W
008DC:  SUBLW  06
008DE:  BNC   0932
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
008E0:  MOVLB  6
008E2:  CLRF   x32
008E4:  MOVFF  5F1,631
008E8:  CLRF   x34
008EA:  MOVLW  B5
008EC:  MOVWF  x33
008EE:  MOVLB  0
008F0:  RCALL  08AC
008F2:  MOVFF  02,5F4
008F6:  MOVFF  01,5F3
008FA:  MOVLW  06
008FC:  MOVLB  5
008FE:  ADDWF  xF3,F
00900:  MOVLW  00
00902:  ADDWFC xF4,F
00904:  MOVLB  6
00906:  CLRF   x32
00908:  MOVFF  5F2,631
0090C:  CLRF   x34
0090E:  MOVLW  19
00910:  MOVWF  x33
00912:  MOVLB  0
00914:  RCALL  08AC
00916:  MOVF   01,W
00918:  MOVLB  5
0091A:  ADDWF  xF3,F
0091C:  MOVF   02,W
0091E:  ADDWFC xF4,F
00920:  MOVLW  6C
00922:  ADDWF  xF3,W
00924:  MOVWF  FE9
00926:  MOVLW  01
00928:  ADDWFC xF4,W
0092A:  MOVWF  FEA
0092C:  CLRF   FEF
0092E:  INCF   xF2,F
00930:  BRA    08DA
....................       }
....................       SERcmd[recNum].t = 0;
00932:  MOVLB  6
00934:  CLRF   x32
00936:  MOVFF  5F1,631
0093A:  CLRF   x34
0093C:  MOVLW  B5
0093E:  MOVWF  x33
00940:  MOVLB  0
00942:  RCALL  08AC
00944:  MOVFF  01,5F3
00948:  MOVLW  05
0094A:  MOVLB  5
0094C:  ADDWF  01,W
0094E:  MOVWF  01
00950:  MOVLW  00
00952:  ADDWFC 02,W
00954:  MOVWF  03
00956:  MOVF   01,W
00958:  ADDLW  6C
0095A:  MOVWF  FE9
0095C:  MOVLW  01
0095E:  ADDWFC 03,W
00960:  MOVWF  FEA
00962:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
00964:  MOVLB  6
00966:  CLRF   x32
00968:  MOVFF  5F1,631
0096C:  CLRF   x34
0096E:  MOVLW  B5
00970:  MOVWF  x33
00972:  MOVLB  0
00974:  RCALL  08AC
00976:  MOVFF  01,5F3
0097A:  MOVLW  01
0097C:  MOVLB  5
0097E:  ADDWF  01,W
00980:  MOVWF  01
00982:  MOVLW  00
00984:  ADDWFC 02,W
00986:  MOVWF  03
00988:  MOVF   01,W
0098A:  ADDLW  6C
0098C:  MOVWF  FE9
0098E:  MOVLW  01
00990:  ADDWFC 03,W
00992:  MOVWF  FEA
00994:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
00996:  MOVLB  6
00998:  CLRF   x32
0099A:  MOVFF  5F1,631
0099E:  CLRF   x34
009A0:  MOVLW  B5
009A2:  MOVWF  x33
009A4:  MOVLB  0
009A6:  RCALL  08AC
009A8:  MOVFF  01,5F3
009AC:  MOVLW  02
009AE:  MOVLB  5
009B0:  ADDWF  01,W
009B2:  MOVWF  01
009B4:  MOVLW  00
009B6:  ADDWFC 02,W
009B8:  MOVWF  03
009BA:  MOVF   01,W
009BC:  ADDLW  6C
009BE:  MOVWF  FE9
009C0:  MOVLW  01
009C2:  ADDWFC 03,W
009C4:  MOVWF  FEA
009C6:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
009C8:  MOVLB  6
009CA:  CLRF   x32
009CC:  MOVFF  5F1,631
009D0:  CLRF   x34
009D2:  MOVLW  B5
009D4:  MOVWF  x33
009D6:  MOVLB  0
009D8:  RCALL  08AC
009DA:  MOVFF  01,5F3
009DE:  MOVLW  03
009E0:  MOVLB  5
009E2:  ADDWF  01,W
009E4:  MOVWF  01
009E6:  MOVLW  00
009E8:  ADDWFC 02,W
009EA:  MOVWF  03
009EC:  MOVF   01,W
009EE:  ADDLW  6C
009F0:  MOVWF  FE9
009F2:  MOVLW  01
009F4:  ADDWFC 03,W
009F6:  MOVWF  FEA
009F8:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
009FA:  MOVLB  6
009FC:  CLRF   x32
009FE:  MOVFF  5F1,631
00A02:  CLRF   x34
00A04:  MOVLW  B5
00A06:  MOVWF  x33
00A08:  MOVLB  0
00A0A:  RCALL  08AC
00A0C:  MOVFF  01,5F3
00A10:  MOVLW  04
00A12:  MOVLB  5
00A14:  ADDWF  01,W
00A16:  MOVWF  01
00A18:  MOVLW  00
00A1A:  ADDWFC 02,W
00A1C:  MOVWF  03
00A1E:  MOVF   01,W
00A20:  ADDLW  6C
00A22:  MOVWF  FE9
00A24:  MOVLW  01
00A26:  ADDWFC 03,W
00A28:  MOVWF  FEA
00A2A:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
00A2C:  MOVLB  6
00A2E:  CLRF   x32
00A30:  MOVFF  5F1,631
00A34:  CLRF   x34
00A36:  MOVLW  B5
00A38:  MOVWF  x33
00A3A:  MOVLB  0
00A3C:  RCALL  08AC
00A3E:  MOVLW  6C
00A40:  MOVLB  5
00A42:  ADDWF  01,W
00A44:  MOVWF  FE9
00A46:  MOVLW  01
00A48:  ADDWFC 02,W
00A4A:  MOVWF  FEA
00A4C:  BCF    FEF.0
....................       retData[0] = '\0';
00A4E:  MOVLB  4
00A50:  CLRF   x42
00A52:  MOVLB  5
....................    }
00A54:  MOVLB  0
00A56:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
050C8:  MOVLB  6
050CA:  CLRF   x32
050CC:  MOVFF  440,631
050D0:  CLRF   x34
050D2:  MOVLW  B5
050D4:  MOVWF  x33
050D6:  MOVLB  0
050D8:  CALL   08AC
050DC:  MOVFF  02,5F2
050E0:  MOVFF  01,5F1
050E4:  MOVLW  6C
050E6:  MOVLB  5
050E8:  ADDWF  01,W
050EA:  MOVWF  FE9
050EC:  MOVLW  01
050EE:  ADDWFC 02,W
050F0:  MOVWF  FEA
050F2:  BTFSC  FEF.0
050F4:  BRA    5116
....................    {
....................       if (SRI == SWI) return FALSE;
050F6:  MOVLB  4
050F8:  MOVF   x41,W
050FA:  SUBWF  x40,W
050FC:  BNZ   5104
050FE:  MOVLW  00
05100:  MOVWF  01
05102:  BRA    511C
....................       SRI +=1;
05104:  MOVLW  01
05106:  ADDWF  x40,F
....................       if (SRI >= numRecords) SRI=0;
05108:  MOVF   x40,W
0510A:  SUBLW  03
0510C:  BC    5110
0510E:  CLRF   x40
05110:  MOVLB  0
05112:  BRA    50C8
05114:  MOVLB  5
....................    }
....................    return TRUE;
05116:  MOVLW  01
05118:  MOVWF  01
0511A:  MOVLB  4
0511C:  MOVLB  0
0511E:  GOTO   99C4 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
04702:  MOVLW  01
04704:  MOVLB  4
04706:  ADDWF  x41,F
....................    if (SWI >= numRecords) SWI=0;
04708:  MOVF   x41,W
0470A:  SUBLW  03
0470C:  BC    4710
0470E:  CLRF   x41
04710:  MOVLB  0
04712:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B5,PIN_B4,PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define INV_HVX      PIN_B4
.................... #define INV_HVY      PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4E5
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xE5.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
04714:  MOVLW  93
04716:  MOVWF  F89
04718:  BSF    F84.5
0471A:  MOVLB  E
0471C:  BTFSS  xC8.4
0471E:  BRA    471C
04720:  MOVLW  93
04722:  MOVWF  F89
04724:  BSF    F84.5
04726:  MOVLB  6
04728:  MOVFF  60D,F99
0472C:  NOP   
0472E:  BTFSS  F9D.1
04730:  BRA    472E
04732:  MOVLW  93
04734:  MOVWF  F89
04736:  BCF    F84.5
04738:  MOVLB  0
0473A:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xE2,W
000F6:  ADDLW  A6
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,667
00104:  MOVFF  FE9,666
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  667,FEA
00110:  MOVFF  666,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xE2,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xE2,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xE2
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xE4.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
046CE:  CLRF   03
046D0:  MOVLB  4
046D2:  MOVF   xE3,W
046D4:  ADDLW  A6
046D6:  MOVWF  FE9
046D8:  MOVLW  04
046DA:  ADDWFC 03,W
046DC:  MOVWF  FEA
046DE:  MOVFF  FEF,5F1
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
046E2:  MOVLW  01
046E4:  ADDWF  xE3,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
046E6:  MOVF   xE3,W
046E8:  SUBLW  3B
046EA:  BC    46EE
046EC:  CLRF   xE3
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
046EE:  MOVF   xE2,W
046F0:  SUBWF  xE3,W
046F2:  BNZ   46F6
046F4:  BCF    xE4.0
....................    return data;
046F6:  MOVLB  5
046F8:  MOVFF  5F1,01
046FC:  MOVLB  0
046FE:  GOTO   47A2 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
04760:  MOVLB  4
04762:  BTFSS  xE4.0
04764:  BRA    4C72
04766:  MOVLB  6
04768:  CLRF   x32
0476A:  MOVFF  441,631
0476E:  CLRF   x34
04770:  MOVLW  B5
04772:  MOVWF  x33
04774:  MOVLB  0
04776:  CALL   08AC
0477A:  MOVFF  02,5F2
0477E:  MOVFF  01,5F1
04782:  MOVLW  6C
04784:  MOVLB  5
04786:  ADDWF  01,W
04788:  MOVWF  01
0478A:  MOVLW  01
0478C:  ADDWFC 02,W
0478E:  MOVWF  03
04790:  MOVFF  01,FE9
04794:  MOVWF  FEA
04796:  BTFSS  FEF.0
04798:  BRA    479E
0479A:  MOVLB  4
0479C:  BRA    4C72
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
0479E:  MOVLB  0
047A0:  BRA    46CE
047A2:  MOVFF  01,5F0
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
047A6:  MOVLB  5
047A8:  MOVF   xF0,W
047AA:  SUBLW  0D
047AC:  BZ    47B4
047AE:  MOVF   xF0,W
047B0:  SUBLW  20
047B2:  BNZ   47B6
....................       {
....................       }
047B4:  BRA    4C6C
....................       else if (rxChar == UART_SOT_CHAR)
047B6:  MOVF   xF0,W
047B8:  SUBLW  7E
047BA:  BNZ   47FE
....................       {
....................          resetSERcmd(SWI);
047BC:  MOVFF  441,5F1
047C0:  MOVLB  0
047C2:  CALL   08CE
....................          SERcmd[SWI].t = rxChar;
047C6:  MOVLB  6
047C8:  CLRF   x32
047CA:  MOVFF  441,631
047CE:  CLRF   x34
047D0:  MOVLW  B5
047D2:  MOVWF  x33
047D4:  MOVLB  0
047D6:  CALL   08AC
047DA:  MOVFF  01,5F1
047DE:  MOVLW  05
047E0:  MOVLB  5
047E2:  ADDWF  01,W
047E4:  MOVWF  01
047E6:  MOVLW  00
047E8:  ADDWFC 02,W
047EA:  MOVWF  03
047EC:  MOVF   01,W
047EE:  ADDLW  6C
047F0:  MOVWF  FE9
047F2:  MOVLW  01
047F4:  ADDWFC 03,W
047F6:  MOVWF  FEA
047F8:  MOVFF  5F0,FEF
....................       }
047FC:  BRA    4C6C
....................       else if (rxChar >= oneByteCmdTestValue)
047FE:  MOVF   xF0,W
04800:  SUBLW  7F
04802:  BC    4870
....................       {
....................          resetSERcmd(SWI);
04804:  MOVFF  441,5F1
04808:  MOVLB  0
0480A:  CALL   08CE
....................          SERcmd[SWI].t = rxChar;
0480E:  MOVLB  6
04810:  CLRF   x32
04812:  MOVFF  441,631
04816:  CLRF   x34
04818:  MOVLW  B5
0481A:  MOVWF  x33
0481C:  MOVLB  0
0481E:  CALL   08AC
04822:  MOVFF  01,5F1
04826:  MOVLW  05
04828:  MOVLB  5
0482A:  ADDWF  01,W
0482C:  MOVWF  01
0482E:  MOVLW  00
04830:  ADDWFC 02,W
04832:  MOVWF  03
04834:  MOVF   01,W
04836:  ADDLW  6C
04838:  MOVWF  FE9
0483A:  MOVLW  01
0483C:  ADDWFC 03,W
0483E:  MOVWF  FEA
04840:  MOVFF  5F0,FEF
....................          SERcmd[SWI].full = TRUE;
04844:  MOVLB  6
04846:  CLRF   x32
04848:  MOVFF  441,631
0484C:  CLRF   x34
0484E:  MOVLW  B5
04850:  MOVWF  x33
04852:  MOVLB  0
04854:  CALL   08AC
04858:  MOVLW  6C
0485A:  MOVLB  5
0485C:  ADDWF  01,W
0485E:  MOVWF  FE9
04860:  MOVLW  01
04862:  ADDWFC 02,W
04864:  MOVWF  FEA
04866:  BSF    FEF.0
....................          setNextSERWriteIndex();
04868:  MOVLB  0
0486A:  RCALL  4702
....................       }
0486C:  BRA    4C6A
0486E:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
04870:  MOVF   xF0,W
04872:  SUBLW  0A
04874:  BTFSS  FD8.2
04876:  BRA    4984
....................       {
....................          SERcmd[SWI].full = TRUE;
04878:  MOVLB  6
0487A:  CLRF   x32
0487C:  MOVFF  441,631
04880:  CLRF   x34
04882:  MOVLW  B5
04884:  MOVWF  x33
04886:  MOVLB  0
04888:  CALL   08AC
0488C:  MOVLW  6C
0488E:  MOVLB  5
04890:  ADDWF  01,W
04892:  MOVWF  FE9
04894:  MOVLW  01
04896:  ADDWFC 02,W
04898:  MOVWF  FEA
0489A:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
0489C:  MOVLB  6
0489E:  CLRF   x32
048A0:  MOVFF  441,631
048A4:  CLRF   x34
048A6:  MOVLW  B5
048A8:  MOVWF  x33
048AA:  MOVLB  0
048AC:  CALL   08AC
048B0:  MOVFF  01,5F1
048B4:  MOVLW  04
048B6:  ADDWF  01,W
048B8:  MOVWF  01
048BA:  MOVLW  00
048BC:  ADDWFC 02,W
048BE:  MOVWF  03
048C0:  MOVF   01,W
048C2:  ADDLW  6C
048C4:  MOVWF  01
048C6:  MOVLW  01
048C8:  ADDWFC 03,F
048CA:  MOVFF  01,5F1
048CE:  MOVFF  03,5F2
048D2:  MOVLB  6
048D4:  CLRF   x32
048D6:  MOVFF  441,631
048DA:  CLRF   x34
048DC:  MOVLW  B5
048DE:  MOVWF  x33
048E0:  MOVLB  0
048E2:  CALL   08AC
048E6:  MOVFF  01,5F3
048EA:  MOVLW  02
048EC:  MOVLB  5
048EE:  ADDWF  01,W
048F0:  MOVWF  01
048F2:  MOVLW  00
048F4:  ADDWFC 02,W
048F6:  MOVWF  03
048F8:  MOVF   01,W
048FA:  ADDLW  6C
048FC:  MOVWF  FE9
048FE:  MOVLW  01
04900:  ADDWFC 03,W
04902:  MOVWF  FEA
04904:  MOVFF  FEF,5F3
04908:  MOVFF  5F2,FEA
0490C:  MOVFF  5F1,FE9
04910:  MOVFF  5F3,FEF
....................          SERcmd[SWI].chrIndex = 0;
04914:  MOVLB  6
04916:  CLRF   x32
04918:  MOVFF  441,631
0491C:  CLRF   x34
0491E:  MOVLW  B5
04920:  MOVWF  x33
04922:  MOVLB  0
04924:  CALL   08AC
04928:  MOVFF  01,5F1
0492C:  MOVLW  01
0492E:  MOVLB  5
04930:  ADDWF  01,W
04932:  MOVWF  01
04934:  MOVLW  00
04936:  ADDWFC 02,W
04938:  MOVWF  03
0493A:  MOVF   01,W
0493C:  ADDLW  6C
0493E:  MOVWF  FE9
04940:  MOVLW  01
04942:  ADDWFC 03,W
04944:  MOVWF  FEA
04946:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
04948:  MOVLB  6
0494A:  CLRF   x32
0494C:  MOVFF  441,631
04950:  CLRF   x34
04952:  MOVLW  B5
04954:  MOVWF  x33
04956:  MOVLB  0
04958:  CALL   08AC
0495C:  MOVFF  01,5F1
04960:  MOVLW  02
04962:  MOVLB  5
04964:  ADDWF  01,W
04966:  MOVWF  01
04968:  MOVLW  00
0496A:  ADDWFC 02,W
0496C:  MOVWF  03
0496E:  MOVF   01,W
04970:  ADDLW  6C
04972:  MOVWF  FE9
04974:  MOVLW  01
04976:  ADDWFC 03,W
04978:  MOVWF  FEA
0497A:  CLRF   FEF
....................          setNextSERWriteIndex();
0497C:  MOVLB  0
0497E:  RCALL  4702
....................       }
04980:  BRA    4C6A
04982:  MOVLB  5
....................       else if (rxChar == delimiter)
04984:  MOVF   xF0,W
04986:  SUBLW  2C
04988:  BNZ   4A4C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
0498A:  MOVLB  6
0498C:  CLRF   x32
0498E:  MOVFF  441,631
04992:  CLRF   x34
04994:  MOVLW  B5
04996:  MOVWF  x33
04998:  MOVLB  0
0499A:  CALL   08AC
0499E:  MOVFF  02,5F2
049A2:  MOVFF  01,5F1
049A6:  MOVLW  02
049A8:  MOVLB  5
049AA:  ADDWF  01,W
049AC:  MOVWF  01
049AE:  MOVLW  00
049B0:  ADDWFC 02,W
049B2:  MOVWF  03
049B4:  MOVF   01,W
049B6:  ADDLW  6C
049B8:  MOVWF  FE9
049BA:  MOVLW  01
049BC:  ADDWFC 03,W
049BE:  MOVWF  FEA
049C0:  MOVF   FEF,W
049C2:  SUBLW  05
049C4:  BNC   4A34
....................          {
....................             SERcmd[SWI].paramIndex +=1;
049C6:  MOVLB  6
049C8:  CLRF   x32
049CA:  MOVFF  441,631
049CE:  CLRF   x34
049D0:  MOVLW  B5
049D2:  MOVWF  x33
049D4:  MOVLB  0
049D6:  CALL   08AC
049DA:  MOVFF  01,5F1
049DE:  MOVLW  02
049E0:  MOVLB  5
049E2:  ADDWF  01,W
049E4:  MOVWF  01
049E6:  MOVLW  00
049E8:  ADDWFC 02,W
049EA:  MOVWF  03
049EC:  MOVF   01,W
049EE:  ADDLW  6C
049F0:  MOVWF  FE9
049F2:  MOVLW  01
049F4:  ADDWFC 03,W
049F6:  MOVWF  FEA
049F8:  MOVLW  01
049FA:  ADDWF  FEF,W
049FC:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
049FE:  MOVLB  6
04A00:  CLRF   x32
04A02:  MOVFF  441,631
04A06:  CLRF   x34
04A08:  MOVLW  B5
04A0A:  MOVWF  x33
04A0C:  MOVLB  0
04A0E:  CALL   08AC
04A12:  MOVFF  01,5F1
04A16:  MOVLW  01
04A18:  MOVLB  5
04A1A:  ADDWF  01,W
04A1C:  MOVWF  01
04A1E:  MOVLW  00
04A20:  ADDWFC 02,W
04A22:  MOVWF  03
04A24:  MOVF   01,W
04A26:  ADDLW  6C
04A28:  MOVWF  FE9
04A2A:  MOVLW  01
04A2C:  ADDWFC 03,W
04A2E:  MOVWF  FEA
04A30:  CLRF   FEF
....................          }
04A32:  BRA    4A4A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
04A34:  MOVFF  441,5F1
04A38:  MOVLB  0
04A3A:  CALL   08CE
....................             fprintf(SERIAL, retData);
04A3E:  MOVLW  04
04A40:  MOVWF  FEA
04A42:  MOVLW  42
04A44:  MOVWF  FE9
04A46:  RCALL  473C
04A48:  MOVLB  5
....................          }
....................       }
04A4A:  BRA    4C6C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
04A4C:  MOVLB  6
04A4E:  CLRF   x32
04A50:  MOVFF  441,631
04A54:  CLRF   x34
04A56:  MOVLW  B5
04A58:  MOVWF  x33
04A5A:  MOVLB  0
04A5C:  CALL   08AC
04A60:  MOVFF  02,5F2
04A64:  MOVFF  01,5F1
04A68:  MOVLW  01
04A6A:  MOVLB  5
04A6C:  ADDWF  01,W
04A6E:  MOVWF  01
04A70:  MOVLW  00
04A72:  ADDWFC 02,W
04A74:  MOVWF  03
04A76:  MOVF   01,W
04A78:  ADDLW  6C
04A7A:  MOVWF  FE9
04A7C:  MOVLW  01
04A7E:  ADDWFC 03,W
04A80:  MOVWF  FEA
04A82:  MOVF   FEF,W
04A84:  SUBLW  18
04A86:  BTFSS  FD8.0
04A88:  BRA    4C56
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
04A8A:  MOVLB  6
04A8C:  CLRF   x32
04A8E:  MOVFF  441,631
04A92:  CLRF   x34
04A94:  MOVLW  B5
04A96:  MOVWF  x33
04A98:  MOVLB  0
04A9A:  CALL   08AC
04A9E:  MOVFF  02,5F2
04AA2:  MOVFF  01,5F1
04AA6:  MOVLW  06
04AA8:  MOVLB  5
04AAA:  ADDWF  xF1,F
04AAC:  MOVLW  00
04AAE:  ADDWFC xF2,F
04AB0:  MOVLB  6
04AB2:  CLRF   x32
04AB4:  MOVFF  441,631
04AB8:  CLRF   x34
04ABA:  MOVLW  B5
04ABC:  MOVWF  x33
04ABE:  MOVLB  0
04AC0:  CALL   08AC
04AC4:  MOVFF  02,5F4
04AC8:  MOVFF  01,5F3
04ACC:  MOVLW  02
04ACE:  ADDWF  01,W
04AD0:  MOVWF  01
04AD2:  MOVLW  00
04AD4:  ADDWFC 02,W
04AD6:  MOVWF  03
04AD8:  MOVF   01,W
04ADA:  ADDLW  6C
04ADC:  MOVWF  FE9
04ADE:  MOVLW  01
04AE0:  ADDWFC 03,W
04AE2:  MOVWF  FEA
04AE4:  MOVLB  6
04AE6:  CLRF   x32
04AE8:  MOVFF  FEF,631
04AEC:  CLRF   x34
04AEE:  MOVLW  19
04AF0:  MOVWF  x33
04AF2:  MOVLB  0
04AF4:  CALL   08AC
04AF8:  MOVFF  02,03
04AFC:  MOVF   01,W
04AFE:  MOVLB  5
04B00:  ADDWF  xF1,F
04B02:  MOVF   02,W
04B04:  ADDWFC xF2,F
04B06:  MOVLB  6
04B08:  CLRF   x32
04B0A:  MOVFF  441,631
04B0E:  CLRF   x34
04B10:  MOVLW  B5
04B12:  MOVWF  x33
04B14:  MOVLB  0
04B16:  CALL   08AC
04B1A:  MOVFF  01,5F3
04B1E:  MOVLW  01
04B20:  MOVLB  5
04B22:  ADDWF  01,W
04B24:  MOVWF  01
04B26:  MOVLW  00
04B28:  ADDWFC 02,W
04B2A:  MOVWF  03
04B2C:  MOVF   01,W
04B2E:  ADDLW  6C
04B30:  MOVWF  FE9
04B32:  MOVLW  01
04B34:  ADDWFC 03,W
04B36:  MOVWF  FEA
04B38:  MOVF   FEF,W
04B3A:  ADDWF  xF1,W
04B3C:  MOVWF  01
04B3E:  MOVLW  00
04B40:  ADDWFC xF2,W
04B42:  MOVWF  03
04B44:  MOVF   01,W
04B46:  ADDLW  6C
04B48:  MOVWF  FE9
04B4A:  MOVLW  01
04B4C:  ADDWFC 03,W
04B4E:  MOVWF  FEA
04B50:  MOVFF  5F0,FEF
....................             SERcmd[SWI].chrIndex += 1;
04B54:  MOVLB  6
04B56:  CLRF   x32
04B58:  MOVFF  441,631
04B5C:  CLRF   x34
04B5E:  MOVLW  B5
04B60:  MOVWF  x33
04B62:  MOVLB  0
04B64:  CALL   08AC
04B68:  MOVFF  01,5F1
04B6C:  MOVLW  01
04B6E:  MOVLB  5
04B70:  ADDWF  01,W
04B72:  MOVWF  01
04B74:  MOVLW  00
04B76:  ADDWFC 02,W
04B78:  MOVWF  03
04B7A:  MOVF   01,W
04B7C:  ADDLW  6C
04B7E:  MOVWF  FE9
04B80:  MOVLW  01
04B82:  ADDWFC 03,W
04B84:  MOVWF  FEA
04B86:  MOVLW  01
04B88:  ADDWF  FEF,W
04B8A:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
04B8C:  MOVLB  6
04B8E:  CLRF   x32
04B90:  MOVFF  441,631
04B94:  CLRF   x34
04B96:  MOVLW  B5
04B98:  MOVWF  x33
04B9A:  MOVLB  0
04B9C:  CALL   08AC
04BA0:  MOVFF  02,5F2
04BA4:  MOVFF  01,5F1
04BA8:  MOVLW  06
04BAA:  MOVLB  5
04BAC:  ADDWF  xF1,F
04BAE:  MOVLW  00
04BB0:  ADDWFC xF2,F
04BB2:  MOVLB  6
04BB4:  CLRF   x32
04BB6:  MOVFF  441,631
04BBA:  CLRF   x34
04BBC:  MOVLW  B5
04BBE:  MOVWF  x33
04BC0:  MOVLB  0
04BC2:  CALL   08AC
04BC6:  MOVFF  02,5F4
04BCA:  MOVFF  01,5F3
04BCE:  MOVLW  02
04BD0:  ADDWF  01,W
04BD2:  MOVWF  01
04BD4:  MOVLW  00
04BD6:  ADDWFC 02,W
04BD8:  MOVWF  03
04BDA:  MOVF   01,W
04BDC:  ADDLW  6C
04BDE:  MOVWF  FE9
04BE0:  MOVLW  01
04BE2:  ADDWFC 03,W
04BE4:  MOVWF  FEA
04BE6:  MOVLB  6
04BE8:  CLRF   x32
04BEA:  MOVFF  FEF,631
04BEE:  CLRF   x34
04BF0:  MOVLW  19
04BF2:  MOVWF  x33
04BF4:  MOVLB  0
04BF6:  CALL   08AC
04BFA:  MOVFF  02,03
04BFE:  MOVF   01,W
04C00:  MOVLB  5
04C02:  ADDWF  xF1,F
04C04:  MOVF   02,W
04C06:  ADDWFC xF2,F
04C08:  MOVLB  6
04C0A:  CLRF   x32
04C0C:  MOVFF  441,631
04C10:  CLRF   x34
04C12:  MOVLW  B5
04C14:  MOVWF  x33
04C16:  MOVLB  0
04C18:  CALL   08AC
04C1C:  MOVFF  01,5F3
04C20:  MOVLW  01
04C22:  MOVLB  5
04C24:  ADDWF  01,W
04C26:  MOVWF  01
04C28:  MOVLW  00
04C2A:  ADDWFC 02,W
04C2C:  MOVWF  03
04C2E:  MOVF   01,W
04C30:  ADDLW  6C
04C32:  MOVWF  FE9
04C34:  MOVLW  01
04C36:  ADDWFC 03,W
04C38:  MOVWF  FEA
04C3A:  MOVF   FEF,W
04C3C:  ADDWF  xF1,W
04C3E:  MOVWF  01
04C40:  MOVLW  00
04C42:  ADDWFC xF2,W
04C44:  MOVWF  03
04C46:  MOVF   01,W
04C48:  ADDLW  6C
04C4A:  MOVWF  FE9
04C4C:  MOVLW  01
04C4E:  ADDWFC 03,W
04C50:  MOVWF  FEA
04C52:  CLRF   FEF
....................          }
04C54:  BRA    4C6C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
04C56:  MOVFF  441,5F1
04C5A:  MOVLB  0
04C5C:  CALL   08CE
....................             fprintf(SERIAL, retData);
04C60:  MOVLW  04
04C62:  MOVWF  FEA
04C64:  MOVLW  42
04C66:  MOVWF  FE9
04C68:  RCALL  473C
04C6A:  MOVLB  5
....................          }
....................       }
04C6C:  MOVLB  0
04C6E:  BRA    4760
04C70:  MOVLB  4
....................    }          
04C72:  MOVLB  0
04C74:  GOTO   9E78 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
00A58:  MOVLB  5
00A5A:  CLRF   xF0
00A5C:  MOVF   xF0,W
00A5E:  SUBLW  03
00A60:  BNC   0A70
....................    {
....................       resetSERcmd(i);
00A62:  MOVFF  5F0,5F1
00A66:  MOVLB  0
00A68:  RCALL  08CE
00A6A:  MOVLB  5
00A6C:  INCF   xF0,F
00A6E:  BRA    0A5C
....................    }
....................    enable_interrupts(INT_RDA);
00A70:  MOVLB  E
00A72:  BSF    xC0.5
00A74:  MOVLB  0
00A76:  GOTO   9E60 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #include <math.h>
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;  // error = set value - measured
....................    
....................    PID[ch].I += err*PID[ch].kI;
....................    if (PID[ch].I > op_upper_bound) PID[ch].I = op_upper_bound; // anti-windup
....................    else if (PID[ch].I < op_lower_bound) PID[ch].I = op_lower_bound;
....................    
....................    float P = err * PID[ch].kP;  // proportional value
....................    
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold);  // derivative value
....................    
....................    PID[ch].CV = P + PID[ch].I + D;  // new control variable
....................    if (PID[ch].CV > op_upper_bound) PID[ch].CV = op_upper_bound; // limit positive output
....................    else if (PID[ch].CV < op_lower_bound) PID[ch].CV = op_lower_bound; // limit negative output
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (PID[ch].SP != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
00A7A:  MOVLB  E
00A7C:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
00A7E:  MOVLW  01
00A80:  MOVWF  FD1
00A82:  MOVLW  07
00A84:  MOVWF  FCE
00A86:  CLRF   FCF
00A88:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
00A8A:  MOVLB  1
00A8C:  CLRF   x5A
00A8E:  CLRF   x59
00A90:  CLRF   x58
00A92:  CLRF   x57
....................    timeoutReg1 = 0;
00A94:  CLRF   x5E
00A96:  CLRF   x5D
00A98:  CLRF   x5C
00A9A:  CLRF   x5B
....................    timeoutReg2 = 0;
00A9C:  CLRF   x62
00A9E:  CLRF   x61
00AA0:  CLRF   x60
00AA2:  CLRF   x5F
....................    intTimeoutReg = 50;
00AA4:  CLRF   x64
00AA6:  MOVLW  32
00AA8:  MOVWF  x63
....................    enable_interrupts(INT_TIMER1);
00AAA:  MOVLB  E
00AAC:  BSF    xC1.0
00AAE:  MOVLB  0
00AB0:  GOTO   9E64 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
00246:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00248:  MOVLW  0B
0024A:  MOVWF  FCD
0024C:  MOVLW  DB
0024E:  MOVWF  FCC
00250:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
00252:  MOVLB  1
00254:  MOVF   x5A,F
00256:  BNZ   0266
00258:  MOVF   x59,F
0025A:  BNZ   0266
0025C:  MOVF   x58,F
0025E:  BNZ   0266
00260:  MOVF   x57,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x57,F
0026A:  MOVLW  00
0026C:  SUBWFB x58,F
0026E:  SUBWFB x59,F
00270:  SUBWFB x5A,F
00272:  BRA    027C
00274:  CLRF   x5A
00276:  CLRF   x59
00278:  CLRF   x58
0027A:  CLRF   x57
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
0027C:  MOVF   x5E,F
0027E:  BNZ   028E
00280:  MOVF   x5D,F
00282:  BNZ   028E
00284:  MOVF   x5C,F
00286:  BNZ   028E
00288:  MOVF   x5B,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x5B,F
00292:  MOVLW  00
00294:  SUBWFB x5C,F
00296:  SUBWFB x5D,F
00298:  SUBWFB x5E,F
0029A:  BRA    02A4
0029C:  CLRF   x5E
0029E:  CLRF   x5D
002A0:  CLRF   x5C
002A2:  CLRF   x5B
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
002A4:  MOVF   x62,F
002A6:  BNZ   02B6
002A8:  MOVF   x61,F
002AA:  BNZ   02B6
002AC:  MOVF   x60,F
002AE:  BNZ   02B6
002B0:  MOVF   x5F,W
002B2:  SUBLW  0A
002B4:  BC    02C4
002B6:  MOVLW  0A
002B8:  SUBWF  x5F,F
002BA:  MOVLW  00
002BC:  SUBWFB x60,F
002BE:  SUBWFB x61,F
002C0:  SUBWFB x62,F
002C2:  BRA    02CC
002C4:  CLRF   x62
002C6:  CLRF   x61
002C8:  CLRF   x60
002CA:  CLRF   x5F
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002CC:  MOVF   x63,F
002CE:  BNZ   02D4
002D0:  MOVF   x64,F
002D2:  BZ    0310
....................    {
....................       timeCounter+=10;
002D4:  MOVLW  0A
002D6:  MOVLB  4
002D8:  ADDWF  xE8,F
002DA:  MOVLW  00
002DC:  ADDWFC xE9,F
002DE:  ADDWFC xEA,F
002E0:  ADDWFC xEB,F
....................       if (timeCounter >= intTimeoutReg)
002E2:  MOVF   xEB,F
002E4:  BNZ   0300
002E6:  MOVF   xEA,F
002E8:  BNZ   0300
002EA:  MOVLB  1
002EC:  MOVF   x64,W
002EE:  MOVLB  4
002F0:  SUBWF  xE9,W
002F2:  BNC   030E
002F4:  BNZ   0300
002F6:  MOVLB  1
002F8:  MOVF   x63,W
002FA:  MOVLB  4
002FC:  SUBWF  xE8,W
002FE:  BNC   030E
....................       {
....................          sensor_monitor_interrupt_task();
00300:  MOVLB  0
00302:  BRA    01C0
....................          timeCounter = 0;
00304:  MOVLB  4
00306:  CLRF   xEB
00308:  CLRF   xEA
0030A:  CLRF   xE9
0030C:  CLRF   xE8
0030E:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2] = {
....................    {0.01,0.3,0.1,0,0,0,0,0},
....................    {0.01,0.3,0.1,0,0,0,0,0}
....................    };
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... #define op_upper_bound 63
.................... #define op_lower_bound -63
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = {
....................    {0, -0.02245509}, 
....................    {0,   0.2127659}, 
....................    {0, 0.008432515}, 
....................    {0, 0.008173486}, 
....................    {0, 0.009655914}, 
....................    {0, 0.007094828}, 
....................    {0, 0.007081720}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals = {0,0,0,0,0,0,0};
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;           // adc raw count data
....................    float cosRaw;           // adc raw count data
....................    float sinCounts;        // calibrated counts
....................    float cosCounts;        // calibrated counts
....................    float sinLast;          // previous sin data
....................    float cosLast;          // previous cos data
....................    float p0;               // mid-pole position in microns
....................    signed int8  npoles;           // number of poles passed
....................    float pReal;            // real position in microns
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0,0,0,0,0},
....................    {0,0,0,0,0,0,0,0,0}
.................... };
.................... 
.................... struct dacV
.................... {
....................    unsigned int16 val;
....................    BOOLEAN invV;
.................... }dacVals[2] = 
.................... {
....................    {0,FALSE},
....................    {0,FALSE}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
00310:  MOVLB  E
00312:  BCF    xC9.0
00314:  MOVLB  0
00316:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 enablePID(unsigned int8);             // enaPID,   {1|2}
.................... int8 disablePID(unsigned int8);            // disPID,   {1|2}
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {0|1|2|3|4|5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {0|1|2|3|4|5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}, {PV|CV|PVold|I}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|p0|poles|real}
....................    
.................... int8 getManOPvals(unsigned int8);          // gManOP,   {1|2}  
.................... int8 setManOPvals(unsigned int8);          // sManOP,   {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
.................... //!   {"enaPID",   &enablePID},
.................... //!   {"disPID",   &disablePID},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"gManOP",   &getManOPvals},
....................    {"sManOP",   &setManOPvals},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
0524C:  MOVLW  04
0524E:  MOVLB  6
05250:  MOVWF  x32
05252:  MOVLW  42
05254:  MOVWF  x31
05256:  MOVLB  0
05258:  RCALL  515C
0525A:  MOVFF  02,03
0525E:  MOVF   01,W
05260:  ADDLW  42
05262:  MOVLB  5
05264:  MOVWF  xFB
05266:  MOVLW  04
05268:  ADDWFC 02,W
0526A:  MOVWF  xFC
0526C:  MOVFF  FE8,4E7
05270:  MOVFF  5FB,4E6
05274:  MOVLW  1A
05276:  MOVWF  FF6
05278:  MOVLW  03
0527A:  MOVWF  FF7
0527C:  MOVLB  0
0527E:  RCALL  522C
05280:  MOVLW  2C
05282:  MOVLB  6
05284:  MOVWF  x40
05286:  MOVLB  0
05288:  RCALL  520C
....................    return SUCCESS;
0528A:  MOVLW  00
0528C:  MOVWF  01
0528E:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
05290:  MOVLW  04
05292:  MOVLB  6
05294:  MOVWF  x32
05296:  MOVLW  42
05298:  MOVWF  x31
0529A:  MOVLB  0
0529C:  RCALL  515C
0529E:  MOVFF  02,03
052A2:  MOVF   01,W
052A4:  ADDLW  42
052A6:  MOVLB  5
052A8:  MOVWF  xFB
052AA:  MOVLW  04
052AC:  ADDWFC 02,W
052AE:  MOVWF  xFC
052B0:  MOVFF  FE8,4E7
052B4:  MOVFF  5FB,4E6
052B8:  MOVLW  24
052BA:  MOVWF  FF6
052BC:  MOVLW  03
052BE:  MOVWF  FF7
052C0:  MOVLB  0
052C2:  RCALL  522C
052C4:  MOVLW  2C
052C6:  MOVLB  6
052C8:  MOVWF  x40
052CA:  MOVLB  0
052CC:  RCALL  520C
....................    return SUCCESS;
052CE:  MOVLW  00
052D0:  MOVWF  01
052D2:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
057D8:  MOVLB  6
057DA:  CLRF   x32
057DC:  MOVFF  5EF,631
057E0:  CLRF   x34
057E2:  MOVLW  B5
057E4:  MOVWF  x33
057E6:  MOVLB  0
057E8:  CALL   08AC
057EC:  MOVFF  02,5FD
057F0:  MOVFF  01,5FC
057F4:  MOVLW  06
057F6:  MOVLB  5
057F8:  ADDWF  xFC,F
057FA:  MOVLW  00
057FC:  ADDWFC xFD,F
057FE:  MOVLW  32
05800:  ADDWF  xFC,W
05802:  MOVWF  01
05804:  MOVLW  00
05806:  ADDWFC xFD,W
05808:  MOVWF  03
0580A:  MOVF   01,W
0580C:  ADDLW  6C
0580E:  MOVWF  01
05810:  MOVLW  01
05812:  ADDWFC 03,F
05814:  MOVFF  01,5FC
05818:  MOVFF  03,5FD
0581C:  MOVFF  03,629
05820:  MOVFF  01,628
05824:  MOVLB  0
05826:  RCALL  52D4
05828:  MOVF   01,F
0582A:  BNZ   5834
0582C:  MOVLW  02
0582E:  MOVWF  01
05830:  BRA    5978
05832:  BRA    5892
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05834:  MOVLB  6
05836:  CLRF   x32
05838:  MOVFF  5EF,631
0583C:  CLRF   x34
0583E:  MOVLW  B5
05840:  MOVWF  x33
05842:  MOVLB  0
05844:  CALL   08AC
05848:  MOVFF  02,5FD
0584C:  MOVFF  01,5FC
05850:  MOVLW  06
05852:  MOVLB  5
05854:  ADDWF  xFC,F
05856:  MOVLW  00
05858:  ADDWFC xFD,F
0585A:  MOVLW  32
0585C:  ADDWF  xFC,W
0585E:  MOVWF  01
05860:  MOVLW  00
05862:  ADDWFC xFD,W
05864:  MOVWF  03
05866:  MOVF   01,W
05868:  ADDLW  6C
0586A:  MOVWF  01
0586C:  MOVLW  01
0586E:  ADDWFC 03,F
05870:  MOVFF  01,5FC
05874:  MOVFF  03,5FD
05878:  MOVFF  03,629
0587C:  MOVFF  01,628
05880:  MOVLB  6
05882:  CLRF   x2B
05884:  CLRF   x2A
05886:  MOVLW  0A
05888:  MOVWF  x2C
0588A:  MOVLB  0
0588C:  RCALL  53C4
0588E:  MOVFF  01,5FB
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'X');
05892:  MOVLW  01
05894:  MOVLB  5
05896:  SUBWF  xFB,W
05898:  MOVWF  xFD
0589A:  CLRF   xFF
0589C:  MOVLW  60
0589E:  MOVWF  xFE
058A0:  MOVLB  0
058A2:  CALL   3CCE
058A6:  BTFSC  01.0
058A8:  BRA    5900
058AA:  MOVLW  04
058AC:  MOVLB  6
058AE:  MOVWF  x32
058B0:  MOVLW  42
058B2:  MOVWF  x31
058B4:  MOVLB  0
058B6:  RCALL  515C
058B8:  MOVFF  02,03
058BC:  MOVF   01,W
058BE:  ADDLW  42
058C0:  MOVLB  5
058C2:  MOVWF  xFC
058C4:  MOVLW  04
058C6:  ADDWFC 02,W
058C8:  MOVWF  xFD
058CA:  MOVFF  FE8,4E7
058CE:  MOVFF  5FC,4E6
058D2:  MOVFF  5FB,629
058D6:  MOVLW  18
058D8:  MOVLB  6
058DA:  MOVWF  x2A
058DC:  MOVLB  0
058DE:  RCALL  5718
058E0:  MOVLW  2C
058E2:  MOVLB  6
058E4:  MOVWF  x40
058E6:  MOVLB  0
058E8:  RCALL  520C
058EA:  MOVLW  58
058EC:  MOVLB  6
058EE:  MOVWF  x40
058F0:  MOVLB  0
058F2:  RCALL  520C
058F4:  MOVLW  2C
058F6:  MOVLB  6
058F8:  MOVWF  x40
058FA:  MOVLB  0
058FC:  RCALL  520C
058FE:  BRA    5974
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%d,%c,", arg1, 'Y');
05900:  MOVLW  01
05902:  MOVLB  5
05904:  SUBWF  xFB,W
05906:  MOVWF  xFD
05908:  CLRF   xFF
0590A:  MOVLW  60
0590C:  MOVWF  xFE
0590E:  MOVLB  0
05910:  CALL   3CCE
05914:  BTFSS  01.0
05916:  BRA    596E
05918:  MOVLW  04
0591A:  MOVLB  6
0591C:  MOVWF  x32
0591E:  MOVLW  42
05920:  MOVWF  x31
05922:  MOVLB  0
05924:  RCALL  515C
05926:  MOVFF  02,03
0592A:  MOVF   01,W
0592C:  ADDLW  42
0592E:  MOVLB  5
05930:  MOVWF  xFC
05932:  MOVLW  04
05934:  ADDWFC 02,W
05936:  MOVWF  xFD
05938:  MOVFF  FE8,4E7
0593C:  MOVFF  5FC,4E6
05940:  MOVFF  5FB,629
05944:  MOVLW  18
05946:  MOVLB  6
05948:  MOVWF  x2A
0594A:  MOVLB  0
0594C:  RCALL  5718
0594E:  MOVLW  2C
05950:  MOVLB  6
05952:  MOVWF  x40
05954:  MOVLB  0
05956:  RCALL  520C
05958:  MOVLW  59
0595A:  MOVLB  6
0595C:  MOVWF  x40
0595E:  MOVLB  0
05960:  RCALL  520C
05962:  MOVLW  2C
05964:  MOVLB  6
05966:  MOVWF  x40
05968:  MOVLB  0
0596A:  RCALL  520C
0596C:  BRA    5974
....................    else return INV_PARAM;
0596E:  MOVLW  02
05970:  MOVWF  01
05972:  BRA    5978
....................    
....................    return SUCCESS;
05974:  MOVLW  00
05976:  MOVWF  01
05978:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
059BC:  MOVLB  6
059BE:  CLRF   x32
059C0:  MOVFF  5EF,631
059C4:  CLRF   x34
059C6:  MOVLW  B5
059C8:  MOVWF  x33
059CA:  MOVLB  0
059CC:  CALL   08AC
059D0:  MOVFF  02,5FE
059D4:  MOVFF  01,5FD
059D8:  MOVLW  06
059DA:  MOVLB  5
059DC:  ADDWF  xFD,F
059DE:  MOVLW  00
059E0:  ADDWFC xFE,F
059E2:  MOVLW  32
059E4:  ADDWF  xFD,W
059E6:  MOVWF  01
059E8:  MOVLW  00
059EA:  ADDWFC xFE,W
059EC:  MOVWF  03
059EE:  MOVF   01,W
059F0:  ADDLW  6C
059F2:  MOVWF  01
059F4:  MOVLW  01
059F6:  ADDWFC 03,F
059F8:  MOVFF  01,5FD
059FC:  MOVFF  03,5FE
05A00:  MOVFF  03,629
05A04:  MOVFF  01,628
05A08:  MOVLB  0
05A0A:  RCALL  52D4
05A0C:  MOVF   01,F
05A0E:  BNZ   5A18
05A10:  MOVLW  02
05A12:  MOVWF  01
05A14:  BRA    5B72
05A16:  BRA    5A76
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05A18:  MOVLB  6
05A1A:  CLRF   x32
05A1C:  MOVFF  5EF,631
05A20:  CLRF   x34
05A22:  MOVLW  B5
05A24:  MOVWF  x33
05A26:  MOVLB  0
05A28:  CALL   08AC
05A2C:  MOVFF  02,5FE
05A30:  MOVFF  01,5FD
05A34:  MOVLW  06
05A36:  MOVLB  5
05A38:  ADDWF  xFD,F
05A3A:  MOVLW  00
05A3C:  ADDWFC xFE,F
05A3E:  MOVLW  32
05A40:  ADDWF  xFD,W
05A42:  MOVWF  01
05A44:  MOVLW  00
05A46:  ADDWFC xFE,W
05A48:  MOVWF  03
05A4A:  MOVF   01,W
05A4C:  ADDLW  6C
05A4E:  MOVWF  01
05A50:  MOVLW  01
05A52:  ADDWFC 03,F
05A54:  MOVFF  01,5FD
05A58:  MOVFF  03,5FE
05A5C:  MOVFF  03,629
05A60:  MOVFF  01,628
05A64:  MOVLB  6
05A66:  CLRF   x2B
05A68:  CLRF   x2A
05A6A:  MOVLW  0A
05A6C:  MOVWF  x2C
05A6E:  MOVLB  0
05A70:  RCALL  53C4
05A72:  MOVFF  01,5FB
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05A76:  MOVLB  6
05A78:  CLRF   x32
05A7A:  MOVFF  5EF,631
05A7E:  CLRF   x34
05A80:  MOVLW  B5
05A82:  MOVWF  x33
05A84:  MOVLB  0
05A86:  CALL   08AC
05A8A:  MOVFF  02,5FE
05A8E:  MOVFF  01,5FD
05A92:  MOVLW  06
05A94:  MOVLB  5
05A96:  ADDWF  xFD,F
05A98:  MOVLW  00
05A9A:  ADDWFC xFE,F
05A9C:  MOVLW  4B
05A9E:  ADDWF  xFD,W
05AA0:  MOVWF  01
05AA2:  MOVLW  00
05AA4:  ADDWFC xFE,W
05AA6:  MOVWF  03
05AA8:  MOVF   01,W
05AAA:  ADDLW  6C
05AAC:  MOVWF  01
05AAE:  MOVLW  01
05AB0:  ADDWFC 03,F
05AB2:  MOVFF  01,5FD
05AB6:  MOVFF  03,5FE
05ABA:  MOVFF  03,632
05ABE:  MOVFF  01,631
05AC2:  MOVLB  0
05AC4:  CALL   515C
05AC8:  MOVFF  02,03
05ACC:  MOVF   01,W
05ACE:  SUBLW  01
05AD0:  BNZ   5AD6
05AD2:  MOVF   03,F
05AD4:  BZ    5ADE
05AD6:  MOVLW  02
05AD8:  MOVWF  01
05ADA:  BRA    5B72
05ADC:  BRA    5B1E
....................    else arg2 = SERcmd[rec].p[3][0];
05ADE:  MOVLB  6
05AE0:  CLRF   x32
05AE2:  MOVFF  5EF,631
05AE6:  CLRF   x34
05AE8:  MOVLW  B5
05AEA:  MOVWF  x33
05AEC:  MOVLB  0
05AEE:  CALL   08AC
05AF2:  MOVFF  02,5FE
05AF6:  MOVFF  01,5FD
05AFA:  MOVLW  06
05AFC:  MOVLB  5
05AFE:  ADDWF  xFD,F
05B00:  MOVLW  00
05B02:  ADDWFC xFE,F
05B04:  MOVLW  4B
05B06:  ADDWF  xFD,F
05B08:  MOVLW  00
05B0A:  ADDWFC xFE,F
05B0C:  MOVLW  6C
05B0E:  ADDWF  xFD,W
05B10:  MOVWF  FE9
05B12:  MOVLW  01
05B14:  ADDWFC xFE,W
05B16:  MOVWF  FEA
05B18:  MOVFF  FEF,5FC
05B1C:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
05B1E:  MOVLB  5
05B20:  MOVF   xFC,W
05B22:  SUBLW  58
05B24:  BNZ   5B42
05B26:  MOVLW  01
05B28:  SUBWF  xFB,W
05B2A:  MOVWF  xFD
05B2C:  MOVFF  FE8,612
05B30:  MOVLB  6
05B32:  CLRF   x13
05B34:  CLRF   x15
05B36:  MOVLW  60
05B38:  MOVWF  x14
05B3A:  MOVLB  0
05B3C:  RCALL  597A
05B3E:  BRA    5B6E
05B40:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
05B42:  MOVF   xFC,W
05B44:  SUBLW  59
05B46:  BNZ   5B66
05B48:  MOVLW  01
05B4A:  SUBWF  xFB,W
05B4C:  MOVWF  xFD
05B4E:  MOVFF  FE8,612
05B52:  MOVLW  01
05B54:  MOVLB  6
05B56:  MOVWF  x13
05B58:  CLRF   x15
05B5A:  MOVLW  60
05B5C:  MOVWF  x14
05B5E:  MOVLB  0
05B60:  RCALL  597A
05B62:  BRA    5B6E
05B64:  MOVLB  5
....................    else return INV_PARAM;
05B66:  MOVLW  02
05B68:  MOVWF  01
05B6A:  MOVLB  0
05B6C:  BRA    5B72
....................    
....................    return SUCCESS;
05B6E:  MOVLW  00
05B70:  MOVWF  01
05B72:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05B9E:  MOVLB  6
05BA0:  CLRF   x32
05BA2:  MOVFF  5EF,631
05BA6:  CLRF   x34
05BA8:  MOVLW  B5
05BAA:  MOVWF  x33
05BAC:  MOVLB  0
05BAE:  CALL   08AC
05BB2:  MOVFF  02,5FD
05BB6:  MOVFF  01,5FC
05BBA:  MOVLW  06
05BBC:  MOVLB  5
05BBE:  ADDWF  xFC,F
05BC0:  MOVLW  00
05BC2:  ADDWFC xFD,F
05BC4:  MOVLW  32
05BC6:  ADDWF  xFC,W
05BC8:  MOVWF  01
05BCA:  MOVLW  00
05BCC:  ADDWFC xFD,W
05BCE:  MOVWF  03
05BD0:  MOVF   01,W
05BD2:  ADDLW  6C
05BD4:  MOVWF  01
05BD6:  MOVLW  01
05BD8:  ADDWFC 03,F
05BDA:  MOVFF  01,5FC
05BDE:  MOVFF  03,5FD
05BE2:  MOVFF  03,629
05BE6:  MOVFF  01,628
05BEA:  MOVLB  0
05BEC:  CALL   52D4
05BF0:  MOVF   01,F
05BF2:  BNZ   5BFC
05BF4:  MOVLW  02
05BF6:  MOVWF  01
05BF8:  BRA    5D2E
05BFA:  BRA    5C5C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05BFC:  MOVLB  6
05BFE:  CLRF   x32
05C00:  MOVFF  5EF,631
05C04:  CLRF   x34
05C06:  MOVLW  B5
05C08:  MOVWF  x33
05C0A:  MOVLB  0
05C0C:  CALL   08AC
05C10:  MOVFF  02,5FD
05C14:  MOVFF  01,5FC
05C18:  MOVLW  06
05C1A:  MOVLB  5
05C1C:  ADDWF  xFC,F
05C1E:  MOVLW  00
05C20:  ADDWFC xFD,F
05C22:  MOVLW  32
05C24:  ADDWF  xFC,W
05C26:  MOVWF  01
05C28:  MOVLW  00
05C2A:  ADDWFC xFD,W
05C2C:  MOVWF  03
05C2E:  MOVF   01,W
05C30:  ADDLW  6C
05C32:  MOVWF  01
05C34:  MOVLW  01
05C36:  ADDWFC 03,F
05C38:  MOVFF  01,5FC
05C3C:  MOVFF  03,5FD
05C40:  MOVFF  03,629
05C44:  MOVFF  01,628
05C48:  MOVLB  6
05C4A:  CLRF   x2B
05C4C:  CLRF   x2A
05C4E:  MOVLW  0A
05C50:  MOVWF  x2C
05C52:  MOVLB  0
05C54:  CALL   53C4
05C58:  MOVFF  01,5FB
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MANUAL,", arg1);
05C5C:  MOVLW  01
05C5E:  MOVLB  5
05C60:  SUBWF  xFB,W
05C62:  MOVWF  xFD
05C64:  CLRF   xFF
05C66:  MOVLW  61
05C68:  MOVWF  xFE
05C6A:  MOVLB  0
05C6C:  CALL   3CCE
05C70:  BTFSC  01.0
05C72:  BRA    5CC0
05C74:  MOVLW  04
05C76:  MOVLB  6
05C78:  MOVWF  x32
05C7A:  MOVLW  42
05C7C:  MOVWF  x31
05C7E:  MOVLB  0
05C80:  CALL   515C
05C84:  MOVFF  02,03
05C88:  MOVF   01,W
05C8A:  ADDLW  42
05C8C:  MOVLB  5
05C8E:  MOVWF  xFC
05C90:  MOVLW  04
05C92:  ADDWFC 02,W
05C94:  MOVWF  xFD
05C96:  MOVFF  FE8,4E7
05C9A:  MOVFF  5FC,4E6
05C9E:  MOVFF  5FB,629
05CA2:  MOVLW  18
05CA4:  MOVLB  6
05CA6:  MOVWF  x2A
05CA8:  MOVLB  0
05CAA:  RCALL  5718
05CAC:  MOVLW  2C
05CAE:  MOVWF  FF6
05CB0:  MOVLW  03
05CB2:  MOVWF  FF7
05CB4:  MOVLW  08
05CB6:  MOVLB  5
05CB8:  MOVWF  xFF
05CBA:  MOVLB  0
05CBC:  RCALL  5B74
05CBE:  BRA    5D2A
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "%d,MAGSNS,", arg1);
05CC0:  MOVLW  01
05CC2:  MOVLB  5
05CC4:  SUBWF  xFB,W
05CC6:  MOVWF  xFD
05CC8:  CLRF   xFF
05CCA:  MOVLW  61
05CCC:  MOVWF  xFE
05CCE:  MOVLB  0
05CD0:  CALL   3CCE
05CD4:  BTFSS  01.0
05CD6:  BRA    5D24
05CD8:  MOVLW  04
05CDA:  MOVLB  6
05CDC:  MOVWF  x32
05CDE:  MOVLW  42
05CE0:  MOVWF  x31
05CE2:  MOVLB  0
05CE4:  CALL   515C
05CE8:  MOVFF  02,03
05CEC:  MOVF   01,W
05CEE:  ADDLW  42
05CF0:  MOVLB  5
05CF2:  MOVWF  xFC
05CF4:  MOVLW  04
05CF6:  ADDWFC 02,W
05CF8:  MOVWF  xFD
05CFA:  MOVFF  FE8,4E7
05CFE:  MOVFF  5FC,4E6
05D02:  MOVFF  5FB,629
05D06:  MOVLW  18
05D08:  MOVLB  6
05D0A:  MOVWF  x2A
05D0C:  MOVLB  0
05D0E:  RCALL  5718
05D10:  MOVLW  38
05D12:  MOVWF  FF6
05D14:  MOVLW  03
05D16:  MOVWF  FF7
05D18:  MOVLW  08
05D1A:  MOVLB  5
05D1C:  MOVWF  xFF
05D1E:  MOVLB  0
05D20:  RCALL  5B74
05D22:  BRA    5D2A
....................    else return INV_PARAM;
05D24:  MOVLW  02
05D26:  MOVWF  01
05D28:  BRA    5D2E
....................    
....................    return SUCCESS;
05D2A:  MOVLW  00
05D2C:  MOVWF  01
05D2E:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
05D30:  MOVLW  4D
05D32:  MOVLB  6
05D34:  MOVWF  x00
05D36:  MOVLW  41
05D38:  MOVWF  x01
05D3A:  MOVLW  4E
05D3C:  MOVWF  x02
05D3E:  MOVLW  55
05D40:  MOVWF  x03
05D42:  MOVLW  41
05D44:  MOVWF  x04
05D46:  MOVLW  4C
05D48:  MOVWF  x05
05D4A:  CLRF   x06
05D4C:  MOVLW  06
05D4E:  MOVLB  5
05D50:  MOVWF  xFF
05D52:  CLRF   xFE
....................    char *s_magsns = "MAGSNS";
05D54:  MOVLW  4D
05D56:  MOVLB  6
05D58:  MOVWF  x09
05D5A:  MOVLW  41
05D5C:  MOVWF  x0A
05D5E:  MOVLW  47
05D60:  MOVWF  x0B
05D62:  MOVLW  53
05D64:  MOVWF  x0C
05D66:  MOVLW  4E
05D68:  MOVWF  x0D
05D6A:  MOVLW  53
05D6C:  MOVWF  x0E
05D6E:  CLRF   x0F
05D70:  MOVLW  06
05D72:  MOVWF  x08
05D74:  MOVLW  09
05D76:  MOVWF  x07
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05D78:  CLRF   x32
05D7A:  MOVFF  5EF,631
05D7E:  CLRF   x34
05D80:  MOVLW  B5
05D82:  MOVWF  x33
05D84:  MOVLB  0
05D86:  CALL   08AC
05D8A:  MOVFF  02,611
05D8E:  MOVFF  01,610
05D92:  MOVLW  06
05D94:  MOVLB  6
05D96:  ADDWF  x10,F
05D98:  MOVLW  00
05D9A:  ADDWFC x11,F
05D9C:  MOVLW  32
05D9E:  ADDWF  x10,W
05DA0:  MOVWF  01
05DA2:  MOVLW  00
05DA4:  ADDWFC x11,W
05DA6:  MOVWF  03
05DA8:  MOVF   01,W
05DAA:  ADDLW  6C
05DAC:  MOVWF  01
05DAE:  MOVLW  01
05DB0:  ADDWFC 03,F
05DB2:  MOVFF  01,610
05DB6:  MOVFF  03,611
05DBA:  MOVFF  03,629
05DBE:  MOVFF  01,628
05DC2:  MOVLB  0
05DC4:  CALL   52D4
05DC8:  MOVF   01,F
05DCA:  BNZ   5DD4
05DCC:  MOVLW  02
05DCE:  MOVWF  01
05DD0:  BRA    5F4E
05DD2:  BRA    5E32
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05DD4:  MOVLB  6
05DD6:  CLRF   x32
05DD8:  MOVFF  5EF,631
05DDC:  CLRF   x34
05DDE:  MOVLW  B5
05DE0:  MOVWF  x33
05DE2:  MOVLB  0
05DE4:  CALL   08AC
05DE8:  MOVFF  02,611
05DEC:  MOVFF  01,610
05DF0:  MOVLW  06
05DF2:  MOVLB  6
05DF4:  ADDWF  x10,F
05DF6:  MOVLW  00
05DF8:  ADDWFC x11,F
05DFA:  MOVLW  32
05DFC:  ADDWF  x10,W
05DFE:  MOVWF  01
05E00:  MOVLW  00
05E02:  ADDWFC x11,W
05E04:  MOVWF  03
05E06:  MOVF   01,W
05E08:  ADDLW  6C
05E0A:  MOVWF  01
05E0C:  MOVLW  01
05E0E:  ADDWFC 03,F
05E10:  MOVFF  01,610
05E14:  MOVFF  03,611
05E18:  MOVFF  03,629
05E1C:  MOVFF  01,628
05E20:  CLRF   x2B
05E22:  CLRF   x2A
05E24:  MOVLW  0A
05E26:  MOVWF  x2C
05E28:  MOVLB  0
05E2A:  CALL   53C4
05E2E:  MOVFF  01,5FB
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
05E32:  MOVLB  6
05E34:  CLRF   x32
05E36:  MOVFF  5EF,631
05E3A:  CLRF   x34
05E3C:  MOVLW  B5
05E3E:  MOVWF  x33
05E40:  MOVLB  0
05E42:  CALL   08AC
05E46:  MOVFF  02,611
05E4A:  MOVFF  01,610
05E4E:  MOVLW  06
05E50:  MOVLB  6
05E52:  ADDWF  x10,F
05E54:  MOVLW  00
05E56:  ADDWFC x11,F
05E58:  MOVLW  4B
05E5A:  ADDWF  x10,W
05E5C:  MOVWF  01
05E5E:  MOVLW  00
05E60:  ADDWFC x11,W
05E62:  MOVWF  03
05E64:  MOVF   01,W
05E66:  ADDLW  6C
05E68:  MOVWF  01
05E6A:  MOVLW  01
05E6C:  ADDWFC 03,F
05E6E:  MOVFF  01,610
05E72:  MOVFF  03,611
05E76:  MOVFF  03,632
05E7A:  MOVFF  01,631
05E7E:  MOVLB  0
05E80:  CALL   515C
05E84:  MOVFF  02,03
05E88:  MOVF   01,W
05E8A:  BNZ   5E98
05E8C:  MOVF   03,F
05E8E:  BNZ   5E98
05E90:  MOVLW  02
05E92:  MOVWF  01
05E94:  BRA    5F4E
05E96:  BRA    5EDE
....................    else arg2 = SERcmd[rec].p[3];
05E98:  MOVLB  6
05E9A:  CLRF   x32
05E9C:  MOVFF  5EF,631
05EA0:  CLRF   x34
05EA2:  MOVLW  B5
05EA4:  MOVWF  x33
05EA6:  MOVLB  0
05EA8:  CALL   08AC
05EAC:  MOVFF  02,611
05EB0:  MOVFF  01,610
05EB4:  MOVLW  06
05EB6:  MOVLB  6
05EB8:  ADDWF  x10,F
05EBA:  MOVLW  00
05EBC:  ADDWFC x11,F
05EBE:  MOVLW  4B
05EC0:  ADDWF  x10,W
05EC2:  MOVWF  01
05EC4:  MOVLW  00
05EC6:  ADDWFC x11,W
05EC8:  MOVWF  03
05ECA:  MOVF   01,W
05ECC:  ADDLW  6C
05ECE:  MOVWF  01
05ED0:  MOVLW  01
05ED2:  ADDWFC 03,F
05ED4:  MOVFF  01,5FC
05ED8:  MOVFF  03,5FD
05EDC:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
05EDE:  MOVFF  5FF,632
05EE2:  MOVFF  5FE,631
05EE6:  MOVFF  5FD,634
05EEA:  MOVFF  5FC,633
05EEE:  CALL   5194
05EF2:  MOVF   01,F
05EF4:  BNZ   5F10
05EF6:  MOVLW  01
05EF8:  MOVLB  5
05EFA:  SUBWF  xFB,W
05EFC:  MOVLB  6
05EFE:  MOVWF  x10
05F00:  MOVWF  x12
05F02:  CLRF   x13
05F04:  CLRF   x15
05F06:  MOVLW  61
05F08:  MOVWF  x14
05F0A:  MOVLB  0
05F0C:  RCALL  597A
05F0E:  BRA    5F4A
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
05F10:  MOVFF  608,632
05F14:  MOVFF  607,631
05F18:  MOVFF  5FD,634
05F1C:  MOVFF  5FC,633
05F20:  CALL   5194
05F24:  MOVF   01,F
05F26:  BNZ   5F44
05F28:  MOVLW  01
05F2A:  MOVLB  5
05F2C:  SUBWF  xFB,W
05F2E:  MOVLB  6
05F30:  MOVWF  x10
05F32:  MOVWF  x12
05F34:  MOVLW  01
05F36:  MOVWF  x13
05F38:  CLRF   x15
05F3A:  MOVLW  61
05F3C:  MOVWF  x14
05F3E:  MOVLB  0
05F40:  RCALL  597A
05F42:  BRA    5F4A
....................    else return INV_PARAM;
05F44:  MOVLW  02
05F46:  MOVWF  01
05F48:  BRA    5F4E
....................    
....................    return SUCCESS;
05F4A:  MOVLW  00
05F4C:  MOVWF  01
05F4E:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
06106:  MOVLB  6
06108:  CLRF   x32
0610A:  MOVFF  5EF,631
0610E:  CLRF   x34
06110:  MOVLW  B5
06112:  MOVWF  x33
06114:  MOVLB  0
06116:  CALL   08AC
0611A:  MOVFF  02,601
0611E:  MOVFF  01,600
06122:  MOVLW  06
06124:  MOVLB  6
06126:  ADDWF  x00,F
06128:  MOVLW  00
0612A:  ADDWFC x01,F
0612C:  MOVLW  32
0612E:  ADDWF  x00,W
06130:  MOVWF  01
06132:  MOVLW  00
06134:  ADDWFC x01,W
06136:  MOVWF  03
06138:  MOVF   01,W
0613A:  ADDLW  6C
0613C:  MOVWF  01
0613E:  MOVLW  01
06140:  ADDWFC 03,F
06142:  MOVFF  01,600
06146:  MOVFF  03,601
0614A:  MOVFF  03,629
0614E:  MOVFF  01,628
06152:  MOVLB  0
06154:  CALL   52D4
06158:  MOVF   01,F
0615A:  BNZ   6164
0615C:  MOVLW  02
0615E:  MOVWF  01
06160:  BRA    65DA
06162:  BRA    61C2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06164:  MOVLB  6
06166:  CLRF   x32
06168:  MOVFF  5EF,631
0616C:  CLRF   x34
0616E:  MOVLW  B5
06170:  MOVWF  x33
06172:  MOVLB  0
06174:  CALL   08AC
06178:  MOVFF  02,601
0617C:  MOVFF  01,600
06180:  MOVLW  06
06182:  MOVLB  6
06184:  ADDWF  x00,F
06186:  MOVLW  00
06188:  ADDWFC x01,F
0618A:  MOVLW  32
0618C:  ADDWF  x00,W
0618E:  MOVWF  01
06190:  MOVLW  00
06192:  ADDWFC x01,W
06194:  MOVWF  03
06196:  MOVF   01,W
06198:  ADDLW  6C
0619A:  MOVWF  01
0619C:  MOVLW  01
0619E:  ADDWFC 03,F
061A0:  MOVFF  01,600
061A4:  MOVFF  03,601
061A8:  MOVFF  03,629
061AC:  MOVFF  01,628
061B0:  CLRF   x2B
061B2:  CLRF   x2A
061B4:  MOVLW  0A
061B6:  MOVWF  x2C
061B8:  MOVLB  0
061BA:  CALL   53C4
061BE:  MOVFF  01,5FB
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
061C2:  MOVLB  6
061C4:  CLRF   x32
061C6:  MOVFF  5EF,631
061CA:  CLRF   x34
061CC:  MOVLW  B5
061CE:  MOVWF  x33
061D0:  MOVLB  0
061D2:  CALL   08AC
061D6:  MOVFF  02,601
061DA:  MOVFF  01,600
061DE:  MOVLW  06
061E0:  MOVLB  6
061E2:  ADDWF  x00,F
061E4:  MOVLW  00
061E6:  ADDWFC x01,F
061E8:  MOVLW  4B
061EA:  ADDWF  x00,W
061EC:  MOVWF  01
061EE:  MOVLW  00
061F0:  ADDWFC x01,W
061F2:  MOVWF  03
061F4:  MOVF   01,W
061F6:  ADDLW  6C
061F8:  MOVWF  01
061FA:  MOVLW  01
061FC:  ADDWFC 03,F
061FE:  MOVFF  01,600
06202:  MOVFF  03,601
06206:  MOVFF  03,632
0620A:  MOVFF  01,631
0620E:  MOVLB  0
06210:  CALL   515C
06214:  MOVFF  02,03
06218:  MOVF   01,W
0621A:  SUBLW  01
0621C:  BNZ   6222
0621E:  MOVF   03,F
06220:  BZ    622A
06222:  MOVLW  02
06224:  MOVWF  01
06226:  BRA    65DA
06228:  BRA    626A
....................    else arg2 = SERcmd[rec].p[3][0];
0622A:  MOVLB  6
0622C:  CLRF   x32
0622E:  MOVFF  5EF,631
06232:  CLRF   x34
06234:  MOVLW  B5
06236:  MOVWF  x33
06238:  MOVLB  0
0623A:  CALL   08AC
0623E:  MOVFF  02,601
06242:  MOVFF  01,600
06246:  MOVLW  06
06248:  MOVLB  6
0624A:  ADDWF  x00,F
0624C:  MOVLW  00
0624E:  ADDWFC x01,F
06250:  MOVLW  4B
06252:  ADDWF  x00,F
06254:  MOVLW  00
06256:  ADDWFC x01,F
06258:  MOVLW  6C
0625A:  ADDWF  x00,W
0625C:  MOVWF  FE9
0625E:  MOVLW  01
06260:  ADDWFC x01,W
06262:  MOVWF  FEA
06264:  MOVFF  FEF,5FC
06268:  MOVLB  0
....................    
....................    /*** GET P, I, D, or A(LL) VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kP);
0626A:  MOVLB  5
0626C:  MOVF   xFC,W
0626E:  SUBLW  50
06270:  BNZ   6310
06272:  MOVLW  04
06274:  MOVLB  6
06276:  MOVWF  x32
06278:  MOVLW  42
0627A:  MOVWF  x31
0627C:  MOVLB  0
0627E:  CALL   515C
06282:  MOVFF  02,03
06286:  MOVF   01,W
06288:  ADDLW  42
0628A:  MOVLB  6
0628C:  MOVWF  x00
0628E:  MOVLW  04
06290:  ADDWFC 02,W
06292:  MOVWF  x01
06294:  MOVLW  01
06296:  MOVLB  5
06298:  SUBWF  xFB,W
0629A:  MULLW  20
0629C:  MOVF   FF3,W
0629E:  MOVLB  6
062A0:  CLRF   x03
062A2:  MOVWF  x02
062A4:  MOVLW  20
062A6:  ADDWF  x02,W
062A8:  MOVWF  FE9
062AA:  MOVLW  00
062AC:  ADDWFC x03,W
062AE:  MOVWF  FEA
062B0:  MOVFF  FEF,604
062B4:  MOVFF  FEC,605
062B8:  MOVFF  FEC,606
062BC:  MOVFF  FEC,607
062C0:  MOVFF  601,4E7
062C4:  MOVFF  600,4E6
062C8:  MOVFF  5FB,629
062CC:  MOVLW  18
062CE:  MOVWF  x2A
062D0:  MOVLB  0
062D2:  CALL   5718
062D6:  MOVLW  2C
062D8:  MOVLB  6
062DA:  MOVWF  x40
062DC:  MOVLB  0
062DE:  CALL   520C
062E2:  MOVLW  89
062E4:  MOVWF  FE9
062E6:  MOVFF  607,636
062EA:  MOVFF  606,635
062EE:  MOVFF  605,634
062F2:  MOVFF  604,633
062F6:  MOVLW  02
062F8:  MOVLB  6
062FA:  MOVWF  x37
062FC:  MOVLB  0
062FE:  RCALL  5F50
06300:  MOVLW  2C
06302:  MOVLB  6
06304:  MOVWF  x40
06306:  MOVLB  0
06308:  CALL   520C
0630C:  BRA    65D6
0630E:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kI);
06310:  MOVF   xFC,W
06312:  SUBLW  49
06314:  BNZ   63BC
06316:  MOVLW  04
06318:  MOVLB  6
0631A:  MOVWF  x32
0631C:  MOVLW  42
0631E:  MOVWF  x31
06320:  MOVLB  0
06322:  CALL   515C
06326:  MOVF   01,W
06328:  ADDLW  42
0632A:  MOVLB  6
0632C:  MOVWF  x00
0632E:  MOVLW  04
06330:  ADDWFC 02,W
06332:  MOVWF  x01
06334:  MOVLW  01
06336:  MOVLB  5
06338:  SUBWF  xFB,W
0633A:  MULLW  20
0633C:  MOVF   FF3,W
0633E:  MOVLB  6
06340:  CLRF   x03
06342:  MOVWF  x02
06344:  MOVLW  04
06346:  ADDWF  x02,W
06348:  MOVWF  01
0634A:  MOVLW  00
0634C:  ADDWFC x03,W
0634E:  MOVWF  03
06350:  MOVF   01,W
06352:  ADDLW  20
06354:  MOVWF  FE9
06356:  MOVLW  00
06358:  ADDWFC 03,W
0635A:  MOVWF  FEA
0635C:  MOVFF  FEF,602
06360:  MOVFF  FEC,603
06364:  MOVFF  FEC,604
06368:  MOVFF  FEC,605
0636C:  MOVFF  601,4E7
06370:  MOVFF  600,4E6
06374:  MOVFF  5FB,629
06378:  MOVLW  18
0637A:  MOVWF  x2A
0637C:  MOVLB  0
0637E:  CALL   5718
06382:  MOVLW  2C
06384:  MOVLB  6
06386:  MOVWF  x40
06388:  MOVLB  0
0638A:  CALL   520C
0638E:  MOVLW  89
06390:  MOVWF  FE9
06392:  MOVFF  605,636
06396:  MOVFF  604,635
0639A:  MOVFF  603,634
0639E:  MOVFF  602,633
063A2:  MOVLW  02
063A4:  MOVLB  6
063A6:  MOVWF  x37
063A8:  MOVLB  0
063AA:  RCALL  5F50
063AC:  MOVLW  2C
063AE:  MOVLB  6
063B0:  MOVWF  x40
063B2:  MOVLB  0
063B4:  CALL   520C
063B8:  BRA    65D6
063BA:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].kD);
063BC:  MOVF   xFC,W
063BE:  SUBLW  44
063C0:  BNZ   6468
063C2:  MOVLW  04
063C4:  MOVLB  6
063C6:  MOVWF  x32
063C8:  MOVLW  42
063CA:  MOVWF  x31
063CC:  MOVLB  0
063CE:  CALL   515C
063D2:  MOVF   01,W
063D4:  ADDLW  42
063D6:  MOVLB  6
063D8:  MOVWF  x00
063DA:  MOVLW  04
063DC:  ADDWFC 02,W
063DE:  MOVWF  x01
063E0:  MOVLW  01
063E2:  MOVLB  5
063E4:  SUBWF  xFB,W
063E6:  MULLW  20
063E8:  MOVF   FF3,W
063EA:  MOVLB  6
063EC:  CLRF   x03
063EE:  MOVWF  x02
063F0:  MOVLW  08
063F2:  ADDWF  x02,W
063F4:  MOVWF  01
063F6:  MOVLW  00
063F8:  ADDWFC x03,W
063FA:  MOVWF  03
063FC:  MOVF   01,W
063FE:  ADDLW  20
06400:  MOVWF  FE9
06402:  MOVLW  00
06404:  ADDWFC 03,W
06406:  MOVWF  FEA
06408:  MOVFF  FEF,602
0640C:  MOVFF  FEC,603
06410:  MOVFF  FEC,604
06414:  MOVFF  FEC,605
06418:  MOVFF  601,4E7
0641C:  MOVFF  600,4E6
06420:  MOVFF  5FB,629
06424:  MOVLW  18
06426:  MOVWF  x2A
06428:  MOVLB  0
0642A:  CALL   5718
0642E:  MOVLW  2C
06430:  MOVLB  6
06432:  MOVWF  x40
06434:  MOVLB  0
06436:  CALL   520C
0643A:  MOVLW  89
0643C:  MOVWF  FE9
0643E:  MOVFF  605,636
06442:  MOVFF  604,635
06446:  MOVFF  603,634
0644A:  MOVFF  602,633
0644E:  MOVLW  02
06450:  MOVLB  6
06452:  MOVWF  x37
06454:  MOVLB  0
06456:  RCALL  5F50
06458:  MOVLW  2C
0645A:  MOVLB  6
0645C:  MOVWF  x40
0645E:  MOVLB  0
06460:  CALL   520C
06464:  BRA    65D6
06466:  MOVLB  5
....................    else if ('A' == arg2) sprintf(retData+strlen(retData), "%d,%f,%f,%f,", arg1, PID[arg1-1].kP, PID[arg1-1].kI, PID[arg1-1].kD);
06468:  MOVF   xFC,W
0646A:  SUBLW  41
0646C:  BTFSS  FD8.2
0646E:  BRA    65CE
06470:  MOVLW  04
06472:  MOVLB  6
06474:  MOVWF  x32
06476:  MOVLW  42
06478:  MOVWF  x31
0647A:  MOVLB  0
0647C:  CALL   515C
06480:  MOVF   01,W
06482:  ADDLW  42
06484:  MOVLB  6
06486:  MOVWF  x00
06488:  MOVLW  04
0648A:  ADDWFC 02,W
0648C:  MOVWF  x01
0648E:  MOVLW  01
06490:  MOVLB  5
06492:  SUBWF  xFB,W
06494:  MULLW  20
06496:  MOVF   FF3,W
06498:  MOVLB  6
0649A:  CLRF   x03
0649C:  MOVWF  x02
0649E:  MOVLW  20
064A0:  ADDWF  x02,W
064A2:  MOVWF  FE9
064A4:  MOVLW  00
064A6:  ADDWFC x03,W
064A8:  MOVWF  FEA
064AA:  MOVFF  FEF,604
064AE:  MOVFF  FEC,605
064B2:  MOVFF  FEC,606
064B6:  MOVFF  FEC,607
064BA:  MOVLW  01
064BC:  MOVLB  5
064BE:  SUBWF  xFB,W
064C0:  MULLW  20
064C2:  MOVF   FF3,W
064C4:  MOVLB  6
064C6:  CLRF   x09
064C8:  MOVWF  x08
064CA:  MOVLW  04
064CC:  ADDWF  x08,W
064CE:  MOVWF  01
064D0:  MOVLW  00
064D2:  ADDWFC x09,W
064D4:  MOVWF  03
064D6:  MOVF   01,W
064D8:  ADDLW  20
064DA:  MOVWF  FE9
064DC:  MOVLW  00
064DE:  ADDWFC 03,W
064E0:  MOVWF  FEA
064E2:  MOVFF  FEF,608
064E6:  MOVFF  FEC,609
064EA:  MOVFF  FEC,60A
064EE:  MOVFF  FEC,60B
064F2:  MOVLW  01
064F4:  MOVLB  5
064F6:  SUBWF  xFB,W
064F8:  MULLW  20
064FA:  MOVF   FF3,W
064FC:  MOVLB  6
064FE:  CLRF   x0D
06500:  MOVWF  x0C
06502:  MOVLW  08
06504:  ADDWF  x0C,W
06506:  MOVWF  01
06508:  MOVLW  00
0650A:  ADDWFC x0D,W
0650C:  MOVWF  03
0650E:  MOVF   01,W
06510:  ADDLW  20
06512:  MOVWF  FE9
06514:  MOVLW  00
06516:  ADDWFC 03,W
06518:  MOVWF  FEA
0651A:  MOVFF  FEF,60C
0651E:  MOVFF  FEC,60D
06522:  MOVFF  FEC,60E
06526:  MOVFF  FEC,60F
0652A:  MOVFF  601,4E7
0652E:  MOVFF  600,4E6
06532:  MOVFF  5FB,629
06536:  MOVLW  18
06538:  MOVWF  x2A
0653A:  MOVLB  0
0653C:  CALL   5718
06540:  MOVLW  2C
06542:  MOVLB  6
06544:  MOVWF  x40
06546:  MOVLB  0
06548:  CALL   520C
0654C:  MOVLW  89
0654E:  MOVWF  FE9
06550:  MOVFF  607,636
06554:  MOVFF  606,635
06558:  MOVFF  605,634
0655C:  MOVFF  604,633
06560:  MOVLW  02
06562:  MOVLB  6
06564:  MOVWF  x37
06566:  MOVLB  0
06568:  RCALL  5F50
0656A:  MOVLW  2C
0656C:  MOVLB  6
0656E:  MOVWF  x40
06570:  MOVLB  0
06572:  CALL   520C
06576:  MOVLW  89
06578:  MOVWF  FE9
0657A:  MOVFF  60B,636
0657E:  MOVFF  60A,635
06582:  MOVFF  609,634
06586:  MOVFF  608,633
0658A:  MOVLW  02
0658C:  MOVLB  6
0658E:  MOVWF  x37
06590:  MOVLB  0
06592:  RCALL  5F50
06594:  MOVLW  2C
06596:  MOVLB  6
06598:  MOVWF  x40
0659A:  MOVLB  0
0659C:  CALL   520C
065A0:  MOVLW  89
065A2:  MOVWF  FE9
065A4:  MOVFF  60F,636
065A8:  MOVFF  60E,635
065AC:  MOVFF  60D,634
065B0:  MOVFF  60C,633
065B4:  MOVLW  02
065B6:  MOVLB  6
065B8:  MOVWF  x37
065BA:  MOVLB  0
065BC:  RCALL  5F50
065BE:  MOVLW  2C
065C0:  MOVLB  6
065C2:  MOVWF  x40
065C4:  MOVLB  0
065C6:  CALL   520C
065CA:  BRA    65D6
065CC:  MOVLB  5
....................    else return INV_PARAM;
065CE:  MOVLW  02
065D0:  MOVWF  01
065D2:  MOVLB  0
065D4:  BRA    65DA
....................    
....................    return SUCCESS;
065D6:  MOVLW  00
065D8:  MOVWF  01
065DA:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
068F8:  MOVLB  6
068FA:  CLRF   x32
068FC:  MOVFF  5EF,631
06900:  CLRF   x34
06902:  MOVLW  B5
06904:  MOVWF  x33
06906:  MOVLB  0
06908:  CALL   08AC
0690C:  MOVFF  02,602
06910:  MOVFF  01,601
06914:  MOVLW  06
06916:  MOVLB  6
06918:  ADDWF  x01,F
0691A:  MOVLW  00
0691C:  ADDWFC x02,F
0691E:  MOVLW  32
06920:  ADDWF  x01,W
06922:  MOVWF  01
06924:  MOVLW  00
06926:  ADDWFC x02,W
06928:  MOVWF  03
0692A:  MOVF   01,W
0692C:  ADDLW  6C
0692E:  MOVWF  01
06930:  MOVLW  01
06932:  ADDWFC 03,F
06934:  MOVFF  01,601
06938:  MOVFF  03,602
0693C:  MOVFF  03,629
06940:  MOVFF  01,628
06944:  MOVLB  0
06946:  CALL   52D4
0694A:  MOVF   01,F
0694C:  BNZ   6956
0694E:  MOVLW  02
06950:  MOVWF  01
06952:  BRA    6BE2
06954:  BRA    69B4
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06956:  MOVLB  6
06958:  CLRF   x32
0695A:  MOVFF  5EF,631
0695E:  CLRF   x34
06960:  MOVLW  B5
06962:  MOVWF  x33
06964:  MOVLB  0
06966:  CALL   08AC
0696A:  MOVFF  02,602
0696E:  MOVFF  01,601
06972:  MOVLW  06
06974:  MOVLB  6
06976:  ADDWF  x01,F
06978:  MOVLW  00
0697A:  ADDWFC x02,F
0697C:  MOVLW  32
0697E:  ADDWF  x01,W
06980:  MOVWF  01
06982:  MOVLW  00
06984:  ADDWFC x02,W
06986:  MOVWF  03
06988:  MOVF   01,W
0698A:  ADDLW  6C
0698C:  MOVWF  01
0698E:  MOVLW  01
06990:  ADDWFC 03,F
06992:  MOVFF  01,601
06996:  MOVFF  03,602
0699A:  MOVFF  03,629
0699E:  MOVFF  01,628
069A2:  CLRF   x2B
069A4:  CLRF   x2A
069A6:  MOVLW  0A
069A8:  MOVWF  x2C
069AA:  MOVLB  0
069AC:  CALL   53C4
069B0:  MOVFF  01,5FB
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
069B4:  MOVLB  6
069B6:  CLRF   x32
069B8:  MOVFF  5EF,631
069BC:  CLRF   x34
069BE:  MOVLW  B5
069C0:  MOVWF  x33
069C2:  MOVLB  0
069C4:  CALL   08AC
069C8:  MOVFF  02,602
069CC:  MOVFF  01,601
069D0:  MOVLW  06
069D2:  MOVLB  6
069D4:  ADDWF  x01,F
069D6:  MOVLW  00
069D8:  ADDWFC x02,F
069DA:  MOVLW  4B
069DC:  ADDWF  x01,W
069DE:  MOVWF  01
069E0:  MOVLW  00
069E2:  ADDWFC x02,W
069E4:  MOVWF  03
069E6:  MOVF   01,W
069E8:  ADDLW  6C
069EA:  MOVWF  01
069EC:  MOVLW  01
069EE:  ADDWFC 03,F
069F0:  MOVFF  01,601
069F4:  MOVFF  03,602
069F8:  MOVFF  03,632
069FC:  MOVFF  01,631
06A00:  MOVLB  0
06A02:  CALL   515C
06A06:  MOVFF  02,03
06A0A:  MOVF   01,W
06A0C:  SUBLW  01
06A0E:  BNZ   6A14
06A10:  MOVF   03,F
06A12:  BZ    6A1C
06A14:  MOVLW  02
06A16:  MOVWF  01
06A18:  BRA    6BE2
06A1A:  BRA    6A5C
....................    else arg2 = SERcmd[rec].p[3][0];
06A1C:  MOVLB  6
06A1E:  CLRF   x32
06A20:  MOVFF  5EF,631
06A24:  CLRF   x34
06A26:  MOVLW  B5
06A28:  MOVWF  x33
06A2A:  MOVLB  0
06A2C:  CALL   08AC
06A30:  MOVFF  02,602
06A34:  MOVFF  01,601
06A38:  MOVLW  06
06A3A:  MOVLB  6
06A3C:  ADDWF  x01,F
06A3E:  MOVLW  00
06A40:  ADDWFC x02,F
06A42:  MOVLW  4B
06A44:  ADDWF  x01,F
06A46:  MOVLW  00
06A48:  ADDWFC x02,F
06A4A:  MOVLW  6C
06A4C:  ADDWF  x01,W
06A4E:  MOVWF  FE9
06A50:  MOVLW  01
06A52:  ADDWFC x02,W
06A54:  MOVWF  FEA
06A56:  MOVFF  FEF,5FC
06A5A:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
06A5C:  MOVLB  6
06A5E:  CLRF   x32
06A60:  MOVFF  5EF,631
06A64:  CLRF   x34
06A66:  MOVLW  B5
06A68:  MOVWF  x33
06A6A:  MOVLB  0
06A6C:  CALL   08AC
06A70:  MOVFF  02,602
06A74:  MOVFF  01,601
06A78:  MOVLW  06
06A7A:  MOVLB  6
06A7C:  ADDWF  x01,F
06A7E:  MOVLW  00
06A80:  ADDWFC x02,F
06A82:  MOVLW  64
06A84:  ADDWF  x01,W
06A86:  MOVWF  01
06A88:  MOVLW  00
06A8A:  ADDWFC x02,W
06A8C:  MOVWF  03
06A8E:  MOVF   01,W
06A90:  ADDLW  6C
06A92:  MOVWF  01
06A94:  MOVLW  01
06A96:  ADDWFC 03,F
06A98:  MOVFF  01,601
06A9C:  MOVFF  03,602
06AA0:  MOVFF  03,605
06AA4:  MOVFF  01,604
06AA8:  MOVLB  0
06AAA:  RCALL  65DC
06AAC:  MOVF   01,F
06AAE:  BNZ   6AB8
06AB0:  MOVLW  02
06AB2:  MOVWF  01
06AB4:  BRA    6BE2
06AB6:  BRA    6B1C
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06AB8:  MOVLB  6
06ABA:  CLRF   x32
06ABC:  MOVFF  5EF,631
06AC0:  CLRF   x34
06AC2:  MOVLW  B5
06AC4:  MOVWF  x33
06AC6:  MOVLB  0
06AC8:  CALL   08AC
06ACC:  MOVFF  02,602
06AD0:  MOVFF  01,601
06AD4:  MOVLW  06
06AD6:  MOVLB  6
06AD8:  ADDWF  x01,F
06ADA:  MOVLW  00
06ADC:  ADDWFC x02,F
06ADE:  MOVLW  64
06AE0:  ADDWF  x01,W
06AE2:  MOVWF  01
06AE4:  MOVLW  00
06AE6:  ADDWFC x02,W
06AE8:  MOVWF  03
06AEA:  MOVF   01,W
06AEC:  ADDLW  6C
06AEE:  MOVWF  01
06AF0:  MOVLW  01
06AF2:  ADDWFC 03,F
06AF4:  MOVFF  01,601
06AF8:  MOVFF  03,602
06AFC:  MOVFF  03,605
06B00:  MOVFF  01,604
06B04:  CLRF   x07
06B06:  CLRF   x06
06B08:  MOVLB  0
06B0A:  RCALL  669E
06B0C:  MOVFF  03,600
06B10:  MOVFF  02,5FF
06B14:  MOVFF  01,5FE
06B18:  MOVFF  00,5FD
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
06B1C:  MOVLB  5
06B1E:  MOVF   xFC,W
06B20:  SUBLW  50
06B22:  BNZ   6B52
06B24:  MOVLW  01
06B26:  SUBWF  xFB,W
06B28:  MULLW  20
06B2A:  MOVF   FF3,W
06B2C:  MOVLB  6
06B2E:  CLRF   x02
06B30:  MOVWF  x01
06B32:  MOVLW  20
06B34:  ADDWF  x01,W
06B36:  MOVWF  FE9
06B38:  MOVLW  00
06B3A:  ADDWFC x02,W
06B3C:  MOVWF  FEA
06B3E:  MOVFF  5FD,FEF
06B42:  MOVFF  5FE,FEC
06B46:  MOVFF  5FF,FEC
06B4A:  MOVFF  600,FEC
06B4E:  BRA    6BDC
06B50:  MOVLB  5
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
06B52:  MOVF   xFC,W
06B54:  SUBLW  49
06B56:  BNZ   6B92
06B58:  MOVLW  01
06B5A:  SUBWF  xFB,W
06B5C:  MULLW  20
06B5E:  MOVF   FF3,W
06B60:  MOVLB  6
06B62:  CLRF   x02
06B64:  MOVWF  x01
06B66:  MOVLW  04
06B68:  ADDWF  x01,W
06B6A:  MOVWF  01
06B6C:  MOVLW  00
06B6E:  ADDWFC x02,W
06B70:  MOVWF  03
06B72:  MOVF   01,W
06B74:  ADDLW  20
06B76:  MOVWF  FE9
06B78:  MOVLW  00
06B7A:  ADDWFC 03,W
06B7C:  MOVWF  FEA
06B7E:  MOVFF  5FD,FEF
06B82:  MOVFF  5FE,FEC
06B86:  MOVFF  5FF,FEC
06B8A:  MOVFF  600,FEC
06B8E:  BRA    6BDC
06B90:  MOVLB  5
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
06B92:  MOVF   xFC,W
06B94:  SUBLW  44
06B96:  BNZ   6BD2
06B98:  MOVLW  01
06B9A:  SUBWF  xFB,W
06B9C:  MULLW  20
06B9E:  MOVF   FF3,W
06BA0:  MOVLB  6
06BA2:  CLRF   x02
06BA4:  MOVWF  x01
06BA6:  MOVLW  08
06BA8:  ADDWF  x01,W
06BAA:  MOVWF  01
06BAC:  MOVLW  00
06BAE:  ADDWFC x02,W
06BB0:  MOVWF  03
06BB2:  MOVF   01,W
06BB4:  ADDLW  20
06BB6:  MOVWF  FE9
06BB8:  MOVLW  00
06BBA:  ADDWFC 03,W
06BBC:  MOVWF  FEA
06BBE:  MOVFF  5FD,FEF
06BC2:  MOVFF  5FE,FEC
06BC6:  MOVFF  5FF,FEC
06BCA:  MOVFF  600,FEC
06BCE:  BRA    6BDC
06BD0:  MOVLB  5
....................    else return INV_PARAM;
06BD2:  MOVLW  02
06BD4:  MOVWF  01
06BD6:  MOVLB  0
06BD8:  BRA    6BE2
06BDA:  MOVLB  6
....................    
....................    return SUCCESS;
06BDC:  MOVLW  00
06BDE:  MOVWF  01
06BE0:  MOVLB  0
06BE2:  RETURN 0
.................... }
.................... 
.................... //!int8 enablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = TRUE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... //!
.................... //!int8 disablePID(unsigned int8 rec){
.................... //!   /*** ARG CHECKS ********************/
.................... //!   int8  arg1;
.................... //!   
.................... //!   if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
.................... //!   else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
.................... //!   
.................... //!   PID[arg1-1].enable = FALSE;
.................... //!   
.................... //!   return SUCCESS;
.................... //!}
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06BE4:  MOVLB  6
06BE6:  CLRF   x32
06BE8:  MOVFF  5EF,631
06BEC:  CLRF   x34
06BEE:  MOVLW  B5
06BF0:  MOVWF  x33
06BF2:  MOVLB  0
06BF4:  CALL   08AC
06BF8:  MOVFF  02,601
06BFC:  MOVFF  01,600
06C00:  MOVLW  06
06C02:  MOVLB  6
06C04:  ADDWF  x00,F
06C06:  MOVLW  00
06C08:  ADDWFC x01,F
06C0A:  MOVLW  32
06C0C:  ADDWF  x00,W
06C0E:  MOVWF  01
06C10:  MOVLW  00
06C12:  ADDWFC x01,W
06C14:  MOVWF  03
06C16:  MOVF   01,W
06C18:  ADDLW  6C
06C1A:  MOVWF  01
06C1C:  MOVLW  01
06C1E:  ADDWFC 03,F
06C20:  MOVFF  01,600
06C24:  MOVFF  03,601
06C28:  MOVFF  03,629
06C2C:  MOVFF  01,628
06C30:  MOVLB  0
06C32:  CALL   52D4
06C36:  MOVF   01,F
06C38:  BNZ   6C42
06C3A:  MOVLW  02
06C3C:  MOVWF  01
06C3E:  BRA    6D48
06C40:  BRA    6CA0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06C42:  MOVLB  6
06C44:  CLRF   x32
06C46:  MOVFF  5EF,631
06C4A:  CLRF   x34
06C4C:  MOVLW  B5
06C4E:  MOVWF  x33
06C50:  MOVLB  0
06C52:  CALL   08AC
06C56:  MOVFF  02,601
06C5A:  MOVFF  01,600
06C5E:  MOVLW  06
06C60:  MOVLB  6
06C62:  ADDWF  x00,F
06C64:  MOVLW  00
06C66:  ADDWFC x01,F
06C68:  MOVLW  32
06C6A:  ADDWF  x00,W
06C6C:  MOVWF  01
06C6E:  MOVLW  00
06C70:  ADDWFC x01,W
06C72:  MOVWF  03
06C74:  MOVF   01,W
06C76:  ADDLW  6C
06C78:  MOVWF  01
06C7A:  MOVLW  01
06C7C:  ADDWFC 03,F
06C7E:  MOVFF  01,600
06C82:  MOVFF  03,601
06C86:  MOVFF  03,629
06C8A:  MOVFF  01,628
06C8E:  CLRF   x2B
06C90:  CLRF   x2A
06C92:  MOVLW  0A
06C94:  MOVWF  x2C
06C96:  MOVLB  0
06C98:  CALL   53C4
06C9C:  MOVFF  01,5FB
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].SP);
06CA0:  MOVLW  04
06CA2:  MOVLB  6
06CA4:  MOVWF  x32
06CA6:  MOVLW  42
06CA8:  MOVWF  x31
06CAA:  MOVLB  0
06CAC:  CALL   515C
06CB0:  MOVF   01,W
06CB2:  ADDLW  42
06CB4:  MOVLB  6
06CB6:  MOVWF  x00
06CB8:  MOVLW  04
06CBA:  ADDWFC 02,W
06CBC:  MOVWF  x01
06CBE:  MOVLW  01
06CC0:  MOVLB  5
06CC2:  SUBWF  xFB,W
06CC4:  MULLW  20
06CC6:  MOVF   FF3,W
06CC8:  MOVLB  6
06CCA:  CLRF   x03
06CCC:  MOVWF  x02
06CCE:  MOVLW  0C
06CD0:  ADDWF  x02,W
06CD2:  MOVWF  01
06CD4:  MOVLW  00
06CD6:  ADDWFC x03,W
06CD8:  MOVWF  03
06CDA:  MOVF   01,W
06CDC:  ADDLW  20
06CDE:  MOVWF  FE9
06CE0:  MOVLW  00
06CE2:  ADDWFC 03,W
06CE4:  MOVWF  FEA
06CE6:  MOVFF  FEF,602
06CEA:  MOVFF  FEC,603
06CEE:  MOVFF  FEC,604
06CF2:  MOVFF  FEC,605
06CF6:  MOVFF  601,4E7
06CFA:  MOVFF  600,4E6
06CFE:  MOVFF  5FB,629
06D02:  MOVLW  18
06D04:  MOVWF  x2A
06D06:  MOVLB  0
06D08:  CALL   5718
06D0C:  MOVLW  2C
06D0E:  MOVLB  6
06D10:  MOVWF  x40
06D12:  MOVLB  0
06D14:  CALL   520C
06D18:  MOVLW  89
06D1A:  MOVWF  FE9
06D1C:  MOVFF  605,636
06D20:  MOVFF  604,635
06D24:  MOVFF  603,634
06D28:  MOVFF  602,633
06D2C:  MOVLW  02
06D2E:  MOVLB  6
06D30:  MOVWF  x37
06D32:  MOVLB  0
06D34:  CALL   5F50
06D38:  MOVLW  2C
06D3A:  MOVLB  6
06D3C:  MOVWF  x40
06D3E:  MOVLB  0
06D40:  CALL   520C
....................    return SUCCESS;
06D44:  MOVLW  00
06D46:  MOVWF  01
06D48:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06D4A:  MOVLB  6
06D4C:  CLRF   x32
06D4E:  MOVFF  5EF,631
06D52:  CLRF   x34
06D54:  MOVLW  B5
06D56:  MOVWF  x33
06D58:  MOVLB  0
06D5A:  CALL   08AC
06D5E:  MOVFF  02,601
06D62:  MOVFF  01,600
06D66:  MOVLW  06
06D68:  MOVLB  6
06D6A:  ADDWF  x00,F
06D6C:  MOVLW  00
06D6E:  ADDWFC x01,F
06D70:  MOVLW  32
06D72:  ADDWF  x00,W
06D74:  MOVWF  01
06D76:  MOVLW  00
06D78:  ADDWFC x01,W
06D7A:  MOVWF  03
06D7C:  MOVF   01,W
06D7E:  ADDLW  6C
06D80:  MOVWF  01
06D82:  MOVLW  01
06D84:  ADDWFC 03,F
06D86:  MOVFF  01,600
06D8A:  MOVFF  03,601
06D8E:  MOVFF  03,629
06D92:  MOVFF  01,628
06D96:  MOVLB  0
06D98:  CALL   52D4
06D9C:  MOVF   01,F
06D9E:  BNZ   6DA8
06DA0:  MOVLW  02
06DA2:  MOVWF  01
06DA4:  BRA    6F08
06DA6:  BRA    6E06
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06DA8:  MOVLB  6
06DAA:  CLRF   x32
06DAC:  MOVFF  5EF,631
06DB0:  CLRF   x34
06DB2:  MOVLW  B5
06DB4:  MOVWF  x33
06DB6:  MOVLB  0
06DB8:  CALL   08AC
06DBC:  MOVFF  02,601
06DC0:  MOVFF  01,600
06DC4:  MOVLW  06
06DC6:  MOVLB  6
06DC8:  ADDWF  x00,F
06DCA:  MOVLW  00
06DCC:  ADDWFC x01,F
06DCE:  MOVLW  32
06DD0:  ADDWF  x00,W
06DD2:  MOVWF  01
06DD4:  MOVLW  00
06DD6:  ADDWFC x01,W
06DD8:  MOVWF  03
06DDA:  MOVF   01,W
06DDC:  ADDLW  6C
06DDE:  MOVWF  01
06DE0:  MOVLW  01
06DE2:  ADDWFC 03,F
06DE4:  MOVFF  01,600
06DE8:  MOVFF  03,601
06DEC:  MOVFF  03,629
06DF0:  MOVFF  01,628
06DF4:  CLRF   x2B
06DF6:  CLRF   x2A
06DF8:  MOVLW  0A
06DFA:  MOVWF  x2C
06DFC:  MOVLB  0
06DFE:  CALL   53C4
06E02:  MOVFF  01,5FB
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
06E06:  MOVLB  6
06E08:  CLRF   x32
06E0A:  MOVFF  5EF,631
06E0E:  CLRF   x34
06E10:  MOVLW  B5
06E12:  MOVWF  x33
06E14:  MOVLB  0
06E16:  CALL   08AC
06E1A:  MOVFF  02,601
06E1E:  MOVFF  01,600
06E22:  MOVLW  06
06E24:  MOVLB  6
06E26:  ADDWF  x00,F
06E28:  MOVLW  00
06E2A:  ADDWFC x01,F
06E2C:  MOVLW  4B
06E2E:  ADDWF  x00,W
06E30:  MOVWF  01
06E32:  MOVLW  00
06E34:  ADDWFC x01,W
06E36:  MOVWF  03
06E38:  MOVF   01,W
06E3A:  ADDLW  6C
06E3C:  MOVWF  01
06E3E:  MOVLW  01
06E40:  ADDWFC 03,F
06E42:  MOVFF  01,600
06E46:  MOVFF  03,601
06E4A:  MOVFF  03,605
06E4E:  MOVFF  01,604
06E52:  MOVLB  0
06E54:  CALL   65DC
06E58:  MOVF   01,F
06E5A:  BNZ   6E64
06E5C:  MOVLW  02
06E5E:  MOVWF  01
06E60:  BRA    6F08
06E62:  BRA    6ECA
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
06E64:  MOVLB  6
06E66:  CLRF   x32
06E68:  MOVFF  5EF,631
06E6C:  CLRF   x34
06E6E:  MOVLW  B5
06E70:  MOVWF  x33
06E72:  MOVLB  0
06E74:  CALL   08AC
06E78:  MOVFF  02,601
06E7C:  MOVFF  01,600
06E80:  MOVLW  06
06E82:  MOVLB  6
06E84:  ADDWF  x00,F
06E86:  MOVLW  00
06E88:  ADDWFC x01,F
06E8A:  MOVLW  4B
06E8C:  ADDWF  x00,W
06E8E:  MOVWF  01
06E90:  MOVLW  00
06E92:  ADDWFC x01,W
06E94:  MOVWF  03
06E96:  MOVF   01,W
06E98:  ADDLW  6C
06E9A:  MOVWF  01
06E9C:  MOVLW  01
06E9E:  ADDWFC 03,F
06EA0:  MOVFF  01,600
06EA4:  MOVFF  03,601
06EA8:  MOVFF  03,605
06EAC:  MOVFF  01,604
06EB0:  CLRF   x07
06EB2:  CLRF   x06
06EB4:  MOVLB  0
06EB6:  CALL   669E
06EBA:  MOVFF  03,5FF
06EBE:  MOVFF  02,5FE
06EC2:  MOVFF  01,5FD
06EC6:  MOVFF  00,5FC
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
06ECA:  MOVLW  01
06ECC:  MOVLB  5
06ECE:  SUBWF  xFB,W
06ED0:  MULLW  20
06ED2:  MOVF   FF3,W
06ED4:  MOVLB  6
06ED6:  CLRF   x01
06ED8:  MOVWF  x00
06EDA:  MOVLW  0C
06EDC:  ADDWF  x00,W
06EDE:  MOVWF  01
06EE0:  MOVLW  00
06EE2:  ADDWFC x01,W
06EE4:  MOVWF  03
06EE6:  MOVF   01,W
06EE8:  ADDLW  20
06EEA:  MOVWF  FE9
06EEC:  MOVLW  00
06EEE:  ADDWFC 03,W
06EF0:  MOVWF  FEA
06EF2:  MOVFF  5FC,FEF
06EF6:  MOVFF  5FD,FEC
06EFA:  MOVFF  5FE,FEC
06EFE:  MOVFF  5FF,FEC
....................    
....................    return SUCCESS;
06F02:  MOVLW  00
06F04:  MOVWF  01
06F06:  MOVLB  0
06F08:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06F0A:  MOVLB  6
06F0C:  CLRF   x32
06F0E:  MOVFF  5EF,631
06F12:  CLRF   x34
06F14:  MOVLW  B5
06F16:  MOVWF  x33
06F18:  MOVLB  0
06F1A:  CALL   08AC
06F1E:  MOVFF  02,601
06F22:  MOVFF  01,600
06F26:  MOVLW  06
06F28:  MOVLB  6
06F2A:  ADDWF  x00,F
06F2C:  MOVLW  00
06F2E:  ADDWFC x01,F
06F30:  MOVLW  32
06F32:  ADDWF  x00,W
06F34:  MOVWF  01
06F36:  MOVLW  00
06F38:  ADDWFC x01,W
06F3A:  MOVWF  03
06F3C:  MOVF   01,W
06F3E:  ADDLW  6C
06F40:  MOVWF  01
06F42:  MOVLW  01
06F44:  ADDWFC 03,F
06F46:  MOVFF  01,600
06F4A:  MOVFF  03,601
06F4E:  MOVFF  03,629
06F52:  MOVFF  01,628
06F56:  MOVLB  0
06F58:  CALL   52D4
06F5C:  MOVF   01,F
06F5E:  BNZ   6F68
06F60:  MOVLW  02
06F62:  MOVWF  01
06F64:  BRA    72D6
06F66:  BRA    6FC6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06F68:  MOVLB  6
06F6A:  CLRF   x32
06F6C:  MOVFF  5EF,631
06F70:  CLRF   x34
06F72:  MOVLW  B5
06F74:  MOVWF  x33
06F76:  MOVLB  0
06F78:  CALL   08AC
06F7C:  MOVFF  02,601
06F80:  MOVFF  01,600
06F84:  MOVLW  06
06F86:  MOVLB  6
06F88:  ADDWF  x00,F
06F8A:  MOVLW  00
06F8C:  ADDWFC x01,F
06F8E:  MOVLW  32
06F90:  ADDWF  x00,W
06F92:  MOVWF  01
06F94:  MOVLW  00
06F96:  ADDWFC x01,W
06F98:  MOVWF  03
06F9A:  MOVF   01,W
06F9C:  ADDLW  6C
06F9E:  MOVWF  01
06FA0:  MOVLW  01
06FA2:  ADDWFC 03,F
06FA4:  MOVFF  01,600
06FA8:  MOVFF  03,601
06FAC:  MOVFF  03,629
06FB0:  MOVFF  01,628
06FB4:  CLRF   x2B
06FB6:  CLRF   x2A
06FB8:  MOVLW  0A
06FBA:  MOVWF  x2C
06FBC:  MOVLB  0
06FBE:  CALL   53C4
06FC2:  MOVFF  01,5FB
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%d,", arg1);
06FC6:  MOVLW  04
06FC8:  MOVLB  6
06FCA:  MOVWF  x32
06FCC:  MOVLW  42
06FCE:  MOVWF  x31
06FD0:  MOVLB  0
06FD2:  CALL   515C
06FD6:  MOVFF  02,03
06FDA:  MOVF   01,W
06FDC:  ADDLW  42
06FDE:  MOVLB  6
06FE0:  MOVWF  x00
06FE2:  MOVLW  04
06FE4:  ADDWFC 02,W
06FE6:  MOVWF  x01
06FE8:  MOVFF  FE8,4E7
06FEC:  MOVFF  600,4E6
06FF0:  MOVFF  5FB,629
06FF4:  MOVLW  18
06FF6:  MOVWF  x2A
06FF8:  MOVLB  0
06FFA:  CALL   5718
06FFE:  MOVLW  2C
07000:  MOVLB  6
07002:  MOVWF  x40
07004:  MOVLB  0
07006:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
0700A:  MOVLW  04
0700C:  MOVLB  6
0700E:  MOVWF  x32
07010:  MOVLW  42
07012:  MOVWF  x31
07014:  MOVLB  0
07016:  CALL   515C
0701A:  MOVFF  02,03
0701E:  MOVF   01,W
07020:  ADDLW  42
07022:  MOVLB  6
07024:  MOVWF  x00
07026:  MOVLW  04
07028:  ADDWFC 02,W
0702A:  MOVWF  x01
0702C:  MOVLW  01
0702E:  MOVLB  5
07030:  SUBWF  xFB,W
07032:  MULLW  18
07034:  MOVF   FF3,W
07036:  MOVLB  6
07038:  CLRF   x03
0703A:  MOVWF  x02
0703C:  MOVLW  82
0703E:  ADDWF  x02,W
07040:  MOVWF  FE9
07042:  MOVLW  00
07044:  ADDWFC x03,W
07046:  MOVWF  FEA
07048:  MOVFF  FEF,633
0704C:  MOVFF  FEC,634
07050:  MOVFF  FEC,635
07054:  MOVFF  FEC,636
07058:  MOVFF  601,4E7
0705C:  MOVFF  600,4E6
07060:  MOVLW  89
07062:  MOVWF  FE9
07064:  MOVLW  02
07066:  MOVWF  x37
07068:  MOVLB  0
0706A:  CALL   5F50
0706E:  MOVLW  2C
07070:  MOVLB  6
07072:  MOVWF  x40
07074:  MOVLB  0
07076:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0707A:  MOVLW  04
0707C:  MOVLB  6
0707E:  MOVWF  x32
07080:  MOVLW  42
07082:  MOVWF  x31
07084:  MOVLB  0
07086:  CALL   515C
0708A:  MOVF   01,W
0708C:  ADDLW  42
0708E:  MOVLB  6
07090:  MOVWF  x00
07092:  MOVLW  04
07094:  ADDWFC 02,W
07096:  MOVWF  x01
07098:  MOVLW  01
0709A:  MOVLB  5
0709C:  SUBWF  xFB,W
0709E:  MULLW  18
070A0:  MOVF   FF3,W
070A2:  MOVLB  6
070A4:  CLRF   x03
070A6:  MOVWF  x02
070A8:  MOVLW  04
070AA:  ADDWF  x02,W
070AC:  MOVWF  01
070AE:  MOVLW  00
070B0:  ADDWFC x03,W
070B2:  MOVWF  03
070B4:  MOVF   01,W
070B6:  ADDLW  82
070B8:  MOVWF  FE9
070BA:  MOVLW  00
070BC:  ADDWFC 03,W
070BE:  MOVWF  FEA
070C0:  MOVFF  FEF,633
070C4:  MOVFF  FEC,634
070C8:  MOVFF  FEC,635
070CC:  MOVFF  FEC,636
070D0:  MOVFF  601,4E7
070D4:  MOVFF  600,4E6
070D8:  MOVLW  89
070DA:  MOVWF  FE9
070DC:  MOVLW  02
070DE:  MOVWF  x37
070E0:  MOVLB  0
070E2:  CALL   5F50
070E6:  MOVLW  2C
070E8:  MOVLB  6
070EA:  MOVWF  x40
070EC:  MOVLB  0
070EE:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
070F2:  MOVLW  04
070F4:  MOVLB  6
070F6:  MOVWF  x32
070F8:  MOVLW  42
070FA:  MOVWF  x31
070FC:  MOVLB  0
070FE:  CALL   515C
07102:  MOVF   01,W
07104:  ADDLW  42
07106:  MOVLB  6
07108:  MOVWF  x00
0710A:  MOVLW  04
0710C:  ADDWFC 02,W
0710E:  MOVWF  x01
07110:  MOVLW  01
07112:  MOVLB  5
07114:  SUBWF  xFB,W
07116:  MULLW  18
07118:  MOVF   FF3,W
0711A:  MOVLB  6
0711C:  CLRF   x03
0711E:  MOVWF  x02
07120:  MOVLW  08
07122:  ADDWF  x02,W
07124:  MOVWF  01
07126:  MOVLW  00
07128:  ADDWFC x03,W
0712A:  MOVWF  03
0712C:  MOVF   01,W
0712E:  ADDLW  82
07130:  MOVWF  FE9
07132:  MOVLW  00
07134:  ADDWFC 03,W
07136:  MOVWF  FEA
07138:  MOVFF  FEF,633
0713C:  MOVFF  FEC,634
07140:  MOVFF  FEC,635
07144:  MOVFF  FEC,636
07148:  MOVFF  601,4E7
0714C:  MOVFF  600,4E6
07150:  MOVLW  89
07152:  MOVWF  FE9
07154:  MOVLW  02
07156:  MOVWF  x37
07158:  MOVLB  0
0715A:  CALL   5F50
0715E:  MOVLW  2C
07160:  MOVLB  6
07162:  MOVWF  x40
07164:  MOVLB  0
07166:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
0716A:  MOVLW  04
0716C:  MOVLB  6
0716E:  MOVWF  x32
07170:  MOVLW  42
07172:  MOVWF  x31
07174:  MOVLB  0
07176:  CALL   515C
0717A:  MOVF   01,W
0717C:  ADDLW  42
0717E:  MOVLB  6
07180:  MOVWF  x00
07182:  MOVLW  04
07184:  ADDWFC 02,W
07186:  MOVWF  x01
07188:  MOVLW  01
0718A:  MOVLB  5
0718C:  SUBWF  xFB,W
0718E:  MULLW  18
07190:  MOVF   FF3,W
07192:  MOVLB  6
07194:  CLRF   x03
07196:  MOVWF  x02
07198:  MOVLW  0C
0719A:  ADDWF  x02,W
0719C:  MOVWF  01
0719E:  MOVLW  00
071A0:  ADDWFC x03,W
071A2:  MOVWF  03
071A4:  MOVF   01,W
071A6:  ADDLW  82
071A8:  MOVWF  FE9
071AA:  MOVLW  00
071AC:  ADDWFC 03,W
071AE:  MOVWF  FEA
071B0:  MOVFF  FEF,633
071B4:  MOVFF  FEC,634
071B8:  MOVFF  FEC,635
071BC:  MOVFF  FEC,636
071C0:  MOVFF  601,4E7
071C4:  MOVFF  600,4E6
071C8:  MOVLW  89
071CA:  MOVWF  FE9
071CC:  MOVLW  02
071CE:  MOVWF  x37
071D0:  MOVLB  0
071D2:  CALL   5F50
071D6:  MOVLW  2C
071D8:  MOVLB  6
071DA:  MOVWF  x40
071DC:  MOVLB  0
071DE:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
071E2:  MOVLW  04
071E4:  MOVLB  6
071E6:  MOVWF  x32
071E8:  MOVLW  42
071EA:  MOVWF  x31
071EC:  MOVLB  0
071EE:  CALL   515C
071F2:  MOVF   01,W
071F4:  ADDLW  42
071F6:  MOVLB  6
071F8:  MOVWF  x00
071FA:  MOVLW  04
071FC:  ADDWFC 02,W
071FE:  MOVWF  x01
07200:  MOVLW  01
07202:  MOVLB  5
07204:  SUBWF  xFB,W
07206:  MULLW  18
07208:  MOVF   FF3,W
0720A:  MOVLB  6
0720C:  CLRF   x03
0720E:  MOVWF  x02
07210:  MOVLW  10
07212:  ADDWF  x02,W
07214:  MOVWF  01
07216:  MOVLW  00
07218:  ADDWFC x03,W
0721A:  MOVWF  03
0721C:  MOVF   01,W
0721E:  ADDLW  82
07220:  MOVWF  FE9
07222:  MOVLW  00
07224:  ADDWFC 03,W
07226:  MOVWF  FEA
07228:  MOVFF  FEF,633
0722C:  MOVFF  FEC,634
07230:  MOVFF  FEC,635
07234:  MOVFF  FEC,636
07238:  MOVFF  601,4E7
0723C:  MOVFF  600,4E6
07240:  MOVLW  89
07242:  MOVWF  FE9
07244:  MOVLW  02
07246:  MOVWF  x37
07248:  MOVLB  0
0724A:  CALL   5F50
0724E:  MOVLW  2C
07250:  MOVLB  6
07252:  MOVWF  x40
07254:  MOVLB  0
07256:  CALL   520C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0725A:  MOVLW  04
0725C:  MOVLB  6
0725E:  MOVWF  x32
07260:  MOVLW  42
07262:  MOVWF  x31
07264:  MOVLB  0
07266:  CALL   515C
0726A:  MOVF   01,W
0726C:  ADDLW  42
0726E:  MOVLB  6
07270:  MOVWF  x00
07272:  MOVLW  04
07274:  ADDWFC 02,W
07276:  MOVWF  x01
07278:  MOVLW  01
0727A:  MOVLB  5
0727C:  SUBWF  xFB,W
0727E:  MULLW  18
07280:  MOVF   FF3,W
07282:  MOVLB  6
07284:  CLRF   x03
07286:  MOVWF  x02
07288:  MOVLW  14
0728A:  ADDWF  x02,W
0728C:  MOVWF  01
0728E:  MOVLW  00
07290:  ADDWFC x03,W
07292:  MOVWF  03
07294:  MOVF   01,W
07296:  ADDLW  82
07298:  MOVWF  FE9
0729A:  MOVLW  00
0729C:  ADDWFC 03,W
0729E:  MOVWF  FEA
072A0:  MOVFF  FEF,633
072A4:  MOVFF  FEC,634
072A8:  MOVFF  FEC,635
072AC:  MOVFF  FEC,636
072B0:  MOVFF  601,4E7
072B4:  MOVFF  600,4E6
072B8:  MOVLW  89
072BA:  MOVWF  FE9
072BC:  MOVLW  02
072BE:  MOVWF  x37
072C0:  MOVLB  0
072C2:  CALL   5F50
072C6:  MOVLW  2C
072C8:  MOVLB  6
072CA:  MOVWF  x40
072CC:  MOVLB  0
072CE:  CALL   520C
....................    
....................    return SUCCESS;
072D2:  MOVLW  00
072D4:  MOVWF  01
072D6:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
072D8:  MOVLB  6
072DA:  CLRF   x32
072DC:  MOVFF  5EF,631
072E0:  CLRF   x34
072E2:  MOVLW  B5
072E4:  MOVWF  x33
072E6:  MOVLB  0
072E8:  CALL   08AC
072EC:  MOVFF  02,601
072F0:  MOVFF  01,600
072F4:  MOVLW  06
072F6:  MOVLB  6
072F8:  ADDWF  x00,F
072FA:  MOVLW  00
072FC:  ADDWFC x01,F
072FE:  MOVLW  32
07300:  ADDWF  x00,W
07302:  MOVWF  01
07304:  MOVLW  00
07306:  ADDWFC x01,W
07308:  MOVWF  03
0730A:  MOVF   01,W
0730C:  ADDLW  6C
0730E:  MOVWF  01
07310:  MOVLW  01
07312:  ADDWFC 03,F
07314:  MOVFF  01,600
07318:  MOVFF  03,601
0731C:  MOVFF  03,629
07320:  MOVFF  01,628
07324:  MOVLB  0
07326:  CALL   52D4
0732A:  MOVF   01,F
0732C:  BNZ   7336
0732E:  MOVLW  02
07330:  MOVWF  01
07332:  BRA    7856
07334:  BRA    7394
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
07336:  MOVLB  6
07338:  CLRF   x32
0733A:  MOVFF  5EF,631
0733E:  CLRF   x34
07340:  MOVLW  B5
07342:  MOVWF  x33
07344:  MOVLB  0
07346:  CALL   08AC
0734A:  MOVFF  02,601
0734E:  MOVFF  01,600
07352:  MOVLW  06
07354:  MOVLB  6
07356:  ADDWF  x00,F
07358:  MOVLW  00
0735A:  ADDWFC x01,F
0735C:  MOVLW  32
0735E:  ADDWF  x00,W
07360:  MOVWF  01
07362:  MOVLW  00
07364:  ADDWFC x01,W
07366:  MOVWF  03
07368:  MOVF   01,W
0736A:  ADDLW  6C
0736C:  MOVWF  01
0736E:  MOVLW  01
07370:  ADDWFC 03,F
07372:  MOVFF  01,600
07376:  MOVFF  03,601
0737A:  MOVFF  03,629
0737E:  MOVFF  01,628
07382:  CLRF   x2B
07384:  CLRF   x2A
07386:  MOVLW  0A
07388:  MOVWF  x2C
0738A:  MOVLB  0
0738C:  CALL   53C4
07390:  MOVFF  01,5FB
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07394:  MOVLB  6
07396:  CLRF   x32
07398:  MOVFF  5EF,631
0739C:  CLRF   x34
0739E:  MOVLW  B5
073A0:  MOVWF  x33
073A2:  MOVLB  0
073A4:  CALL   08AC
073A8:  MOVFF  02,601
073AC:  MOVFF  01,600
073B0:  MOVLW  06
073B2:  MOVLB  6
073B4:  ADDWF  x00,F
073B6:  MOVLW  00
073B8:  ADDWFC x01,F
073BA:  MOVLW  4B
073BC:  ADDWF  x00,W
073BE:  MOVWF  01
073C0:  MOVLW  00
073C2:  ADDWFC x01,W
073C4:  MOVWF  03
073C6:  MOVF   01,W
073C8:  ADDLW  6C
073CA:  MOVWF  01
073CC:  MOVLW  01
073CE:  ADDWFC 03,F
073D0:  MOVFF  01,600
073D4:  MOVFF  03,601
073D8:  MOVFF  03,632
073DC:  MOVFF  01,631
073E0:  MOVLB  0
073E2:  CALL   515C
073E6:  MOVFF  02,03
073EA:  MOVF   01,W
073EC:  SUBLW  01
073EE:  BNZ   73F4
073F0:  MOVF   03,F
073F2:  BZ    73FC
073F4:  MOVLW  02
073F6:  MOVWF  01
073F8:  BRA    7856
073FA:  BRA    743C
....................    else arg2 = SERcmd[rec].p[3][0];
073FC:  MOVLB  6
073FE:  CLRF   x32
07400:  MOVFF  5EF,631
07404:  CLRF   x34
07406:  MOVLW  B5
07408:  MOVWF  x33
0740A:  MOVLB  0
0740C:  CALL   08AC
07410:  MOVFF  02,601
07414:  MOVFF  01,600
07418:  MOVLW  06
0741A:  MOVLB  6
0741C:  ADDWF  x00,F
0741E:  MOVLW  00
07420:  ADDWFC x01,F
07422:  MOVLW  4B
07424:  ADDWF  x00,F
07426:  MOVLW  00
07428:  ADDWFC x01,F
0742A:  MOVLW  6C
0742C:  ADDWF  x00,W
0742E:  MOVWF  FE9
07430:  MOVLW  01
07432:  ADDWFC x01,W
07434:  MOVWF  FEA
07436:  MOVFF  FEF,5FC
0743A:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c0);
0743C:  MOVLB  5
0743E:  MOVF   xFC,W
07440:  SUBLW  30
07442:  BNZ   74E4
07444:  MOVLW  04
07446:  MOVLB  6
07448:  MOVWF  x32
0744A:  MOVLW  42
0744C:  MOVWF  x31
0744E:  MOVLB  0
07450:  CALL   515C
07454:  MOVFF  02,03
07458:  MOVF   01,W
0745A:  ADDLW  42
0745C:  MOVLB  6
0745E:  MOVWF  x00
07460:  MOVLW  04
07462:  ADDWFC 02,W
07464:  MOVWF  x01
07466:  MOVLW  01
07468:  MOVLB  5
0746A:  SUBWF  xFB,W
0746C:  MULLW  18
0746E:  MOVF   FF3,W
07470:  MOVLB  6
07472:  CLRF   x03
07474:  MOVWF  x02
07476:  MOVLW  82
07478:  ADDWF  x02,W
0747A:  MOVWF  FE9
0747C:  MOVLW  00
0747E:  ADDWFC x03,W
07480:  MOVWF  FEA
07482:  MOVFF  FEF,604
07486:  MOVFF  FEC,605
0748A:  MOVFF  FEC,606
0748E:  MOVFF  FEC,607
07492:  MOVFF  601,4E7
07496:  MOVFF  600,4E6
0749A:  MOVFF  5FB,629
0749E:  MOVLW  18
074A0:  MOVWF  x2A
074A2:  MOVLB  0
074A4:  CALL   5718
074A8:  MOVLW  2C
074AA:  MOVLB  6
074AC:  MOVWF  x40
074AE:  MOVLB  0
074B0:  CALL   520C
074B4:  MOVLW  89
074B6:  MOVWF  FE9
074B8:  MOVFF  607,636
074BC:  MOVFF  606,635
074C0:  MOVFF  605,634
074C4:  MOVFF  604,633
074C8:  MOVLW  02
074CA:  MOVLB  6
074CC:  MOVWF  x37
074CE:  MOVLB  0
074D0:  CALL   5F50
074D4:  MOVLW  2C
074D6:  MOVLB  6
074D8:  MOVWF  x40
074DA:  MOVLB  0
074DC:  CALL   520C
074E0:  BRA    7852
074E2:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c1);
074E4:  MOVF   xFC,W
074E6:  SUBLW  31
074E8:  BNZ   7592
074EA:  MOVLW  04
074EC:  MOVLB  6
074EE:  MOVWF  x32
074F0:  MOVLW  42
074F2:  MOVWF  x31
074F4:  MOVLB  0
074F6:  CALL   515C
074FA:  MOVF   01,W
074FC:  ADDLW  42
074FE:  MOVLB  6
07500:  MOVWF  x00
07502:  MOVLW  04
07504:  ADDWFC 02,W
07506:  MOVWF  x01
07508:  MOVLW  01
0750A:  MOVLB  5
0750C:  SUBWF  xFB,W
0750E:  MULLW  18
07510:  MOVF   FF3,W
07512:  MOVLB  6
07514:  CLRF   x03
07516:  MOVWF  x02
07518:  MOVLW  04
0751A:  ADDWF  x02,W
0751C:  MOVWF  01
0751E:  MOVLW  00
07520:  ADDWFC x03,W
07522:  MOVWF  03
07524:  MOVF   01,W
07526:  ADDLW  82
07528:  MOVWF  FE9
0752A:  MOVLW  00
0752C:  ADDWFC 03,W
0752E:  MOVWF  FEA
07530:  MOVFF  FEF,602
07534:  MOVFF  FEC,603
07538:  MOVFF  FEC,604
0753C:  MOVFF  FEC,605
07540:  MOVFF  601,4E7
07544:  MOVFF  600,4E6
07548:  MOVFF  5FB,629
0754C:  MOVLW  18
0754E:  MOVWF  x2A
07550:  MOVLB  0
07552:  CALL   5718
07556:  MOVLW  2C
07558:  MOVLB  6
0755A:  MOVWF  x40
0755C:  MOVLB  0
0755E:  CALL   520C
07562:  MOVLW  89
07564:  MOVWF  FE9
07566:  MOVFF  605,636
0756A:  MOVFF  604,635
0756E:  MOVFF  603,634
07572:  MOVFF  602,633
07576:  MOVLW  02
07578:  MOVLB  6
0757A:  MOVWF  x37
0757C:  MOVLB  0
0757E:  CALL   5F50
07582:  MOVLW  2C
07584:  MOVLB  6
07586:  MOVWF  x40
07588:  MOVLB  0
0758A:  CALL   520C
0758E:  BRA    7852
07590:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c2);
07592:  MOVF   xFC,W
07594:  SUBLW  32
07596:  BNZ   7640
07598:  MOVLW  04
0759A:  MOVLB  6
0759C:  MOVWF  x32
0759E:  MOVLW  42
075A0:  MOVWF  x31
075A2:  MOVLB  0
075A4:  CALL   515C
075A8:  MOVF   01,W
075AA:  ADDLW  42
075AC:  MOVLB  6
075AE:  MOVWF  x00
075B0:  MOVLW  04
075B2:  ADDWFC 02,W
075B4:  MOVWF  x01
075B6:  MOVLW  01
075B8:  MOVLB  5
075BA:  SUBWF  xFB,W
075BC:  MULLW  18
075BE:  MOVF   FF3,W
075C0:  MOVLB  6
075C2:  CLRF   x03
075C4:  MOVWF  x02
075C6:  MOVLW  08
075C8:  ADDWF  x02,W
075CA:  MOVWF  01
075CC:  MOVLW  00
075CE:  ADDWFC x03,W
075D0:  MOVWF  03
075D2:  MOVF   01,W
075D4:  ADDLW  82
075D6:  MOVWF  FE9
075D8:  MOVLW  00
075DA:  ADDWFC 03,W
075DC:  MOVWF  FEA
075DE:  MOVFF  FEF,602
075E2:  MOVFF  FEC,603
075E6:  MOVFF  FEC,604
075EA:  MOVFF  FEC,605
075EE:  MOVFF  601,4E7
075F2:  MOVFF  600,4E6
075F6:  MOVFF  5FB,629
075FA:  MOVLW  18
075FC:  MOVWF  x2A
075FE:  MOVLB  0
07600:  CALL   5718
07604:  MOVLW  2C
07606:  MOVLB  6
07608:  MOVWF  x40
0760A:  MOVLB  0
0760C:  CALL   520C
07610:  MOVLW  89
07612:  MOVWF  FE9
07614:  MOVFF  605,636
07618:  MOVFF  604,635
0761C:  MOVFF  603,634
07620:  MOVFF  602,633
07624:  MOVLW  02
07626:  MOVLB  6
07628:  MOVWF  x37
0762A:  MOVLB  0
0762C:  CALL   5F50
07630:  MOVLW  2C
07632:  MOVLB  6
07634:  MOVWF  x40
07636:  MOVLB  0
07638:  CALL   520C
0763C:  BRA    7852
0763E:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c3);
07640:  MOVF   xFC,W
07642:  SUBLW  33
07644:  BNZ   76EE
07646:  MOVLW  04
07648:  MOVLB  6
0764A:  MOVWF  x32
0764C:  MOVLW  42
0764E:  MOVWF  x31
07650:  MOVLB  0
07652:  CALL   515C
07656:  MOVF   01,W
07658:  ADDLW  42
0765A:  MOVLB  6
0765C:  MOVWF  x00
0765E:  MOVLW  04
07660:  ADDWFC 02,W
07662:  MOVWF  x01
07664:  MOVLW  01
07666:  MOVLB  5
07668:  SUBWF  xFB,W
0766A:  MULLW  18
0766C:  MOVF   FF3,W
0766E:  MOVLB  6
07670:  CLRF   x03
07672:  MOVWF  x02
07674:  MOVLW  0C
07676:  ADDWF  x02,W
07678:  MOVWF  01
0767A:  MOVLW  00
0767C:  ADDWFC x03,W
0767E:  MOVWF  03
07680:  MOVF   01,W
07682:  ADDLW  82
07684:  MOVWF  FE9
07686:  MOVLW  00
07688:  ADDWFC 03,W
0768A:  MOVWF  FEA
0768C:  MOVFF  FEF,602
07690:  MOVFF  FEC,603
07694:  MOVFF  FEC,604
07698:  MOVFF  FEC,605
0769C:  MOVFF  601,4E7
076A0:  MOVFF  600,4E6
076A4:  MOVFF  5FB,629
076A8:  MOVLW  18
076AA:  MOVWF  x2A
076AC:  MOVLB  0
076AE:  CALL   5718
076B2:  MOVLW  2C
076B4:  MOVLB  6
076B6:  MOVWF  x40
076B8:  MOVLB  0
076BA:  CALL   520C
076BE:  MOVLW  89
076C0:  MOVWF  FE9
076C2:  MOVFF  605,636
076C6:  MOVFF  604,635
076CA:  MOVFF  603,634
076CE:  MOVFF  602,633
076D2:  MOVLW  02
076D4:  MOVLB  6
076D6:  MOVWF  x37
076D8:  MOVLB  0
076DA:  CALL   5F50
076DE:  MOVLW  2C
076E0:  MOVLB  6
076E2:  MOVWF  x40
076E4:  MOVLB  0
076E6:  CALL   520C
076EA:  BRA    7852
076EC:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c4);
076EE:  MOVF   xFC,W
076F0:  SUBLW  34
076F2:  BNZ   779C
076F4:  MOVLW  04
076F6:  MOVLB  6
076F8:  MOVWF  x32
076FA:  MOVLW  42
076FC:  MOVWF  x31
076FE:  MOVLB  0
07700:  CALL   515C
07704:  MOVF   01,W
07706:  ADDLW  42
07708:  MOVLB  6
0770A:  MOVWF  x00
0770C:  MOVLW  04
0770E:  ADDWFC 02,W
07710:  MOVWF  x01
07712:  MOVLW  01
07714:  MOVLB  5
07716:  SUBWF  xFB,W
07718:  MULLW  18
0771A:  MOVF   FF3,W
0771C:  MOVLB  6
0771E:  CLRF   x03
07720:  MOVWF  x02
07722:  MOVLW  10
07724:  ADDWF  x02,W
07726:  MOVWF  01
07728:  MOVLW  00
0772A:  ADDWFC x03,W
0772C:  MOVWF  03
0772E:  MOVF   01,W
07730:  ADDLW  82
07732:  MOVWF  FE9
07734:  MOVLW  00
07736:  ADDWFC 03,W
07738:  MOVWF  FEA
0773A:  MOVFF  FEF,602
0773E:  MOVFF  FEC,603
07742:  MOVFF  FEC,604
07746:  MOVFF  FEC,605
0774A:  MOVFF  601,4E7
0774E:  MOVFF  600,4E6
07752:  MOVFF  5FB,629
07756:  MOVLW  18
07758:  MOVWF  x2A
0775A:  MOVLB  0
0775C:  CALL   5718
07760:  MOVLW  2C
07762:  MOVLB  6
07764:  MOVWF  x40
07766:  MOVLB  0
07768:  CALL   520C
0776C:  MOVLW  89
0776E:  MOVWF  FE9
07770:  MOVFF  605,636
07774:  MOVFF  604,635
07778:  MOVFF  603,634
0777C:  MOVFF  602,633
07780:  MOVLW  02
07782:  MOVLB  6
07784:  MOVWF  x37
07786:  MOVLB  0
07788:  CALL   5F50
0778C:  MOVLW  2C
0778E:  MOVLB  6
07790:  MOVWF  x40
07792:  MOVLB  0
07794:  CALL   520C
07798:  BRA    7852
0779A:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%d,%f,", arg1, sensorCal[arg1-1].c5);
0779C:  MOVF   xFC,W
0779E:  SUBLW  35
077A0:  BNZ   784A
077A2:  MOVLW  04
077A4:  MOVLB  6
077A6:  MOVWF  x32
077A8:  MOVLW  42
077AA:  MOVWF  x31
077AC:  MOVLB  0
077AE:  CALL   515C
077B2:  MOVF   01,W
077B4:  ADDLW  42
077B6:  MOVLB  6
077B8:  MOVWF  x00
077BA:  MOVLW  04
077BC:  ADDWFC 02,W
077BE:  MOVWF  x01
077C0:  MOVLW  01
077C2:  MOVLB  5
077C4:  SUBWF  xFB,W
077C6:  MULLW  18
077C8:  MOVF   FF3,W
077CA:  MOVLB  6
077CC:  CLRF   x03
077CE:  MOVWF  x02
077D0:  MOVLW  14
077D2:  ADDWF  x02,W
077D4:  MOVWF  01
077D6:  MOVLW  00
077D8:  ADDWFC x03,W
077DA:  MOVWF  03
077DC:  MOVF   01,W
077DE:  ADDLW  82
077E0:  MOVWF  FE9
077E2:  MOVLW  00
077E4:  ADDWFC 03,W
077E6:  MOVWF  FEA
077E8:  MOVFF  FEF,602
077EC:  MOVFF  FEC,603
077F0:  MOVFF  FEC,604
077F4:  MOVFF  FEC,605
077F8:  MOVFF  601,4E7
077FC:  MOVFF  600,4E6
07800:  MOVFF  5FB,629
07804:  MOVLW  18
07806:  MOVWF  x2A
07808:  MOVLB  0
0780A:  CALL   5718
0780E:  MOVLW  2C
07810:  MOVLB  6
07812:  MOVWF  x40
07814:  MOVLB  0
07816:  CALL   520C
0781A:  MOVLW  89
0781C:  MOVWF  FE9
0781E:  MOVFF  605,636
07822:  MOVFF  604,635
07826:  MOVFF  603,634
0782A:  MOVFF  602,633
0782E:  MOVLW  02
07830:  MOVLB  6
07832:  MOVWF  x37
07834:  MOVLB  0
07836:  CALL   5F50
0783A:  MOVLW  2C
0783C:  MOVLB  6
0783E:  MOVWF  x40
07840:  MOVLB  0
07842:  CALL   520C
07846:  BRA    7852
07848:  MOVLB  5
....................    else return INV_PARAM;
0784A:  MOVLW  02
0784C:  MOVWF  01
0784E:  MOVLB  0
07850:  BRA    7856
....................    
....................    return SUCCESS;
07852:  MOVLW  00
07854:  MOVWF  01
07856:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
07858:  MOVLB  6
0785A:  CLRF   x32
0785C:  MOVFF  5EF,631
07860:  CLRF   x34
07862:  MOVLW  B5
07864:  MOVWF  x33
07866:  MOVLB  0
07868:  CALL   08AC
0786C:  MOVFF  02,602
07870:  MOVFF  01,601
07874:  MOVLW  06
07876:  MOVLB  6
07878:  ADDWF  x01,F
0787A:  MOVLW  00
0787C:  ADDWFC x02,F
0787E:  MOVLW  32
07880:  ADDWF  x01,W
07882:  MOVWF  01
07884:  MOVLW  00
07886:  ADDWFC x02,W
07888:  MOVWF  03
0788A:  MOVF   01,W
0788C:  ADDLW  6C
0788E:  MOVWF  01
07890:  MOVLW  01
07892:  ADDWFC 03,F
07894:  MOVFF  01,601
07898:  MOVFF  03,602
0789C:  MOVFF  03,629
078A0:  MOVFF  01,628
078A4:  MOVLB  0
078A6:  CALL   52D4
078AA:  MOVF   01,F
078AC:  BNZ   78B6
078AE:  MOVLW  02
078B0:  MOVWF  01
078B2:  BRA    7C06
078B4:  BRA    7914
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
078B6:  MOVLB  6
078B8:  CLRF   x32
078BA:  MOVFF  5EF,631
078BE:  CLRF   x34
078C0:  MOVLW  B5
078C2:  MOVWF  x33
078C4:  MOVLB  0
078C6:  CALL   08AC
078CA:  MOVFF  02,602
078CE:  MOVFF  01,601
078D2:  MOVLW  06
078D4:  MOVLB  6
078D6:  ADDWF  x01,F
078D8:  MOVLW  00
078DA:  ADDWFC x02,F
078DC:  MOVLW  32
078DE:  ADDWF  x01,W
078E0:  MOVWF  01
078E2:  MOVLW  00
078E4:  ADDWFC x02,W
078E6:  MOVWF  03
078E8:  MOVF   01,W
078EA:  ADDLW  6C
078EC:  MOVWF  01
078EE:  MOVLW  01
078F0:  ADDWFC 03,F
078F2:  MOVFF  01,601
078F6:  MOVFF  03,602
078FA:  MOVFF  03,629
078FE:  MOVFF  01,628
07902:  CLRF   x2B
07904:  CLRF   x2A
07906:  MOVLW  0A
07908:  MOVWF  x2C
0790A:  MOVLB  0
0790C:  CALL   53C4
07910:  MOVFF  01,5FB
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
07914:  MOVLB  6
07916:  CLRF   x32
07918:  MOVFF  5EF,631
0791C:  CLRF   x34
0791E:  MOVLW  B5
07920:  MOVWF  x33
07922:  MOVLB  0
07924:  CALL   08AC
07928:  MOVFF  02,602
0792C:  MOVFF  01,601
07930:  MOVLW  06
07932:  MOVLB  6
07934:  ADDWF  x01,F
07936:  MOVLW  00
07938:  ADDWFC x02,F
0793A:  MOVLW  4B
0793C:  ADDWF  x01,W
0793E:  MOVWF  01
07940:  MOVLW  00
07942:  ADDWFC x02,W
07944:  MOVWF  03
07946:  MOVF   01,W
07948:  ADDLW  6C
0794A:  MOVWF  01
0794C:  MOVLW  01
0794E:  ADDWFC 03,F
07950:  MOVFF  01,601
07954:  MOVFF  03,602
07958:  MOVFF  03,632
0795C:  MOVFF  01,631
07960:  MOVLB  0
07962:  CALL   515C
07966:  MOVFF  02,03
0796A:  MOVF   01,W
0796C:  SUBLW  01
0796E:  BNZ   7974
07970:  MOVF   03,F
07972:  BZ    797C
07974:  MOVLW  02
07976:  MOVWF  01
07978:  BRA    7C06
0797A:  BRA    79BC
....................    else arg2 = SERcmd[rec].p[3][0];
0797C:  MOVLB  6
0797E:  CLRF   x32
07980:  MOVFF  5EF,631
07984:  CLRF   x34
07986:  MOVLW  B5
07988:  MOVWF  x33
0798A:  MOVLB  0
0798C:  CALL   08AC
07990:  MOVFF  02,602
07994:  MOVFF  01,601
07998:  MOVLW  06
0799A:  MOVLB  6
0799C:  ADDWF  x01,F
0799E:  MOVLW  00
079A0:  ADDWFC x02,F
079A2:  MOVLW  4B
079A4:  ADDWF  x01,F
079A6:  MOVLW  00
079A8:  ADDWFC x02,F
079AA:  MOVLW  6C
079AC:  ADDWF  x01,W
079AE:  MOVWF  FE9
079B0:  MOVLW  01
079B2:  ADDWFC x02,W
079B4:  MOVWF  FEA
079B6:  MOVFF  FEF,5FC
079BA:  MOVLB  0
....................    
....................    if (!arg_is_float(SERcmd[rec].p[4])) return INV_PARAM;
079BC:  MOVLB  6
079BE:  CLRF   x32
079C0:  MOVFF  5EF,631
079C4:  CLRF   x34
079C6:  MOVLW  B5
079C8:  MOVWF  x33
079CA:  MOVLB  0
079CC:  CALL   08AC
079D0:  MOVFF  02,602
079D4:  MOVFF  01,601
079D8:  MOVLW  06
079DA:  MOVLB  6
079DC:  ADDWF  x01,F
079DE:  MOVLW  00
079E0:  ADDWFC x02,F
079E2:  MOVLW  64
079E4:  ADDWF  x01,W
079E6:  MOVWF  01
079E8:  MOVLW  00
079EA:  ADDWFC x02,W
079EC:  MOVWF  03
079EE:  MOVF   01,W
079F0:  ADDLW  6C
079F2:  MOVWF  01
079F4:  MOVLW  01
079F6:  ADDWFC 03,F
079F8:  MOVFF  01,601
079FC:  MOVFF  03,602
07A00:  MOVFF  03,605
07A04:  MOVFF  01,604
07A08:  MOVLB  0
07A0A:  CALL   65DC
07A0E:  MOVF   01,F
07A10:  BNZ   7A1A
07A12:  MOVLW  02
07A14:  MOVWF  01
07A16:  BRA    7C06
07A18:  BRA    7A80
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
07A1A:  MOVLB  6
07A1C:  CLRF   x32
07A1E:  MOVFF  5EF,631
07A22:  CLRF   x34
07A24:  MOVLW  B5
07A26:  MOVWF  x33
07A28:  MOVLB  0
07A2A:  CALL   08AC
07A2E:  MOVFF  02,602
07A32:  MOVFF  01,601
07A36:  MOVLW  06
07A38:  MOVLB  6
07A3A:  ADDWF  x01,F
07A3C:  MOVLW  00
07A3E:  ADDWFC x02,F
07A40:  MOVLW  64
07A42:  ADDWF  x01,W
07A44:  MOVWF  01
07A46:  MOVLW  00
07A48:  ADDWFC x02,W
07A4A:  MOVWF  03
07A4C:  MOVF   01,W
07A4E:  ADDLW  6C
07A50:  MOVWF  01
07A52:  MOVLW  01
07A54:  ADDWFC 03,F
07A56:  MOVFF  01,601
07A5A:  MOVFF  03,602
07A5E:  MOVFF  03,605
07A62:  MOVFF  01,604
07A66:  CLRF   x07
07A68:  CLRF   x06
07A6A:  MOVLB  0
07A6C:  CALL   669E
07A70:  MOVFF  03,600
07A74:  MOVFF  02,5FF
07A78:  MOVFF  01,5FE
07A7C:  MOVFF  00,5FD
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
07A80:  MOVLB  5
07A82:  MOVF   xFC,W
07A84:  SUBLW  30
07A86:  BNZ   7AB6
07A88:  MOVLW  01
07A8A:  SUBWF  xFB,W
07A8C:  MULLW  18
07A8E:  MOVF   FF3,W
07A90:  MOVLB  6
07A92:  CLRF   x02
07A94:  MOVWF  x01
07A96:  MOVLW  82
07A98:  ADDWF  x01,W
07A9A:  MOVWF  FE9
07A9C:  MOVLW  00
07A9E:  ADDWFC x02,W
07AA0:  MOVWF  FEA
07AA2:  MOVFF  5FD,FEF
07AA6:  MOVFF  5FE,FEC
07AAA:  MOVFF  5FF,FEC
07AAE:  MOVFF  600,FEC
07AB2:  BRA    7C00
07AB4:  MOVLB  5
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
07AB6:  MOVF   xFC,W
07AB8:  SUBLW  31
07ABA:  BNZ   7AF6
07ABC:  MOVLW  01
07ABE:  SUBWF  xFB,W
07AC0:  MULLW  18
07AC2:  MOVF   FF3,W
07AC4:  MOVLB  6
07AC6:  CLRF   x02
07AC8:  MOVWF  x01
07ACA:  MOVLW  04
07ACC:  ADDWF  x01,W
07ACE:  MOVWF  01
07AD0:  MOVLW  00
07AD2:  ADDWFC x02,W
07AD4:  MOVWF  03
07AD6:  MOVF   01,W
07AD8:  ADDLW  82
07ADA:  MOVWF  FE9
07ADC:  MOVLW  00
07ADE:  ADDWFC 03,W
07AE0:  MOVWF  FEA
07AE2:  MOVFF  5FD,FEF
07AE6:  MOVFF  5FE,FEC
07AEA:  MOVFF  5FF,FEC
07AEE:  MOVFF  600,FEC
07AF2:  BRA    7C00
07AF4:  MOVLB  5
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
07AF6:  MOVF   xFC,W
07AF8:  SUBLW  32
07AFA:  BNZ   7B36
07AFC:  MOVLW  01
07AFE:  SUBWF  xFB,W
07B00:  MULLW  18
07B02:  MOVF   FF3,W
07B04:  MOVLB  6
07B06:  CLRF   x02
07B08:  MOVWF  x01
07B0A:  MOVLW  08
07B0C:  ADDWF  x01,W
07B0E:  MOVWF  01
07B10:  MOVLW  00
07B12:  ADDWFC x02,W
07B14:  MOVWF  03
07B16:  MOVF   01,W
07B18:  ADDLW  82
07B1A:  MOVWF  FE9
07B1C:  MOVLW  00
07B1E:  ADDWFC 03,W
07B20:  MOVWF  FEA
07B22:  MOVFF  5FD,FEF
07B26:  MOVFF  5FE,FEC
07B2A:  MOVFF  5FF,FEC
07B2E:  MOVFF  600,FEC
07B32:  BRA    7C00
07B34:  MOVLB  5
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
07B36:  MOVF   xFC,W
07B38:  SUBLW  33
07B3A:  BNZ   7B76
07B3C:  MOVLW  01
07B3E:  SUBWF  xFB,W
07B40:  MULLW  18
07B42:  MOVF   FF3,W
07B44:  MOVLB  6
07B46:  CLRF   x02
07B48:  MOVWF  x01
07B4A:  MOVLW  0C
07B4C:  ADDWF  x01,W
07B4E:  MOVWF  01
07B50:  MOVLW  00
07B52:  ADDWFC x02,W
07B54:  MOVWF  03
07B56:  MOVF   01,W
07B58:  ADDLW  82
07B5A:  MOVWF  FE9
07B5C:  MOVLW  00
07B5E:  ADDWFC 03,W
07B60:  MOVWF  FEA
07B62:  MOVFF  5FD,FEF
07B66:  MOVFF  5FE,FEC
07B6A:  MOVFF  5FF,FEC
07B6E:  MOVFF  600,FEC
07B72:  BRA    7C00
07B74:  MOVLB  5
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
07B76:  MOVF   xFC,W
07B78:  SUBLW  34
07B7A:  BNZ   7BB6
07B7C:  MOVLW  01
07B7E:  SUBWF  xFB,W
07B80:  MULLW  18
07B82:  MOVF   FF3,W
07B84:  MOVLB  6
07B86:  CLRF   x02
07B88:  MOVWF  x01
07B8A:  MOVLW  10
07B8C:  ADDWF  x01,W
07B8E:  MOVWF  01
07B90:  MOVLW  00
07B92:  ADDWFC x02,W
07B94:  MOVWF  03
07B96:  MOVF   01,W
07B98:  ADDLW  82
07B9A:  MOVWF  FE9
07B9C:  MOVLW  00
07B9E:  ADDWFC 03,W
07BA0:  MOVWF  FEA
07BA2:  MOVFF  5FD,FEF
07BA6:  MOVFF  5FE,FEC
07BAA:  MOVFF  5FF,FEC
07BAE:  MOVFF  600,FEC
07BB2:  BRA    7C00
07BB4:  MOVLB  5
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
07BB6:  MOVF   xFC,W
07BB8:  SUBLW  35
07BBA:  BNZ   7BF6
07BBC:  MOVLW  01
07BBE:  SUBWF  xFB,W
07BC0:  MULLW  18
07BC2:  MOVF   FF3,W
07BC4:  MOVLB  6
07BC6:  CLRF   x02
07BC8:  MOVWF  x01
07BCA:  MOVLW  14
07BCC:  ADDWF  x01,W
07BCE:  MOVWF  01
07BD0:  MOVLW  00
07BD2:  ADDWFC x02,W
07BD4:  MOVWF  03
07BD6:  MOVF   01,W
07BD8:  ADDLW  82
07BDA:  MOVWF  FE9
07BDC:  MOVLW  00
07BDE:  ADDWFC 03,W
07BE0:  MOVWF  FEA
07BE2:  MOVFF  5FD,FEF
07BE6:  MOVFF  5FE,FEC
07BEA:  MOVFF  5FF,FEC
07BEE:  MOVFF  600,FEC
07BF2:  BRA    7C00
07BF4:  MOVLB  5
....................    else return INV_PARAM;
07BF6:  MOVLW  02
07BF8:  MOVWF  01
07BFA:  MOVLB  0
07BFC:  BRA    7C06
07BFE:  MOVLB  6
....................    
....................    return SUCCESS;
07C00:  MOVLW  00
07C02:  MOVWF  01
07C04:  MOVLB  0
07C06:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
07C08:  MOVLW  4E
07C0A:  MOVLB  5
07C0C:  MOVWF  xFF
07C0E:  MOVLW  31
07C10:  MOVLB  6
07C12:  MOVWF  x00
07C14:  MOVLW  35
07C16:  MOVWF  x01
07C18:  CLRF   x02
07C1A:  MOVLW  05
07C1C:  MOVLB  5
07C1E:  MOVWF  xFE
07C20:  SETF   xFD
....................    char *s_200 = "200";
07C22:  MOVLW  32
07C24:  MOVLB  6
07C26:  MOVWF  x05
07C28:  MOVLW  30
07C2A:  MOVWF  x06
07C2C:  MOVWF  x07
07C2E:  CLRF   x08
07C30:  MOVLW  06
07C32:  MOVWF  x04
07C34:  MOVLW  05
07C36:  MOVWF  x03
....................    char *s_5V6 = "5V6";
07C38:  MOVLW  35
07C3A:  MOVWF  x0B
07C3C:  MOVLW  56
07C3E:  MOVWF  x0C
07C40:  MOVLW  36
07C42:  MOVWF  x0D
07C44:  CLRF   x0E
07C46:  MOVLW  06
07C48:  MOVWF  x0A
07C4A:  MOVLW  0B
07C4C:  MOVWF  x09
....................    char *s_5VA = "5VA";
07C4E:  MOVLW  35
07C50:  MOVWF  x11
07C52:  MOVLW  56
07C54:  MOVWF  x12
07C56:  MOVLW  41
07C58:  MOVWF  x13
07C5A:  CLRF   x14
07C5C:  MOVLW  06
07C5E:  MOVWF  x10
07C60:  MOVLW  11
07C62:  MOVWF  x0F
....................    char *s_3V6X = "3V6X";
07C64:  MOVLW  33
07C66:  MOVWF  x17
07C68:  MOVLW  56
07C6A:  MOVWF  x18
07C6C:  MOVLW  36
07C6E:  MOVWF  x19
07C70:  MOVLW  58
07C72:  MOVWF  x1A
07C74:  CLRF   x1B
07C76:  MOVLW  06
07C78:  MOVWF  x16
07C7A:  MOVLW  17
07C7C:  MOVWF  x15
....................    char *s_3V3A = "3V3A";
07C7E:  MOVLW  33
07C80:  MOVWF  x1E
07C82:  MOVLW  56
07C84:  MOVWF  x1F
07C86:  MOVLW  33
07C88:  MOVWF  x20
07C8A:  MOVLW  41
07C8C:  MOVWF  x21
07C8E:  CLRF   x22
07C90:  MOVLW  06
07C92:  MOVWF  x1D
07C94:  MOVLW  1E
07C96:  MOVWF  x1C
....................    char *s_3V3D = "3V3D";
07C98:  MOVLW  33
07C9A:  MOVWF  x25
07C9C:  MOVLW  56
07C9E:  MOVWF  x26
07CA0:  MOVLW  33
07CA2:  MOVWF  x27
07CA4:  MOVLW  44
07CA6:  MOVWF  x28
07CA8:  CLRF   x29
07CAA:  MOVLW  06
07CAC:  MOVWF  x24
07CAE:  MOVLW  25
07CB0:  MOVWF  x23
.................... //!   char *s_all = "all";
....................    
....................    arg1 = SERcmd[rec].p[2];
07CB2:  CLRF   x32
07CB4:  MOVFF  5EF,631
07CB8:  CLRF   x34
07CBA:  MOVLW  B5
07CBC:  MOVWF  x33
07CBE:  MOVLB  0
07CC0:  CALL   08AC
07CC4:  MOVFF  02,62B
07CC8:  MOVFF  01,62A
07CCC:  MOVLW  06
07CCE:  MOVLB  6
07CD0:  ADDWF  x2A,F
07CD2:  MOVLW  00
07CD4:  ADDWFC x2B,F
07CD6:  MOVLW  32
07CD8:  ADDWF  x2A,W
07CDA:  MOVWF  01
07CDC:  MOVLW  00
07CDE:  ADDWFC x2B,W
07CE0:  MOVWF  03
07CE2:  MOVF   01,W
07CE4:  ADDLW  6C
07CE6:  MOVWF  01
07CE8:  MOVLW  01
07CEA:  ADDWFC 03,F
07CEC:  MOVFF  01,5FB
07CF0:  MOVLB  5
07CF2:  MOVFF  03,5FC
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
07CF6:  MOVFF  5FE,632
07CFA:  MOVFF  5FD,631
07CFE:  MOVFF  5FC,634
07D02:  MOVFF  5FB,633
07D06:  MOVLB  0
07D08:  CALL   5194
07D0C:  MOVF   01,F
07D0E:  BNZ   7D92
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
07D10:  MOVLW  04
07D12:  MOVLB  6
07D14:  MOVWF  x32
07D16:  MOVLW  42
07D18:  MOVWF  x31
07D1A:  MOVLB  0
07D1C:  CALL   515C
07D20:  MOVFF  02,03
07D24:  MOVF   01,W
07D26:  ADDLW  42
07D28:  MOVLB  6
07D2A:  MOVWF  x2A
07D2C:  MOVLW  04
07D2E:  ADDWFC 02,W
07D30:  MOVWF  x2B
07D32:  MOVFF  FE8,4E7
07D36:  MOVFF  62A,4E6
07D3A:  MOVLW  89
07D3C:  MOVWF  FE9
07D3E:  MOVFF  B5,636
07D42:  MOVFF  B4,635
07D46:  MOVFF  B3,634
07D4A:  MOVFF  B2,633
07D4E:  MOVLW  02
07D50:  MOVWF  x37
07D52:  MOVLB  0
07D54:  CALL   5F50
07D58:  MOVLW  2C
07D5A:  MOVLB  6
07D5C:  MOVWF  x40
07D5E:  MOVLB  0
07D60:  CALL   520C
07D64:  MOVLW  89
07D66:  MOVWF  FE9
07D68:  MOVFF  B9,636
07D6C:  MOVFF  B8,635
07D70:  MOVFF  B7,634
07D74:  MOVFF  B6,633
07D78:  MOVLW  02
07D7A:  MOVLB  6
07D7C:  MOVWF  x37
07D7E:  MOVLB  0
07D80:  CALL   5F50
07D84:  MOVLW  2C
07D86:  MOVLB  6
07D88:  MOVWF  x40
07D8A:  MOVLB  0
07D8C:  CALL   520C
....................    }
07D90:  BRA    8134
....................    else if (0 == strcmp(s_200, arg1)) {
07D92:  MOVFF  604,632
07D96:  MOVFF  603,631
07D9A:  MOVFF  5FC,634
07D9E:  MOVFF  5FB,633
07DA2:  CALL   5194
07DA6:  MOVF   01,F
07DA8:  BNZ   7E2C
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
07DAA:  MOVLW  04
07DAC:  MOVLB  6
07DAE:  MOVWF  x32
07DB0:  MOVLW  42
07DB2:  MOVWF  x31
07DB4:  MOVLB  0
07DB6:  CALL   515C
07DBA:  MOVFF  02,03
07DBE:  MOVF   01,W
07DC0:  ADDLW  42
07DC2:  MOVLB  6
07DC4:  MOVWF  x2A
07DC6:  MOVLW  04
07DC8:  ADDWFC 02,W
07DCA:  MOVWF  x2B
07DCC:  MOVFF  FE8,4E7
07DD0:  MOVFF  62A,4E6
07DD4:  MOVLW  89
07DD6:  MOVWF  FE9
07DD8:  MOVFF  BD,636
07DDC:  MOVFF  BC,635
07DE0:  MOVFF  BB,634
07DE4:  MOVFF  BA,633
07DE8:  MOVLW  02
07DEA:  MOVWF  x37
07DEC:  MOVLB  0
07DEE:  CALL   5F50
07DF2:  MOVLW  2C
07DF4:  MOVLB  6
07DF6:  MOVWF  x40
07DF8:  MOVLB  0
07DFA:  CALL   520C
07DFE:  MOVLW  89
07E00:  MOVWF  FE9
07E02:  MOVFF  C1,636
07E06:  MOVFF  C0,635
07E0A:  MOVFF  BF,634
07E0E:  MOVFF  BE,633
07E12:  MOVLW  02
07E14:  MOVLB  6
07E16:  MOVWF  x37
07E18:  MOVLB  0
07E1A:  CALL   5F50
07E1E:  MOVLW  2C
07E20:  MOVLB  6
07E22:  MOVWF  x40
07E24:  MOVLB  0
07E26:  CALL   520C
....................    }
07E2A:  BRA    8134
....................    else if (0 == strcmp(s_5V6, arg1)) {
07E2C:  MOVFF  60A,632
07E30:  MOVFF  609,631
07E34:  MOVFF  5FC,634
07E38:  MOVFF  5FB,633
07E3C:  CALL   5194
07E40:  MOVF   01,F
07E42:  BNZ   7EC6
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
07E44:  MOVLW  04
07E46:  MOVLB  6
07E48:  MOVWF  x32
07E4A:  MOVLW  42
07E4C:  MOVWF  x31
07E4E:  MOVLB  0
07E50:  CALL   515C
07E54:  MOVFF  02,03
07E58:  MOVF   01,W
07E5A:  ADDLW  42
07E5C:  MOVLB  6
07E5E:  MOVWF  x2A
07E60:  MOVLW  04
07E62:  ADDWFC 02,W
07E64:  MOVWF  x2B
07E66:  MOVFF  FE8,4E7
07E6A:  MOVFF  62A,4E6
07E6E:  MOVLW  89
07E70:  MOVWF  FE9
07E72:  MOVFF  C5,636
07E76:  MOVFF  C4,635
07E7A:  MOVFF  C3,634
07E7E:  MOVFF  C2,633
07E82:  MOVLW  02
07E84:  MOVWF  x37
07E86:  MOVLB  0
07E88:  CALL   5F50
07E8C:  MOVLW  2C
07E8E:  MOVLB  6
07E90:  MOVWF  x40
07E92:  MOVLB  0
07E94:  CALL   520C
07E98:  MOVLW  89
07E9A:  MOVWF  FE9
07E9C:  MOVFF  C9,636
07EA0:  MOVFF  C8,635
07EA4:  MOVFF  C7,634
07EA8:  MOVFF  C6,633
07EAC:  MOVLW  02
07EAE:  MOVLB  6
07EB0:  MOVWF  x37
07EB2:  MOVLB  0
07EB4:  CALL   5F50
07EB8:  MOVLW  2C
07EBA:  MOVLB  6
07EBC:  MOVWF  x40
07EBE:  MOVLB  0
07EC0:  CALL   520C
....................    }
07EC4:  BRA    8134
....................    else if (0 == strcmp(s_5VA, arg1)) {
07EC6:  MOVFF  610,632
07ECA:  MOVFF  60F,631
07ECE:  MOVFF  5FC,634
07ED2:  MOVFF  5FB,633
07ED6:  CALL   5194
07EDA:  MOVF   01,F
07EDC:  BNZ   7F60
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
07EDE:  MOVLW  04
07EE0:  MOVLB  6
07EE2:  MOVWF  x32
07EE4:  MOVLW  42
07EE6:  MOVWF  x31
07EE8:  MOVLB  0
07EEA:  CALL   515C
07EEE:  MOVFF  02,03
07EF2:  MOVF   01,W
07EF4:  ADDLW  42
07EF6:  MOVLB  6
07EF8:  MOVWF  x2A
07EFA:  MOVLW  04
07EFC:  ADDWFC 02,W
07EFE:  MOVWF  x2B
07F00:  MOVFF  FE8,4E7
07F04:  MOVFF  62A,4E6
07F08:  MOVLW  89
07F0A:  MOVWF  FE9
07F0C:  MOVFF  CD,636
07F10:  MOVFF  CC,635
07F14:  MOVFF  CB,634
07F18:  MOVFF  CA,633
07F1C:  MOVLW  02
07F1E:  MOVWF  x37
07F20:  MOVLB  0
07F22:  CALL   5F50
07F26:  MOVLW  2C
07F28:  MOVLB  6
07F2A:  MOVWF  x40
07F2C:  MOVLB  0
07F2E:  CALL   520C
07F32:  MOVLW  89
07F34:  MOVWF  FE9
07F36:  MOVFF  D1,636
07F3A:  MOVFF  D0,635
07F3E:  MOVFF  CF,634
07F42:  MOVFF  CE,633
07F46:  MOVLW  02
07F48:  MOVLB  6
07F4A:  MOVWF  x37
07F4C:  MOVLB  0
07F4E:  CALL   5F50
07F52:  MOVLW  2C
07F54:  MOVLB  6
07F56:  MOVWF  x40
07F58:  MOVLB  0
07F5A:  CALL   520C
....................    }
07F5E:  BRA    8134
....................    else if (0 == strcmp(s_3V6X, arg1)) {
07F60:  MOVFF  616,632
07F64:  MOVFF  615,631
07F68:  MOVFF  5FC,634
07F6C:  MOVFF  5FB,633
07F70:  CALL   5194
07F74:  MOVF   01,F
07F76:  BNZ   7FFA
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
07F78:  MOVLW  04
07F7A:  MOVLB  6
07F7C:  MOVWF  x32
07F7E:  MOVLW  42
07F80:  MOVWF  x31
07F82:  MOVLB  0
07F84:  CALL   515C
07F88:  MOVFF  02,03
07F8C:  MOVF   01,W
07F8E:  ADDLW  42
07F90:  MOVLB  6
07F92:  MOVWF  x2A
07F94:  MOVLW  04
07F96:  ADDWFC 02,W
07F98:  MOVWF  x2B
07F9A:  MOVFF  FE8,4E7
07F9E:  MOVFF  62A,4E6
07FA2:  MOVLW  89
07FA4:  MOVWF  FE9
07FA6:  MOVFF  D5,636
07FAA:  MOVFF  D4,635
07FAE:  MOVFF  D3,634
07FB2:  MOVFF  D2,633
07FB6:  MOVLW  02
07FB8:  MOVWF  x37
07FBA:  MOVLB  0
07FBC:  CALL   5F50
07FC0:  MOVLW  2C
07FC2:  MOVLB  6
07FC4:  MOVWF  x40
07FC6:  MOVLB  0
07FC8:  CALL   520C
07FCC:  MOVLW  89
07FCE:  MOVWF  FE9
07FD0:  MOVFF  D9,636
07FD4:  MOVFF  D8,635
07FD8:  MOVFF  D7,634
07FDC:  MOVFF  D6,633
07FE0:  MOVLW  02
07FE2:  MOVLB  6
07FE4:  MOVWF  x37
07FE6:  MOVLB  0
07FE8:  CALL   5F50
07FEC:  MOVLW  2C
07FEE:  MOVLB  6
07FF0:  MOVWF  x40
07FF2:  MOVLB  0
07FF4:  CALL   520C
....................    }
07FF8:  BRA    8134
....................    else if (0 == strcmp(s_3V3A, arg1)) {
07FFA:  MOVFF  61D,632
07FFE:  MOVFF  61C,631
08002:  MOVFF  5FC,634
08006:  MOVFF  5FB,633
0800A:  CALL   5194
0800E:  MOVF   01,F
08010:  BNZ   8094
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
08012:  MOVLW  04
08014:  MOVLB  6
08016:  MOVWF  x32
08018:  MOVLW  42
0801A:  MOVWF  x31
0801C:  MOVLB  0
0801E:  CALL   515C
08022:  MOVFF  02,03
08026:  MOVF   01,W
08028:  ADDLW  42
0802A:  MOVLB  6
0802C:  MOVWF  x2A
0802E:  MOVLW  04
08030:  ADDWFC 02,W
08032:  MOVWF  x2B
08034:  MOVFF  FE8,4E7
08038:  MOVFF  62A,4E6
0803C:  MOVLW  89
0803E:  MOVWF  FE9
08040:  MOVFF  DD,636
08044:  MOVFF  DC,635
08048:  MOVFF  DB,634
0804C:  MOVFF  DA,633
08050:  MOVLW  02
08052:  MOVWF  x37
08054:  MOVLB  0
08056:  CALL   5F50
0805A:  MOVLW  2C
0805C:  MOVLB  6
0805E:  MOVWF  x40
08060:  MOVLB  0
08062:  CALL   520C
08066:  MOVLW  89
08068:  MOVWF  FE9
0806A:  MOVFF  E1,636
0806E:  MOVFF  E0,635
08072:  MOVFF  DF,634
08076:  MOVFF  DE,633
0807A:  MOVLW  02
0807C:  MOVLB  6
0807E:  MOVWF  x37
08080:  MOVLB  0
08082:  CALL   5F50
08086:  MOVLW  2C
08088:  MOVLB  6
0808A:  MOVWF  x40
0808C:  MOVLB  0
0808E:  CALL   520C
....................    }
08092:  BRA    8134
....................    else if (0 == strcmp(s_3V3D, arg1)) {
08094:  MOVFF  624,632
08098:  MOVFF  623,631
0809C:  MOVFF  5FC,634
080A0:  MOVFF  5FB,633
080A4:  CALL   5194
080A8:  MOVF   01,F
080AA:  BNZ   812E
....................       sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
080AC:  MOVLW  04
080AE:  MOVLB  6
080B0:  MOVWF  x32
080B2:  MOVLW  42
080B4:  MOVWF  x31
080B6:  MOVLB  0
080B8:  CALL   515C
080BC:  MOVFF  02,03
080C0:  MOVF   01,W
080C2:  ADDLW  42
080C4:  MOVLB  6
080C6:  MOVWF  x2A
080C8:  MOVLW  04
080CA:  ADDWFC 02,W
080CC:  MOVWF  x2B
080CE:  MOVFF  FE8,4E7
080D2:  MOVFF  62A,4E6
080D6:  MOVLW  89
080D8:  MOVWF  FE9
080DA:  MOVFF  E5,636
080DE:  MOVFF  E4,635
080E2:  MOVFF  E3,634
080E6:  MOVFF  E2,633
080EA:  MOVLW  02
080EC:  MOVWF  x37
080EE:  MOVLB  0
080F0:  CALL   5F50
080F4:  MOVLW  2C
080F6:  MOVLB  6
080F8:  MOVWF  x40
080FA:  MOVLB  0
080FC:  CALL   520C
08100:  MOVLW  89
08102:  MOVWF  FE9
08104:  MOVFF  E9,636
08108:  MOVFF  E8,635
0810C:  MOVFF  E7,634
08110:  MOVFF  E6,633
08114:  MOVLW  02
08116:  MOVLB  6
08118:  MOVWF  x37
0811A:  MOVLB  0
0811C:  CALL   5F50
08120:  MOVLW  2C
08122:  MOVLB  6
08124:  MOVWF  x40
08126:  MOVLB  0
08128:  CALL   520C
....................    }
0812C:  BRA    8134
.................... //!   else if (0 == strcmp(s_all, arg1)) {
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.vN15[0],monCal.vN15[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v200[0],monCal.v200[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5V6[0],monCal.v5V6[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v5VA[0],monCal.v5VA[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V6X[0],monCal.v3V6X[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3A[0],monCal.v3V3A[1]);
.................... //!      sprintf(retData+strlen(retData), "%f,%f,", monCal.v3V3D[0],monCal.v3V3D[1]);
.................... //!   }
....................    else return INV_PARAM;
0812E:  MOVLW  02
08130:  MOVWF  01
08132:  BRA    8138
....................    
....................    return SUCCESS;
08134:  MOVLW  00
08136:  MOVWF  01
08138:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
0813A:  MOVLW  00
0813C:  MOVWF  01
0813E:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    char *arg1;
....................    char *s_N15 = "N15";
08140:  MOVLW  4E
08142:  MOVLB  5
08144:  MOVWF  xFF
08146:  MOVLW  31
08148:  MOVLB  6
0814A:  MOVWF  x00
0814C:  MOVLW  35
0814E:  MOVWF  x01
08150:  CLRF   x02
08152:  MOVLW  05
08154:  MOVLB  5
08156:  MOVWF  xFE
08158:  SETF   xFD
....................    char *s_200 = "200";
0815A:  MOVLW  32
0815C:  MOVLB  6
0815E:  MOVWF  x05
08160:  MOVLW  30
08162:  MOVWF  x06
08164:  MOVWF  x07
08166:  CLRF   x08
08168:  MOVLW  06
0816A:  MOVWF  x04
0816C:  MOVLW  05
0816E:  MOVWF  x03
....................    char *s_5V6 = "5V6";
08170:  MOVLW  35
08172:  MOVWF  x0B
08174:  MOVLW  56
08176:  MOVWF  x0C
08178:  MOVLW  36
0817A:  MOVWF  x0D
0817C:  CLRF   x0E
0817E:  MOVLW  06
08180:  MOVWF  x0A
08182:  MOVLW  0B
08184:  MOVWF  x09
....................    char *s_5VA = "5VA";
08186:  MOVLW  35
08188:  MOVWF  x11
0818A:  MOVLW  56
0818C:  MOVWF  x12
0818E:  MOVLW  41
08190:  MOVWF  x13
08192:  CLRF   x14
08194:  MOVLW  06
08196:  MOVWF  x10
08198:  MOVLW  11
0819A:  MOVWF  x0F
....................    char *s_3V6X = "3V6X";
0819C:  MOVLW  33
0819E:  MOVWF  x17
081A0:  MOVLW  56
081A2:  MOVWF  x18
081A4:  MOVLW  36
081A6:  MOVWF  x19
081A8:  MOVLW  58
081AA:  MOVWF  x1A
081AC:  CLRF   x1B
081AE:  MOVLW  06
081B0:  MOVWF  x16
081B2:  MOVLW  17
081B4:  MOVWF  x15
....................    char *s_3V3A = "3V3A";
081B6:  MOVLW  33
081B8:  MOVWF  x1E
081BA:  MOVLW  56
081BC:  MOVWF  x1F
081BE:  MOVLW  33
081C0:  MOVWF  x20
081C2:  MOVLW  41
081C4:  MOVWF  x21
081C6:  CLRF   x22
081C8:  MOVLW  06
081CA:  MOVWF  x1D
081CC:  MOVLW  1E
081CE:  MOVWF  x1C
....................    char *s_3V3D = "3V3D";
081D0:  MOVLW  33
081D2:  MOVWF  x25
081D4:  MOVLW  56
081D6:  MOVWF  x26
081D8:  MOVLW  33
081DA:  MOVWF  x27
081DC:  MOVLW  44
081DE:  MOVWF  x28
081E0:  CLRF   x29
081E2:  MOVLW  06
081E4:  MOVWF  x24
081E6:  MOVLW  25
081E8:  MOVWF  x23
....................    char *s_all = "all";
081EA:  MOVLW  61
081EC:  MOVWF  x2C
081EE:  MOVLW  6C
081F0:  MOVWF  x2D
081F2:  MOVWF  x2E
081F4:  CLRF   x2F
081F6:  MOVLW  06
081F8:  MOVWF  x2B
081FA:  MOVLW  2C
081FC:  MOVWF  x2A
....................    
....................    arg1 = SERcmd[rec].p[2];
081FE:  CLRF   x32
08200:  MOVFF  5EF,631
08204:  CLRF   x34
08206:  MOVLW  B5
08208:  MOVWF  x33
0820A:  MOVLB  0
0820C:  CALL   08AC
08210:  MOVFF  02,631
08214:  MOVFF  01,630
08218:  MOVLW  06
0821A:  MOVLB  6
0821C:  ADDWF  x30,F
0821E:  MOVLW  00
08220:  ADDWFC x31,F
08222:  MOVLW  32
08224:  ADDWF  x30,W
08226:  MOVWF  01
08228:  MOVLW  00
0822A:  ADDWFC x31,W
0822C:  MOVWF  03
0822E:  MOVF   01,W
08230:  ADDLW  6C
08232:  MOVWF  01
08234:  MOVLW  01
08236:  ADDWFC 03,F
08238:  MOVFF  01,5FB
0823C:  MOVLB  5
0823E:  MOVFF  03,5FC
....................    
....................    /*** GET MONITOR VALUES ************/
....................    if      (0 == strcmp(s_N15, arg1)) {
08242:  MOVFF  5FE,632
08246:  MOVFF  5FD,631
0824A:  MOVFF  5FC,634
0824E:  MOVFF  5FB,633
08252:  MOVLB  0
08254:  CALL   5194
08258:  MOVF   01,F
0825A:  BNZ   82B2
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
0825C:  MOVLW  04
0825E:  MOVLB  6
08260:  MOVWF  x32
08262:  MOVLW  42
08264:  MOVWF  x31
08266:  MOVLB  0
08268:  CALL   515C
0826C:  MOVFF  02,03
08270:  MOVF   01,W
08272:  ADDLW  42
08274:  MOVLB  6
08276:  MOVWF  x30
08278:  MOVLW  04
0827A:  ADDWFC 02,W
0827C:  MOVWF  x31
0827E:  MOVFF  FE8,4E7
08282:  MOVFF  630,4E6
08286:  MOVLW  89
08288:  MOVWF  FE9
0828A:  MOVFF  F6,636
0828E:  MOVFF  F5,635
08292:  MOVFF  F4,634
08296:  MOVFF  F3,633
0829A:  MOVLW  02
0829C:  MOVWF  x37
0829E:  MOVLB  0
082A0:  CALL   5F50
082A4:  MOVLW  2C
082A6:  MOVLB  6
082A8:  MOVWF  x40
082AA:  MOVLB  0
082AC:  CALL   520C
....................    }
082B0:  BRA    87B4
....................    else if (0 == strcmp(s_200, arg1)) {
082B2:  MOVFF  604,632
082B6:  MOVFF  603,631
082BA:  MOVFF  5FC,634
082BE:  MOVFF  5FB,633
082C2:  CALL   5194
082C6:  MOVF   01,F
082C8:  BNZ   8320
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
082CA:  MOVLW  04
082CC:  MOVLB  6
082CE:  MOVWF  x32
082D0:  MOVLW  42
082D2:  MOVWF  x31
082D4:  MOVLB  0
082D6:  CALL   515C
082DA:  MOVFF  02,03
082DE:  MOVF   01,W
082E0:  ADDLW  42
082E2:  MOVLB  6
082E4:  MOVWF  x30
082E6:  MOVLW  04
082E8:  ADDWFC 02,W
082EA:  MOVWF  x31
082EC:  MOVFF  FE8,4E7
082F0:  MOVFF  630,4E6
082F4:  MOVLW  89
082F6:  MOVWF  FE9
082F8:  MOVFF  FA,636
082FC:  MOVFF  F9,635
08300:  MOVFF  F8,634
08304:  MOVFF  F7,633
08308:  MOVLW  01
0830A:  MOVWF  x37
0830C:  MOVLB  0
0830E:  CALL   5F50
08312:  MOVLW  2C
08314:  MOVLB  6
08316:  MOVWF  x40
08318:  MOVLB  0
0831A:  CALL   520C
....................    }
0831E:  BRA    87B4
....................    else if (0 == strcmp(s_5V6, arg1)) {
08320:  MOVFF  60A,632
08324:  MOVFF  609,631
08328:  MOVFF  5FC,634
0832C:  MOVFF  5FB,633
08330:  CALL   5194
08334:  MOVF   01,F
08336:  BNZ   838E
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08338:  MOVLW  04
0833A:  MOVLB  6
0833C:  MOVWF  x32
0833E:  MOVLW  42
08340:  MOVWF  x31
08342:  MOVLB  0
08344:  CALL   515C
08348:  MOVFF  02,03
0834C:  MOVF   01,W
0834E:  ADDLW  42
08350:  MOVLB  6
08352:  MOVWF  x30
08354:  MOVLW  04
08356:  ADDWFC 02,W
08358:  MOVWF  x31
0835A:  MOVFF  FE8,4E7
0835E:  MOVFF  630,4E6
08362:  MOVLW  89
08364:  MOVWF  FE9
08366:  MOVFF  FE,636
0836A:  MOVFF  FD,635
0836E:  MOVFF  FC,634
08372:  MOVFF  FB,633
08376:  MOVLW  03
08378:  MOVWF  x37
0837A:  MOVLB  0
0837C:  CALL   5F50
08380:  MOVLW  2C
08382:  MOVLB  6
08384:  MOVWF  x40
08386:  MOVLB  0
08388:  CALL   520C
....................    }
0838C:  BRA    87B4
....................    else if (0 == strcmp(s_5VA, arg1)) {
0838E:  MOVFF  610,632
08392:  MOVFF  60F,631
08396:  MOVFF  5FC,634
0839A:  MOVFF  5FB,633
0839E:  CALL   5194
083A2:  MOVF   01,F
083A4:  BNZ   83FC
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
083A6:  MOVLW  04
083A8:  MOVLB  6
083AA:  MOVWF  x32
083AC:  MOVLW  42
083AE:  MOVWF  x31
083B0:  MOVLB  0
083B2:  CALL   515C
083B6:  MOVFF  02,03
083BA:  MOVF   01,W
083BC:  ADDLW  42
083BE:  MOVLB  6
083C0:  MOVWF  x30
083C2:  MOVLW  04
083C4:  ADDWFC 02,W
083C6:  MOVWF  x31
083C8:  MOVFF  FE8,4E7
083CC:  MOVFF  630,4E6
083D0:  MOVLW  89
083D2:  MOVWF  FE9
083D4:  MOVFF  102,636
083D8:  MOVFF  101,635
083DC:  MOVFF  100,634
083E0:  MOVFF  FF,633
083E4:  MOVLW  03
083E6:  MOVWF  x37
083E8:  MOVLB  0
083EA:  CALL   5F50
083EE:  MOVLW  2C
083F0:  MOVLB  6
083F2:  MOVWF  x40
083F4:  MOVLB  0
083F6:  CALL   520C
....................    }
083FA:  BRA    87B4
....................    else if (0 == strcmp(s_3V6X, arg1)) {
083FC:  MOVFF  616,632
08400:  MOVFF  615,631
08404:  MOVFF  5FC,634
08408:  MOVFF  5FB,633
0840C:  CALL   5194
08410:  MOVF   01,F
08412:  BNZ   846A
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
08414:  MOVLW  04
08416:  MOVLB  6
08418:  MOVWF  x32
0841A:  MOVLW  42
0841C:  MOVWF  x31
0841E:  MOVLB  0
08420:  CALL   515C
08424:  MOVFF  02,03
08428:  MOVF   01,W
0842A:  ADDLW  42
0842C:  MOVLB  6
0842E:  MOVWF  x30
08430:  MOVLW  04
08432:  ADDWFC 02,W
08434:  MOVWF  x31
08436:  MOVFF  FE8,4E7
0843A:  MOVFF  630,4E6
0843E:  MOVLW  89
08440:  MOVWF  FE9
08442:  MOVFF  106,636
08446:  MOVFF  105,635
0844A:  MOVFF  104,634
0844E:  MOVFF  103,633
08452:  MOVLW  03
08454:  MOVWF  x37
08456:  MOVLB  0
08458:  CALL   5F50
0845C:  MOVLW  2C
0845E:  MOVLB  6
08460:  MOVWF  x40
08462:  MOVLB  0
08464:  CALL   520C
....................    }
08468:  BRA    87B4
....................    else if (0 == strcmp(s_3V3A, arg1)) {
0846A:  MOVFF  61D,632
0846E:  MOVFF  61C,631
08472:  MOVFF  5FC,634
08476:  MOVFF  5FB,633
0847A:  CALL   5194
0847E:  MOVF   01,F
08480:  BNZ   84D8
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08482:  MOVLW  04
08484:  MOVLB  6
08486:  MOVWF  x32
08488:  MOVLW  42
0848A:  MOVWF  x31
0848C:  MOVLB  0
0848E:  CALL   515C
08492:  MOVFF  02,03
08496:  MOVF   01,W
08498:  ADDLW  42
0849A:  MOVLB  6
0849C:  MOVWF  x30
0849E:  MOVLW  04
084A0:  ADDWFC 02,W
084A2:  MOVWF  x31
084A4:  MOVFF  FE8,4E7
084A8:  MOVFF  630,4E6
084AC:  MOVLW  89
084AE:  MOVWF  FE9
084B0:  MOVFF  10A,636
084B4:  MOVFF  109,635
084B8:  MOVFF  108,634
084BC:  MOVFF  107,633
084C0:  MOVLW  03
084C2:  MOVWF  x37
084C4:  MOVLB  0
084C6:  CALL   5F50
084CA:  MOVLW  2C
084CC:  MOVLB  6
084CE:  MOVWF  x40
084D0:  MOVLB  0
084D2:  CALL   520C
....................    }
084D6:  BRA    87B4
....................    else if (0 == strcmp(s_3V3D, arg1)) {
084D8:  MOVFF  624,632
084DC:  MOVFF  623,631
084E0:  MOVFF  5FC,634
084E4:  MOVFF  5FB,633
084E8:  CALL   5194
084EC:  MOVF   01,F
084EE:  BNZ   8546
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
084F0:  MOVLW  04
084F2:  MOVLB  6
084F4:  MOVWF  x32
084F6:  MOVLW  42
084F8:  MOVWF  x31
084FA:  MOVLB  0
084FC:  CALL   515C
08500:  MOVFF  02,03
08504:  MOVF   01,W
08506:  ADDLW  42
08508:  MOVLB  6
0850A:  MOVWF  x30
0850C:  MOVLW  04
0850E:  ADDWFC 02,W
08510:  MOVWF  x31
08512:  MOVFF  FE8,4E7
08516:  MOVFF  630,4E6
0851A:  MOVLW  89
0851C:  MOVWF  FE9
0851E:  MOVFF  10E,636
08522:  MOVFF  10D,635
08526:  MOVFF  10C,634
0852A:  MOVFF  10B,633
0852E:  MOVLW  03
08530:  MOVWF  x37
08532:  MOVLB  0
08534:  CALL   5F50
08538:  MOVLW  2C
0853A:  MOVLB  6
0853C:  MOVWF  x40
0853E:  MOVLB  0
08540:  CALL   520C
....................    }
08544:  BRA    87B4
....................    else if (0 == strcmp(s_all, arg1)) {
08546:  MOVFF  62B,632
0854A:  MOVFF  62A,631
0854E:  MOVFF  5FC,634
08552:  MOVFF  5FB,633
08556:  CALL   5194
0855A:  MOVF   01,F
0855C:  BTFSS  FD8.2
0855E:  BRA    87AE
....................       sprintf(retData+strlen(retData), "%.2f,", monitorVals.vN15);
08560:  MOVLW  04
08562:  MOVLB  6
08564:  MOVWF  x32
08566:  MOVLW  42
08568:  MOVWF  x31
0856A:  MOVLB  0
0856C:  CALL   515C
08570:  MOVFF  02,03
08574:  MOVF   01,W
08576:  ADDLW  42
08578:  MOVLB  6
0857A:  MOVWF  x30
0857C:  MOVLW  04
0857E:  ADDWFC 02,W
08580:  MOVWF  x31
08582:  MOVFF  FE8,4E7
08586:  MOVFF  630,4E6
0858A:  MOVLW  89
0858C:  MOVWF  FE9
0858E:  MOVFF  F6,636
08592:  MOVFF  F5,635
08596:  MOVFF  F4,634
0859A:  MOVFF  F3,633
0859E:  MOVLW  02
085A0:  MOVWF  x37
085A2:  MOVLB  0
085A4:  CALL   5F50
085A8:  MOVLW  2C
085AA:  MOVLB  6
085AC:  MOVWF  x40
085AE:  MOVLB  0
085B0:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.1f,", monitorVals.v200);
085B4:  MOVLW  04
085B6:  MOVLB  6
085B8:  MOVWF  x32
085BA:  MOVLW  42
085BC:  MOVWF  x31
085BE:  MOVLB  0
085C0:  CALL   515C
085C4:  MOVFF  02,03
085C8:  MOVF   01,W
085CA:  ADDLW  42
085CC:  MOVLB  6
085CE:  MOVWF  x30
085D0:  MOVLW  04
085D2:  ADDWFC 02,W
085D4:  MOVWF  x31
085D6:  MOVFF  FE8,4E7
085DA:  MOVFF  630,4E6
085DE:  MOVLW  89
085E0:  MOVWF  FE9
085E2:  MOVFF  FA,636
085E6:  MOVFF  F9,635
085EA:  MOVFF  F8,634
085EE:  MOVFF  F7,633
085F2:  MOVLW  01
085F4:  MOVWF  x37
085F6:  MOVLB  0
085F8:  CALL   5F50
085FC:  MOVLW  2C
085FE:  MOVLB  6
08600:  MOVWF  x40
08602:  MOVLB  0
08604:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5V6);
08608:  MOVLW  04
0860A:  MOVLB  6
0860C:  MOVWF  x32
0860E:  MOVLW  42
08610:  MOVWF  x31
08612:  MOVLB  0
08614:  CALL   515C
08618:  MOVFF  02,03
0861C:  MOVF   01,W
0861E:  ADDLW  42
08620:  MOVLB  6
08622:  MOVWF  x30
08624:  MOVLW  04
08626:  ADDWFC 02,W
08628:  MOVWF  x31
0862A:  MOVFF  FE8,4E7
0862E:  MOVFF  630,4E6
08632:  MOVLW  89
08634:  MOVWF  FE9
08636:  MOVFF  FE,636
0863A:  MOVFF  FD,635
0863E:  MOVFF  FC,634
08642:  MOVFF  FB,633
08646:  MOVLW  03
08648:  MOVWF  x37
0864A:  MOVLB  0
0864C:  CALL   5F50
08650:  MOVLW  2C
08652:  MOVLB  6
08654:  MOVWF  x40
08656:  MOVLB  0
08658:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v5VA);
0865C:  MOVLW  04
0865E:  MOVLB  6
08660:  MOVWF  x32
08662:  MOVLW  42
08664:  MOVWF  x31
08666:  MOVLB  0
08668:  CALL   515C
0866C:  MOVFF  02,03
08670:  MOVF   01,W
08672:  ADDLW  42
08674:  MOVLB  6
08676:  MOVWF  x30
08678:  MOVLW  04
0867A:  ADDWFC 02,W
0867C:  MOVWF  x31
0867E:  MOVFF  FE8,4E7
08682:  MOVFF  630,4E6
08686:  MOVLW  89
08688:  MOVWF  FE9
0868A:  MOVFF  102,636
0868E:  MOVFF  101,635
08692:  MOVFF  100,634
08696:  MOVFF  FF,633
0869A:  MOVLW  03
0869C:  MOVWF  x37
0869E:  MOVLB  0
086A0:  CALL   5F50
086A4:  MOVLW  2C
086A6:  MOVLB  6
086A8:  MOVWF  x40
086AA:  MOVLB  0
086AC:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V6X);
086B0:  MOVLW  04
086B2:  MOVLB  6
086B4:  MOVWF  x32
086B6:  MOVLW  42
086B8:  MOVWF  x31
086BA:  MOVLB  0
086BC:  CALL   515C
086C0:  MOVFF  02,03
086C4:  MOVF   01,W
086C6:  ADDLW  42
086C8:  MOVLB  6
086CA:  MOVWF  x30
086CC:  MOVLW  04
086CE:  ADDWFC 02,W
086D0:  MOVWF  x31
086D2:  MOVFF  FE8,4E7
086D6:  MOVFF  630,4E6
086DA:  MOVLW  89
086DC:  MOVWF  FE9
086DE:  MOVFF  106,636
086E2:  MOVFF  105,635
086E6:  MOVFF  104,634
086EA:  MOVFF  103,633
086EE:  MOVLW  03
086F0:  MOVWF  x37
086F2:  MOVLB  0
086F4:  CALL   5F50
086F8:  MOVLW  2C
086FA:  MOVLB  6
086FC:  MOVWF  x40
086FE:  MOVLB  0
08700:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3A);
08704:  MOVLW  04
08706:  MOVLB  6
08708:  MOVWF  x32
0870A:  MOVLW  42
0870C:  MOVWF  x31
0870E:  MOVLB  0
08710:  CALL   515C
08714:  MOVFF  02,03
08718:  MOVF   01,W
0871A:  ADDLW  42
0871C:  MOVLB  6
0871E:  MOVWF  x30
08720:  MOVLW  04
08722:  ADDWFC 02,W
08724:  MOVWF  x31
08726:  MOVFF  FE8,4E7
0872A:  MOVFF  630,4E6
0872E:  MOVLW  89
08730:  MOVWF  FE9
08732:  MOVFF  10A,636
08736:  MOVFF  109,635
0873A:  MOVFF  108,634
0873E:  MOVFF  107,633
08742:  MOVLW  03
08744:  MOVWF  x37
08746:  MOVLB  0
08748:  CALL   5F50
0874C:  MOVLW  2C
0874E:  MOVLB  6
08750:  MOVWF  x40
08752:  MOVLB  0
08754:  CALL   520C
....................       sprintf(retData+strlen(retData), "%.3f,", monitorVals.v3V3D);
08758:  MOVLW  04
0875A:  MOVLB  6
0875C:  MOVWF  x32
0875E:  MOVLW  42
08760:  MOVWF  x31
08762:  MOVLB  0
08764:  CALL   515C
08768:  MOVFF  02,03
0876C:  MOVF   01,W
0876E:  ADDLW  42
08770:  MOVLB  6
08772:  MOVWF  x30
08774:  MOVLW  04
08776:  ADDWFC 02,W
08778:  MOVWF  x31
0877A:  MOVFF  FE8,4E7
0877E:  MOVFF  630,4E6
08782:  MOVLW  89
08784:  MOVWF  FE9
08786:  MOVFF  10E,636
0878A:  MOVFF  10D,635
0878E:  MOVFF  10C,634
08792:  MOVFF  10B,633
08796:  MOVLW  03
08798:  MOVWF  x37
0879A:  MOVLB  0
0879C:  CALL   5F50
087A0:  MOVLW  2C
087A2:  MOVLB  6
087A4:  MOVWF  x40
087A6:  MOVLB  0
087A8:  CALL   520C
....................    }
087AC:  BRA    87B4
....................    else return INV_PARAM;
087AE:  MOVLW  02
087B0:  MOVWF  01
087B2:  BRA    87B8
....................    
....................    return SUCCESS;
087B4:  MOVLW  00
087B6:  MOVWF  01
087B8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................   /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char *arg2;
....................    char *s_PV = "PV";
087BA:  MOVLW  50
087BC:  MOVLB  6
087BE:  MOVWF  x00
087C0:  MOVLW  56
087C2:  MOVWF  x01
087C4:  CLRF   x02
087C6:  MOVLW  06
087C8:  MOVLB  5
087CA:  MOVWF  xFF
087CC:  CLRF   xFE
....................    char *s_CV = "CV";
087CE:  MOVLW  43
087D0:  MOVLB  6
087D2:  MOVWF  x05
087D4:  MOVLW  56
087D6:  MOVWF  x06
087D8:  CLRF   x07
087DA:  MOVLW  06
087DC:  MOVWF  x04
087DE:  MOVLW  05
087E0:  MOVWF  x03
....................    char *s_PVold = "PVold";
087E2:  MOVLW  50
087E4:  MOVWF  x0A
087E6:  MOVLW  56
087E8:  MOVWF  x0B
087EA:  MOVLW  6F
087EC:  MOVWF  x0C
087EE:  MOVLW  6C
087F0:  MOVWF  x0D
087F2:  MOVLW  64
087F4:  MOVWF  x0E
087F6:  CLRF   x0F
087F8:  MOVLW  06
087FA:  MOVWF  x09
087FC:  MOVLW  0A
087FE:  MOVWF  x08
....................    char *s_I = "I";
08800:  MOVLW  49
08802:  MOVWF  x12
08804:  CLRF   x13
08806:  MOVLW  06
08808:  MOVWF  x11
0880A:  MOVLW  12
0880C:  MOVWF  x10
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0880E:  CLRF   x32
08810:  MOVFF  5EF,631
08814:  CLRF   x34
08816:  MOVLW  B5
08818:  MOVWF  x33
0881A:  MOVLB  0
0881C:  CALL   08AC
08820:  MOVFF  02,615
08824:  MOVFF  01,614
08828:  MOVLW  06
0882A:  MOVLB  6
0882C:  ADDWF  x14,F
0882E:  MOVLW  00
08830:  ADDWFC x15,F
08832:  MOVLW  32
08834:  ADDWF  x14,W
08836:  MOVWF  01
08838:  MOVLW  00
0883A:  ADDWFC x15,W
0883C:  MOVWF  03
0883E:  MOVF   01,W
08840:  ADDLW  6C
08842:  MOVWF  01
08844:  MOVLW  01
08846:  ADDWFC 03,F
08848:  MOVFF  01,614
0884C:  MOVFF  03,615
08850:  MOVFF  03,629
08854:  MOVFF  01,628
08858:  MOVLB  0
0885A:  CALL   52D4
0885E:  MOVF   01,F
08860:  BNZ   886A
08862:  MOVLW  02
08864:  MOVWF  01
08866:  BRA    8C12
08868:  BRA    88C8
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0886A:  MOVLB  6
0886C:  CLRF   x32
0886E:  MOVFF  5EF,631
08872:  CLRF   x34
08874:  MOVLW  B5
08876:  MOVWF  x33
08878:  MOVLB  0
0887A:  CALL   08AC
0887E:  MOVFF  02,615
08882:  MOVFF  01,614
08886:  MOVLW  06
08888:  MOVLB  6
0888A:  ADDWF  x14,F
0888C:  MOVLW  00
0888E:  ADDWFC x15,F
08890:  MOVLW  32
08892:  ADDWF  x14,W
08894:  MOVWF  01
08896:  MOVLW  00
08898:  ADDWFC x15,W
0889A:  MOVWF  03
0889C:  MOVF   01,W
0889E:  ADDLW  6C
088A0:  MOVWF  01
088A2:  MOVLW  01
088A4:  ADDWFC 03,F
088A6:  MOVFF  01,614
088AA:  MOVFF  03,615
088AE:  MOVFF  03,629
088B2:  MOVFF  01,628
088B6:  CLRF   x2B
088B8:  CLRF   x2A
088BA:  MOVLW  0A
088BC:  MOVWF  x2C
088BE:  MOVLB  0
088C0:  CALL   53C4
088C4:  MOVFF  01,5FB
....................    
....................    arg2 = SERcmd[rec].p[3];
088C8:  MOVLB  6
088CA:  CLRF   x32
088CC:  MOVFF  5EF,631
088D0:  CLRF   x34
088D2:  MOVLW  B5
088D4:  MOVWF  x33
088D6:  MOVLB  0
088D8:  CALL   08AC
088DC:  MOVFF  02,615
088E0:  MOVFF  01,614
088E4:  MOVLW  06
088E6:  MOVLB  6
088E8:  ADDWF  x14,F
088EA:  MOVLW  00
088EC:  ADDWFC x15,F
088EE:  MOVLW  4B
088F0:  ADDWF  x14,W
088F2:  MOVWF  01
088F4:  MOVLW  00
088F6:  ADDWFC x15,W
088F8:  MOVWF  03
088FA:  MOVF   01,W
088FC:  ADDLW  6C
088FE:  MOVWF  01
08900:  MOVLW  01
08902:  ADDWFC 03,F
08904:  MOVFF  01,5FC
08908:  MOVLB  5
0890A:  MOVFF  03,5FD
....................    
....................    /*** GET PV, CV, PVold, I, or A(LL) VALUE **********/
....................    if      (0 == strcmp(s_PV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PV);
0890E:  MOVFF  5FF,632
08912:  MOVFF  5FE,631
08916:  MOVFF  5FD,634
0891A:  MOVFF  5FC,633
0891E:  MOVLB  0
08920:  CALL   5194
08924:  MOVF   01,F
08926:  BNZ   89CE
08928:  MOVLW  04
0892A:  MOVLB  6
0892C:  MOVWF  x32
0892E:  MOVLW  42
08930:  MOVWF  x31
08932:  MOVLB  0
08934:  CALL   515C
08938:  MOVF   01,W
0893A:  ADDLW  42
0893C:  MOVLB  6
0893E:  MOVWF  x14
08940:  MOVLW  04
08942:  ADDWFC 02,W
08944:  MOVWF  x15
08946:  MOVLW  01
08948:  MOVLB  5
0894A:  SUBWF  xFB,W
0894C:  MULLW  20
0894E:  MOVF   FF3,W
08950:  MOVLB  6
08952:  CLRF   x17
08954:  MOVWF  x16
08956:  MOVLW  10
08958:  ADDWF  x16,W
0895A:  MOVWF  01
0895C:  MOVLW  00
0895E:  ADDWFC x17,W
08960:  MOVWF  03
08962:  MOVF   01,W
08964:  ADDLW  20
08966:  MOVWF  FE9
08968:  MOVLW  00
0896A:  ADDWFC 03,W
0896C:  MOVWF  FEA
0896E:  MOVFF  FEF,616
08972:  MOVFF  FEC,617
08976:  MOVFF  FEC,618
0897A:  MOVFF  FEC,619
0897E:  MOVFF  615,4E7
08982:  MOVFF  614,4E6
08986:  MOVFF  5FB,629
0898A:  MOVLW  18
0898C:  MOVWF  x2A
0898E:  MOVLB  0
08990:  CALL   5718
08994:  MOVLW  2C
08996:  MOVLB  6
08998:  MOVWF  x40
0899A:  MOVLB  0
0899C:  CALL   520C
089A0:  MOVLW  89
089A2:  MOVWF  FE9
089A4:  MOVFF  619,636
089A8:  MOVFF  618,635
089AC:  MOVFF  617,634
089B0:  MOVFF  616,633
089B4:  MOVLW  02
089B6:  MOVLB  6
089B8:  MOVWF  x37
089BA:  MOVLB  0
089BC:  CALL   5F50
089C0:  MOVLW  2C
089C2:  MOVLB  6
089C4:  MOVWF  x40
089C6:  MOVLB  0
089C8:  CALL   520C
089CC:  BRA    8C0E
....................    else if (0 == strcmp(s_CV, arg2))     sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].CV);
089CE:  MOVFF  604,632
089D2:  MOVFF  603,631
089D6:  MOVFF  5FD,634
089DA:  MOVFF  5FC,633
089DE:  CALL   5194
089E2:  MOVF   01,F
089E4:  BNZ   8A8C
089E6:  MOVLW  04
089E8:  MOVLB  6
089EA:  MOVWF  x32
089EC:  MOVLW  42
089EE:  MOVWF  x31
089F0:  MOVLB  0
089F2:  CALL   515C
089F6:  MOVF   01,W
089F8:  ADDLW  42
089FA:  MOVLB  6
089FC:  MOVWF  x14
089FE:  MOVLW  04
08A00:  ADDWFC 02,W
08A02:  MOVWF  x15
08A04:  MOVLW  01
08A06:  MOVLB  5
08A08:  SUBWF  xFB,W
08A0A:  MULLW  20
08A0C:  MOVF   FF3,W
08A0E:  MOVLB  6
08A10:  CLRF   x17
08A12:  MOVWF  x16
08A14:  MOVLW  18
08A16:  ADDWF  x16,W
08A18:  MOVWF  01
08A1A:  MOVLW  00
08A1C:  ADDWFC x17,W
08A1E:  MOVWF  03
08A20:  MOVF   01,W
08A22:  ADDLW  20
08A24:  MOVWF  FE9
08A26:  MOVLW  00
08A28:  ADDWFC 03,W
08A2A:  MOVWF  FEA
08A2C:  MOVFF  FEF,616
08A30:  MOVFF  FEC,617
08A34:  MOVFF  FEC,618
08A38:  MOVFF  FEC,619
08A3C:  MOVFF  615,4E7
08A40:  MOVFF  614,4E6
08A44:  MOVFF  5FB,629
08A48:  MOVLW  18
08A4A:  MOVWF  x2A
08A4C:  MOVLB  0
08A4E:  CALL   5718
08A52:  MOVLW  2C
08A54:  MOVLB  6
08A56:  MOVWF  x40
08A58:  MOVLB  0
08A5A:  CALL   520C
08A5E:  MOVLW  89
08A60:  MOVWF  FE9
08A62:  MOVFF  619,636
08A66:  MOVFF  618,635
08A6A:  MOVFF  617,634
08A6E:  MOVFF  616,633
08A72:  MOVLW  02
08A74:  MOVLB  6
08A76:  MOVWF  x37
08A78:  MOVLB  0
08A7A:  CALL   5F50
08A7E:  MOVLW  2C
08A80:  MOVLB  6
08A82:  MOVWF  x40
08A84:  MOVLB  0
08A86:  CALL   520C
08A8A:  BRA    8C0E
....................    else if (0 == strcmp(s_PVold, arg2))  sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].PVold);
08A8C:  MOVFF  609,632
08A90:  MOVFF  608,631
08A94:  MOVFF  5FD,634
08A98:  MOVFF  5FC,633
08A9C:  CALL   5194
08AA0:  MOVF   01,F
08AA2:  BNZ   8B4A
08AA4:  MOVLW  04
08AA6:  MOVLB  6
08AA8:  MOVWF  x32
08AAA:  MOVLW  42
08AAC:  MOVWF  x31
08AAE:  MOVLB  0
08AB0:  CALL   515C
08AB4:  MOVF   01,W
08AB6:  ADDLW  42
08AB8:  MOVLB  6
08ABA:  MOVWF  x14
08ABC:  MOVLW  04
08ABE:  ADDWFC 02,W
08AC0:  MOVWF  x15
08AC2:  MOVLW  01
08AC4:  MOVLB  5
08AC6:  SUBWF  xFB,W
08AC8:  MULLW  20
08ACA:  MOVF   FF3,W
08ACC:  MOVLB  6
08ACE:  CLRF   x17
08AD0:  MOVWF  x16
08AD2:  MOVLW  14
08AD4:  ADDWF  x16,W
08AD6:  MOVWF  01
08AD8:  MOVLW  00
08ADA:  ADDWFC x17,W
08ADC:  MOVWF  03
08ADE:  MOVF   01,W
08AE0:  ADDLW  20
08AE2:  MOVWF  FE9
08AE4:  MOVLW  00
08AE6:  ADDWFC 03,W
08AE8:  MOVWF  FEA
08AEA:  MOVFF  FEF,616
08AEE:  MOVFF  FEC,617
08AF2:  MOVFF  FEC,618
08AF6:  MOVFF  FEC,619
08AFA:  MOVFF  615,4E7
08AFE:  MOVFF  614,4E6
08B02:  MOVFF  5FB,629
08B06:  MOVLW  18
08B08:  MOVWF  x2A
08B0A:  MOVLB  0
08B0C:  CALL   5718
08B10:  MOVLW  2C
08B12:  MOVLB  6
08B14:  MOVWF  x40
08B16:  MOVLB  0
08B18:  CALL   520C
08B1C:  MOVLW  89
08B1E:  MOVWF  FE9
08B20:  MOVFF  619,636
08B24:  MOVFF  618,635
08B28:  MOVFF  617,634
08B2C:  MOVFF  616,633
08B30:  MOVLW  02
08B32:  MOVLB  6
08B34:  MOVWF  x37
08B36:  MOVLB  0
08B38:  CALL   5F50
08B3C:  MOVLW  2C
08B3E:  MOVLB  6
08B40:  MOVWF  x40
08B42:  MOVLB  0
08B44:  CALL   520C
08B48:  BRA    8C0E
....................    else if (0 == strcmp(s_I, arg2))      sprintf(retData+strlen(retData), "%d,%f,", arg1, PID[arg1-1].I);
08B4A:  MOVFF  611,632
08B4E:  MOVFF  610,631
08B52:  MOVFF  5FD,634
08B56:  MOVFF  5FC,633
08B5A:  CALL   5194
08B5E:  MOVF   01,F
08B60:  BNZ   8C08
08B62:  MOVLW  04
08B64:  MOVLB  6
08B66:  MOVWF  x32
08B68:  MOVLW  42
08B6A:  MOVWF  x31
08B6C:  MOVLB  0
08B6E:  CALL   515C
08B72:  MOVF   01,W
08B74:  ADDLW  42
08B76:  MOVLB  6
08B78:  MOVWF  x14
08B7A:  MOVLW  04
08B7C:  ADDWFC 02,W
08B7E:  MOVWF  x15
08B80:  MOVLW  01
08B82:  MOVLB  5
08B84:  SUBWF  xFB,W
08B86:  MULLW  20
08B88:  MOVF   FF3,W
08B8A:  MOVLB  6
08B8C:  CLRF   x17
08B8E:  MOVWF  x16
08B90:  MOVLW  1C
08B92:  ADDWF  x16,W
08B94:  MOVWF  01
08B96:  MOVLW  00
08B98:  ADDWFC x17,W
08B9A:  MOVWF  03
08B9C:  MOVF   01,W
08B9E:  ADDLW  20
08BA0:  MOVWF  FE9
08BA2:  MOVLW  00
08BA4:  ADDWFC 03,W
08BA6:  MOVWF  FEA
08BA8:  MOVFF  FEF,616
08BAC:  MOVFF  FEC,617
08BB0:  MOVFF  FEC,618
08BB4:  MOVFF  FEC,619
08BB8:  MOVFF  615,4E7
08BBC:  MOVFF  614,4E6
08BC0:  MOVFF  5FB,629
08BC4:  MOVLW  18
08BC6:  MOVWF  x2A
08BC8:  MOVLB  0
08BCA:  CALL   5718
08BCE:  MOVLW  2C
08BD0:  MOVLB  6
08BD2:  MOVWF  x40
08BD4:  MOVLB  0
08BD6:  CALL   520C
08BDA:  MOVLW  89
08BDC:  MOVWF  FE9
08BDE:  MOVFF  619,636
08BE2:  MOVFF  618,635
08BE6:  MOVFF  617,634
08BEA:  MOVFF  616,633
08BEE:  MOVLW  02
08BF0:  MOVLB  6
08BF2:  MOVWF  x37
08BF4:  MOVLB  0
08BF6:  CALL   5F50
08BFA:  MOVLW  2C
08BFC:  MOVLB  6
08BFE:  MOVWF  x40
08C00:  MOVLB  0
08C02:  CALL   520C
08C06:  BRA    8C0E
....................    else return INV_PARAM;
08C08:  MOVLW  02
08C0A:  MOVWF  01
08C0C:  BRA    8C12
....................    
....................    return SUCCESS;
08C0E:  MOVLW  00
08C10:  MOVWF  01
08C12:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
08D32:  MOVLW  72
08D34:  MOVLB  6
08D36:  MOVWF  x00
08D38:  MOVLW  61
08D3A:  MOVWF  x01
08D3C:  MOVLW  77
08D3E:  MOVWF  x02
08D40:  CLRF   x03
08D42:  MOVLW  06
08D44:  MOVLB  5
08D46:  MOVWF  xFF
08D48:  CLRF   xFE
....................    char *s_calibrated = "calib";
08D4A:  MOVLW  63
08D4C:  MOVLB  6
08D4E:  MOVWF  x06
08D50:  MOVLW  61
08D52:  MOVWF  x07
08D54:  MOVLW  6C
08D56:  MOVWF  x08
08D58:  MOVLW  69
08D5A:  MOVWF  x09
08D5C:  MOVLW  62
08D5E:  MOVWF  x0A
08D60:  CLRF   x0B
08D62:  MOVLW  06
08D64:  MOVWF  x05
08D66:  MOVWF  x04
....................    char *s_p0 = "p0";
08D68:  MOVLW  70
08D6A:  MOVWF  x0E
08D6C:  MOVLW  30
08D6E:  MOVWF  x0F
08D70:  CLRF   x10
08D72:  MOVLW  06
08D74:  MOVWF  x0D
08D76:  MOVLW  0E
08D78:  MOVWF  x0C
....................    char *s_poles = "poles";
08D7A:  MOVLW  70
08D7C:  MOVWF  x13
08D7E:  MOVLW  6F
08D80:  MOVWF  x14
08D82:  MOVLW  6C
08D84:  MOVWF  x15
08D86:  MOVLW  65
08D88:  MOVWF  x16
08D8A:  MOVLW  73
08D8C:  MOVWF  x17
08D8E:  CLRF   x18
08D90:  MOVLW  06
08D92:  MOVWF  x12
08D94:  MOVLW  13
08D96:  MOVWF  x11
....................    char *s_real = "real";
08D98:  MOVLW  72
08D9A:  MOVWF  x1B
08D9C:  MOVLW  65
08D9E:  MOVWF  x1C
08DA0:  MOVLW  61
08DA2:  MOVWF  x1D
08DA4:  MOVLW  6C
08DA6:  MOVWF  x1E
08DA8:  CLRF   x1F
08DAA:  MOVLW  06
08DAC:  MOVWF  x1A
08DAE:  MOVLW  1B
08DB0:  MOVWF  x19
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
08DB2:  CLRF   x32
08DB4:  MOVFF  5EF,631
08DB8:  CLRF   x34
08DBA:  MOVLW  B5
08DBC:  MOVWF  x33
08DBE:  MOVLB  0
08DC0:  CALL   08AC
08DC4:  MOVFF  02,621
08DC8:  MOVFF  01,620
08DCC:  MOVLW  06
08DCE:  MOVLB  6
08DD0:  ADDWF  x20,F
08DD2:  MOVLW  00
08DD4:  ADDWFC x21,F
08DD6:  MOVLW  32
08DD8:  ADDWF  x20,W
08DDA:  MOVWF  01
08DDC:  MOVLW  00
08DDE:  ADDWFC x21,W
08DE0:  MOVWF  03
08DE2:  MOVF   01,W
08DE4:  ADDLW  6C
08DE6:  MOVWF  01
08DE8:  MOVLW  01
08DEA:  ADDWFC 03,F
08DEC:  MOVFF  01,620
08DF0:  MOVFF  03,621
08DF4:  MOVFF  03,629
08DF8:  MOVFF  01,628
08DFC:  MOVLB  0
08DFE:  CALL   52D4
08E02:  MOVF   01,F
08E04:  BNZ   8E0E
08E06:  MOVLW  02
08E08:  MOVWF  01
08E0A:  BRA    9470
08E0C:  BRA    8E6C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
08E0E:  MOVLB  6
08E10:  CLRF   x32
08E12:  MOVFF  5EF,631
08E16:  CLRF   x34
08E18:  MOVLW  B5
08E1A:  MOVWF  x33
08E1C:  MOVLB  0
08E1E:  CALL   08AC
08E22:  MOVFF  02,621
08E26:  MOVFF  01,620
08E2A:  MOVLW  06
08E2C:  MOVLB  6
08E2E:  ADDWF  x20,F
08E30:  MOVLW  00
08E32:  ADDWFC x21,F
08E34:  MOVLW  32
08E36:  ADDWF  x20,W
08E38:  MOVWF  01
08E3A:  MOVLW  00
08E3C:  ADDWFC x21,W
08E3E:  MOVWF  03
08E40:  MOVF   01,W
08E42:  ADDLW  6C
08E44:  MOVWF  01
08E46:  MOVLW  01
08E48:  ADDWFC 03,F
08E4A:  MOVFF  01,620
08E4E:  MOVFF  03,621
08E52:  MOVFF  03,629
08E56:  MOVFF  01,628
08E5A:  CLRF   x2B
08E5C:  CLRF   x2A
08E5E:  MOVLW  0A
08E60:  MOVWF  x2C
08E62:  MOVLB  0
08E64:  CALL   53C4
08E68:  MOVFF  01,5FB
....................    
....................    arg2 = SERcmd[rec].p[3];
08E6C:  MOVLB  6
08E6E:  CLRF   x32
08E70:  MOVFF  5EF,631
08E74:  CLRF   x34
08E76:  MOVLW  B5
08E78:  MOVWF  x33
08E7A:  MOVLB  0
08E7C:  CALL   08AC
08E80:  MOVFF  02,621
08E84:  MOVFF  01,620
08E88:  MOVLW  06
08E8A:  MOVLB  6
08E8C:  ADDWF  x20,F
08E8E:  MOVLW  00
08E90:  ADDWFC x21,F
08E92:  MOVLW  4B
08E94:  ADDWF  x20,W
08E96:  MOVWF  01
08E98:  MOVLW  00
08E9A:  ADDWFC x21,W
08E9C:  MOVWF  03
08E9E:  MOVF   01,W
08EA0:  ADDLW  6C
08EA2:  MOVWF  01
08EA4:  MOVLW  01
08EA6:  ADDWFC 03,F
08EA8:  MOVFF  01,5FC
08EAC:  MOVLB  5
08EAE:  MOVFF  03,5FD
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
08EB2:  MOVFF  5FF,632
08EB6:  MOVFF  5FE,631
08EBA:  MOVFF  5FD,634
08EBE:  MOVFF  5FC,633
08EC2:  MOVLB  0
08EC4:  CALL   5194
08EC8:  MOVF   01,F
08ECA:  BTFSS  FD8.2
08ECC:  BRA    9050
....................       sprintf(retData+strlen(retData), "%d,", arg1);
08ECE:  MOVLW  04
08ED0:  MOVLB  6
08ED2:  MOVWF  x32
08ED4:  MOVLW  42
08ED6:  MOVWF  x31
08ED8:  MOVLB  0
08EDA:  CALL   515C
08EDE:  MOVFF  02,03
08EE2:  MOVF   01,W
08EE4:  ADDLW  42
08EE6:  MOVLB  6
08EE8:  MOVWF  x20
08EEA:  MOVLW  04
08EEC:  ADDWFC 02,W
08EEE:  MOVWF  x21
08EF0:  MOVFF  FE8,4E7
08EF4:  MOVFF  620,4E6
08EF8:  MOVFF  5FB,629
08EFC:  MOVLW  18
08EFE:  MOVWF  x2A
08F00:  MOVLB  0
08F02:  CALL   5718
08F06:  MOVLW  2C
08F08:  MOVLB  6
08F0A:  MOVWF  x40
08F0C:  MOVLB  0
08F0E:  CALL   520C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinRaw);
08F12:  MOVLW  04
08F14:  MOVLB  6
08F16:  MOVWF  x32
08F18:  MOVLW  42
08F1A:  MOVWF  x31
08F1C:  MOVLB  0
08F1E:  CALL   515C
08F22:  MOVFF  02,03
08F26:  MOVF   01,W
08F28:  ADDLW  42
08F2A:  MOVLB  6
08F2C:  MOVWF  x20
08F2E:  MOVLW  04
08F30:  ADDWFC 02,W
08F32:  MOVWF  x21
08F34:  MOVLW  01
08F36:  MOVLB  5
08F38:  SUBWF  xFB,W
08F3A:  MULLW  21
08F3C:  MOVF   FF3,W
08F3E:  MOVLB  6
08F40:  CLRF   x23
08F42:  MOVWF  x22
08F44:  MOVLW  0F
08F46:  ADDWF  x22,W
08F48:  MOVWF  FE9
08F4A:  MOVLW  01
08F4C:  ADDWFC x23,W
08F4E:  MOVWF  FEA
08F50:  MOVFF  FEF,640
08F54:  MOVFF  FEC,01
08F58:  MOVFF  FEC,02
08F5C:  MOVFF  FEC,03
08F60:  MOVFF  03,643
08F64:  MOVFF  02,642
08F68:  MOVFF  01,641
08F6C:  MOVLB  0
08F6E:  CALL   4D48
08F72:  MOVFF  03,627
08F76:  MOVFF  02,626
08F7A:  MOVFF  01,625
08F7E:  MOVFF  00,624
08F82:  MOVFF  621,4E7
08F86:  MOVFF  620,4E6
08F8A:  MOVLW  41
08F8C:  MOVWF  FE9
08F8E:  MOVFF  03,631
08F92:  MOVFF  02,630
08F96:  MOVFF  01,62F
08F9A:  MOVFF  00,62E
08F9E:  RCALL  8C14
08FA0:  MOVLW  2C
08FA2:  MOVLB  6
08FA4:  MOVWF  x40
08FA6:  MOVLB  0
08FA8:  CALL   520C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosRaw);
08FAC:  MOVLW  04
08FAE:  MOVLB  6
08FB0:  MOVWF  x32
08FB2:  MOVLW  42
08FB4:  MOVWF  x31
08FB6:  MOVLB  0
08FB8:  CALL   515C
08FBC:  MOVF   01,W
08FBE:  ADDLW  42
08FC0:  MOVLB  6
08FC2:  MOVWF  x20
08FC4:  MOVLW  04
08FC6:  ADDWFC 02,W
08FC8:  MOVWF  x21
08FCA:  MOVLW  01
08FCC:  MOVLB  5
08FCE:  SUBWF  xFB,W
08FD0:  MULLW  21
08FD2:  MOVF   FF3,W
08FD4:  MOVLB  6
08FD6:  CLRF   x23
08FD8:  MOVWF  x22
08FDA:  MOVLW  04
08FDC:  ADDWF  x22,W
08FDE:  MOVWF  01
08FE0:  MOVLW  00
08FE2:  ADDWFC x23,W
08FE4:  MOVWF  03
08FE6:  MOVF   01,W
08FE8:  ADDLW  0F
08FEA:  MOVWF  FE9
08FEC:  MOVLW  01
08FEE:  ADDWFC 03,W
08FF0:  MOVWF  FEA
08FF2:  MOVFF  FEF,640
08FF6:  MOVFF  FEC,01
08FFA:  MOVFF  FEC,02
08FFE:  MOVFF  FEC,03
09002:  MOVFF  03,643
09006:  MOVFF  02,642
0900A:  MOVFF  01,641
0900E:  MOVLB  0
09010:  CALL   4D48
09014:  MOVFF  03,625
09018:  MOVFF  02,624
0901C:  MOVFF  01,623
09020:  MOVFF  00,622
09024:  MOVFF  621,4E7
09028:  MOVFF  620,4E6
0902C:  MOVLW  41
0902E:  MOVWF  FE9
09030:  MOVFF  03,631
09034:  MOVFF  02,630
09038:  MOVFF  01,62F
0903C:  MOVFF  00,62E
09040:  RCALL  8C14
09042:  MOVLW  2C
09044:  MOVLB  6
09046:  MOVWF  x40
09048:  MOVLB  0
0904A:  CALL   520C
....................    }
0904E:  BRA    946C
....................    else if (0 == strcmp(s_calibrated, arg2)) {
09050:  MOVFF  605,632
09054:  MOVFF  604,631
09058:  MOVFF  5FD,634
0905C:  MOVFF  5FC,633
09060:  CALL   5194
09064:  MOVF   01,F
09066:  BTFSS  FD8.2
09068:  BRA    91F4
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0906A:  MOVLW  04
0906C:  MOVLB  6
0906E:  MOVWF  x32
09070:  MOVLW  42
09072:  MOVWF  x31
09074:  MOVLB  0
09076:  CALL   515C
0907A:  MOVFF  02,03
0907E:  MOVF   01,W
09080:  ADDLW  42
09082:  MOVLB  6
09084:  MOVWF  x20
09086:  MOVLW  04
09088:  ADDWFC 02,W
0908A:  MOVWF  x21
0908C:  MOVFF  FE8,4E7
09090:  MOVFF  620,4E6
09094:  MOVFF  5FB,629
09098:  MOVLW  18
0909A:  MOVWF  x2A
0909C:  MOVLB  0
0909E:  CALL   5718
090A2:  MOVLW  2C
090A4:  MOVLB  6
090A6:  MOVWF  x40
090A8:  MOVLB  0
090AA:  CALL   520C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].sinCounts);
090AE:  MOVLW  04
090B0:  MOVLB  6
090B2:  MOVWF  x32
090B4:  MOVLW  42
090B6:  MOVWF  x31
090B8:  MOVLB  0
090BA:  CALL   515C
090BE:  MOVF   01,W
090C0:  ADDLW  42
090C2:  MOVLB  6
090C4:  MOVWF  x20
090C6:  MOVLW  04
090C8:  ADDWFC 02,W
090CA:  MOVWF  x21
090CC:  MOVLW  01
090CE:  MOVLB  5
090D0:  SUBWF  xFB,W
090D2:  MULLW  21
090D4:  MOVF   FF3,W
090D6:  MOVLB  6
090D8:  CLRF   x23
090DA:  MOVWF  x22
090DC:  MOVLW  08
090DE:  ADDWF  x22,W
090E0:  MOVWF  01
090E2:  MOVLW  00
090E4:  ADDWFC x23,W
090E6:  MOVWF  03
090E8:  MOVF   01,W
090EA:  ADDLW  0F
090EC:  MOVWF  FE9
090EE:  MOVLW  01
090F0:  ADDWFC 03,W
090F2:  MOVWF  FEA
090F4:  MOVFF  FEF,640
090F8:  MOVFF  FEC,01
090FC:  MOVFF  FEC,02
09100:  MOVFF  FEC,03
09104:  MOVFF  03,643
09108:  MOVFF  02,642
0910C:  MOVFF  01,641
09110:  MOVLB  0
09112:  CALL   4D48
09116:  MOVFF  03,625
0911A:  MOVFF  02,624
0911E:  MOVFF  01,623
09122:  MOVFF  00,622
09126:  MOVFF  621,4E7
0912A:  MOVFF  620,4E6
0912E:  MOVLW  41
09130:  MOVWF  FE9
09132:  MOVFF  03,631
09136:  MOVFF  02,630
0913A:  MOVFF  01,62F
0913E:  MOVFF  00,62E
09142:  RCALL  8C14
09144:  MOVLW  2C
09146:  MOVLB  6
09148:  MOVWF  x40
0914A:  MOVLB  0
0914C:  CALL   520C
....................       sprintf(retData+strlen(retData), "%Ld,", (signed int32)adcVals[arg1-1].cosCounts);
09150:  MOVLW  04
09152:  MOVLB  6
09154:  MOVWF  x32
09156:  MOVLW  42
09158:  MOVWF  x31
0915A:  MOVLB  0
0915C:  CALL   515C
09160:  MOVF   01,W
09162:  ADDLW  42
09164:  MOVLB  6
09166:  MOVWF  x20
09168:  MOVLW  04
0916A:  ADDWFC 02,W
0916C:  MOVWF  x21
0916E:  MOVLW  01
09170:  MOVLB  5
09172:  SUBWF  xFB,W
09174:  MULLW  21
09176:  MOVF   FF3,W
09178:  MOVLB  6
0917A:  CLRF   x23
0917C:  MOVWF  x22
0917E:  MOVLW  0C
09180:  ADDWF  x22,W
09182:  MOVWF  01
09184:  MOVLW  00
09186:  ADDWFC x23,W
09188:  MOVWF  03
0918A:  MOVF   01,W
0918C:  ADDLW  0F
0918E:  MOVWF  FE9
09190:  MOVLW  01
09192:  ADDWFC 03,W
09194:  MOVWF  FEA
09196:  MOVFF  FEF,640
0919A:  MOVFF  FEC,01
0919E:  MOVFF  FEC,02
091A2:  MOVFF  FEC,03
091A6:  MOVFF  03,643
091AA:  MOVFF  02,642
091AE:  MOVFF  01,641
091B2:  MOVLB  0
091B4:  CALL   4D48
091B8:  MOVFF  03,625
091BC:  MOVFF  02,624
091C0:  MOVFF  01,623
091C4:  MOVFF  00,622
091C8:  MOVFF  621,4E7
091CC:  MOVFF  620,4E6
091D0:  MOVLW  41
091D2:  MOVWF  FE9
091D4:  MOVFF  03,631
091D8:  MOVFF  02,630
091DC:  MOVFF  01,62F
091E0:  MOVFF  00,62E
091E4:  RCALL  8C14
091E6:  MOVLW  2C
091E8:  MOVLB  6
091EA:  MOVWF  x40
091EC:  MOVLB  0
091EE:  CALL   520C
....................    }
091F2:  BRA    946C
....................    else if (0 == strcmp(s_p0, arg2)) {
091F4:  MOVFF  60D,632
091F8:  MOVFF  60C,631
091FC:  MOVFF  5FD,634
09200:  MOVFF  5FC,633
09204:  CALL   5194
09208:  MOVF   01,F
0920A:  BNZ   92CA
....................       sprintf(retData+strlen(retData), "%d,", arg1);
0920C:  MOVLW  04
0920E:  MOVLB  6
09210:  MOVWF  x32
09212:  MOVLW  42
09214:  MOVWF  x31
09216:  MOVLB  0
09218:  CALL   515C
0921C:  MOVFF  02,03
09220:  MOVF   01,W
09222:  ADDLW  42
09224:  MOVLB  6
09226:  MOVWF  x20
09228:  MOVLW  04
0922A:  ADDWFC 02,W
0922C:  MOVWF  x21
0922E:  MOVFF  FE8,4E7
09232:  MOVFF  620,4E6
09236:  MOVFF  5FB,629
0923A:  MOVLW  18
0923C:  MOVWF  x2A
0923E:  MOVLB  0
09240:  CALL   5718
09244:  MOVLW  2C
09246:  MOVLB  6
09248:  MOVWF  x40
0924A:  MOVLB  0
0924C:  CALL   520C
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].p0);
09250:  MOVLW  04
09252:  MOVLB  6
09254:  MOVWF  x32
09256:  MOVLW  42
09258:  MOVWF  x31
0925A:  MOVLB  0
0925C:  CALL   515C
09260:  MOVF   01,W
09262:  ADDLW  42
09264:  MOVLB  6
09266:  MOVWF  x20
09268:  MOVLW  04
0926A:  ADDWFC 02,W
0926C:  MOVWF  x21
0926E:  MOVLW  01
09270:  MOVLB  5
09272:  SUBWF  xFB,W
09274:  MULLW  21
09276:  MOVF   FF3,W
09278:  MOVLB  6
0927A:  CLRF   x23
0927C:  MOVWF  x22
0927E:  MOVLW  18
09280:  ADDWF  x22,W
09282:  MOVWF  01
09284:  MOVLW  00
09286:  ADDWFC x23,W
09288:  MOVWF  03
0928A:  MOVF   01,W
0928C:  ADDLW  0F
0928E:  MOVWF  FE9
09290:  MOVLW  01
09292:  ADDWFC 03,W
09294:  MOVWF  FEA
09296:  MOVFF  FEF,633
0929A:  MOVFF  FEC,634
0929E:  MOVFF  FEC,635
092A2:  MOVFF  FEC,636
092A6:  MOVFF  621,4E7
092AA:  MOVFF  620,4E6
092AE:  MOVLW  89
092B0:  MOVWF  FE9
092B2:  MOVLW  02
092B4:  MOVWF  x37
092B6:  MOVLB  0
092B8:  CALL   5F50
092BC:  MOVLW  2C
092BE:  MOVLB  6
092C0:  MOVWF  x40
092C2:  MOVLB  0
092C4:  CALL   520C
....................    }
092C8:  BRA    946C
....................    else if (0 == strcmp(s_poles, arg2)) {
092CA:  MOVFF  612,632
092CE:  MOVFF  611,631
092D2:  MOVFF  5FD,634
092D6:  MOVFF  5FC,633
092DA:  CALL   5194
092DE:  MOVF   01,F
092E0:  BNZ   9390
....................       sprintf(retData+strlen(retData), "%d,", arg1);
092E2:  MOVLW  04
092E4:  MOVLB  6
092E6:  MOVWF  x32
092E8:  MOVLW  42
092EA:  MOVWF  x31
092EC:  MOVLB  0
092EE:  CALL   515C
092F2:  MOVFF  02,03
092F6:  MOVF   01,W
092F8:  ADDLW  42
092FA:  MOVLB  6
092FC:  MOVWF  x20
092FE:  MOVLW  04
09300:  ADDWFC 02,W
09302:  MOVWF  x21
09304:  MOVFF  FE8,4E7
09308:  MOVFF  620,4E6
0930C:  MOVFF  5FB,629
09310:  MOVLW  18
09312:  MOVWF  x2A
09314:  MOVLB  0
09316:  CALL   5718
0931A:  MOVLW  2C
0931C:  MOVLB  6
0931E:  MOVWF  x40
09320:  MOVLB  0
09322:  CALL   520C
....................       sprintf(retData+strlen(retData), "%d,", adcVals[arg1-1].npoles);
09326:  MOVLW  04
09328:  MOVLB  6
0932A:  MOVWF  x32
0932C:  MOVLW  42
0932E:  MOVWF  x31
09330:  MOVLB  0
09332:  CALL   515C
09336:  MOVF   01,W
09338:  ADDLW  42
0933A:  MOVLB  6
0933C:  MOVWF  x20
0933E:  MOVLW  04
09340:  ADDWFC 02,W
09342:  MOVWF  x21
09344:  MOVLW  01
09346:  MOVLB  5
09348:  SUBWF  xFB,W
0934A:  MULLW  21
0934C:  MOVF   FF3,W
0934E:  MOVLB  6
09350:  CLRF   x23
09352:  MOVWF  x22
09354:  MOVLW  1C
09356:  ADDWF  x22,W
09358:  MOVWF  01
0935A:  MOVLW  00
0935C:  ADDWFC x23,W
0935E:  MOVWF  03
09360:  MOVF   01,W
09362:  ADDLW  0F
09364:  MOVWF  FE9
09366:  MOVLW  01
09368:  ADDWFC 03,W
0936A:  MOVWF  FEA
0936C:  MOVFF  FEF,629
09370:  MOVFF  621,4E7
09374:  MOVFF  620,4E6
09378:  MOVLW  18
0937A:  MOVWF  x2A
0937C:  MOVLB  0
0937E:  CALL   5718
09382:  MOVLW  2C
09384:  MOVLB  6
09386:  MOVWF  x40
09388:  MOVLB  0
0938A:  CALL   520C
....................    }
0938E:  BRA    946C
....................    else if (0 == strcmp(s_real, arg2)) {
09390:  MOVFF  61A,632
09394:  MOVFF  619,631
09398:  MOVFF  5FD,634
0939C:  MOVFF  5FC,633
093A0:  CALL   5194
093A4:  MOVF   01,F
093A6:  BNZ   9466
....................       sprintf(retData+strlen(retData), "%d,", arg1);
093A8:  MOVLW  04
093AA:  MOVLB  6
093AC:  MOVWF  x32
093AE:  MOVLW  42
093B0:  MOVWF  x31
093B2:  MOVLB  0
093B4:  CALL   515C
093B8:  MOVFF  02,03
093BC:  MOVF   01,W
093BE:  ADDLW  42
093C0:  MOVLB  6
093C2:  MOVWF  x20
093C4:  MOVLW  04
093C6:  ADDWFC 02,W
093C8:  MOVWF  x21
093CA:  MOVFF  FE8,4E7
093CE:  MOVFF  620,4E6
093D2:  MOVFF  5FB,629
093D6:  MOVLW  18
093D8:  MOVWF  x2A
093DA:  MOVLB  0
093DC:  CALL   5718
093E0:  MOVLW  2C
093E2:  MOVLB  6
093E4:  MOVWF  x40
093E6:  MOVLB  0
093E8:  CALL   520C
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
093EC:  MOVLW  04
093EE:  MOVLB  6
093F0:  MOVWF  x32
093F2:  MOVLW  42
093F4:  MOVWF  x31
093F6:  MOVLB  0
093F8:  CALL   515C
093FC:  MOVF   01,W
093FE:  ADDLW  42
09400:  MOVLB  6
09402:  MOVWF  x20
09404:  MOVLW  04
09406:  ADDWFC 02,W
09408:  MOVWF  x21
0940A:  MOVLW  01
0940C:  MOVLB  5
0940E:  SUBWF  xFB,W
09410:  MULLW  21
09412:  MOVF   FF3,W
09414:  MOVLB  6
09416:  CLRF   x23
09418:  MOVWF  x22
0941A:  MOVLW  1D
0941C:  ADDWF  x22,W
0941E:  MOVWF  01
09420:  MOVLW  00
09422:  ADDWFC x23,W
09424:  MOVWF  03
09426:  MOVF   01,W
09428:  ADDLW  0F
0942A:  MOVWF  FE9
0942C:  MOVLW  01
0942E:  ADDWFC 03,W
09430:  MOVWF  FEA
09432:  MOVFF  FEF,633
09436:  MOVFF  FEC,634
0943A:  MOVFF  FEC,635
0943E:  MOVFF  FEC,636
09442:  MOVFF  621,4E7
09446:  MOVFF  620,4E6
0944A:  MOVLW  89
0944C:  MOVWF  FE9
0944E:  MOVLW  02
09450:  MOVWF  x37
09452:  MOVLB  0
09454:  CALL   5F50
09458:  MOVLW  2C
0945A:  MOVLB  6
0945C:  MOVWF  x40
0945E:  MOVLB  0
09460:  CALL   520C
....................    }
09464:  BRA    946C
....................    else return INV_PARAM;
09466:  MOVLW  02
09468:  MOVWF  01
0946A:  BRA    9470
....................    
....................    return SUCCESS;
0946C:  MOVLW  00
0946E:  MOVWF  01
09470:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
09472:  MOVLB  6
09474:  CLRF   x32
09476:  MOVFF  5EF,631
0947A:  CLRF   x34
0947C:  MOVLW  B5
0947E:  MOVWF  x33
09480:  MOVLB  0
09482:  CALL   08AC
09486:  MOVFF  02,601
0948A:  MOVFF  01,600
0948E:  MOVLW  06
09490:  MOVLB  6
09492:  ADDWF  x00,F
09494:  MOVLW  00
09496:  ADDWFC x01,F
09498:  MOVLW  32
0949A:  ADDWF  x00,W
0949C:  MOVWF  01
0949E:  MOVLW  00
094A0:  ADDWFC x01,W
094A2:  MOVWF  03
094A4:  MOVF   01,W
094A6:  ADDLW  6C
094A8:  MOVWF  01
094AA:  MOVLW  01
094AC:  ADDWFC 03,F
094AE:  MOVFF  01,600
094B2:  MOVFF  03,601
094B6:  MOVFF  03,629
094BA:  MOVFF  01,628
094BE:  MOVLB  0
094C0:  CALL   52D4
094C4:  MOVF   01,F
094C6:  BNZ   94D0
094C8:  MOVLW  02
094CA:  MOVWF  01
094CC:  BRA    95C6
094CE:  BRA    952E
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
094D0:  MOVLB  6
094D2:  CLRF   x32
094D4:  MOVFF  5EF,631
094D8:  CLRF   x34
094DA:  MOVLW  B5
094DC:  MOVWF  x33
094DE:  MOVLB  0
094E0:  CALL   08AC
094E4:  MOVFF  02,601
094E8:  MOVFF  01,600
094EC:  MOVLW  06
094EE:  MOVLB  6
094F0:  ADDWF  x00,F
094F2:  MOVLW  00
094F4:  ADDWFC x01,F
094F6:  MOVLW  32
094F8:  ADDWF  x00,W
094FA:  MOVWF  01
094FC:  MOVLW  00
094FE:  ADDWFC x01,W
09500:  MOVWF  03
09502:  MOVF   01,W
09504:  ADDLW  6C
09506:  MOVWF  01
09508:  MOVLW  01
0950A:  ADDWFC 03,F
0950C:  MOVFF  01,600
09510:  MOVFF  03,601
09514:  MOVFF  03,629
09518:  MOVFF  01,628
0951C:  CLRF   x2B
0951E:  CLRF   x2A
09520:  MOVLW  0A
09522:  MOVWF  x2C
09524:  MOVLB  0
09526:  CALL   53C4
0952A:  MOVFF  01,5FB
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%d,%f,", arg1, manualOutputValues[arg1-1]);
0952E:  MOVLW  04
09530:  MOVLB  6
09532:  MOVWF  x32
09534:  MOVLW  42
09536:  MOVWF  x31
09538:  MOVLB  0
0953A:  CALL   515C
0953E:  MOVF   01,W
09540:  ADDLW  42
09542:  MOVLB  6
09544:  MOVWF  x00
09546:  MOVLW  04
09548:  ADDWFC 02,W
0954A:  MOVWF  x01
0954C:  MOVLW  01
0954E:  MOVLB  5
09550:  SUBWF  xFB,W
09552:  MULLW  04
09554:  MOVF   FF3,W
09556:  CLRF   03
09558:  ADDLW  EA
0955A:  MOVWF  FE9
0955C:  MOVLW  00
0955E:  ADDWFC 03,W
09560:  MOVWF  FEA
09562:  MOVFF  FEF,602
09566:  MOVFF  FEC,603
0956A:  MOVFF  FEC,604
0956E:  MOVFF  FEC,605
09572:  MOVFF  601,4E7
09576:  MOVFF  600,4E6
0957A:  MOVFF  5FB,629
0957E:  MOVLW  18
09580:  MOVLB  6
09582:  MOVWF  x2A
09584:  MOVLB  0
09586:  CALL   5718
0958A:  MOVLW  2C
0958C:  MOVLB  6
0958E:  MOVWF  x40
09590:  MOVLB  0
09592:  CALL   520C
09596:  MOVLW  89
09598:  MOVWF  FE9
0959A:  MOVFF  605,636
0959E:  MOVFF  604,635
095A2:  MOVFF  603,634
095A6:  MOVFF  602,633
095AA:  MOVLW  02
095AC:  MOVLB  6
095AE:  MOVWF  x37
095B0:  MOVLB  0
095B2:  CALL   5F50
095B6:  MOVLW  2C
095B8:  MOVLB  6
095BA:  MOVWF  x40
095BC:  MOVLB  0
095BE:  CALL   520C
....................    
....................    return SUCCESS;
095C2:  MOVLW  00
095C4:  MOVWF  01
095C6:  RETURN 0
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
095C8:  MOVLB  6
095CA:  CLRF   x32
095CC:  MOVFF  5EF,631
095D0:  CLRF   x34
095D2:  MOVLW  B5
095D4:  MOVWF  x33
095D6:  MOVLB  0
095D8:  CALL   08AC
095DC:  MOVFF  02,601
095E0:  MOVFF  01,600
095E4:  MOVLW  06
095E6:  MOVLB  6
095E8:  ADDWF  x00,F
095EA:  MOVLW  00
095EC:  ADDWFC x01,F
095EE:  MOVLW  32
095F0:  ADDWF  x00,W
095F2:  MOVWF  01
095F4:  MOVLW  00
095F6:  ADDWFC x01,W
095F8:  MOVWF  03
095FA:  MOVF   01,W
095FC:  ADDLW  6C
095FE:  MOVWF  01
09600:  MOVLW  01
09602:  ADDWFC 03,F
09604:  MOVFF  01,600
09608:  MOVFF  03,601
0960C:  MOVFF  03,629
09610:  MOVFF  01,628
09614:  MOVLB  0
09616:  CALL   52D4
0961A:  MOVF   01,F
0961C:  BNZ   9626
0961E:  MOVLW  02
09620:  MOVWF  01
09622:  BRA    9808
09624:  BRA    9684
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
09626:  MOVLB  6
09628:  CLRF   x32
0962A:  MOVFF  5EF,631
0962E:  CLRF   x34
09630:  MOVLW  B5
09632:  MOVWF  x33
09634:  MOVLB  0
09636:  CALL   08AC
0963A:  MOVFF  02,601
0963E:  MOVFF  01,600
09642:  MOVLW  06
09644:  MOVLB  6
09646:  ADDWF  x00,F
09648:  MOVLW  00
0964A:  ADDWFC x01,F
0964C:  MOVLW  32
0964E:  ADDWF  x00,W
09650:  MOVWF  01
09652:  MOVLW  00
09654:  ADDWFC x01,W
09656:  MOVWF  03
09658:  MOVF   01,W
0965A:  ADDLW  6C
0965C:  MOVWF  01
0965E:  MOVLW  01
09660:  ADDWFC 03,F
09662:  MOVFF  01,600
09666:  MOVFF  03,601
0966A:  MOVFF  03,629
0966E:  MOVFF  01,628
09672:  CLRF   x2B
09674:  CLRF   x2A
09676:  MOVLW  0A
09678:  MOVWF  x2C
0967A:  MOVLB  0
0967C:  CALL   53C4
09680:  MOVFF  01,5FB
....................    
....................    if (!arg_is_float(SERcmd[rec].p[3])) return INV_PARAM;
09684:  MOVLB  6
09686:  CLRF   x32
09688:  MOVFF  5EF,631
0968C:  CLRF   x34
0968E:  MOVLW  B5
09690:  MOVWF  x33
09692:  MOVLB  0
09694:  CALL   08AC
09698:  MOVFF  02,601
0969C:  MOVFF  01,600
096A0:  MOVLW  06
096A2:  MOVLB  6
096A4:  ADDWF  x00,F
096A6:  MOVLW  00
096A8:  ADDWFC x01,F
096AA:  MOVLW  4B
096AC:  ADDWF  x00,W
096AE:  MOVWF  01
096B0:  MOVLW  00
096B2:  ADDWFC x01,W
096B4:  MOVWF  03
096B6:  MOVF   01,W
096B8:  ADDLW  6C
096BA:  MOVWF  01
096BC:  MOVLW  01
096BE:  ADDWFC 03,F
096C0:  MOVFF  01,600
096C4:  MOVFF  03,601
096C8:  MOVFF  03,605
096CC:  MOVFF  01,604
096D0:  MOVLB  0
096D2:  CALL   65DC
096D6:  MOVF   01,F
096D8:  BNZ   96E2
096DA:  MOVLW  02
096DC:  MOVWF  01
096DE:  BRA    9808
096E0:  BRA    9748
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
096E2:  MOVLB  6
096E4:  CLRF   x32
096E6:  MOVFF  5EF,631
096EA:  CLRF   x34
096EC:  MOVLW  B5
096EE:  MOVWF  x33
096F0:  MOVLB  0
096F2:  CALL   08AC
096F6:  MOVFF  02,601
096FA:  MOVFF  01,600
096FE:  MOVLW  06
09700:  MOVLB  6
09702:  ADDWF  x00,F
09704:  MOVLW  00
09706:  ADDWFC x01,F
09708:  MOVLW  4B
0970A:  ADDWF  x00,W
0970C:  MOVWF  01
0970E:  MOVLW  00
09710:  ADDWFC x01,W
09712:  MOVWF  03
09714:  MOVF   01,W
09716:  ADDLW  6C
09718:  MOVWF  01
0971A:  MOVLW  01
0971C:  ADDWFC 03,F
0971E:  MOVFF  01,600
09722:  MOVFF  03,601
09726:  MOVFF  03,605
0972A:  MOVFF  01,604
0972E:  CLRF   x07
09730:  CLRF   x06
09732:  MOVLB  0
09734:  CALL   669E
09738:  MOVFF  03,5FF
0973C:  MOVFF  02,5FE
09740:  MOVFF  01,5FD
09744:  MOVFF  00,5FC
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    if (arg2 > op_upper_bound) manualOutputValues[arg1-1] = op_upper_bound;
09748:  MOVLB  6
0974A:  CLRF   x4E
0974C:  CLRF   x4D
0974E:  MOVLW  7C
09750:  MOVWF  x4C
09752:  MOVLW  84
09754:  MOVWF  x4B
09756:  MOVFF  5FF,652
0975A:  MOVFF  5FE,651
0975E:  MOVFF  5FD,650
09762:  MOVFF  5FC,64F
09766:  MOVLB  0
09768:  CALL   149A
0976C:  BNC   9792
0976E:  MOVLW  01
09770:  MOVLB  5
09772:  SUBWF  xFB,W
09774:  MULLW  04
09776:  MOVF   FF3,W
09778:  CLRF   03
0977A:  ADDLW  EA
0977C:  MOVWF  FE9
0977E:  MOVLW  00
09780:  ADDWFC 03,W
09782:  MOVWF  FEA
09784:  MOVLW  84
09786:  MOVWF  FEF
09788:  MOVLW  7C
0978A:  MOVWF  FEC
0978C:  CLRF   FEC
0978E:  CLRF   FEC
09790:  BRA    9802
....................    else if (arg2 < op_lower_bound) manualOutputValues[arg1-1] = op_lower_bound;  
09792:  MOVFF  5FF,64E
09796:  MOVFF  5FE,64D
0979A:  MOVFF  5FD,64C
0979E:  MOVFF  5FC,64B
097A2:  MOVLB  6
097A4:  CLRF   x52
097A6:  CLRF   x51
097A8:  MOVLW  FC
097AA:  MOVWF  x50
097AC:  MOVLW  84
097AE:  MOVWF  x4F
097B0:  MOVLB  0
097B2:  CALL   149A
097B6:  BNC   97DC
097B8:  MOVLW  01
097BA:  MOVLB  5
097BC:  SUBWF  xFB,W
097BE:  MULLW  04
097C0:  MOVF   FF3,W
097C2:  CLRF   03
097C4:  ADDLW  EA
097C6:  MOVWF  FE9
097C8:  MOVLW  00
097CA:  ADDWFC 03,W
097CC:  MOVWF  FEA
097CE:  MOVLW  84
097D0:  MOVWF  FEF
097D2:  MOVLW  FC
097D4:  MOVWF  FEC
097D6:  CLRF   FEC
097D8:  CLRF   FEC
097DA:  BRA    9802
....................    else manualOutputValues[arg1-1] = arg2;
097DC:  MOVLW  01
097DE:  MOVLB  5
097E0:  SUBWF  xFB,W
097E2:  MULLW  04
097E4:  MOVF   FF3,W
097E6:  CLRF   03
097E8:  ADDLW  EA
097EA:  MOVWF  FE9
097EC:  MOVLW  00
097EE:  ADDWFC 03,W
097F0:  MOVWF  FEA
097F2:  MOVFF  5FC,FEF
097F6:  MOVFF  5FD,FEC
097FA:  MOVFF  5FE,FEC
097FE:  MOVFF  5FF,FEC
....................    
....................    return SUCCESS;
09802:  MOVLW  00
09804:  MOVWF  01
09806:  MOVLB  0
09808:  RETURN 0
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
0980A:  MOVLW  01
0980C:  MOVWF  01
0980E:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
065DC:  MOVLB  6
065DE:  BCF    x06.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
065E0:  CLRF   x07
065E2:  MOVFF  605,632
065E6:  MOVFF  604,631
065EA:  MOVLB  0
065EC:  CALL   515C
065F0:  MOVFF  02,03
065F4:  MOVF   01,W
065F6:  MOVF   03,F
065F8:  BNZ   6604
065FA:  MOVF   01,W
065FC:  MOVLB  6
065FE:  SUBWF  x07,W
06600:  BC    6696
06602:  MOVLB  0
....................       if (!isdigit(arg[i])){
06604:  MOVLB  6
06606:  MOVF   x07,W
06608:  ADDWF  x04,W
0660A:  MOVWF  FE9
0660C:  MOVLW  00
0660E:  ADDWFC x05,W
06610:  MOVWF  FEA
06612:  MOVFF  FEF,608
06616:  MOVF   x08,W
06618:  SUBLW  2F
0661A:  BC    6622
0661C:  MOVF   x08,W
0661E:  SUBLW  39
06620:  BC    668E
....................          // Check for negative sign
....................          if ('-' != arg[i]){
06622:  MOVF   x07,W
06624:  ADDWF  x04,W
06626:  MOVWF  FE9
06628:  MOVLW  00
0662A:  ADDWFC x05,W
0662C:  MOVWF  FEA
0662E:  MOVF   FEF,W
06630:  SUBLW  2D
06632:  BZ    665E
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
06634:  MOVF   x07,W
06636:  ADDWF  x04,W
06638:  MOVWF  FE9
0663A:  MOVLW  00
0663C:  ADDWFC x05,W
0663E:  MOVWF  FEA
06640:  MOVF   FEF,W
06642:  SUBLW  2E
06644:  BZ    664E
06646:  MOVLW  00
06648:  MOVWF  01
0664A:  BRA    669A
0664C:  BRA    665C
....................             else if  (decimal) return FALSE;
0664E:  BTFSS  x06.0
06650:  BRA    665A
06652:  MOVLW  00
06654:  MOVWF  01
06656:  BRA    669A
06658:  BRA    665C
....................             else decimal = TRUE;
0665A:  BSF    x06.0
....................          }
0665C:  BRA    668E
....................          else if (0 != i) return FALSE;
0665E:  MOVF   x07,F
06660:  BZ    666A
06662:  MOVLW  00
06664:  MOVWF  01
06666:  BRA    669A
06668:  BRA    668E
....................          else if (1 == strlen(arg)) return FALSE;
0666A:  MOVFF  605,632
0666E:  MOVFF  604,631
06672:  MOVLB  0
06674:  CALL   515C
06678:  MOVFF  02,03
0667C:  MOVF   01,W
0667E:  SUBLW  01
06680:  BNZ   6690
06682:  MOVF   03,F
06684:  BNZ   6690
06686:  MOVLW  00
06688:  MOVWF  01
0668A:  MOVLB  6
0668C:  BRA    669A
0668E:  MOVLB  0
....................       }
06690:  MOVLB  6
06692:  INCF   x07,F
06694:  BRA    65E2
....................    }
....................    return TRUE;
06696:  MOVLW  01
06698:  MOVWF  01
0669A:  MOVLB  0
0669C:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
052D4:  MOVFF  629,632
052D8:  MOVFF  628,631
052DC:  RCALL  515C
052DE:  MOVFF  02,03
052E2:  MOVF   01,W
052E4:  SUBLW  01
052E6:  BNZ   52EC
052E8:  MOVF   03,F
052EA:  BZ    52F4
052EC:  MOVLW  00
052EE:  MOVWF  01
052F0:  BRA    5322
052F2:  BRA    531A
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
052F4:  MOVLB  6
052F6:  MOVFF  628,FE9
052FA:  MOVFF  629,FEA
052FE:  MOVF   FEF,W
05300:  SUBLW  31
05302:  BZ    531C
05304:  MOVFF  628,FE9
05308:  MOVFF  629,FEA
0530C:  MOVF   FEF,W
0530E:  SUBLW  32
05310:  BZ    531C
05312:  MOVLW  00
05314:  MOVWF  01
05316:  MOVLB  0
05318:  BRA    5322
0531A:  MOVLB  6
....................     return TRUE;
0531C:  MOVLW  01
0531E:  MOVWF  01
05320:  MOVLB  0
05322:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
05122:  MOVLB  5
05124:  MOVF   xFA,W
05126:  SUBLW  2F
05128:  BC    513A
0512A:  MOVF   xFA,W
0512C:  SUBLW  39
0512E:  BNC   513A
05130:  MOVLW  30
05132:  SUBWF  xFA,W
05134:  MOVWF  01
05136:  BRA    5156
05138:  BRA    5156
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
0513A:  MOVF   xFA,W
0513C:  SUBLW  40
0513E:  BC    5152
05140:  MOVF   xFA,W
05142:  SUBLW  46
05144:  BNC   5152
05146:  MOVLW  41
05148:  SUBWF  xFA,W
0514A:  ADDLW  0A
0514C:  MOVWF  01
0514E:  BRA    5156
05150:  BRA    5156
....................    else return 0xFF;
05152:  MOVLW  FF
05154:  MOVWF  01
05156:  MOVLB  0
05158:  GOTO   98B6 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
09810:  MOVLB  6
09812:  CLRF   x32
09814:  MOVFF  5F1,631
09818:  CLRF   x34
0981A:  MOVLW  B5
0981C:  MOVWF  x33
0981E:  MOVLB  0
09820:  CALL   08AC
09824:  MOVFF  02,5FA
09828:  MOVFF  01,5F9
0982C:  MOVLW  06
0982E:  MOVLB  5
09830:  ADDWF  xF9,F
09832:  MOVLW  00
09834:  ADDWFC xFA,F
09836:  MOVLW  6C
09838:  ADDWF  xF9,W
0983A:  MOVWF  01
0983C:  MOVLW  01
0983E:  ADDWFC xFA,W
09840:  MOVWF  03
09842:  MOVFF  01,5F2
09846:  MOVWF  xF3
09848:  MOVLB  6
0984A:  CLRF   x32
0984C:  MOVFF  5F1,631
09850:  CLRF   x34
09852:  MOVLW  B5
09854:  MOVWF  x33
09856:  MOVLB  0
09858:  CALL   08AC
0985C:  MOVFF  02,5FC
09860:  MOVFF  01,5FB
09864:  MOVLW  06
09866:  MOVLB  5
09868:  ADDWF  xFB,F
0986A:  MOVLW  00
0986C:  ADDWFC xFC,F
0986E:  MOVLW  19
09870:  ADDWF  xFB,W
09872:  MOVWF  01
09874:  MOVLW  00
09876:  ADDWFC xFC,W
09878:  MOVWF  03
0987A:  MOVF   01,W
0987C:  ADDLW  6C
0987E:  MOVWF  01
09880:  MOVLW  01
09882:  ADDWFC 03,F
09884:  MOVFF  01,5F4
09888:  MOVFF  03,5F5
0988C:  CLRF   xF6
0988E:  CLRF   xF7
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
09890:  MOVFF  5F2,FE9
09894:  MOVFF  5F3,FEA
09898:  MOVF   FEF,W
0989A:  SUBLW  44
0989C:  BTFSS  FD8.2
0989E:  BRA    998E
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
098A0:  MOVLW  01
098A2:  ADDWF  xF2,W
098A4:  MOVWF  FE9
098A6:  MOVLW  00
098A8:  ADDWFC xF3,W
098AA:  MOVWF  FEA
098AC:  MOVFF  FEF,5FA
098B0:  MOVLB  0
098B2:  GOTO   5122
098B6:  MOVFF  01,5F9
098BA:  MOVLB  5
098BC:  MOVF   xF6,W
098BE:  ANDLW  0F
098C0:  SUBWF  01,W
098C2:  BNZ   9986
....................          while (0 != strlen(cmd_list[i].cmd_name)){
098C4:  MOVF   xF7,W
098C6:  MULLW  04
098C8:  MOVF   FF3,W
098CA:  CLRF   xFA
098CC:  MOVWF  xF9
098CE:  MOVLW  EC
098D0:  ADDWF  xF9,W
098D2:  MOVWF  FE9
098D4:  MOVLW  04
098D6:  ADDWFC xFA,W
098D8:  MOVWF  FEA
098DA:  MOVFF  FEC,632
098DE:  MOVF   FED,F
098E0:  MOVFF  FEF,631
098E4:  MOVLB  0
098E6:  CALL   515C
098EA:  MOVFF  02,03
098EE:  MOVF   01,W
098F0:  BNZ   98F6
098F2:  MOVF   03,F
098F4:  BZ    997C
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
098F6:  MOVLB  5
098F8:  MOVF   xF7,W
098FA:  MULLW  04
098FC:  MOVF   FF3,W
098FE:  CLRF   xFA
09900:  MOVWF  xF9
09902:  MOVLW  EC
09904:  ADDWF  xF9,W
09906:  MOVWF  FE9
09908:  MOVLW  04
0990A:  ADDWFC xFA,W
0990C:  MOVWF  FEA
0990E:  MOVFF  FEC,634
09912:  MOVF   FED,F
09914:  MOVFF  FEF,633
09918:  MOVFF  5F5,632
0991C:  MOVFF  5F4,631
09920:  MOVLB  0
09922:  CALL   5194
09926:  MOVF   01,F
09928:  BNZ   9974
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
0992A:  MOVLB  5
0992C:  MOVF   xF7,W
0992E:  MULLW  04
09930:  MOVF   FF3,W
09932:  CLRF   xFA
09934:  MOVWF  xF9
09936:  MOVLW  02
09938:  ADDWF  xF9,W
0993A:  MOVWF  01
0993C:  MOVLW  00
0993E:  ADDWFC xFA,W
09940:  MOVWF  03
09942:  MOVF   01,W
09944:  ADDLW  EC
09946:  MOVWF  01
09948:  MOVLW  04
0994A:  ADDWFC 03,F
0994C:  MOVFF  01,5F9
09950:  MOVFF  03,5FA
09954:  MOVFF  03,FEA
09958:  MOVFF  01,FE9
0995C:  MOVFF  5F1,5EF
09960:  MOVLB  0
09962:  CALL   00BC
09966:  MOVFF  01,5F8
....................                return return_code;
0996A:  MOVLB  5
0996C:  MOVFF  5F8,01
09970:  BRA    9992
09972:  MOVLB  0
....................             }
....................             i++;
09974:  MOVLB  5
09976:  INCF   xF7,F
09978:  BRA    98C4
0997A:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
0997C:  MOVLW  01
0997E:  MOVWF  01
09980:  MOVLB  5
09982:  BRA    9992
....................       } else return 254; // NOT THIS ADDRESS
09984:  BRA    998C
09986:  MOVLW  FE
09988:  MOVWF  01
0998A:  BRA    9992
....................    } else return 255; // NOT THIS DEVICE TYPE
0998C:  BRA    9992
0998E:  MOVLW  FF
09990:  MOVWF  01
09992:  MOVLB  0
09994:  GOTO   99CE (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
099C0:  GOTO   50C8
099C4:  MOVF   01,F
099C6:  BZ    9AB8
....................    {
....................       int8 return_code = command_parser(SRI);
099C8:  MOVFF  440,5F1
099CC:  BRA    9810
099CE:  MOVFF  01,5F0
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
099D2:  MOVLW  04
099D4:  MOVLB  6
099D6:  MOVWF  x32
099D8:  MOVLW  42
099DA:  MOVWF  x31
099DC:  MOVLB  0
099DE:  CALL   515C
099E2:  MOVF   01,W
099E4:  ADDLW  42
099E6:  MOVLB  5
099E8:  MOVWF  xF1
099EA:  MOVLW  04
099EC:  ADDWFC 02,W
099EE:  MOVWF  xF2
099F0:  MOVF   xF0,W
099F2:  MULLW  03
099F4:  MOVF   FF3,W
099F6:  CLRF   xF4
099F8:  MOVWF  xF3
099FA:  MOVLW  01
099FC:  ADDWF  xF3,W
099FE:  MOVWF  01
09A00:  MOVLW  00
09A02:  ADDWFC xF4,W
09A04:  MOVWF  03
09A06:  MOVF   01,W
09A08:  ADDLW  BB
09A0A:  MOVWF  FE9
09A0C:  MOVLW  05
09A0E:  ADDWFC 03,W
09A10:  MOVWF  FEA
09A12:  MOVFF  FEC,5F4
09A16:  MOVF   FED,F
09A18:  MOVFF  FEF,5F3
09A1C:  MOVFF  5F2,4E7
09A20:  MOVFF  5F1,4E6
09A24:  MOVFF  4E7,FEA
09A28:  MOVFF  4E6,FE9
09A2C:  CLRF   FEF
09A2E:  MOVFF  5F4,FEA
09A32:  MOVFF  5F3,FE9
09A36:  MOVLB  0
09A38:  BRA    9998
....................       fprintf(SERIAL, "$%s,%s\n", SERcmd[SRI].p[0], retData);
09A3A:  MOVLB  6
09A3C:  CLRF   x32
09A3E:  MOVFF  440,631
09A42:  CLRF   x34
09A44:  MOVLW  B5
09A46:  MOVWF  x33
09A48:  MOVLB  0
09A4A:  CALL   08AC
09A4E:  MOVFF  02,5F2
09A52:  MOVFF  01,5F1
09A56:  MOVLW  06
09A58:  MOVLB  5
09A5A:  ADDWF  xF1,F
09A5C:  MOVLW  00
09A5E:  ADDWFC xF2,F
09A60:  MOVLW  6C
09A62:  ADDWF  xF1,W
09A64:  MOVWF  01
09A66:  MOVLW  01
09A68:  ADDWFC xF2,W
09A6A:  MOVWF  03
09A6C:  MOVFF  01,5F3
09A70:  MOVWF  xF4
09A72:  MOVLW  24
09A74:  MOVLB  6
09A76:  MOVWF  x0D
09A78:  MOVLB  0
09A7A:  CALL   4714
09A7E:  MOVFF  5F4,FEA
09A82:  MOVFF  5F3,FE9
09A86:  CALL   473C
09A8A:  MOVLW  2C
09A8C:  MOVLB  6
09A8E:  MOVWF  x0D
09A90:  MOVLB  0
09A92:  CALL   4714
09A96:  MOVLW  04
09A98:  MOVWF  FEA
09A9A:  MOVLW  42
09A9C:  MOVWF  FE9
09A9E:  CALL   473C
09AA2:  MOVLW  0A
09AA4:  MOVLB  6
09AA6:  MOVWF  x0D
09AA8:  MOVLB  0
09AAA:  CALL   4714
....................       
....................       resetSERcmd(SRI);
09AAE:  MOVFF  440,5F1
09AB2:  CALL   08CE
09AB6:  BRA    99C0
....................    }
09AB8:  GOTO   A128 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define DEBUG_1
.................... 
.................... void main()
09ABC:  CLRF   FF8
09ABE:  BCF    FF2.5
09AC0:  BSF    07.7
09AC2:  MOVLB  E
09AC4:  MOVLW  55
09AC6:  MOVWF  x9B
09AC8:  MOVLW  AA
09ACA:  MOVWF  x9B
09ACC:  BCF    x9B.0
09ACE:  MOVLW  17
09AD0:  MOVWF  xB0
09AD2:  MOVLW  13
09AD4:  MOVWF  xB2
09AD6:  MOVLW  09
09AD8:  MOVWF  x8A
09ADA:  MOVLW  0A
09ADC:  MOVWF  x8B
09ADE:  MOVLW  11
09AE0:  MOVWF  xEB
09AE2:  MOVLW  12
09AE4:  MOVWF  xED
09AE6:  MOVLW  10
09AE8:  MOVWF  xF4
09AEA:  MOVLW  0F
09AEC:  MOVWF  xF5
09AEE:  MOVLW  09
09AF0:  MOVWF  xF8
09AF2:  MOVLW  55
09AF4:  MOVWF  x9B
09AF6:  MOVLW  AA
09AF8:  MOVWF  x9B
09AFA:  BSF    x9B.0
09AFC:  CLRF   xD8
09AFE:  CLRF   xD5
09B00:  CLRF   xD7
09B02:  MOVLW  08
09B04:  MOVWF  xD9
09B06:  MOVLW  60
09B08:  MOVWF  xD3
09B0A:  MOVLW  AA
09B0C:  MOVLB  0
09B0E:  MOVWF  xF2
09B10:  MOVLB  1
09B12:  CLRF   x5A
09B14:  CLRF   x59
09B16:  CLRF   x58
09B18:  CLRF   x57
09B1A:  CLRF   x5E
09B1C:  CLRF   x5D
09B1E:  CLRF   x5C
09B20:  CLRF   x5B
09B22:  CLRF   x62
09B24:  CLRF   x61
09B26:  CLRF   x60
09B28:  CLRF   x5F
09B2A:  CLRF   x64
09B2C:  CLRF   x63
09B2E:  MOVLB  E
09B30:  BCF    x91.5
09B32:  MOVLW  00
09B34:  MOVWF  x90
09B36:  MOVLW  0F
09B38:  MOVWF  x8E
09B3A:  MOVLW  2A
09B3C:  MOVWF  x91
09B3E:  MOVLW  C4
09B40:  MOVWF  F88
09B42:  MOVWF  F88
09B44:  MOVWF  F88
09B46:  BCF    F95.5
09B48:  MOVLW  40
09B4A:  MOVWF  F94
09B4C:  MOVLW  9F
09B4E:  MOVWF  F92
09B50:  MOVLW  3A
09B52:  MOVWF  F95
09B54:  MOVLW  93
09B56:  MOVWF  F89
09B58:  MOVWF  F89
09B5A:  MOVLB  4
09B5C:  CLRF   x40
09B5E:  CLRF   x41
09B60:  CLRF   xE2
09B62:  CLRF   xE3
09B64:  BCF    xE4.0
09B66:  CLRF   xE5
09B68:  BSF    F9E.3
09B6A:  MOVLW  7C
09B6C:  MOVWF  F9A
09B6E:  MOVLW  00
09B70:  MOVWF  F9B
09B72:  MOVLW  A6
09B74:  MOVWF  F9D
09B76:  MOVLW  90
09B78:  MOVWF  F9C
09B7A:  MOVLW  93
09B7C:  MOVWF  F89
09B7E:  BCF    F84.5
09B80:  CLRF   xE7
09B82:  CLRF   xE6
09B84:  CLRF   xEB
09B86:  CLRF   xEA
09B88:  CLRF   xE9
09B8A:  CLRF   xE8
09B8C:  MOVLB  F
09B8E:  CLRF   x0C
09B90:  CLRF   x14
09B92:  CLRF   x1C
09B94:  CLRF   x21
09B96:  CLRF   x29
09B98:  CLRF   x35
09B9A:  CLRF   x36
09B9C:  CLRF   x37
09B9E:  CLRF   x34
09BA0:  CLRF   x31
09BA2:  CLRF   x32
09BA4:  CLRF   x33
09BA6:  CLRF   x30
09BA8:  MOVLW  52
09BAA:  MOVLB  4
09BAC:  MOVWF  xEF
09BAE:  MOVLW  4C
09BB0:  MOVWF  xEE
09BB2:  MOVLW  52
09BB4:  MOVWF  xF3
09BB6:  MOVLW  90
09BB8:  MOVWF  xF2
09BBA:  MOVLW  57
09BBC:  MOVWF  xF7
09BBE:  MOVLW  D8
09BC0:  MOVWF  xF6
09BC2:  MOVLW  59
09BC4:  MOVWF  xFB
09BC6:  MOVLW  BC
09BC8:  MOVWF  xFA
09BCA:  MOVLW  5B
09BCC:  MOVWF  xFF
09BCE:  MOVLW  9E
09BD0:  MOVWF  xFE
09BD2:  MOVLW  5D
09BD4:  MOVLB  5
09BD6:  MOVWF  x03
09BD8:  MOVLW  30
09BDA:  MOVWF  x02
09BDC:  MOVLW  61
09BDE:  MOVWF  x07
09BE0:  MOVLW  06
09BE2:  MOVWF  x06
09BE4:  MOVLW  68
09BE6:  MOVWF  x0B
09BE8:  MOVLW  F8
09BEA:  MOVWF  x0A
09BEC:  MOVLW  6B
09BEE:  MOVWF  x0F
09BF0:  MOVLW  E4
09BF2:  MOVWF  x0E
09BF4:  MOVLW  6D
09BF6:  MOVWF  x13
09BF8:  MOVLW  4A
09BFA:  MOVWF  x12
09BFC:  MOVLW  6F
09BFE:  MOVWF  x17
09C00:  MOVLW  0A
09C02:  MOVWF  x16
09C04:  MOVLW  72
09C06:  MOVWF  x1B
09C08:  MOVLW  D8
09C0A:  MOVWF  x1A
09C0C:  MOVLW  78
09C0E:  MOVWF  x1F
09C10:  MOVLW  58
09C12:  MOVWF  x1E
09C14:  MOVLW  7C
09C16:  MOVWF  x23
09C18:  MOVLW  08
09C1A:  MOVWF  x22
09C1C:  MOVLW  81
09C1E:  MOVWF  x27
09C20:  MOVLW  3A
09C22:  MOVWF  x26
09C24:  MOVLW  81
09C26:  MOVWF  x2B
09C28:  MOVLW  40
09C2A:  MOVWF  x2A
09C2C:  MOVLW  87
09C2E:  MOVWF  x2F
09C30:  MOVLW  BA
09C32:  MOVWF  x2E
09C34:  MOVLW  8D
09C36:  MOVWF  x33
09C38:  MOVLW  32
09C3A:  MOVWF  x32
09C3C:  MOVLW  94
09C3E:  MOVWF  x37
09C40:  MOVLW  72
09C42:  MOVWF  x36
09C44:  MOVLW  95
09C46:  MOVWF  x3B
09C48:  MOVLW  C8
09C4A:  MOVWF  x3A
09C4C:  MOVLW  98
09C4E:  MOVWF  x3F
09C50:  MOVLW  0A
09C52:  MOVWF  x3E
09C54:  BRA    9E0C
09C56:  DATA 02,00
09C58:  DATA 1A,00
09C5A:  DATA 00,0C
09C5C:  DATA 00,20
09C5E:  DATA 78,23
09C60:  DATA D7,0A
09C62:  DATA 7D,19
09C64:  DATA 99,9A
09C66:  DATA 7B,4C
09C68:  DATA CC,CD
09C6A:  DATA 14,C0
09C6C:  DATA 00,0C
09C6E:  DATA 80,78
09C70:  DATA 23,D7
09C72:  DATA 0A,7D
09C74:  DATA 19,99
09C76:  DATA 9A,7B
09C78:  DATA 4C,CC
09C7A:  DATA CD,14
09C7C:  DATA C0,00
09C7E:  DATA 01,80
09C80:  DATA 02,09
09C82:  DATA C0,00
09C84:  DATA 05,80
09C86:  DATA 7F,00
09C88:  DATA 00,00
09C8A:  DATA 7F,0B
09C8C:  DATA C0,00
09C8E:  DATA 05,80
09C90:  DATA 7F,00
09C92:  DATA 00,00
09C94:  DATA 7F,07
09C96:  DATA C0,00
09C98:  DATA 01,80
09C9A:  DATA 7F,17
09C9C:  DATA C0,00
09C9E:  DATA 01,80
09CA0:  DATA 7F,17
09CA2:  DATA C0,00
09CA4:  DATA 04,80
09CA6:  DATA 79,B7
09CA8:  DATA F3,BD
09CAA:  DATA 04,C0
09CAC:  DATA 00,04
09CAE:  DATA 80,7C
09CB0:  DATA 59,DF
09CB2:  DATA 4E,04
09CB4:  DATA C0,00
09CB6:  DATA 04,80
09CB8:  DATA 78,0A
09CBA:  DATA 28,88
09CBC:  DATA 04,C0
09CBE:  DATA 00,04
09CC0:  DATA 80,78
09CC2:  DATA 05,EA
09CC4:  DATA 16,04
09CC6:  DATA C0,00
09CC8:  DATA 04,80
09CCA:  DATA 78,1E
09CCC:  DATA 33,D7
09CCE:  DATA 04,C0
09CD0:  DATA 00,04
09CD2:  DATA 80,77
09CD4:  DATA 68,7B
09CD6:  DATA BB,04
09CD8:  DATA C0,00
09CDA:  DATA 04,80
09CDC:  DATA 77,68
09CDE:  DATA 0D,C6
09CE0:  DATA 08,C0
09CE2:  DATA 00,64
09CE4:  DATA 40,F3
09CE6:  DATA 00,07
09CE8:  DATA 41,65
09CEA:  DATA 00,3C
09CEC:  DATA 44,A6
09CEE:  DATA 00,02
09CF0:  DATA 04,EC
09CF2:  DATA 40,05
09CF4:  DATA 02,04
09CF6:  DATA F0,43
09CF8:  DATA 05,02
09CFA:  DATA 04,F4
09CFC:  DATA 46,05
09CFE:  DATA 02,04
09D00:  DATA F8,4D
09D02:  DATA 05,02
09D04:  DATA 04,FC
09D06:  DATA 54,05
09D08:  DATA 02,05
09D0A:  DATA 00,5C
09D0C:  DATA 05,02
09D0E:  DATA 05,04
09D10:  DATA 64,05
09D12:  DATA 02,05
09D14:  DATA 08,69
09D16:  DATA 05,02
09D18:  DATA 05,0C
09D1A:  DATA 6E,05
09D1C:  DATA 02,05
09D1E:  DATA 10,72
09D20:  DATA 05,02
09D22:  DATA 05,14
09D24:  DATA 76,05
09D26:  DATA 02,05
09D28:  DATA 18,7D
09D2A:  DATA 05,02
09D2C:  DATA 05,1C
09D2E:  DATA 83,05
09D30:  DATA 02,05
09D32:  DATA 20,89
09D34:  DATA 05,02
09D36:  DATA 05,24
09D38:  DATA 8F,05
09D3A:  DATA 02,05
09D3C:  DATA 28,95
09D3E:  DATA 05,02
09D40:  DATA 05,2C
09D42:  DATA 9A,05
09D44:  DATA 02,05
09D46:  DATA 30,A3
09D48:  DATA 05,02
09D4A:  DATA 05,34
09D4C:  DATA AB,05
09D4E:  DATA 02,05
09D50:  DATA 38,B2
09D52:  DATA 05,02
09D54:  DATA 05,3C
09D56:  DATA B9,05
09D58:  DATA 78,05
09D5A:  DATA 40,67
09D5C:  DATA 72,00
09D5E:  DATA 67,73
09D60:  DATA 00,67
09D62:  DATA 43,68
09D64:  DATA 4D,61
09D66:  DATA 70,00
09D68:  DATA 73,43
09D6A:  DATA 68,4D
09D6C:  DATA 61,70
09D6E:  DATA 00,67
09D70:  DATA 43,68
09D72:  DATA 4D,6F
09D74:  DATA 64,65
09D76:  DATA 00,73
09D78:  DATA 43,68
09D7A:  DATA 4D,6F
09D7C:  DATA 64,65
09D7E:  DATA 00,67
09D80:  DATA 50,49
09D82:  DATA 44,00
09D84:  DATA 73,50
09D86:  DATA 49,44
09D88:  DATA 00,67
09D8A:  DATA 53,50
09D8C:  DATA 00,73
09D8E:  DATA 53,50
09D90:  DATA 00,67
09D92:  DATA 53,43
09D94:  DATA 61,6C
09D96:  DATA 73,00
09D98:  DATA 67,53
09D9A:  DATA 43,61
09D9C:  DATA 6C,00
09D9E:  DATA 73,53
09DA0:  DATA 43,61
09DA2:  DATA 6C,00
09DA4:  DATA 67,4D
09DA6:  DATA 43,61
09DA8:  DATA 6C,00
09DAA:  DATA 73,4D
09DAC:  DATA 43,61
09DAE:  DATA 6C,00
09DB0:  DATA 67,4D
09DB2:  DATA 6F,6E
09DB4:  DATA 00,67
09DB6:  DATA 50,49
09DB8:  DATA 44,64
09DBA:  DATA 61,74
09DBC:  DATA 61,00
09DBE:  DATA 67,49
09DC0:  DATA 50,64
09DC2:  DATA 61,74
09DC4:  DATA 61,00
09DC6:  DATA 67,4D
09DC8:  DATA 61,6E
09DCA:  DATA 4F,50
09DCC:  DATA 00,73
09DCE:  DATA 4D,61
09DD0:  DATA 6E,4F
09DD2:  DATA 50,04
09DD4:  DATA C0,00
09DD6:  DATA 33,80
09DD8:  DATA C4,05
09DDA:  DATA 01,CC
09DDC:  DATA 05,02
09DDE:  DATA DC,05
09DE0:  DATA 53,55
09DE2:  DATA 43,43
09DE4:  DATA 45,53
09DE6:  DATA 53,00
09DE8:  DATA 49,4E
09DEA:  DATA 56,41
09DEC:  DATA 4C,49
09DEE:  DATA 44,20
09DF0:  DATA 43,4F
09DF2:  DATA 4D,4D
09DF4:  DATA 41,4E
09DF6:  DATA 44,00
09DF8:  DATA 49,4E
09DFA:  DATA 56,41
09DFC:  DATA 4C,49
09DFE:  DATA 44,20
09E00:  DATA 50,41
09E02:  DATA 52,41
09E04:  DATA 4D,45
09E06:  DATA 54,45
09E08:  DATA 52,00
09E0A:  DATA 00,00
09E0C:  MOVLW  00
09E0E:  MOVWF  FF8
09E10:  MOVLW  9C
09E12:  MOVWF  FF7
09E14:  MOVLW  56
09E16:  MOVWF  FF6
09E18:  TBLRD*+
09E1A:  MOVF   FF5,W
09E1C:  MOVWF  00
09E1E:  XORLW  00
09E20:  BZ    9E48
09E22:  TBLRD*+
09E24:  MOVF   FF5,W
09E26:  MOVWF  01
09E28:  BTFSC  FE8.7
09E2A:  BRA    9E36
09E2C:  ANDLW  3F
09E2E:  MOVWF  FEA
09E30:  TBLRD*+
09E32:  MOVFF  FF5,FE9
09E36:  BTFSC  01.6
09E38:  TBLRD*+
09E3A:  BTFSS  01.6
09E3C:  TBLRD*+
09E3E:  MOVFF  FF5,FEE
09E42:  DCFSNZ 00,F
09E44:  BRA    9E18
09E46:  BRA    9E3A
09E48:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
09E4A:  MOVLB  0
09E4C:  GOTO   038E
....................    params_init();                // load parameters
09E50:  GOTO   0636
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
09E54:  GOTO   07F0
....................    control_init();               // initialize the output control DACs
09E58:  GOTO   0888
....................    serial_init();                // setup the serial port
09E5C:  GOTO   0A58
....................    event_timer_init();
09E60:  GOTO   0A7A
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
09E64:  MOVLW  C0
09E66:  IORWF  FF2,F
....................    
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
09E68:  GOTO   0E58
....................       sensor_monitor_task();     //get magnetoresistive sensor data
09E6C:  GOTO   3BBC
....................       control_task();            //output control
09E70:  GOTO   4698
....................       serial_task();             //serial port 
09E74:  GOTO   4760
....................       
....................       #ifdef DEBUG_1
....................       static int8 ch = 0;
....................       fprintf(SERIAL, "#D0,CNT,%u,%.0f,%.0f\n", ch+1, adcVals[ch].sinCounts, adcVals[ch].cosCounts);
09E78:  MOVLW  01
09E7A:  MOVLB  5
09E7C:  ADDWF  xEE,W
09E7E:  MOVWF  xF0
09E80:  MOVF   xEE,W
09E82:  MULLW  21
09E84:  MOVF   FF3,W
09E86:  CLRF   xF2
09E88:  MOVWF  xF1
09E8A:  MOVLW  08
09E8C:  ADDWF  xF1,W
09E8E:  MOVWF  01
09E90:  MOVLW  00
09E92:  ADDWFC xF2,W
09E94:  MOVWF  03
09E96:  MOVF   01,W
09E98:  ADDLW  0F
09E9A:  MOVWF  FE9
09E9C:  MOVLW  01
09E9E:  ADDWFC 03,W
09EA0:  MOVWF  FEA
09EA2:  MOVFF  FEF,5F1
09EA6:  MOVFF  FEC,5F2
09EAA:  MOVFF  FEC,5F3
09EAE:  MOVFF  FEC,5F4
09EB2:  MOVF   xEE,W
09EB4:  MULLW  21
09EB6:  MOVF   FF3,W
09EB8:  CLRF   xF6
09EBA:  MOVWF  xF5
09EBC:  MOVLW  0C
09EBE:  ADDWF  xF5,W
09EC0:  MOVWF  01
09EC2:  MOVLW  00
09EC4:  ADDWFC xF6,W
09EC6:  MOVWF  03
09EC8:  MOVF   01,W
09ECA:  ADDLW  0F
09ECC:  MOVWF  FE9
09ECE:  MOVLW  01
09ED0:  ADDWFC 03,W
09ED2:  MOVWF  FEA
09ED4:  MOVFF  FEF,5F5
09ED8:  MOVFF  FEC,5F6
09EDC:  MOVFF  FEC,5F7
09EE0:  MOVFF  FEC,5F8
09EE4:  MOVLW  42
09EE6:  MOVWF  FF6
09EE8:  MOVLW  03
09EEA:  MOVWF  FF7
09EEC:  MOVLW  08
09EEE:  MOVWF  xF9
09EF0:  MOVLB  0
09EF2:  CALL   4C78
09EF6:  MOVFF  5F0,5F9
09EFA:  MOVLW  1B
09EFC:  MOVLB  5
09EFE:  MOVWF  xFA
09F00:  MOVLB  0
09F02:  CALL   4CCC
09F06:  MOVLW  2C
09F08:  MOVLB  6
09F0A:  MOVWF  x0D
09F0C:  MOVLB  0
09F0E:  CALL   4714
09F12:  MOVLW  89
09F14:  MOVWF  FE9
09F16:  MOVFF  5F4,5FC
09F1A:  MOVFF  5F3,5FB
09F1E:  MOVFF  5F2,5FA
09F22:  MOVFF  5F1,5F9
09F26:  MOVLB  5
09F28:  CLRF   xFD
09F2A:  MOVLB  0
09F2C:  CALL   4E1E
09F30:  MOVLW  2C
09F32:  MOVLB  6
09F34:  MOVWF  x0D
09F36:  MOVLB  0
09F38:  CALL   4714
09F3C:  MOVLW  89
09F3E:  MOVWF  FE9
09F40:  MOVFF  5F8,5FC
09F44:  MOVFF  5F7,5FB
09F48:  MOVFF  5F6,5FA
09F4C:  MOVFF  5F5,5F9
09F50:  MOVLB  5
09F52:  CLRF   xFD
09F54:  MOVLB  0
09F56:  CALL   4E1E
09F5A:  MOVLW  0A
09F5C:  MOVLB  6
09F5E:  MOVWF  x0D
09F60:  MOVLB  0
09F62:  CALL   4714
....................       fprintf(SERIAL, "#D0,POS,%u,%3.3f\n", ch+1, adcVals[ch].pReal);
09F66:  MOVLW  01
09F68:  MOVLB  5
09F6A:  ADDWF  xEE,W
09F6C:  MOVWF  xF0
09F6E:  MOVF   xEE,W
09F70:  MULLW  21
09F72:  MOVF   FF3,W
09F74:  CLRF   xF2
09F76:  MOVWF  xF1
09F78:  MOVLW  1D
09F7A:  ADDWF  xF1,W
09F7C:  MOVWF  01
09F7E:  MOVLW  00
09F80:  ADDWFC xF2,W
09F82:  MOVWF  03
09F84:  MOVF   01,W
09F86:  ADDLW  0F
09F88:  MOVWF  FE9
09F8A:  MOVLW  01
09F8C:  ADDWFC 03,W
09F8E:  MOVWF  FEA
09F90:  MOVFF  FEF,5F1
09F94:  MOVFF  FEC,5F2
09F98:  MOVFF  FEC,5F3
09F9C:  MOVFF  FEC,5F4
09FA0:  MOVLW  58
09FA2:  MOVWF  FF6
09FA4:  MOVLW  03
09FA6:  MOVWF  FF7
09FA8:  MOVLW  08
09FAA:  MOVWF  xF9
09FAC:  MOVLB  0
09FAE:  CALL   4C78
09FB2:  MOVFF  5F0,5F9
09FB6:  MOVLW  1B
09FB8:  MOVLB  5
09FBA:  MOVWF  xFA
09FBC:  MOVLB  0
09FBE:  CALL   4CCC
09FC2:  MOVLW  2C
09FC4:  MOVLB  6
09FC6:  MOVWF  x0D
09FC8:  MOVLB  0
09FCA:  CALL   4714
09FCE:  MOVLW  89
09FD0:  MOVWF  FE9
09FD2:  MOVFF  5F4,5FC
09FD6:  MOVFF  5F3,5FB
09FDA:  MOVFF  5F2,5FA
09FDE:  MOVFF  5F1,5F9
09FE2:  MOVLW  03
09FE4:  MOVLB  5
09FE6:  MOVWF  xFD
09FE8:  MOVLB  0
09FEA:  CALL   4E1E
09FEE:  MOVLW  0A
09FF0:  MOVLB  6
09FF2:  MOVWF  x0D
09FF4:  MOVLB  0
09FF6:  CALL   4714
....................       if ( dacVals[ch].invV ) fprintf(SERIAL, "#D0,OUT,%u,-,%Lu\n", ch+1, dacVals[ch].val);
09FFA:  MOVLB  5
09FFC:  MOVF   xEE,W
09FFE:  MULLW  03
0A000:  MOVF   FF3,W
0A002:  CLRF   xF1
0A004:  MOVWF  xF0
0A006:  MOVLW  02
0A008:  ADDWF  xF0,W
0A00A:  MOVWF  01
0A00C:  MOVLW  00
0A00E:  ADDWFC xF1,W
0A010:  MOVWF  03
0A012:  MOVF   01,W
0A014:  ADDLW  51
0A016:  MOVWF  FE9
0A018:  MOVLW  01
0A01A:  ADDWFC 03,W
0A01C:  MOVWF  FEA
0A01E:  BTFSS  FEF.0
0A020:  BRA    A09E
0A022:  MOVLW  01
0A024:  ADDWF  xEE,W
0A026:  MOVWF  xF0
0A028:  MOVF   xEE,W
0A02A:  MULLW  03
0A02C:  MOVF   FF3,W
0A02E:  CLRF   xF2
0A030:  MOVWF  xF1
0A032:  MOVLW  51
0A034:  ADDWF  xF1,W
0A036:  MOVWF  FE9
0A038:  MOVLW  01
0A03A:  ADDWFC xF2,W
0A03C:  MOVWF  FEA
0A03E:  MOVFF  FEC,5F4
0A042:  MOVF   FED,F
0A044:  MOVFF  FEF,5F3
0A048:  MOVLW  6A
0A04A:  MOVWF  FF6
0A04C:  MOVLW  03
0A04E:  MOVWF  FF7
0A050:  MOVLW  08
0A052:  MOVWF  xF9
0A054:  MOVLB  0
0A056:  CALL   4C78
0A05A:  MOVFF  5F0,5F9
0A05E:  MOVLW  1B
0A060:  MOVLB  5
0A062:  MOVWF  xFA
0A064:  MOVLB  0
0A066:  CALL   4CCC
0A06A:  MOVLW  74
0A06C:  MOVWF  FF6
0A06E:  MOVLW  03
0A070:  MOVWF  FF7
0A072:  MOVLW  03
0A074:  MOVLB  5
0A076:  MOVWF  xF9
0A078:  MOVLB  0
0A07A:  CALL   4C78
0A07E:  MOVLW  10
0A080:  MOVWF  FE9
0A082:  MOVFF  5F4,5F6
0A086:  MOVFF  5F3,5F5
0A08A:  CALL   5000
0A08E:  MOVLW  0A
0A090:  MOVLB  6
0A092:  MOVWF  x0D
0A094:  MOVLB  0
0A096:  CALL   4714
0A09A:  BRA    A116
0A09C:  MOVLB  5
....................       else                    fprintf(SERIAL, "#D0,OUT,%u,+,%Lu\n", ch+1, dacVals[ch].val);
0A09E:  MOVLW  01
0A0A0:  ADDWF  xEE,W
0A0A2:  MOVWF  xF0
0A0A4:  MOVF   xEE,W
0A0A6:  MULLW  03
0A0A8:  MOVF   FF3,W
0A0AA:  CLRF   xF2
0A0AC:  MOVWF  xF1
0A0AE:  MOVLW  51
0A0B0:  ADDWF  xF1,W
0A0B2:  MOVWF  FE9
0A0B4:  MOVLW  01
0A0B6:  ADDWFC xF2,W
0A0B8:  MOVWF  FEA
0A0BA:  MOVFF  FEC,5F4
0A0BE:  MOVF   FED,F
0A0C0:  MOVFF  FEF,5F3
0A0C4:  MOVLW  7C
0A0C6:  MOVWF  FF6
0A0C8:  MOVLW  03
0A0CA:  MOVWF  FF7
0A0CC:  MOVLW  08
0A0CE:  MOVWF  xF9
0A0D0:  MOVLB  0
0A0D2:  CALL   4C78
0A0D6:  MOVFF  5F0,5F9
0A0DA:  MOVLW  1B
0A0DC:  MOVLB  5
0A0DE:  MOVWF  xFA
0A0E0:  MOVLB  0
0A0E2:  CALL   4CCC
0A0E6:  MOVLW  86
0A0E8:  MOVWF  FF6
0A0EA:  MOVLW  03
0A0EC:  MOVWF  FF7
0A0EE:  MOVLW  03
0A0F0:  MOVLB  5
0A0F2:  MOVWF  xF9
0A0F4:  MOVLB  0
0A0F6:  CALL   4C78
0A0FA:  MOVLW  10
0A0FC:  MOVWF  FE9
0A0FE:  MOVFF  5F4,5F6
0A102:  MOVFF  5F3,5F5
0A106:  CALL   5000
0A10A:  MOVLW  0A
0A10C:  MOVLB  6
0A10E:  MOVWF  x0D
0A110:  MOVLB  0
0A112:  CALL   4714
....................       ch = !ch;
0A116:  MOVLB  5
0A118:  MOVF   xEE,F
0A11A:  BZ    A120
0A11C:  MOVLW  00
0A11E:  BRA    A122
0A120:  MOVLW  01
0A122:  MOVWF  xEE
....................       #endif
....................       
....................       command_handler_task();    //execute commands
0A124:  MOVLB  0
0A126:  BRA    99C0
....................       
....................       delay_ms(100);
0A128:  MOVLW  64
0A12A:  MOVLB  5
0A12C:  MOVWF  xF5
0A12E:  MOVLB  0
0A130:  CALL   0424
0A134:  BRA    9E68
....................    }
.................... }
0A136:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
