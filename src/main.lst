CCS PCH C Compiler, Version 5.109, 62303               12-Jun-25 16:17

               Filename:   C:\Users\aidan\Documents\GitHub\DiFCS-Controller\src\main.lst

               ROM used:   29068 bytes (44%)
                           Largest free fragment is 36466
               RAM used:   1474 (41%) at main() level
                           1583 (44%) worst case
               Stack used: 7 locations (4 in main + 3 for interrupts)
               Stack size: 31

*
00000:  NOP   
00002:  GOTO   6E0C
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  00,0E
00048:  MOVFF  01,0F
0004C:  MOVFF  02,10
00050:  MOVFF  03,11
00054:  MOVLB  E
00056:  BTFSS  xC0.5
00058:  GOTO   0062
0005C:  BTFSC  xC8.5
0005E:  GOTO   00E8
00062:  BTFSS  xC1.0
00064:  GOTO   006E
00068:  BTFSC  xC9.0
0006A:  GOTO   021E
0006E:  MOVFF  0E,00
00072:  MOVFF  0F,01
00076:  MOVFF  10,02
0007A:  MOVFF  11,03
0007E:  MOVFF  0C,FE9
00082:  MOVFF  07,FEA
00086:  BSF    07.7
00088:  MOVFF  08,FE1
0008C:  MOVFF  09,FE2
00090:  MOVFF  0A,FD9
00094:  MOVFF  0B,FDA
00098:  MOVFF  12,FF3
0009C:  MOVFF  13,FF4
000A0:  MOVFF  14,FFA
000A4:  MOVFF  15,FF5
000A8:  MOVFF  16,FF6
000AC:  MOVFF  17,FF7
000B0:  MOVF   04,W
000B2:  MOVFF  06,FE0
000B6:  MOVFF  05,FD8
000BA:  RETFIE 0
.................... #include <main.h>
.................... #include <18F46Q10.h>
.................... //////////// Standard Header file for the PIC18F46Q10 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2020 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F46Q10
000BC:  MOVFF  FEC,FFA
000C0:  MOVF   FED,F
000C2:  MOVFF  FEF,FE8
000C6:  MOVWF  FF9
000C8:  RETURN 0
*
002F2:  DATA 32,30
002F4:  DATA 32,35
002F6:  DATA 30,35
002F8:  DATA 32,32
002FA:  DATA 00,00
002FC:  DATA 30,30
002FE:  DATA 30,30
00300:  DATA 00,00
00302:  DATA 56,4F
00304:  DATA 4C,54
00306:  DATA 41,47
00308:  DATA 45,2C
0030A:  DATA 00,00
0030C:  DATA 4D,41
0030E:  DATA 47,53
00310:  DATA 45,4E
00312:  DATA 53,2C
00314:  DATA 00,00
*
0081A:  MOVLB  5
0081C:  MOVF   xE4,W
0081E:  MULWF  xE6
00820:  MOVFF  FF3,01
00824:  MOVFF  FF4,00
00828:  MULWF  xE7
0082A:  MOVF   FF3,W
0082C:  ADDWF  00,F
0082E:  MOVF   xE5,W
00830:  MULWF  xE6
00832:  MOVF   FF3,W
00834:  ADDWFC 00,W
00836:  MOVWF  02
00838:  MOVLB  0
0083A:  RETURN 0
*
00A12:  MOVLW  8E
00A14:  MOVWF  00
00A16:  MOVFF  61A,01
00A1A:  MOVFF  619,02
00A1E:  CLRF   03
00A20:  MOVF   01,F
00A22:  BNZ   0A36
00A24:  MOVFF  02,01
00A28:  CLRF   02
00A2A:  MOVLW  08
00A2C:  SUBWF  00,F
00A2E:  MOVF   01,F
00A30:  BNZ   0A36
00A32:  CLRF   00
00A34:  BRA    0A46
00A36:  BCF    FD8.0
00A38:  BTFSC  01.7
00A3A:  BRA    0A44
00A3C:  RLCF   02,F
00A3E:  RLCF   01,F
00A40:  DECF   00,F
00A42:  BRA    0A36
00A44:  BCF    01.7
00A46:  RETURN 0
00A48:  MOVLB  6
00A4A:  MOVF   x15,W
00A4C:  BTFSC  FD8.2
00A4E:  BRA    0B32
00A50:  MOVWF  00
00A52:  MOVF   x19,W
00A54:  BTFSC  FD8.2
00A56:  BRA    0B32
00A58:  ADDWF  00,F
00A5A:  BNC   0A64
00A5C:  MOVLW  81
00A5E:  ADDWF  00,F
00A60:  BC    0B32
00A62:  BRA    0A6C
00A64:  MOVLW  7F
00A66:  SUBWF  00,F
00A68:  BNC   0B32
00A6A:  BZ    0B32
00A6C:  MOVFF  616,61D
00A70:  MOVF   x1A,W
00A72:  XORWF  x1D,F
00A74:  BSF    x16.7
00A76:  BSF    x1A.7
00A78:  MOVF   x18,W
00A7A:  MULWF  x1C
00A7C:  MOVFF  FF4,61F
00A80:  MOVF   x17,W
00A82:  MULWF  x1B
00A84:  MOVFF  FF4,03
00A88:  MOVFF  FF3,61E
00A8C:  MULWF  x1C
00A8E:  MOVF   FF3,W
00A90:  ADDWF  x1F,F
00A92:  MOVF   FF4,W
00A94:  ADDWFC x1E,F
00A96:  MOVLW  00
00A98:  ADDWFC 03,F
00A9A:  MOVF   x18,W
00A9C:  MULWF  x1B
00A9E:  MOVF   FF3,W
00AA0:  ADDWF  x1F,F
00AA2:  MOVF   FF4,W
00AA4:  ADDWFC x1E,F
00AA6:  MOVLW  00
00AA8:  CLRF   02
00AAA:  ADDWFC 03,F
00AAC:  ADDWFC 02,F
00AAE:  MOVF   x16,W
00AB0:  MULWF  x1C
00AB2:  MOVF   FF3,W
00AB4:  ADDWF  x1E,F
00AB6:  MOVF   FF4,W
00AB8:  ADDWFC 03,F
00ABA:  MOVLW  00
00ABC:  ADDWFC 02,F
00ABE:  MOVF   x16,W
00AC0:  MULWF  x1B
00AC2:  MOVF   FF3,W
00AC4:  ADDWF  03,F
00AC6:  MOVF   FF4,W
00AC8:  ADDWFC 02,F
00ACA:  MOVLW  00
00ACC:  CLRF   01
00ACE:  ADDWFC 01,F
00AD0:  MOVF   x18,W
00AD2:  MULWF  x1A
00AD4:  MOVF   FF3,W
00AD6:  ADDWF  x1E,F
00AD8:  MOVF   FF4,W
00ADA:  ADDWFC 03,F
00ADC:  MOVLW  00
00ADE:  ADDWFC 02,F
00AE0:  ADDWFC 01,F
00AE2:  MOVF   x17,W
00AE4:  MULWF  x1A
00AE6:  MOVF   FF3,W
00AE8:  ADDWF  03,F
00AEA:  MOVF   FF4,W
00AEC:  ADDWFC 02,F
00AEE:  MOVLW  00
00AF0:  ADDWFC 01,F
00AF2:  MOVF   x16,W
00AF4:  MULWF  x1A
00AF6:  MOVF   FF3,W
00AF8:  ADDWF  02,F
00AFA:  MOVF   FF4,W
00AFC:  ADDWFC 01,F
00AFE:  INCF   00,F
00B00:  BTFSC  01.7
00B02:  BRA    0B0E
00B04:  RLCF   x1E,F
00B06:  RLCF   03,F
00B08:  RLCF   02,F
00B0A:  RLCF   01,F
00B0C:  DECF   00,F
00B0E:  MOVLW  00
00B10:  BTFSS  x1E.7
00B12:  BRA    0B28
00B14:  INCF   03,F
00B16:  ADDWFC 02,F
00B18:  ADDWFC 01,F
00B1A:  MOVF   01,W
00B1C:  BNZ   0B28
00B1E:  MOVF   02,W
00B20:  BNZ   0B28
00B22:  MOVF   03,W
00B24:  BNZ   0B28
00B26:  INCF   00,F
00B28:  BTFSC  x1D.7
00B2A:  BSF    01.7
00B2C:  BTFSS  x1D.7
00B2E:  BCF    01.7
00B30:  BRA    0B3A
00B32:  CLRF   00
00B34:  CLRF   01
00B36:  CLRF   02
00B38:  CLRF   03
00B3A:  MOVLB  0
00B3C:  RETURN 0
00B3E:  MOVLW  80
00B40:  BTFSS  FD8.1
00B42:  BRA    0B48
00B44:  MOVLB  6
00B46:  XORWF  x1E,F
00B48:  MOVLB  6
00B4A:  CLRF   x23
00B4C:  CLRF   x24
00B4E:  MOVFF  61A,622
00B52:  MOVF   x1E,W
00B54:  XORWF  x22,F
00B56:  MOVF   x19,W
00B58:  BTFSC  FD8.2
00B5A:  BRA    0D1A
00B5C:  MOVWF  x21
00B5E:  MOVWF  00
00B60:  MOVF   x1D,W
00B62:  BTFSC  FD8.2
00B64:  BRA    0D2C
00B66:  SUBWF  x21,F
00B68:  BTFSC  FD8.2
00B6A:  BRA    0C72
00B6C:  BNC   0BEA
00B6E:  MOVFF  61E,627
00B72:  BSF    x27.7
00B74:  MOVFF  61F,626
00B78:  MOVFF  620,625
00B7C:  CLRF   x24
00B7E:  BCF    FD8.0
00B80:  RRCF   x27,F
00B82:  RRCF   x26,F
00B84:  RRCF   x25,F
00B86:  RRCF   x24,F
00B88:  DECFSZ x21,F
00B8A:  BRA    0B7C
00B8C:  BTFSS  x22.7
00B8E:  BRA    0B96
00B90:  BSF    x23.0
00B92:  BRA    0D54
00B94:  BCF    x23.0
00B96:  BCF    x21.0
00B98:  BSF    x23.4
00B9A:  MOVLW  06
00B9C:  MOVWF  FEA
00B9E:  MOVLW  1C
00BA0:  MOVWF  FE9
00BA2:  BRA    0D7A
00BA4:  BCF    x23.4
00BA6:  BTFSC  x22.7
00BA8:  BRA    0BBE
00BAA:  BTFSS  x21.0
00BAC:  BRA    0BD4
00BAE:  RRCF   x27,F
00BB0:  RRCF   x26,F
00BB2:  RRCF   x25,F
00BB4:  RRCF   x24,F
00BB6:  INCF   00,F
00BB8:  BTFSC  FD8.2
00BBA:  BRA    0D4A
00BBC:  BRA    0BD4
00BBE:  BTFSC  x27.7
00BC0:  BRA    0BDA
00BC2:  BCF    FD8.0
00BC4:  RLCF   x24,F
00BC6:  RLCF   x25,F
00BC8:  RLCF   x26,F
00BCA:  RLCF   x27,F
00BCC:  DECF   00,F
00BCE:  BTFSC  FD8.2
00BD0:  BRA    0D4A
00BD2:  BRA    0BBE
00BD4:  BSF    x23.6
00BD6:  BRA    0CB2
00BD8:  BCF    x23.6
00BDA:  MOVFF  61A,622
00BDE:  BTFSS  x1A.7
00BE0:  BRA    0BE6
00BE2:  BSF    x27.7
00BE4:  BRA    0D3C
00BE6:  BCF    x27.7
00BE8:  BRA    0D3C
00BEA:  MOVFF  61D,621
00BEE:  MOVFF  61D,00
00BF2:  MOVF   x19,W
00BF4:  SUBWF  x21,F
00BF6:  MOVFF  61A,627
00BFA:  BSF    x27.7
00BFC:  MOVFF  61B,626
00C00:  MOVFF  61C,625
00C04:  CLRF   x24
00C06:  BCF    FD8.0
00C08:  RRCF   x27,F
00C0A:  RRCF   x26,F
00C0C:  RRCF   x25,F
00C0E:  RRCF   x24,F
00C10:  DECFSZ x21,F
00C12:  BRA    0C04
00C14:  BTFSS  x22.7
00C16:  BRA    0C1E
00C18:  BSF    x23.1
00C1A:  BRA    0D54
00C1C:  BCF    x23.1
00C1E:  BCF    x21.0
00C20:  BSF    x23.5
00C22:  MOVLW  06
00C24:  MOVWF  FEA
00C26:  MOVLW  20
00C28:  MOVWF  FE9
00C2A:  BRA    0D7A
00C2C:  BCF    x23.5
00C2E:  BTFSC  x22.7
00C30:  BRA    0C46
00C32:  BTFSS  x21.0
00C34:  BRA    0C5C
00C36:  RRCF   x27,F
00C38:  RRCF   x26,F
00C3A:  RRCF   x25,F
00C3C:  RRCF   x24,F
00C3E:  INCF   00,F
00C40:  BTFSC  FD8.2
00C42:  BRA    0D4A
00C44:  BRA    0C5C
00C46:  BTFSC  x27.7
00C48:  BRA    0C62
00C4A:  BCF    FD8.0
00C4C:  RLCF   x24,F
00C4E:  RLCF   x25,F
00C50:  RLCF   x26,F
00C52:  RLCF   x27,F
00C54:  DECF   00,F
00C56:  BTFSC  FD8.2
00C58:  BRA    0D4A
00C5A:  BRA    0C46
00C5C:  BSF    x23.7
00C5E:  BRA    0CB2
00C60:  BCF    x23.7
00C62:  MOVFF  61E,622
00C66:  BTFSS  x1E.7
00C68:  BRA    0C6E
00C6A:  BSF    x27.7
00C6C:  BRA    0D3C
00C6E:  BCF    x27.7
00C70:  BRA    0D3C
00C72:  MOVFF  61E,627
00C76:  BSF    x27.7
00C78:  MOVFF  61F,626
00C7C:  MOVFF  620,625
00C80:  BTFSS  x22.7
00C82:  BRA    0C8C
00C84:  BCF    x27.7
00C86:  BSF    x23.2
00C88:  BRA    0D54
00C8A:  BCF    x23.2
00C8C:  CLRF   x24
00C8E:  BCF    x21.0
00C90:  MOVLW  06
00C92:  MOVWF  FEA
00C94:  MOVLW  1C
00C96:  MOVWF  FE9
00C98:  BRA    0D7A
00C9A:  BTFSC  x22.7
00C9C:  BRA    0CD6
00C9E:  MOVFF  61A,622
00CA2:  BTFSS  x21.0
00CA4:  BRA    0CB2
00CA6:  RRCF   x27,F
00CA8:  RRCF   x26,F
00CAA:  RRCF   x25,F
00CAC:  RRCF   x24,F
00CAE:  INCF   00,F
00CB0:  BZ    0D4A
00CB2:  BTFSS  x24.7
00CB4:  BRA    0CCC
00CB6:  INCF   x25,F
00CB8:  BNZ   0CCC
00CBA:  INCF   x26,F
00CBC:  BNZ   0CCC
00CBE:  INCF   x27,F
00CC0:  BNZ   0CCC
00CC2:  RRCF   x27,F
00CC4:  RRCF   x26,F
00CC6:  RRCF   x25,F
00CC8:  INCF   00,F
00CCA:  BZ    0D4A
00CCC:  BTFSC  x23.6
00CCE:  BRA    0BD8
00CD0:  BTFSC  x23.7
00CD2:  BRA    0C60
00CD4:  BRA    0D0E
00CD6:  MOVLW  80
00CD8:  XORWF  x27,F
00CDA:  BTFSS  x27.7
00CDC:  BRA    0CE6
00CDE:  BRA    0D54
00CE0:  MOVFF  61E,622
00CE4:  BRA    0CFA
00CE6:  MOVFF  61A,622
00CEA:  MOVF   x27,F
00CEC:  BNZ   0CFA
00CEE:  MOVF   x26,F
00CF0:  BNZ   0CFA
00CF2:  MOVF   x25,F
00CF4:  BNZ   0CFA
00CF6:  CLRF   00
00CF8:  BRA    0D3C
00CFA:  BTFSC  x27.7
00CFC:  BRA    0D0E
00CFE:  BCF    FD8.0
00D00:  RLCF   x24,F
00D02:  RLCF   x25,F
00D04:  RLCF   x26,F
00D06:  RLCF   x27,F
00D08:  DECFSZ 00,F
00D0A:  BRA    0CFA
00D0C:  BRA    0D4A
00D0E:  BTFSS  x22.7
00D10:  BRA    0D16
00D12:  BSF    x27.7
00D14:  BRA    0D3C
00D16:  BCF    x27.7
00D18:  BRA    0D3C
00D1A:  MOVFF  61D,00
00D1E:  MOVFF  61E,627
00D22:  MOVFF  61F,626
00D26:  MOVFF  620,625
00D2A:  BRA    0D3C
00D2C:  MOVFF  619,00
00D30:  MOVFF  61A,627
00D34:  MOVFF  61B,626
00D38:  MOVFF  61C,625
00D3C:  MOVFF  627,01
00D40:  MOVFF  626,02
00D44:  MOVFF  625,03
00D48:  BRA    0DB2
00D4A:  CLRF   00
00D4C:  CLRF   01
00D4E:  CLRF   02
00D50:  CLRF   03
00D52:  BRA    0DB2
00D54:  CLRF   x24
00D56:  COMF   x25,F
00D58:  COMF   x26,F
00D5A:  COMF   x27,F
00D5C:  COMF   x24,F
00D5E:  INCF   x24,F
00D60:  BNZ   0D6C
00D62:  INCF   x25,F
00D64:  BNZ   0D6C
00D66:  INCF   x26,F
00D68:  BNZ   0D6C
00D6A:  INCF   x27,F
00D6C:  BTFSC  x23.0
00D6E:  BRA    0B94
00D70:  BTFSC  x23.1
00D72:  BRA    0C1C
00D74:  BTFSC  x23.2
00D76:  BRA    0C8A
00D78:  BRA    0CE0
00D7A:  MOVF   FEF,W
00D7C:  ADDWF  x25,F
00D7E:  BNC   0D8A
00D80:  INCF   x26,F
00D82:  BNZ   0D8A
00D84:  INCF   x27,F
00D86:  BTFSC  FD8.2
00D88:  BSF    x21.0
00D8A:  MOVF   FED,F
00D8C:  MOVF   FEF,W
00D8E:  ADDWF  x26,F
00D90:  BNC   0D98
00D92:  INCF   x27,F
00D94:  BTFSC  FD8.2
00D96:  BSF    x21.0
00D98:  MOVF   FED,F
00D9A:  MOVF   FEF,W
00D9C:  BTFSC  FEF.7
00D9E:  BRA    0DA2
00DA0:  XORLW  80
00DA2:  ADDWF  x27,F
00DA4:  BTFSC  FD8.0
00DA6:  BSF    x21.0
00DA8:  BTFSC  x23.4
00DAA:  BRA    0BA4
00DAC:  BTFSC  x23.5
00DAE:  BRA    0C2C
00DB0:  BRA    0C9A
00DB2:  MOVLB  0
00DB4:  RETURN 0
*
01342:  MOVLW  B6
01344:  MOVWF  00
01346:  CLRF   03
01348:  CLRF   02
0134A:  CLRF   01
0134C:  MOVLB  5
0134E:  MOVF   xDF,W
01350:  IORWF  xE0,W
01352:  IORWF  xE1,W
01354:  IORWF  xE2,W
01356:  BNZ   135C
01358:  CLRF   00
0135A:  BRA    1376
0135C:  BCF    FD8.0
0135E:  BTFSC  01.7
01360:  BRA    1374
01362:  RLCF   xDF,F
01364:  RLCF   xE0,F
01366:  RLCF   xE1,F
01368:  RLCF   xE2,F
0136A:  RLCF   03,F
0136C:  RLCF   02,F
0136E:  RLCF   01,F
01370:  DECFSZ 00,F
01372:  BRA    135C
01374:  BCF    01.7
01376:  MOVLB  0
01378:  RETURN 0
0137A:  MOVFF  616,61D
0137E:  MOVLB  6
01380:  MOVF   x1A,W
01382:  XORWF  x1D,F
01384:  BTFSS  x1D.7
01386:  BRA    1392
01388:  BCF    FD8.2
0138A:  BCF    FD8.0
0138C:  BTFSC  x16.7
0138E:  BSF    FD8.0
01390:  BRA    13F0
01392:  MOVFF  616,61D
01396:  MOVFF  619,61E
0139A:  MOVF   x15,W
0139C:  SUBWF  x1E,F
0139E:  BZ    13AC
013A0:  BTFSS  x1D.7
013A2:  BRA    13F0
013A4:  MOVF   FD8,W
013A6:  XORLW  01
013A8:  MOVWF  FD8
013AA:  BRA    13F0
013AC:  MOVFF  61A,61E
013B0:  MOVF   x16,W
013B2:  SUBWF  x1E,F
013B4:  BZ    13C2
013B6:  BTFSS  x1D.7
013B8:  BRA    13F0
013BA:  MOVF   FD8,W
013BC:  XORLW  01
013BE:  MOVWF  FD8
013C0:  BRA    13F0
013C2:  MOVFF  61B,61E
013C6:  MOVF   x17,W
013C8:  SUBWF  x1E,F
013CA:  BZ    13D8
013CC:  BTFSS  x1D.7
013CE:  BRA    13F0
013D0:  MOVF   FD8,W
013D2:  XORLW  01
013D4:  MOVWF  FD8
013D6:  BRA    13F0
013D8:  MOVFF  61C,61E
013DC:  MOVF   x18,W
013DE:  SUBWF  x1E,F
013E0:  BZ    13EE
013E2:  BTFSS  x1D.7
013E4:  BRA    13F0
013E6:  MOVF   FD8,W
013E8:  XORLW  01
013EA:  MOVWF  FD8
013EC:  BRA    13F0
013EE:  BCF    FD8.0
013F0:  MOVLB  0
013F2:  RETURN 0
013F4:  MOVLB  6
013F6:  MOVF   x0E,W
013F8:  BTFSC  FD8.2
013FA:  BRA    1546
013FC:  MOVWF  x1A
013FE:  MOVF   x12,W
01400:  BTFSC  FD8.2
01402:  BRA    1546
01404:  SUBWF  x1A,F
01406:  BNC   1412
01408:  MOVLW  7F
0140A:  ADDWF  x1A,F
0140C:  BTFSC  FD8.0
0140E:  BRA    1546
01410:  BRA    141E
01412:  MOVLW  81
01414:  SUBWF  x1A,F
01416:  BTFSS  FD8.0
01418:  BRA    1546
0141A:  BTFSC  FD8.2
0141C:  BRA    1546
0141E:  MOVFF  61A,00
01422:  CLRF   01
01424:  CLRF   02
01426:  CLRF   03
01428:  CLRF   x19
0142A:  MOVFF  60F,618
0142E:  BSF    x18.7
01430:  MOVFF  610,617
01434:  MOVFF  611,616
01438:  MOVLW  19
0143A:  MOVWF  x1A
0143C:  MOVF   x15,W
0143E:  SUBWF  x16,F
01440:  BC    145C
01442:  MOVLW  01
01444:  SUBWF  x17,F
01446:  BC    145C
01448:  SUBWF  x18,F
0144A:  BC    145C
0144C:  SUBWF  x19,F
0144E:  BC    145C
01450:  INCF   x19,F
01452:  INCF   x18,F
01454:  INCF   x17,F
01456:  MOVF   x15,W
01458:  ADDWF  x16,F
0145A:  BRA    14AC
0145C:  MOVF   x14,W
0145E:  SUBWF  x17,F
01460:  BC    1486
01462:  MOVLW  01
01464:  SUBWF  x18,F
01466:  BC    1486
01468:  SUBWF  x19,F
0146A:  BC    1486
0146C:  INCF   x19,F
0146E:  INCF   x18,F
01470:  MOVF   x14,W
01472:  ADDWF  x17,F
01474:  MOVF   x15,W
01476:  ADDWF  x16,F
01478:  BNC   14AC
0147A:  INCF   x17,F
0147C:  BNZ   14AC
0147E:  INCF   x18,F
01480:  BNZ   14AC
01482:  INCF   x19,F
01484:  BRA    14AC
01486:  MOVF   x13,W
01488:  IORLW  80
0148A:  SUBWF  x18,F
0148C:  BC    14AA
0148E:  MOVLW  01
01490:  SUBWF  x19,F
01492:  BC    14AA
01494:  INCF   x19,F
01496:  MOVF   x13,W
01498:  IORLW  80
0149A:  ADDWF  x18,F
0149C:  MOVF   x14,W
0149E:  ADDWF  x17,F
014A0:  BNC   1474
014A2:  INCF   x18,F
014A4:  BNZ   1474
014A6:  INCF   x19,F
014A8:  BRA    1474
014AA:  BSF    03.0
014AC:  DECFSZ x1A,F
014AE:  BRA    14B2
014B0:  BRA    14C8
014B2:  BCF    FD8.0
014B4:  RLCF   x16,F
014B6:  RLCF   x17,F
014B8:  RLCF   x18,F
014BA:  RLCF   x19,F
014BC:  BCF    FD8.0
014BE:  RLCF   03,F
014C0:  RLCF   02,F
014C2:  RLCF   01,F
014C4:  RLCF   x1B,F
014C6:  BRA    143C
014C8:  BTFSS  x1B.0
014CA:  BRA    14D8
014CC:  BCF    FD8.0
014CE:  RRCF   01,F
014D0:  RRCF   02,F
014D2:  RRCF   03,F
014D4:  RRCF   x1B,F
014D6:  BRA    14DC
014D8:  DECF   00,F
014DA:  BZ    1546
014DC:  BTFSC  x1B.7
014DE:  BRA    151C
014E0:  BCF    FD8.0
014E2:  RLCF   x16,F
014E4:  RLCF   x17,F
014E6:  RLCF   x18,F
014E8:  RLCF   x19,F
014EA:  MOVF   x15,W
014EC:  SUBWF  x16,F
014EE:  BC    14FE
014F0:  MOVLW  01
014F2:  SUBWF  x17,F
014F4:  BC    14FE
014F6:  SUBWF  x18,F
014F8:  BC    14FE
014FA:  SUBWF  x19,F
014FC:  BNC   1532
014FE:  MOVF   x14,W
01500:  SUBWF  x17,F
01502:  BC    150E
01504:  MOVLW  01
01506:  SUBWF  x18,F
01508:  BC    150E
0150A:  SUBWF  x19,F
0150C:  BNC   1532
0150E:  MOVF   x13,W
01510:  IORLW  80
01512:  SUBWF  x18,F
01514:  BC    151C
01516:  MOVLW  01
01518:  SUBWF  x19,F
0151A:  BNC   1532
0151C:  INCF   03,F
0151E:  BNZ   1532
01520:  INCF   02,F
01522:  BNZ   1532
01524:  INCF   01,F
01526:  BNZ   1532
01528:  INCF   00,F
0152A:  BZ    1546
0152C:  RRCF   01,F
0152E:  RRCF   02,F
01530:  RRCF   03,F
01532:  MOVFF  60F,61A
01536:  MOVF   x13,W
01538:  XORWF  x1A,F
0153A:  BTFSS  x1A.7
0153C:  BRA    1542
0153E:  BSF    01.7
01540:  BRA    154E
01542:  BCF    01.7
01544:  BRA    154E
01546:  CLRF   00
01548:  CLRF   01
0154A:  CLRF   02
0154C:  CLRF   03
0154E:  MOVLB  0
01550:  RETURN 0
*
01D02:  ADDWF  FE8,W
01D04:  CLRF   FF7
01D06:  RLCF   FF7,F
01D08:  ADDLW  1D
01D0A:  MOVWF  FF6
01D0C:  MOVLW  1D
01D0E:  ADDWFC FF7,F
01D10:  TBLRD*-
01D12:  MOVF   FF5,W
01D14:  MOVWF  FFA
01D16:  TBLRD*
01D18:  MOVF   FF5,W
01D1A:  MOVWF  FF9
01D1C:  DATA 0A,1C
01D1E:  DATA 24,1C
01D20:  DATA 78,1C
01D22:  DATA DC,1C
01D24:  MOVLW  8E
01D26:  MOVWF  00
01D28:  MOVLB  6
01D2A:  MOVF   x15,W
01D2C:  SUBWF  00,F
01D2E:  MOVFF  616,02
01D32:  MOVFF  617,01
01D36:  BSF    02.7
01D38:  MOVF   00,F
01D3A:  BZ    1D4E
01D3C:  BCF    FD8.0
01D3E:  MOVF   02,F
01D40:  BNZ   1D46
01D42:  MOVF   01,F
01D44:  BZ    1D4E
01D46:  RRCF   02,F
01D48:  RRCF   01,F
01D4A:  DECFSZ 00,F
01D4C:  BRA    1D3C
01D4E:  BTFSS  x16.7
01D50:  BRA    1D5C
01D52:  COMF   01,F
01D54:  COMF   02,F
01D56:  INCF   01,F
01D58:  BTFSC  FD8.2
01D5A:  INCF   02,F
01D5C:  MOVLB  0
01D5E:  RETURN 0
*
02270:  MOVLW  8E
02272:  MOVWF  00
02274:  MOVFF  60C,01
02278:  MOVFF  60B,02
0227C:  CLRF   03
0227E:  BTFSS  01.7
02280:  BRA    228C
02282:  COMF   01,F
02284:  COMF   02,F
02286:  INCF   02,F
02288:  BNZ   228C
0228A:  INCF   01,F
0228C:  MOVF   01,F
0228E:  BNZ   22A2
02290:  MOVFF  02,01
02294:  CLRF   02
02296:  MOVLW  08
02298:  SUBWF  00,F
0229A:  MOVF   01,F
0229C:  BNZ   22A2
0229E:  CLRF   00
022A0:  BRA    22BE
022A2:  BCF    FD8.0
022A4:  BTFSC  01.7
022A6:  BRA    22B0
022A8:  RLCF   02,F
022AA:  RLCF   01,F
022AC:  DECF   00,F
022AE:  BRA    22A2
022B0:  MOVLB  6
022B2:  BTFSS  x0C.7
022B4:  BRA    22BA
022B6:  MOVLB  0
022B8:  BRA    22BE
022BA:  BCF    01.7
022BC:  MOVLB  0
022BE:  RETURN 0
*
037F6:  MOVLB  5
037F8:  MOVF   xCE,W
037FA:  ANDLW  07
037FC:  MOVWF  00
037FE:  RRCF   xCE,W
03800:  MOVWF  01
03802:  RRCF   01,F
03804:  RRCF   01,F
03806:  MOVLW  1F
03808:  ANDWF  01,F
0380A:  MOVF   01,W
0380C:  ADDWF  xCF,W
0380E:  MOVWF  FE9
03810:  MOVLW  00
03812:  ADDWFC xD0,W
03814:  MOVWF  FEA
03816:  MOVFF  FEF,01
0381A:  INCF   00,F
0381C:  BRA    3820
0381E:  RRCF   01,F
03820:  DECFSZ 00,F
03822:  BRA    381E
03824:  MOVLW  01
03826:  ANDWF  01,F
03828:  MOVLB  0
0382A:  RETURN 0
*
03A0C:  MOVF   FEF,F
03A0E:  BZ    3A2E
03A10:  MOVFF  FEA,5C7
03A14:  MOVFF  FE9,5C6
03A18:  MOVFF  FEF,5C8
03A1C:  RCALL  39E4
03A1E:  MOVFF  5C7,FEA
03A22:  MOVFF  5C6,FE9
03A26:  INCF   FE9,F
03A28:  BTFSC  FD8.2
03A2A:  INCF   FEA,F
03A2C:  BRA    3A0C
03A2E:  RETURN 0
*
0406C:  MOVFF  4CE,FEA
04070:  MOVFF  4CD,FE9
04074:  MOVFF  5F7,FEF
04078:  INCF   FE9,F
0407A:  BTFSC  FD8.2
0407C:  INCF   FEA,F
0407E:  CLRF   FEF
04080:  MOVLB  4
04082:  INCF   xCD,F
04084:  BTFSC  FD8.2
04086:  INCF   xCE,F
04088:  MOVLB  0
0408A:  RETURN 0
0408C:  TBLRD*+
0408E:  MOVF   FF5,F
04090:  BZ    40AA
04092:  MOVFF  FF6,5D0
04096:  MOVFF  FF7,5D1
0409A:  MOVFF  FF5,5F7
0409E:  RCALL  406C
040A0:  MOVFF  5D0,FF6
040A4:  MOVFF  5D1,FF7
040A8:  BRA    408C
040AA:  RETURN 0
*
041CE:  MOVLB  6
041D0:  MOVF   x1B,W
041D2:  XORWF  x1D,W
041D4:  ANDLW  80
041D6:  MOVWF  x1F
041D8:  BTFSS  x1B.7
041DA:  BRA    41E6
041DC:  COMF   x1A,F
041DE:  COMF   x1B,F
041E0:  INCF   x1A,F
041E2:  BTFSC  FD8.2
041E4:  INCF   x1B,F
041E6:  BTFSS  x1D.7
041E8:  BRA    41F4
041EA:  COMF   x1C,F
041EC:  COMF   x1D,F
041EE:  INCF   x1C,F
041F0:  BTFSC  FD8.2
041F2:  INCF   x1D,F
041F4:  MOVF   x1A,W
041F6:  MULWF  x1C
041F8:  MOVFF  FF3,01
041FC:  MOVFF  FF4,00
04200:  MULWF  x1D
04202:  MOVF   FF3,W
04204:  ADDWF  00,F
04206:  MOVF   x1B,W
04208:  MULWF  x1C
0420A:  MOVF   FF3,W
0420C:  ADDWFC 00,W
0420E:  MOVWF  02
04210:  BTFSS  x1F.7
04212:  BRA    421E
04214:  COMF   01,F
04216:  COMF   02,F
04218:  INCF   01,F
0421A:  BTFSC  FD8.2
0421C:  INCF   02,F
0421E:  MOVLB  0
04220:  GOTO   44C0 (RETURN)
*
046F4:  MOVLB  5
046F6:  MOVF   xE3,W
046F8:  ANDLW  07
046FA:  MOVWF  00
046FC:  RRCF   xE3,W
046FE:  MOVWF  01
04700:  RRCF   01,F
04702:  RRCF   01,F
04704:  MOVLW  1F
04706:  ANDWF  01,F
04708:  MOVF   01,W
0470A:  ADDWF  xE5,W
0470C:  MOVWF  FE9
0470E:  MOVLW  00
04710:  ADDWFC xE6,W
04712:  MOVWF  FEA
04714:  CLRF   01
04716:  INCF   01,F
04718:  INCF   00,F
0471A:  BRA    471E
0471C:  RLCF   01,F
0471E:  DECFSZ 00,F
04720:  BRA    471C
04722:  MOVF   xE4,F
04724:  BZ    472C
04726:  MOVF   01,W
04728:  IORWF  FEF,F
0472A:  BRA    4732
0472C:  COMF   01,F
0472E:  MOVF   01,W
04730:  ANDWF  FEF,F
04732:  MOVLB  0
04734:  RETURN 0
*
04C6A:  MOVLB  5
04C6C:  MOVF   xF7,W
04C6E:  SUBLW  B6
04C70:  MOVWF  xF7
04C72:  CLRF   03
04C74:  MOVFF  5F8,5FB
04C78:  BSF    xF8.7
04C7A:  BCF    FD8.0
04C7C:  RRCF   xF8,F
04C7E:  RRCF   xF9,F
04C80:  RRCF   xFA,F
04C82:  RRCF   03,F
04C84:  RRCF   02,F
04C86:  RRCF   01,F
04C88:  RRCF   00,F
04C8A:  DECFSZ xF7,F
04C8C:  BRA    4C7A
04C8E:  BTFSS  xFB.7
04C90:  BRA    4CA8
04C92:  COMF   00,F
04C94:  COMF   01,F
04C96:  COMF   02,F
04C98:  COMF   03,F
04C9A:  INCF   00,F
04C9C:  BTFSC  FD8.2
04C9E:  INCF   01,F
04CA0:  BTFSC  FD8.2
04CA2:  INCF   02,F
04CA4:  BTFSC  FD8.2
04CA6:  INCF   03,F
04CA8:  MOVLB  0
04CAA:  GOTO   4DD2 (RETURN)
04CAE:  BTFSC  FD8.1
04CB0:  BRA    4CB8
04CB2:  MOVLW  05
04CB4:  MOVWF  FEA
04CB6:  SETF   FE9
04CB8:  CLRF   00
04CBA:  CLRF   01
04CBC:  CLRF   02
04CBE:  CLRF   03
04CC0:  MOVLB  5
04CC2:  CLRF   xFF
04CC4:  MOVLB  6
04CC6:  CLRF   x00
04CC8:  CLRF   x01
04CCA:  CLRF   x02
04CCC:  MOVLB  5
04CCE:  MOVF   xFE,W
04CD0:  IORWF  xFD,W
04CD2:  IORWF  xFC,W
04CD4:  IORWF  xFB,W
04CD6:  BZ    4D64
04CD8:  MOVLW  20
04CDA:  MOVLB  6
04CDC:  MOVWF  x03
04CDE:  BCF    FD8.0
04CE0:  MOVLB  5
04CE2:  RLCF   xF7,F
04CE4:  RLCF   xF8,F
04CE6:  RLCF   xF9,F
04CE8:  RLCF   xFA,F
04CEA:  RLCF   xFF,F
04CEC:  MOVLB  6
04CEE:  RLCF   x00,F
04CF0:  RLCF   x01,F
04CF2:  RLCF   x02,F
04CF4:  MOVLB  5
04CF6:  MOVF   xFE,W
04CF8:  MOVLB  6
04CFA:  SUBWF  x02,W
04CFC:  BNZ   4D1A
04CFE:  MOVLB  5
04D00:  MOVF   xFD,W
04D02:  MOVLB  6
04D04:  SUBWF  x01,W
04D06:  BNZ   4D1A
04D08:  MOVLB  5
04D0A:  MOVF   xFC,W
04D0C:  MOVLB  6
04D0E:  SUBWF  x00,W
04D10:  BNZ   4D1A
04D12:  MOVLB  5
04D14:  MOVF   xFB,W
04D16:  SUBWF  xFF,W
04D18:  MOVLB  6
04D1A:  BNC   4D56
04D1C:  MOVLB  5
04D1E:  MOVF   xFB,W
04D20:  SUBWF  xFF,F
04D22:  MOVF   xFC,W
04D24:  BTFSS  FD8.0
04D26:  INCFSZ xFC,W
04D28:  BRA    4D2C
04D2A:  BRA    4D32
04D2C:  MOVLB  6
04D2E:  SUBWF  x00,F
04D30:  MOVLB  5
04D32:  MOVF   xFD,W
04D34:  BTFSS  FD8.0
04D36:  INCFSZ xFD,W
04D38:  BRA    4D3C
04D3A:  BRA    4D42
04D3C:  MOVLB  6
04D3E:  SUBWF  x01,F
04D40:  MOVLB  5
04D42:  MOVF   xFE,W
04D44:  BTFSS  FD8.0
04D46:  INCFSZ xFE,W
04D48:  BRA    4D4C
04D4A:  BRA    4D52
04D4C:  MOVLB  6
04D4E:  SUBWF  x02,F
04D50:  MOVLB  5
04D52:  BSF    FD8.0
04D54:  MOVLB  6
04D56:  RLCF   00,F
04D58:  RLCF   01,F
04D5A:  RLCF   02,F
04D5C:  RLCF   03,F
04D5E:  DECFSZ x03,F
04D60:  BRA    4CDE
04D62:  MOVLB  5
04D64:  MOVFF  5FF,FEF
04D68:  MOVFF  600,FEC
04D6C:  MOVFF  601,FEC
04D70:  MOVFF  602,FEC
04D74:  MOVLB  0
04D76:  RETURN 0
04D78:  MOVF   FE9,W
04D7A:  MOVLB  5
04D7C:  MOVWF  xEF
04D7E:  MOVF   xEE,W
04D80:  MOVWF  xF1
04D82:  BZ    4DBE
04D84:  MOVFF  5ED,618
04D88:  MOVFF  5EC,617
04D8C:  MOVFF  5EB,616
04D90:  MOVFF  5EA,615
04D94:  MOVLB  6
04D96:  CLRF   x1C
04D98:  CLRF   x1B
04D9A:  MOVLW  20
04D9C:  MOVWF  x1A
04D9E:  MOVLW  82
04DA0:  MOVWF  x19
04DA2:  MOVLB  0
04DA4:  CALL   0A48
04DA8:  MOVFF  03,5ED
04DAC:  MOVFF  02,5EC
04DB0:  MOVFF  01,5EB
04DB4:  MOVFF  00,5EA
04DB8:  MOVLB  5
04DBA:  DECFSZ xF1,F
04DBC:  BRA    4D84
04DBE:  MOVFF  5ED,5FA
04DC2:  MOVFF  5EC,5F9
04DC6:  MOVFF  5EB,5F8
04DCA:  MOVFF  5EA,5F7
04DCE:  MOVLB  0
04DD0:  BRA    4C6A
04DD2:  MOVFF  03,5ED
04DD6:  MOVFF  02,5EC
04DDA:  MOVFF  01,5EB
04DDE:  MOVFF  00,5EA
04DE2:  MOVLB  5
04DE4:  BTFSS  xED.7
04DE6:  BRA    4E02
04DE8:  DECF   xEF,F
04DEA:  BSF    xEF.5
04DEC:  COMF   xEA,F
04DEE:  COMF   xEB,F
04DF0:  COMF   xEC,F
04DF2:  COMF   xED,F
04DF4:  INCF   xEA,F
04DF6:  BTFSC  FD8.2
04DF8:  INCF   xEB,F
04DFA:  BTFSC  FD8.2
04DFC:  INCF   xEC,F
04DFE:  BTFSC  FD8.2
04E00:  INCF   xED,F
04E02:  MOVLW  3B
04E04:  MOVWF  xF6
04E06:  MOVLW  9A
04E08:  MOVWF  xF5
04E0A:  MOVLW  CA
04E0C:  MOVWF  xF4
04E0E:  CLRF   xF3
04E10:  MOVLW  0A
04E12:  MOVWF  xF1
04E14:  MOVF   xEE,W
04E16:  BTFSC  FD8.2
04E18:  INCF   xEF,F
04E1A:  BSF    FD8.1
04E1C:  MOVLW  05
04E1E:  MOVWF  FEA
04E20:  MOVLW  EA
04E22:  MOVWF  FE9
04E24:  MOVFF  5ED,5FA
04E28:  MOVFF  5EC,5F9
04E2C:  MOVFF  5EB,5F8
04E30:  MOVFF  5EA,5F7
04E34:  MOVFF  5F6,5FE
04E38:  MOVFF  5F5,5FD
04E3C:  MOVFF  5F4,5FC
04E40:  MOVFF  5F3,5FB
04E44:  MOVLB  0
04E46:  RCALL  4CAE
04E48:  MOVF   01,W
04E4A:  MOVF   00,F
04E4C:  BNZ   4E74
04E4E:  MOVLB  5
04E50:  INCF   xEE,W
04E52:  SUBWF  xF1,W
04E54:  BTFSS  FD8.2
04E56:  BRA    4E5C
04E58:  MOVLB  0
04E5A:  BRA    4E74
04E5C:  MOVF   xEF,W
04E5E:  BZ    4E7A
04E60:  ANDLW  0F
04E62:  SUBWF  xF1,W
04E64:  BZ    4E68
04E66:  BC    4EF0
04E68:  BTFSC  xEF.7
04E6A:  BRA    4EF0
04E6C:  BTFSC  xEF.6
04E6E:  BRA    4E7A
04E70:  MOVLW  20
04E72:  BRA    4EE2
04E74:  MOVLW  20
04E76:  MOVLB  5
04E78:  ANDWF  xEF,F
04E7A:  BTFSS  xEF.5
04E7C:  BRA    4E9C
04E7E:  BCF    xEF.5
04E80:  MOVF   xEE,W
04E82:  BTFSS  FD8.2
04E84:  DECF   xEF,F
04E86:  MOVF   00,W
04E88:  MOVWF  xEF
04E8A:  MOVLW  2D
04E8C:  MOVWF  xF7
04E8E:  MOVLB  0
04E90:  CALL   406C
04E94:  MOVLB  5
04E96:  MOVF   xEF,W
04E98:  MOVWF  00
04E9A:  CLRF   xEF
04E9C:  MOVF   xEE,W
04E9E:  SUBWF  xF1,W
04EA0:  BNZ   4EBC
04EA2:  MOVF   00,W
04EA4:  MOVWF  xEF
04EA6:  MOVLW  2E
04EA8:  MOVWF  xF7
04EAA:  MOVLB  0
04EAC:  CALL   406C
04EB0:  MOVLB  5
04EB2:  MOVF   xEF,W
04EB4:  MOVWF  00
04EB6:  MOVLW  20
04EB8:  ANDWF  xEF,F
04EBA:  MOVLW  00
04EBC:  MOVLW  30
04EBE:  BTFSS  xEF.5
04EC0:  BRA    4EE2
04EC2:  BCF    xEF.5
04EC4:  MOVF   xEE,W
04EC6:  BTFSS  FD8.2
04EC8:  DECF   xEF,F
04ECA:  MOVF   00,W
04ECC:  MOVWF  xEF
04ECE:  MOVLW  2D
04ED0:  MOVWF  xF7
04ED2:  MOVLB  0
04ED4:  CALL   406C
04ED8:  MOVLB  5
04EDA:  MOVF   xEF,W
04EDC:  MOVWF  00
04EDE:  CLRF   xEF
04EE0:  MOVLW  30
04EE2:  ADDWF  00,F
04EE4:  MOVFF  00,5F7
04EE8:  MOVLB  0
04EEA:  CALL   406C
04EEE:  MOVLB  5
04EF0:  BCF    FD8.1
04EF2:  MOVFF  5F6,5FA
04EF6:  MOVFF  5F5,5F9
04EFA:  MOVFF  5F4,5F8
04EFE:  MOVFF  5F3,5F7
04F02:  CLRF   xFE
04F04:  CLRF   xFD
04F06:  CLRF   xFC
04F08:  MOVLW  0A
04F0A:  MOVWF  xFB
04F0C:  MOVLB  0
04F0E:  RCALL  4CAE
04F10:  MOVFF  03,5F6
04F14:  MOVFF  02,5F5
04F18:  MOVFF  01,5F4
04F1C:  MOVFF  00,5F3
04F20:  MOVLB  5
04F22:  DECFSZ xF1,F
04F24:  BRA    4E1A
04F26:  MOVLB  0
04F28:  RETURN 0
*
066F0:  MOVFF  FEA,5F4
066F4:  MOVFF  FE9,5F3
066F8:  MOVLB  5
066FA:  BTFSS  xED.7
066FC:  BRA    670E
066FE:  BSF    xF3.7
06700:  BTFSS  xF3.4
06702:  INCF   xF3,F
06704:  COMF   xEC,F
06706:  COMF   xED,F
06708:  INCF   xEC,F
0670A:  BTFSC  FD8.2
0670C:  INCF   xED,F
0670E:  SWAPF  xED,W
06710:  IORLW  F0
06712:  MOVWF  xEF
06714:  ADDWF  xEF,F
06716:  ADDLW  E2
06718:  MOVWF  xF0
0671A:  ADDLW  32
0671C:  MOVWF  xF2
0671E:  MOVF   xED,W
06720:  ANDLW  0F
06722:  ADDWF  xF0,F
06724:  ADDWF  xF0,F
06726:  ADDWF  xF2,F
06728:  ADDLW  E9
0672A:  MOVWF  xF1
0672C:  ADDWF  xF1,F
0672E:  ADDWF  xF1,F
06730:  SWAPF  xEC,W
06732:  ANDLW  0F
06734:  ADDWF  xF1,F
06736:  ADDWF  xF2,F
06738:  RLCF   xF1,F
0673A:  RLCF   xF2,F
0673C:  COMF   xF2,F
0673E:  RLCF   xF2,F
06740:  MOVF   xEC,W
06742:  ANDLW  0F
06744:  ADDWF  xF2,F
06746:  RLCF   xEF,F
06748:  MOVLW  07
0674A:  MOVWF  xEE
0674C:  MOVLW  0A
0674E:  DECF   xF1,F
06750:  ADDWF  xF2,F
06752:  BNC   674E
06754:  DECF   xF0,F
06756:  ADDWF  xF1,F
06758:  BNC   6754
0675A:  DECF   xEF,F
0675C:  ADDWF  xF0,F
0675E:  BNC   675A
06760:  DECF   xEE,F
06762:  ADDWF  xEF,F
06764:  BNC   6760
06766:  MOVLW  05
06768:  MOVWF  FEA
0676A:  MOVLW  EE
0676C:  MOVWF  FE9
0676E:  MOVLW  07
06770:  ANDWF  xF3,W
06772:  BCF    xF3.6
06774:  MOVF   FED,F
06776:  ANDWF  xF3,W
06778:  BNZ   6788
0677A:  BTFSC  xF3.4
0677C:  MOVF   FEE,F
0677E:  BTFSC  xF3.4
06780:  BRA    6788
06782:  MOVLW  20
06784:  MOVWF  00
06786:  BRA    67CA
06788:  ADDWF  FE9,F
0678A:  MOVLW  00
0678C:  ADDWFC FEA,F
0678E:  MOVF   FE9,W
06790:  SUBLW  F2
06792:  BNZ   679C
06794:  MOVF   FEA,W
06796:  SUBLW  05
06798:  BNZ   679C
0679A:  BSF    xF3.6
0679C:  MOVF   FEF,W
0679E:  MOVWF  00
067A0:  BNZ   67B2
067A2:  BTFSC  xF3.6
067A4:  BRA    67B2
067A6:  BTFSC  xF3.4
067A8:  BRA    67E6
067AA:  BTFSC  xF3.3
067AC:  BRA    67B2
067AE:  MOVLW  20
067B0:  BRA    67C8
067B2:  BTFSS  xF3.7
067B4:  BRA    67C2
067B6:  MOVLW  2D
067B8:  MOVWF  00
067BA:  MOVF   FED,W
067BC:  BCF    xF3.6
067BE:  BCF    xF3.7
067C0:  BRA    67CA
067C2:  BSF    xF3.3
067C4:  BCF    xF3.4
067C6:  MOVLW  30
067C8:  ADDWF  00,F
067CA:  MOVFF  FEA,5ED
067CE:  MOVFF  FE9,5EC
067D2:  MOVFF  00,5F7
067D6:  MOVLB  0
067D8:  CALL   406C
067DC:  MOVFF  5ED,FEA
067E0:  MOVFF  5EC,FE9
067E4:  MOVLB  5
067E6:  MOVF   FEE,W
067E8:  BTFSS  xF3.6
067EA:  BRA    678E
067EC:  MOVLB  0
067EE:  RETURN 0
*
06D00:  MOVF   FEF,F
06D02:  BZ    6D24
06D04:  MOVFF  FEA,5C7
06D08:  MOVFF  FE9,5C6
06D0C:  MOVFF  FEF,5F7
06D10:  CALL   406C
06D14:  MOVFF  5C7,FEA
06D18:  MOVFF  5C6,FE9
06D1C:  INCF   FE9,F
06D1E:  BTFSC  FD8.2
06D20:  INCF   FEA,F
06D22:  BRA    6D00
06D24:  GOTO   6DA2 (RETURN)
.................... 
.................... #list
.................... 
.................... 
.................... #device ADC=10
.................... 
.................... //!#FUSES WDT                      //Watch Dog Timer
.................... //!#FUSES WDT4096                  //Watch Dog Timer uses 1:4096 Postscale
.................... 
.................... #use delay(internal=64000000)
*
003AC:  MOVLW  05
003AE:  MOVWF  FEA
003B0:  MOVLW  C4
003B2:  MOVWF  FE9
003B4:  MOVF   FEF,W
003B6:  BZ    03D4
003B8:  MOVLW  14
003BA:  MOVWF  01
003BC:  CLRF   00
003BE:  DECFSZ 00,F
003C0:  BRA    03BE
003C2:  DECFSZ 01,F
003C4:  BRA    03BC
003C6:  MOVLW  BF
003C8:  MOVWF  00
003CA:  DECFSZ 00,F
003CC:  BRA    03CA
003CE:  BRA    03D0
003D0:  DECFSZ FEF,F
003D2:  BRA    03B8
003D4:  RETURN 0
*
0065E:  MOVLW  01
00660:  MOVLB  5
00662:  SUBWF  xCB,F
00664:  BNC   067E
00666:  MOVLW  05
00668:  MOVWF  FEA
0066A:  MOVLW  CB
0066C:  MOVWF  FE9
0066E:  MOVF   FEF,W
00670:  BZ    067E
00672:  MOVLW  04
00674:  MOVWF  00
00676:  DECFSZ 00,F
00678:  BRA    0676
0067A:  DECFSZ FEF,F
0067C:  BRA    0672
0067E:  MOVLB  0
00680:  GOTO   06D0 (RETURN)
.................... #define baudRate 128000
.................... #define numChannels 2
.................... 
.................... #define version  "20250522" // SW Version
.................... #define serialID "0000"     // Unique Serial ID
.................... #define magPP 1             // Magnetoresistive Sensor Pole Pitch in mm       
.................... 
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
*
00316:  MOVLW  CF
00318:  MOVWF  F87
0031A:  CLRF   F82
....................    output_b(portB_reset);
0031C:  MOVLW  F4
0031E:  MOVWF  F88
00320:  CLRF   F83
....................    output_c(portC_reset);
00322:  MOVLW  93
00324:  MOVWF  F89
00326:  CLRF   F84
....................    output_d(portD_reset);
00328:  MOVLW  1F
0032A:  MOVWF  F8A
0032C:  CLRF   F85
....................    output_e(portE_reset);
0032E:  BCF    F8B.0
00330:  BCF    F8B.1
00332:  BCF    F8B.2
00334:  BCF    F8B.3
00336:  CLRF   F86
....................    
....................    port_a_pullups(portA_pullups);
00338:  MOVLB  F
0033A:  SETF   x0B
....................    port_b_pullups(portB_pullups);
0033C:  CLRF   x13
....................    port_c_pullups(portC_pullups);
0033E:  CLRF   x1B
....................    port_d_pullups(portD_pullups);
00340:  SETF   x20
....................    port_e_pullups(portE_pullups);
00342:  CLRF   x28
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
00344:  MOVLW  40
00346:  MOVWF  x0C
00348:  CLRF   x14
0034A:  MOVLW  03
0034C:  MOVWF  x1C
0034E:  MOVLW  0F
00350:  MOVWF  x21
00352:  CLRF   x29
00354:  MOVLB  0
00356:  GOTO   7148 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <stdlib.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... 
.................... #ifndef _STDLIB
.................... #define _STDLIB
.................... 
.................... //---------------------------------------------------------------------------
.................... // Definitions and types
.................... //---------------------------------------------------------------------------
.................... 
.................... #ifndef RAND_MAX
.................... #define RAND_MAX  32767    // The value of which is the maximum value
....................                            // ... returned by the rand function
.................... #endif
.................... 
.................... 
.................... #IF (sizeof(int16*)>1)
.................... #DEFINE LONG_POINTERS 1
.................... #ELSE 
.................... #DEFINE LONG_POINTERS 0
.................... #ENDIF
.................... 
.................... typedef struct {
....................    signed int quot;
....................    signed int rem;
.................... } div_t;
.................... 
.................... typedef struct {
....................    signed long quot;
....................    signed long rem;
.................... } ldiv_t;
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // String conversion functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Standard template: signed int  atoi(char * s)
....................  * converts the initial portion of the string s to a signed int
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed int atoi(char *s);
.................... 
.................... /* Syntax: signed int32  atoi32(char * s)
....................    converts the initial portion of the string s to a signed int32
....................    returns the converted value if any, 0 otherwise*/
.................... #if (sizeof(long)==4)
....................  #define atoi32(s) atol(s)
.................... #else 
....................  signed int32 atoi32(char *s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... /* Syntax: signed int48  atoi48(char * s)
....................    converts the initial portion of the string s to a signed int48
....................    returns the converted value if any, 0 otherwise*/
....................    
.................... signed int48 atoi48(char *s);
.................... 
.................... /* Syntax: signed int64  atoi64(char * s)
....................    converts the initial portion of the string s to a signed int64
....................    returns the converted value if any, 0 otherwise*/
.................... signed int64 atoi64(char *s);
.................... #endif
.................... 
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s)
....................    converts the signed int32 to a string and
....................    returns the converted value if any, 0 otherwise*/
.................... char * itoa(signed int32 num, unsigned int base, char * s);
.................... 
.................... /* Standard template: signed int16  atol(char * s)
....................  * converts the initial portion of the string s to a signed int16
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... signed long atol(char *s);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base  to a signed long.
....................  * Returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... signed long strtol(char *s,char *endptr, signed int base);
.................... 
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base)
....................  * converts the initial portion of the string s, represented as an
....................  * integral value of radix base to a unsigned long.
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null
....................  */
.................... unsigned long strtoul(char *s,char *endptr, signed int base);
.................... 
.................... /* Standart template: float strtof(char * s,char *endptr)
....................                       float48 strtof48(char *s,char *endptr);
....................                       float64 strtod(char *s,char *endptr);
....................  * converts the initial portion of the string s to a float32, float48 or float64,
....................  * returns the converted value if any, 0 otherwise
....................  * the final string is returned in the endptr, if endptr is not null                   
.................... */
.................... float strtof(char *s,char **endptr);
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s,char **endptr);
.................... float64 strtod(char *s,char **endptr);
.................... #else
.................... //provided for compatibility
.................... #define strtof48(s, e) strtof(s, e)
.................... #define strtod(s, e) strtof(s, e)
.................... #endif
.................... 
.................... /* Standard template: float32 atof(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof(s)   strtof(s, (char*)0)
.................... 
.................... #if defined(__PCD__)
.................... // The following functions only work on the 24 bit compiler
.................... // for the 30F, 33F, 24F and 24H parts
.................... 
.................... /* Standard template: float48 atof48(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof48(s) strtof48(s, 0)
.................... 
.................... /* Standard template: float64 atof64(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  */
.................... #define atof64(s) strtod(s, 0)
.................... #endif
.................... 
.................... /* Standard template: float32 atoe(char * s)
....................  * converts the initial portion of the string s to a float.
....................  * returns the converted value if any, 0 otherwise
....................  * also handles E format numbers
....................  */
.................... #if !defined(__PCD__)
.................... float atoe(char * s);
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s);
.................... #endif
.................... 
.................... //---------------------------------------------------------------------------
.................... // Pseudo-random sequence generation functions
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The rand function computes a sequence of pseudo-random integers in
....................  * the range 0 to RAND_MAX
....................  *
....................  * Parameters:
....................  *       (none)
....................  *
....................  * Returns:
....................  *       The pseudo-random integer
....................  */
.................... unsigned int16 rand(void);
.................... 
.................... /* The srand function uses the argument as a seed for a new sequence of
....................  * pseudo-random numbers to be returned by subsequent calls to rand.
....................  *
....................  * Parameters:
....................  *       [in] seed: The seed value to start from. You might need to pass
....................  *
....................  * Returns:
....................  *       (none)
....................  *
....................  * Remarks
....................  *          The srand function sets the starting point for generating
....................  *       a series of pseudorandom integers. To reinitialize the
....................  *       generator, use 1 as the seed argument. Any other value for
....................  *       seed sets the generator to a random starting point. rand
....................  *       retrieves the pseudorandom numbers that are generated.
....................  *       Calling rand before any call to srand generates the same
....................  *       sequence as calling srand with seed passed as 1.
....................  *          Usually, you need to pass a time here from outer source
....................  *       so that the numbers will be different every time you run.
....................  */
.................... void srand(unsigned int32 seed);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Memory management functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Comming soon
.................... 
.................... //---------------------------------------------------------------------------
.................... // Communication with the environment
.................... //---------------------------------------------------------------------------
.................... 
.................... /* The function returns 0 always
....................  */
.................... signed int8 system(char *string);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities
.................... //---------------------------------------------------------------------------
.................... 
.................... /* Performs a binary search of a sorted array..
....................  *
....................  * Parameters:
....................  *       [in] key: Object to search for
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed
....................  *       to by base. If key is not found, the function returns NULL. If the
....................  *       array is not in order or contains duplicate records with identical keys,
....................  *       the result is unpredictable.
....................  */
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents
....................  * of the array are sorted into ascending order according to a comparison
....................  * function pointed to by compar.
....................  *
....................  * Parameters:
....................  *       [in] base: Pointer to base of search data
....................  *       [in] num: Number of elements
....................  *       [in] width: Width of elements
....................  *       [in] compare: Function that compares two elements
....................  *
....................  * Returns:
....................  *       (none)
....................  */
.................... //void *qsort(const void *base, size_t num, size_t width,
.................... //              int (*compare)(const void *, const void *));
.................... 
.................... //---------------------------------------------------------------------------
.................... // Integer arithmetic functions
.................... //---------------------------------------------------------------------------
.................... 
.................... #define labs abs
.................... 
.................... div_t div(signed int numer, signed int denom);
.................... ldiv_t ldiv(signed long numer, signed long denom);
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte character functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... //---------------------------------------------------------------------------
.................... // Multibyte string functions
.................... //---------------------------------------------------------------------------
.................... 
.................... // Not supported
.................... 
.................... 
.................... //---------------------------------------------------------------------------
.................... // Internal implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
03FF4:  MOVFF  5E5,FEA
03FF8:  MOVLB  5
03FFA:  MOVFF  5E4,FE9
03FFE:  MOVFF  FEF,5E8
04002:  MOVFF  5E7,FEA
04006:  MOVFF  5E6,FE9
0400A:  MOVF   FEF,W
0400C:  SUBWF  xE8,W
0400E:  BNZ   403E
....................       if (*s1 == '\0')
04010:  MOVFF  5E5,03
04014:  MOVFF  5E4,FE9
04018:  MOVFF  03,FEA
0401C:  MOVF   FEF,F
0401E:  BNZ   4026
....................          return(0);
04020:  MOVLW  00
04022:  MOVWF  01
04024:  BRA    4068
04026:  MOVFF  5E5,03
0402A:  MOVF   xE4,W
0402C:  INCF   xE4,F
0402E:  BTFSC  FD8.2
04030:  INCF   xE5,F
04032:  INCF   xE6,F
04034:  BTFSC  FD8.2
04036:  INCF   xE7,F
04038:  MOVLB  0
0403A:  BRA    3FF4
0403C:  MOVLB  5
....................    return((*s1 < *s2) ? -1: 1);
0403E:  MOVFF  5E5,03
04042:  MOVFF  5E4,FE9
04046:  MOVFF  03,FEA
0404A:  MOVFF  FEF,5E8
0404E:  MOVFF  5E7,03
04052:  MOVFF  5E6,FE9
04056:  MOVFF  03,FEA
0405A:  MOVF   FEF,W
0405C:  SUBWF  xE8,W
0405E:  BC    4064
04060:  MOVLW  FF
04062:  BRA    4066
04064:  MOVLW  01
04066:  MOVWF  01
04068:  MOVLB  0
0406A:  RETURN 0
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    size_t n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
*
04184:  MOVFF  61B,61E
....................    for(su=s;0<n;++su,--n)
04188:  MOVFF  61A,620
0418C:  MOVFF  619,61F
04190:  MOVLB  6
04192:  MOVF   x1D,F
04194:  BNZ   419C
04196:  MOVF   x1C,W
04198:  SUBLW  00
0419A:  BC    41C4
....................       if(*su==uc)
0419C:  MOVFF  620,FEA
041A0:  MOVFF  61F,FE9
041A4:  MOVF   x1E,W
041A6:  SUBWF  FEF,W
041A8:  BNZ   41B4
....................       return su;
041AA:  MOVFF  61F,01
041AE:  MOVFF  620,02
041B2:  BRA    41CA
041B4:  INCF   x1F,F
041B6:  BTFSC  FD8.2
041B8:  INCF   x20,F
041BA:  MOVF   x1C,W
041BC:  BTFSC  FD8.2
041BE:  DECF   x1D,F
041C0:  DECF   x1C,F
041C2:  BRA    4192
....................    return NULL;
041C4:  MOVLW  00
041C6:  MOVWF  01
041C8:  MOVWF  02
041CA:  MOVLB  0
041CC:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
*
03FBC:  MOVFF  5E9,5EB
03FC0:  MOVFF  5E8,5EA
03FC4:  MOVFF  5EB,FEA
03FC8:  MOVLB  5
03FCA:  MOVFF  5EA,FE9
03FCE:  MOVF   FEF,F
03FD0:  BZ    3FDE
03FD2:  INCF   xEA,F
03FD4:  BTFSC  FD8.2
03FD6:  INCF   xEB,F
03FD8:  MOVLB  0
03FDA:  BRA    3FC4
03FDC:  MOVLB  5
....................    return(sc - s);
03FDE:  MOVF   xE8,W
03FE0:  SUBWF  xEA,W
03FE2:  MOVWF  00
03FE4:  MOVF   xE9,W
03FE6:  SUBWFB xEB,W
03FE8:  MOVWF  03
03FEA:  MOVFF  00,01
03FEE:  MOVWF  02
03FF0:  MOVLB  0
03FF2:  RETURN 0
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... div_t div(signed int numer, signed int denom)
.................... {
....................    div_t val;
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... ldiv_t ldiv(signed long numer, signed long denom)
.................... {
....................    ldiv_t val;
.................... 
....................    val.quot = numer / denom;
....................    val.rem = numer - (denom * val.quot);
....................    return (val);
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float32 atoe(char * s)
.................... {
....................    float32 pow10 = 1.0;
....................    float32 result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float32 exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if !defined(__PCD__)
.................... float atoe(char * s)
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    unsigned int8 sign = 0;
....................    unsigned int8 expsign = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
....................    unsigned int8 i;
....................    float exp = 1.0;
....................    unsigned int8 expcnt = 0;
.................... 
....................    c = s[ptr++];
.................... 
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') {
....................       if(c == '-') {
....................          sign = 1;
....................          c = s[ptr++];
....................       }
....................       if(c == '+')
....................          c = s[ptr++];
.................... 
....................       while((c >= '0' && c <= '9')) {
....................          result = 10*result + c - '0';
....................          c = s[ptr++];
....................       }
.................... 
....................       if (c == '.') {
....................          c = s[ptr++];
....................          while((c >= '0' && c <= '9')) {
....................              pow10 = pow10*10;
....................              result += (c - '0')/pow10;
....................              c = s[ptr++];
....................          }
....................       }
.................... 
....................       // Handling the exponent
....................       if (c=='e' || c=='E') {
....................          c = s[ptr++];
.................... 
....................          if(c == '-') {
....................             expsign = 1;
....................             c = s[ptr++];
....................          }
....................          if(c == '+')
....................             c = s[ptr++];
.................... 
....................          while((c >= '0' && c <= '9')) {
....................             expcnt = 10*expcnt + c - '0';
....................             c = s[ptr++];
....................          }
.................... 
....................          for(i=0;i<expcnt;i++)
....................             exp*=10;
.................... 
....................          if(expsign==1)
....................             result/=exp;
....................          else
....................             result*=exp;
....................       }
....................    }
.................... 
....................    if (sign == 1)
....................       result = -1*result;
....................    return(result);
.................... }
.................... #endif
.................... 
.................... signed int atoi(char *s)
.................... {
....................    signed int result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    // Omit all preceeding alpha characters
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
.................... 
....................       // Check for hexa number
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];
....................             c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (sign == 1 && base == 10)
....................        result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed long atol(char *s)
.................... {
....................    signed long result;
....................    unsigned int sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9')
....................          {
....................             result = 10*result + (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... /* A fast routine to multiply by 10
....................  */
.................... signed int32 mult_with10(int32 num)
.................... {
....................    return ( (num << 1) + (num << 3) );
.................... }
.................... 
.................... #if sizeof(long)==2
.................... signed int32 atoi32(char *s)
.................... {
....................    signed int32 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #if defined(__PCD__)
.................... 
.................... signed int48 atoi48(char *s)
.................... {
....................    signed int48 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... 
.................... signed int64 atoi64(char *s)
.................... {
....................    signed int64 result;
....................    int8 sign, base, index;
....................    char c;
.................... 
....................    index = 0;
....................    sign = 0;
....................    base = 10;
....................    result = 0;
.................... 
....................    if (!s)
....................       return 0;
....................    c = s[index++];
.................... 
....................    // increase index if either positive or negative sign is detected
....................    if (c == '-')
....................    {
....................       sign = 1;         // Set the sign to negative
....................       c = s[index++];
....................    }
....................    else if (c == '+')
....................    {
....................       c = s[index++];
....................    }
.................... 
....................    if (c >= '0' && c <= '9')
....................    {
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X'))
....................       {
....................          base = 16;
....................          index++;
....................          c = s[index++];
....................       }
.................... 
....................       // The number is a decimal number
....................       if (base == 10)
....................       {
....................          while (c >= '0' && c <= '9') {
....................             result = (result << 1) + (result << 3);  // result *= 10;
....................             result += (c - '0');
....................             c = s[index++];
....................          }
....................       }
....................       else if (base == 16)    // The number is a hexa number
....................       {
....................          c = toupper(c);
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F'))
....................          {
....................             if (c >= '0' && c <= '9')
....................                result = (result << 4) + (c - '0');
....................             else
....................                result = (result << 4) + (c - 'A' + 10);
.................... 
....................             c = s[index++];c = toupper(c);
....................          }
....................       }
....................    }
.................... 
....................    if (base == 10 && sign == 1)
....................       result = -result;
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... char * itoa(signed int32 num, unsigned int base, char * s)
.................... {
....................      unsigned int32 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #if defined(__PCD__)
.................... 
.................... char * itoa(signed int48 num, unsigned int base, char * s)
.................... {
....................      unsigned int48 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
.................... 
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
.................... 
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... char * itoa(signed int64 num, unsigned int base, char * s)
.................... {
....................      unsigned int64 temp=1;
....................      unsigned int8 i,sign=0,cnt=0;
....................      char c;
....................      
....................      if(num<0) {
....................          sign=1;        // Check for negative number
....................          num*=-1;        
....................      }
.................... 
....................      while(temp>0) {
....................          temp=(num/base);
....................          s[cnt]=(num%base)+'0';    // Conversion
.................... 
....................          if(s[cnt]>0x39)
....................             s[cnt]+=0x7;
....................             
....................          cnt++;
....................          num=temp;
....................      }
.................... 
....................      if(sign==1) {
....................          s[cnt]=0x2D;      // Negative sign
....................          cnt++;
....................      }
.................... 
....................      for(i = 0;i<(int8)(cnt/2);i++) {
.................... 
....................          c=s[i];
....................          s[i]=s[cnt-i-1];        // Reverse the number
....................          s[cnt-i-1]=c;
....................      }
....................      s[cnt]='\0';     // End the string
....................      return s;
.................... }
.................... 
.................... #endif
.................... 
.................... float strtof(char *s, char **endptr)
*
05204:  MOVLB  5
05206:  CLRF   xDC
05208:  CLRF   xDB
0520A:  CLRF   xDA
0520C:  MOVLW  7F
0520E:  MOVWF  xD9
05210:  CLRF   xE0
05212:  CLRF   xDF
05214:  CLRF   xDE
05216:  CLRF   xDD
05218:  BSF    xE1.0
0521A:  BCF    xE1.1
0521C:  BCF    xE1.2
0521E:  CLRF   xE3
.................... {
....................    float pow10 = 1.0;
....................    float result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
05220:  MOVF   xD5,W
05222:  IORWF  xD6,W
05224:  BNZ   5230
....................       return 0;
05226:  CLRF   00
05228:  CLRF   01
0522A:  CLRF   02
0522C:  CLRF   03
0522E:  BRA    5460
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
05230:  MOVF   xE3,W
05232:  INCF   xE3,F
05234:  ADDWF  xD5,W
05236:  MOVWF  FE9
05238:  MOVLW  00
0523A:  ADDWFC xD6,W
0523C:  MOVWF  FEA
0523E:  MOVFF  FEF,5E2
05242:  MOVF   xE2,F
05244:  BTFSC  FD8.2
05246:  BRA    53E2
....................    {
....................       if (skip && !isspace(c))
05248:  BTFSS  xE1.0
0524A:  BRA    526A
0524C:  MOVF   xE2,W
0524E:  SUBLW  20
05250:  BZ    526A
....................       {
....................          skip = 0;
05252:  BCF    xE1.0
....................          if (c == '+')
05254:  MOVF   xE2,W
05256:  SUBLW  2B
05258:  BNZ   5260
....................          {
....................             sign = 0;
0525A:  BCF    xE1.1
....................             continue;
0525C:  BRA    53CA
....................          }            
0525E:  BRA    526A
....................          else if (c == '-')
05260:  MOVF   xE2,W
05262:  SUBLW  2D
05264:  BNZ   526A
....................          {
....................             sign = 1;
05266:  BSF    xE1.1
....................             continue;
05268:  BRA    53CA
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
0526A:  BTFSC  xE1.0
0526C:  BRA    527C
0526E:  MOVF   xE2,W
05270:  SUBLW  2E
05272:  BNZ   527C
05274:  BTFSC  xE1.2
05276:  BRA    527C
....................          point = 1;
05278:  BSF    xE1.2
0527A:  BRA    53CA
....................       else if (!skip && isdigit(c))
0527C:  BTFSC  xE1.0
0527E:  BRA    53C4
05280:  MOVF   xE2,W
05282:  SUBLW  2F
05284:  BTFSC  FD8.0
05286:  BRA    53C4
05288:  MOVF   xE2,W
0528A:  SUBLW  39
0528C:  BTFSS  FD8.0
0528E:  BRA    53C4
....................       {
....................          c -= '0';
05290:  MOVLW  30
05292:  SUBWF  xE2,F
....................          if (point)
05294:  BTFSS  xE1.2
05296:  BRA    5348
....................          {
....................             pow10 = pow10 * 10.0;
05298:  MOVFF  5DC,618
0529C:  MOVFF  5DB,617
052A0:  MOVFF  5DA,616
052A4:  MOVFF  5D9,615
052A8:  MOVLB  6
052AA:  CLRF   x1C
052AC:  CLRF   x1B
052AE:  MOVLW  20
052B0:  MOVWF  x1A
052B2:  MOVLW  82
052B4:  MOVWF  x19
052B6:  MOVLB  0
052B8:  CALL   0A48
052BC:  MOVFF  03,5DC
052C0:  MOVFF  02,5DB
052C4:  MOVFF  01,5DA
052C8:  MOVFF  00,5D9
....................             result += (float)c / pow10;   
052CC:  MOVLB  6
052CE:  CLRF   x1A
052D0:  MOVFF  5E2,619
052D4:  MOVLB  0
052D6:  CALL   0A12
052DA:  MOVFF  03,5E7
052DE:  MOVFF  02,5E6
052E2:  MOVFF  01,5E5
052E6:  MOVFF  00,5E4
052EA:  MOVFF  03,611
052EE:  MOVFF  02,610
052F2:  MOVFF  01,60F
052F6:  MOVFF  00,60E
052FA:  MOVFF  5DC,615
052FE:  MOVFF  5DB,614
05302:  MOVFF  5DA,613
05306:  MOVFF  5D9,612
0530A:  CALL   13F4
0530E:  BCF    FD8.1
05310:  MOVFF  5E0,61C
05314:  MOVFF  5DF,61B
05318:  MOVFF  5DE,61A
0531C:  MOVFF  5DD,619
05320:  MOVFF  03,620
05324:  MOVFF  02,61F
05328:  MOVFF  01,61E
0532C:  MOVFF  00,61D
05330:  CALL   0B3E
05334:  MOVFF  03,5E0
05338:  MOVFF  02,5DF
0533C:  MOVFF  01,5DE
05340:  MOVFF  00,5DD
....................          }
05344:  BRA    53C0
05346:  MOVLB  5
....................          else
....................          {
....................             result = 10.0 * result + (float)c;
05348:  MOVLB  6
0534A:  CLRF   x18
0534C:  CLRF   x17
0534E:  MOVLW  20
05350:  MOVWF  x16
05352:  MOVLW  82
05354:  MOVWF  x15
05356:  MOVFF  5E0,61C
0535A:  MOVFF  5DF,61B
0535E:  MOVFF  5DE,61A
05362:  MOVFF  5DD,619
05366:  MOVLB  0
05368:  CALL   0A48
0536C:  MOVFF  03,5E7
05370:  MOVFF  02,5E6
05374:  MOVFF  01,5E5
05378:  MOVFF  00,5E4
0537C:  MOVLB  6
0537E:  CLRF   x1A
05380:  MOVFF  5E2,619
05384:  MOVLB  0
05386:  CALL   0A12
0538A:  BCF    FD8.1
0538C:  MOVFF  5E7,61C
05390:  MOVFF  5E6,61B
05394:  MOVFF  5E5,61A
05398:  MOVFF  5E4,619
0539C:  MOVFF  03,620
053A0:  MOVFF  02,61F
053A4:  MOVFF  01,61E
053A8:  MOVFF  00,61D
053AC:  CALL   0B3E
053B0:  MOVFF  03,5E0
053B4:  MOVFF  02,5DF
053B8:  MOVFF  01,5DE
053BC:  MOVFF  00,5DD
....................          }
....................       }
053C0:  BRA    53CC
053C2:  MOVLB  5
....................       else if (!skip)
053C4:  BTFSC  xE1.0
053C6:  BRA    53CA
....................          break;
053C8:  BRA    53E2
053CA:  MOVLB  0
053CC:  MOVLB  5
053CE:  MOVF   xE3,W
053D0:  INCF   xE3,F
053D2:  ADDWF  xD5,W
053D4:  MOVWF  FE9
053D6:  MOVLW  00
053D8:  ADDWFC xD6,W
053DA:  MOVWF  FEA
053DC:  MOVFF  FEF,5E2
053E0:  BRA    5242
....................    }
.................... 
....................    if (sign)
053E2:  BTFSS  xE1.1
053E4:  BRA    541C
....................       result = -1*result;
053E6:  MOVLB  6
053E8:  CLRF   x18
053EA:  CLRF   x17
053EC:  MOVLW  80
053EE:  MOVWF  x16
053F0:  MOVLW  7F
053F2:  MOVWF  x15
053F4:  MOVFF  5E0,61C
053F8:  MOVFF  5DF,61B
053FC:  MOVFF  5DE,61A
05400:  MOVFF  5DD,619
05404:  MOVLB  0
05406:  CALL   0A48
0540A:  MOVFF  03,5E0
0540E:  MOVFF  02,5DF
05412:  MOVFF  01,5DE
05416:  MOVFF  00,5DD
0541A:  MOVLB  5
....................       
....................    if(endptr)
0541C:  MOVF   xD7,W
0541E:  IORWF  xD8,W
05420:  BZ    5450
....................    {
....................       if (ptr) {
05422:  MOVF   xE3,F
05424:  BZ    543E
....................          ptr--;
05426:  DECF   xE3,F
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
05428:  MOVFF  5D8,FEA
0542C:  MOVFF  5D7,FE9
05430:  MOVF   xE3,W
05432:  ADDWF  xD5,W
05434:  MOVWF  FEF
05436:  MOVLW  00
05438:  ADDWFC xD6,W
0543A:  MOVWF  FEC
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
0543C:  BRA    5450
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
0543E:  MOVFF  5D8,FEA
05442:  MOVFF  5D7,FE9
05446:  MOVFF  5D6,FEC
0544A:  MOVF   FED,F
0544C:  MOVFF  5D5,FEF
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
05450:  MOVFF  5DD,00
05454:  MOVFF  5DE,01
05458:  MOVFF  5DF,02
0545C:  MOVFF  5E0,03
05460:  MOVLB  0
05462:  RETURN 0
.................... }
.................... 
.................... #if defined(__PCD__)
.................... float48 strtof48(char *s, char **endptr)
.................... {
....................    float48 pow10 = 1.0;
....................    float48 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float48)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float48)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... 
.................... float64 strtod(char *s, char **endptr)
.................... {
....................    float64 pow10 = 1.0;
....................    float64 result = 0.0;
....................    int1 skip = 1, sign = 0, point = 0;
....................    char c;
....................    unsigned int8 ptr = 0;
.................... 
....................    if (!s)
....................       return 0;
.................... 
....................    for(c=s[ptr++]; c!=0; c=s[ptr++])
....................    {
....................       if (skip && !isspace(c))
....................       {
....................          skip = 0;
....................          if (c == '+')
....................          {
....................             sign = 0;
....................             continue;
....................          }            
....................          else if (c == '-')
....................          {
....................             sign = 1;
....................             continue;
....................          }
....................       }
....................       if (!skip && (c == '.') && !point)
....................          point = 1;
....................       else if (!skip && isdigit(c))
....................       {
....................          c -= '0';
....................          if (point)
....................          {
....................             pow10 = pow10 * 10.0;
....................             result += (float64)c / pow10;   
....................          }
....................          else
....................          {
....................             result = 10.0 * result + (float64)c;
....................          }
....................       }
....................       else if (!skip)
....................          break;
....................    }
.................... 
....................    if (sign)
....................       result = -1*result;
....................       
....................    if(endptr)
....................    {
....................       if (ptr) {
....................          ptr--;
....................        #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s+ptr; 
....................        #ELSE
....................          *((char *)endptr)=s+ptr;
....................        #ENDIF
....................       }
....................       else
....................       {
....................       #IF LONG_POINTERS
....................       *((int16 *)endptr)= s; 
....................       #ELSE
....................       *((char *)endptr)=s;
....................       #ENDIF
....................       }
....................    }
.................... 
....................    return(result);
.................... }
.................... #endif
.................... 
.................... #ifndef __PCB__
.................... unsigned long strtoul(char *s, char *endptr, signed int base)
*
04224:  MOVLB  5
04226:  CLRF   xF2
04228:  CLRF   xF1
.................... {
....................    char *sc,*s1,*sd;
....................    unsigned long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
0422A:  MOVLW  30
0422C:  MOVWF  xF4
0422E:  MOVLW  31
04230:  MOVWF  xF5
04232:  MOVLW  32
04234:  MOVWF  xF6
04236:  MOVLW  33
04238:  MOVWF  xF7
0423A:  MOVLW  34
0423C:  MOVWF  xF8
0423E:  MOVLW  35
04240:  MOVWF  xF9
04242:  MOVLW  36
04244:  MOVWF  xFA
04246:  MOVLW  37
04248:  MOVWF  xFB
0424A:  MOVLW  38
0424C:  MOVWF  xFC
0424E:  MOVLW  39
04250:  MOVWF  xFD
04252:  MOVLW  61
04254:  MOVWF  xFE
04256:  MOVLW  62
04258:  MOVWF  xFF
0425A:  MOVLW  63
0425C:  MOVLB  6
0425E:  MOVWF  x00
04260:  MOVLW  64
04262:  MOVWF  x01
04264:  MOVLW  65
04266:  MOVWF  x02
04268:  MOVLW  66
0426A:  MOVWF  x03
0426C:  MOVLW  67
0426E:  MOVWF  x04
04270:  MOVLW  68
04272:  MOVWF  x05
04274:  MOVLW  69
04276:  MOVWF  x06
04278:  MOVLW  6A
0427A:  MOVWF  x07
0427C:  MOVLW  6B
0427E:  MOVWF  x08
04280:  MOVLW  6C
04282:  MOVWF  x09
04284:  MOVLW  6D
04286:  MOVWF  x0A
04288:  MOVLW  6E
0428A:  MOVWF  x0B
0428C:  MOVLW  6F
0428E:  MOVWF  x0C
04290:  MOVLW  70
04292:  MOVWF  x0D
04294:  MOVLW  71
04296:  MOVWF  x0E
04298:  MOVLW  73
0429A:  MOVWF  x0F
0429C:  MOVLW  74
0429E:  MOVWF  x10
042A0:  MOVLW  75
042A2:  MOVWF  x11
042A4:  MOVLW  76
042A6:  MOVWF  x12
042A8:  MOVLW  77
042AA:  MOVWF  x13
042AC:  MOVLW  78
042AE:  MOVWF  x14
042B0:  MOVLW  79
042B2:  MOVWF  x15
042B4:  MOVLW  7A
042B6:  MOVWF  x16
042B8:  CLRF   x17
....................    for(sc=s;isspace(*sc);++sc);
042BA:  MOVFF  5E7,5EC
042BE:  MOVFF  5E6,5EB
042C2:  MOVFF  5EC,FEA
042C6:  MOVLB  5
042C8:  MOVFF  5EB,FE9
042CC:  MOVF   FEF,W
042CE:  SUBLW  20
042D0:  BNZ   42DE
042D2:  INCF   xEB,F
042D4:  BTFSC  FD8.2
042D6:  INCF   xEC,F
042D8:  MOVLB  6
042DA:  BRA    42C2
042DC:  MOVLB  5
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
042DE:  MOVFF  5EC,03
042E2:  MOVFF  5EB,FE9
042E6:  MOVFF  03,FEA
042EA:  MOVF   FEF,W
042EC:  SUBLW  2D
042EE:  BZ    42FE
042F0:  MOVFF  5EC,FEA
042F4:  MOVFF  5EB,FE9
042F8:  MOVF   FEF,W
042FA:  SUBLW  2B
042FC:  BNZ   4310
042FE:  MOVFF  5EC,FEA
04302:  MOVF   xEB,W
04304:  INCF   xEB,F
04306:  BTFSC  FD8.2
04308:  INCF   xEC,F
0430A:  MOVWF  FE9
0430C:  MOVF   FEF,W
0430E:  BRA    4312
04310:  MOVLW  2B
04312:  MOVWF  xF3
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base
04314:  MOVF   xF3,W
04316:  SUBLW  2D
04318:  BZ    432E
0431A:  BTFSC  xEA.7
0431C:  BRA    432E
0431E:  DECFSZ xEA,W
04320:  BRA    4324
04322:  BRA    432E
04324:  BTFSC  xEA.7
04326:  BRA    4332
04328:  MOVF   xEA,W
0432A:  SUBLW  24
0432C:  BC    4332
....................    goto StrtoulGO;
0432E:  BRA    4542
04330:  BRA    442A
.................... 
....................    else if (base)
04332:  MOVF   xEA,F
04334:  BZ    43C2
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
04336:  MOVF   xEA,W
04338:  SUBLW  10
0433A:  BNZ   4376
0433C:  MOVFF  5EC,FEA
04340:  MOVFF  5EB,FE9
04344:  MOVF   FEF,W
04346:  SUBLW  30
04348:  BNZ   4376
0434A:  MOVLW  01
0434C:  ADDWF  xEB,W
0434E:  MOVWF  FE9
04350:  MOVLW  00
04352:  ADDWFC xEC,W
04354:  MOVWF  FEA
04356:  MOVF   FEF,W
04358:  SUBLW  78
0435A:  BZ    436E
0435C:  MOVLW  01
0435E:  ADDWF  xEB,W
04360:  MOVWF  FE9
04362:  MOVLW  00
04364:  ADDWFC xEC,W
04366:  MOVWF  FEA
04368:  MOVF   FEF,W
0436A:  SUBLW  58
0436C:  BNZ   4376
....................          sc+=2;
0436E:  MOVLW  02
04370:  ADDWF  xEB,F
04372:  MOVLW  00
04374:  ADDWFC xEC,F
....................       if(base==8 && *sc =='0')
04376:  MOVF   xEA,W
04378:  SUBLW  08
0437A:  BNZ   4392
0437C:  MOVFF  5EC,FEA
04380:  MOVFF  5EB,FE9
04384:  MOVF   FEF,W
04386:  SUBLW  30
04388:  BNZ   4392
....................          sc+=1;
0438A:  MOVLW  01
0438C:  ADDWF  xEB,F
0438E:  MOVLW  00
04390:  ADDWFC xEC,F
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
04392:  MOVF   xEA,W
04394:  SUBLW  02
04396:  BNZ   43C0
04398:  MOVFF  5EC,FEA
0439C:  MOVFF  5EB,FE9
043A0:  MOVF   FEF,W
043A2:  SUBLW  30
043A4:  BNZ   43C0
043A6:  MOVLW  01
043A8:  ADDWF  xEB,W
043AA:  MOVWF  FE9
043AC:  MOVLW  00
043AE:  ADDWFC xEC,W
043B0:  MOVWF  FEA
043B2:  MOVF   FEF,W
043B4:  SUBLW  62
043B6:  BNZ   43C0
....................          sc+=2;
043B8:  MOVLW  02
043BA:  ADDWF  xEB,F
043BC:  MOVLW  00
043BE:  ADDWFC xEC,F
.................... 
....................    }
043C0:  BRA    442A
....................    else if(*sc!='0') // base is 0, find base
043C2:  MOVFF  5EC,FEA
043C6:  MOVFF  5EB,FE9
043CA:  MOVF   FEF,W
043CC:  SUBLW  30
043CE:  BZ    43D6
....................       base=10;
043D0:  MOVLW  0A
043D2:  MOVWF  xEA
043D4:  BRA    442A
....................    else if (sc[1]=='x' || sc[1]=='X')
043D6:  MOVLW  01
043D8:  ADDWF  xEB,W
043DA:  MOVWF  FE9
043DC:  MOVLW  00
043DE:  ADDWFC xEC,W
043E0:  MOVWF  FEA
043E2:  MOVF   FEF,W
043E4:  SUBLW  78
043E6:  BZ    43FA
043E8:  MOVLW  01
043EA:  ADDWF  xEB,W
043EC:  MOVWF  FE9
043EE:  MOVLW  00
043F0:  ADDWFC xEC,W
043F2:  MOVWF  FEA
043F4:  MOVF   FEF,W
043F6:  SUBLW  58
043F8:  BNZ   4408
....................       base =16,sc+=2;
043FA:  MOVLW  10
043FC:  MOVWF  xEA
043FE:  MOVLW  02
04400:  ADDWF  xEB,F
04402:  MOVLW  00
04404:  ADDWFC xEC,F
04406:  BRA    442A
....................    else if(sc[1]=='b')
04408:  MOVLW  01
0440A:  ADDWF  xEB,W
0440C:  MOVWF  FE9
0440E:  MOVLW  00
04410:  ADDWFC xEC,W
04412:  MOVWF  FEA
04414:  MOVF   FEF,W
04416:  SUBLW  62
04418:  BNZ   4426
....................       base=2,sc+=2;
0441A:  MOVLW  02
0441C:  MOVWF  xEA
0441E:  ADDWF  xEB,F
04420:  MOVLW  00
04422:  ADDWFC xEC,F
04424:  BRA    442A
....................    else
....................       base=8;
04426:  MOVLW  08
04428:  MOVWF  xEA
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
0442A:  MOVFF  5EC,5EE
0442E:  MOVFF  5EB,5ED
04432:  MOVFF  5EC,FEA
04436:  MOVFF  5EB,FE9
0443A:  MOVF   FEF,W
0443C:  SUBLW  30
0443E:  BNZ   4448
04440:  INCF   xEB,F
04442:  BTFSC  FD8.2
04444:  INCF   xEC,F
04446:  BRA    4432
....................    sd=memchr(digits,tolower(*sc),base);
04448:  MOVFF  5EC,03
0444C:  MOVFF  5EB,FE9
04450:  MOVFF  03,FEA
04454:  MOVFF  FEF,618
04458:  MOVLB  6
0445A:  MOVF   x18,W
0445C:  SUBLW  40
0445E:  BC    446C
04460:  MOVF   x18,W
04462:  SUBLW  5A
04464:  BNC   446C
04466:  MOVF   x18,W
04468:  IORLW  20
0446A:  BRA    446E
0446C:  MOVF   x18,W
0446E:  MOVWF  x18
04470:  MOVLW  05
04472:  MOVWF  x1A
04474:  MOVLW  F4
04476:  MOVWF  x19
04478:  MOVFF  618,61B
0447C:  CLRF   x1D
0447E:  MOVFF  5EA,61C
04482:  BTFSC  x1C.7
04484:  DECF   x1D,F
04486:  MOVLB  0
04488:  RCALL  4184
0448A:  MOVFF  02,5F0
0448E:  MOVFF  01,5EF
....................    for(; sd!=0; )
04492:  MOVLB  5
04494:  MOVF   xEF,F
04496:  BNZ   449C
04498:  MOVF   xF0,F
0449A:  BZ    4536
....................    {
....................       x=x*base+(int16)(sd-digits);
0449C:  CLRF   03
0449E:  MOVF   xEA,W
044A0:  MOVWF  00
044A2:  BTFSC  FE8.7
044A4:  DECF   03,F
044A6:  MOVLB  6
044A8:  MOVWF  x18
044AA:  MOVFF  03,619
044AE:  MOVFF  5F2,61B
044B2:  MOVFF  5F1,61A
044B6:  MOVFF  03,61D
044BA:  MOVWF  x1C
044BC:  MOVLB  0
044BE:  BRA    41CE
044C0:  MOVFF  01,618
044C4:  MOVLW  F4
044C6:  MOVLB  5
044C8:  SUBWF  xEF,W
044CA:  MOVWF  00
044CC:  MOVLW  05
044CE:  SUBWFB xF0,W
044D0:  MOVWF  03
044D2:  MOVF   00,W
044D4:  ADDWF  01,W
044D6:  MOVWF  01
044D8:  MOVF   02,W
044DA:  ADDWFC 03,F
044DC:  MOVFF  01,5F1
044E0:  MOVLB  5
044E2:  MOVFF  03,5F2
....................       ++sc;
044E6:  INCF   xEB,F
044E8:  BTFSC  FD8.2
044EA:  INCF   xEC,F
....................       sd=memchr(digits,tolower(*sc),base);
044EC:  MOVFF  5EC,FEA
044F0:  MOVFF  5EB,FE9
044F4:  MOVFF  FEF,618
044F8:  MOVLB  6
044FA:  MOVF   x18,W
044FC:  SUBLW  40
044FE:  BC    450C
04500:  MOVF   x18,W
04502:  SUBLW  5A
04504:  BNC   450C
04506:  MOVF   x18,W
04508:  IORLW  20
0450A:  BRA    450E
0450C:  MOVF   x18,W
0450E:  MOVWF  x18
04510:  MOVLW  05
04512:  MOVWF  x1A
04514:  MOVLW  F4
04516:  MOVWF  x19
04518:  MOVFF  618,61B
0451C:  CLRF   x1D
0451E:  MOVFF  5EA,61C
04522:  BTFSC  x1C.7
04524:  DECF   x1D,F
04526:  MOVLB  0
04528:  RCALL  4184
0452A:  MOVFF  02,5F0
0452E:  MOVFF  01,5EF
04532:  BRA    4492
04534:  MOVLB  5
....................    }
....................    if(s1==sc)
04536:  MOVF   xEB,W
04538:  SUBWF  xED,W
0453A:  BNZ   4564
0453C:  MOVF   xEC,W
0453E:  SUBWF  xEE,W
04540:  BNZ   4564
....................    {
....................    StrtoulGO:
....................       if (endptr)
04542:  MOVLB  5
04544:  MOVF   xE8,W
04546:  IORWF  xE9,W
04548:  BZ    455C
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
0454A:  MOVFF  5E9,FEA
0454E:  MOVFF  5E8,FE9
04552:  MOVFF  5E7,FEC
04556:  MOVF   FED,F
04558:  MOVFF  5E6,FEF
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................          }
....................    return 0;
0455C:  MOVLW  00
0455E:  MOVWF  01
04560:  MOVWF  02
04562:  BRA    4584
....................    }
....................    if (endptr)
04564:  MOVF   xE8,W
04566:  IORWF  xE9,W
04568:  BZ    457C
....................    {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
0456A:  MOVFF  5E9,FEA
0456E:  MOVFF  5E8,FE9
04572:  MOVFF  5EC,FEC
04576:  MOVF   FED,F
04578:  MOVFF  5EB,FEF
....................          #ELSE
....................          *((char *)endptr)=sc; 
....................          #ENDIF
....................    }
....................    return x;
0457C:  MOVFF  5F1,01
04580:  MOVFF  5F2,02
04584:  MOVLB  0
04586:  RETURN 0
.................... }
.................... 
.................... 
.................... signed long strtol(char *s,char *endptr, signed int base)
.................... {
....................    char *sc,*s1,*sd;
....................    signed long x=0;
....................    char sign;
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz";
....................    for(sc=s;isspace(*sc);++sc);
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+';
....................    if (base <0 || base ==1|| base >36) // invalid base
....................    goto StrtolGO;
....................    else if (base)
....................    {
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X'))
....................          sc+=2;
....................       if(base==8 && *sc =='0')
....................          sc+=1;
....................       if(base==2 && *sc =='0'&&sc[1]=='b')
....................          sc+=2;
.................... 
....................    }
....................    else if(*sc!='0') // base is 0, find base
....................       base=10;
....................    else if (sc[1]=='x' || sc[1]=='X')
....................       base =16,sc+=2;
....................    else if(sc[1]=='b')
....................       base=2,sc+=2;
....................    else
....................       base=8;
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes
.................... 
....................    sd=memchr(digits,tolower(*sc),base);
....................    for(;sd!=0;)
....................    {
....................       x=x*base+(int16)(sd-digits);
....................       ++sc;
....................       sd=memchr(digits,tolower(*sc),base);
....................    }
....................    if(s1==sc)
....................    {
....................    StrtolGO:
....................       if (endptr)
....................       {
....................          #IF LONG_POINTERS
....................          *((int16 *)endptr)= s; 
....................          #ELSE
....................          *((char *)endptr)=s;
....................          #ENDIF
....................       }
....................    return 0;
....................    }
....................    if(sign=='-')
....................       x  =-x;
....................    if (endptr)
....................    {
....................         #IF LONG_POINTERS
....................          *((int16 *)endptr)= sc; 
....................         #ELSE
....................         *((char *)endptr)=sc;
....................         #ENDIF
....................    }
....................    return x;
.................... }
.................... #endif
.................... 
.................... signed int8 system(char *string)
.................... {
....................    return 0;
.................... }
.................... 
.................... size_t mblen(char *s,size_t n)
.................... {
....................    return strlen(s);
.................... }
.................... 
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n)
.................... {
....................    *pwc=*s;
....................    return 1;
.................... }
.................... 
.................... int8 wctomb(char *s,wchar_t wchar)
.................... {
....................    *s=wchar;
....................    return 1;
.................... }
.................... 
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n)
.................... {
....................    strncpy((char *)pwcs,s,n);
....................    return strlen((char *)pwcs);
.................... }
.................... 
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n)
.................... {
....................    strncpy(s,(char *)pwcs,n);
....................    return strlen(s);
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // The random number implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... unsigned int32 _Randseed;
.................... 
.................... unsigned int16 rand(void)
.................... {
....................    _Randseed = _Randseed * 1103515245 + 12345;
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX);
.................... }
.................... 
.................... void srand(unsigned int32 seed)
.................... {
....................    _Randseed = seed;
.................... }
.................... 
.................... //---------------------------------------------------------------------------
.................... // Searching and sorting utilities implementation
.................... //---------------------------------------------------------------------------
.................... 
.................... #if !defined(__PCD__)
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2); 
.................... #else 
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2); 
.................... #endif
.................... 
.................... 
.................... 
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) {
....................    unsigned int m,j,i,l;
....................    int1 done;
....................    unsigned int8 t[16];
.................... 
....................    m = qitems/2;
....................    while( m > 0 ) {
....................      for(j=0; j<(qitems-m); ++j) {
....................         i = j;
....................         do
....................         {
....................            done=1;
....................            l = i+m;
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) {
....................               memcpy(t, qdata+i*qsize, qsize);
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize);
....................               memcpy(qdata+l*qsize, t, qsize);
....................               if(m <= i)
....................                 i -= m;
....................                 done = 0;
....................            }
....................         } while(!done);
....................      }
....................      m = m/2;
....................    }
.................... }
.................... 
.................... 
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp)
.................... {
....................    char *p, *q;
....................    size_t n;
....................    size_t pivot;
....................    signed int val;
.................... 
....................    p = base;
....................    n = num;
.................... 
....................    while (n > 0)
....................    {
....................       pivot = n >> 1;
....................       q = p + width * pivot;
.................... 
....................       val = (*cmp)(key, q);
.................... 
....................       if (val < 0)
....................          n = pivot;
....................       else if (val == 0)
....................          return ((char *)q);
....................       else {
....................          p = q + width;
....................          n -= pivot + 1;
....................       }
....................    }
.................... 
....................    return NULL;      // There's no match
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
003D6:  MOVLB  5
003D8:  CLRF   xC6
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
003DA:  CLRF   xC6
003DC:  MOVF   xC5,W
003DE:  SUBWF  xC6,W
003E0:  BC    0438
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
003E2:  MOVF   xC6,W
003E4:  ADDWF  xC3,W
003E6:  MOVWF  xC7
003E8:  MOVLW  00
003EA:  ADDWFC xC4,W
003EC:  MOVWF  xC8
003EE:  MOVF   xC6,W
003F0:  ADDWF  xC1,W
003F2:  MOVWF  01
003F4:  MOVLW  00
003F6:  ADDWFC xC2,W
003F8:  MOVWF  03
003FA:  MOVF   01,W
003FC:  MOVWF  FE9
003FE:  MOVFF  03,FEA
00402:  MOVFF  FEF,5C9
00406:  BSF    F7F.7
00408:  MOVF   FF2,W
0040A:  MOVWF  00
0040C:  BCF    FF2.7
0040E:  MOVFF  5C8,F7A
00412:  MOVFF  5C7,F79
00416:  MOVLW  31
00418:  MOVWF  F7B
0041A:  MOVFF  5C9,F7C
0041E:  MOVLB  F
00420:  MOVLW  55
00422:  MOVWF  F81
00424:  MOVLW  AA
00426:  MOVWF  F81
00428:  BSF    F80.4
0042A:  BTFSC  F80.4
0042C:  BRA    042A
0042E:  MOVF   00,W
00430:  IORWF  FF2,F
00432:  MOVLB  5
00434:  INCF   xC6,F
00436:  BRA    03DC
....................    }
00438:  MOVLB  0
0043A:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
*
0035A:  MOVLB  5
0035C:  CLRF   xC6
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
0035E:  CLRF   xC6
00360:  MOVF   xC5,W
00362:  SUBWF  xC6,W
00364:  BC    03A8
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
00366:  MOVF   xC6,W
00368:  ADDWF  xC1,W
0036A:  MOVWF  01
0036C:  MOVLW  00
0036E:  ADDWFC xC2,W
00370:  MOVWF  03
00372:  MOVF   01,W
00374:  MOVWF  FE9
00376:  MOVFF  03,FEA
0037A:  MOVF   xC6,W
0037C:  ADDWF  xC3,W
0037E:  MOVWF  xC9
00380:  MOVLW  00
00382:  ADDWFC xC4,W
00384:  MOVWF  xCA
00386:  BSF    F7F.7
00388:  MOVFF  FF2,5CB
0038C:  BCF    FF2.7
0038E:  MOVFF  5CA,F7A
00392:  MOVFF  5C9,F79
00396:  MOVLW  31
00398:  MOVWF  F7B
0039A:  BSF    F80.0
0039C:  MOVF   F7C,W
0039E:  BTFSC  xCB.7
003A0:  BSF    FF2.7
003A2:  MOVWF  FEF
003A4:  INCF   xC6,F
003A6:  BRA    0360
....................    }
003A8:  MOVLB  0
003AA:  RETURN 0
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
*
0043C:  MOVLB  5
0043E:  CLRF   xC2
00440:  MOVLW  20
00442:  MOVWF  xC1
00444:  CLRF   xC4
00446:  CLRF   xC3
00448:  MOVLW  80
0044A:  MOVWF  xC5
0044C:  MOVLB  0
0044E:  RCALL  03D6
....................    delay_ms(1);
00450:  MOVLW  01
00452:  MOVLB  5
00454:  MOVWF  xC4
00456:  MOVLB  0
00458:  RCALL  03AC
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
0045A:  MOVLB  5
0045C:  CLRF   xC2
0045E:  MOVLW  60
00460:  MOVWF  xC1
00462:  CLRF   xC4
00464:  MOVLW  80
00466:  MOVWF  xC3
00468:  MOVLW  02
0046A:  MOVWF  xC5
0046C:  MOVLB  0
0046E:  RCALL  03D6
....................    delay_ms(1);
00470:  MOVLW  01
00472:  MOVLB  5
00474:  MOVWF  xC4
00476:  MOVLB  0
00478:  RCALL  03AC
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0047A:  MOVLB  5
0047C:  CLRF   xC2
0047E:  MOVLW  61
00480:  MOVWF  xC1
00482:  CLRF   xC4
00484:  MOVLW  90
00486:  MOVWF  xC3
00488:  MOVLW  02
0048A:  MOVWF  xC5
0048C:  MOVLB  0
0048E:  RCALL  03D6
....................    delay_ms(1);
00490:  MOVLW  01
00492:  MOVLB  5
00494:  MOVWF  xC4
00496:  MOVLB  0
00498:  RCALL  03AC
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
0049A:  MOVLB  5
0049C:  CLRF   xC2
0049E:  MOVLW  62
004A0:  MOVWF  xC1
004A2:  CLRF   xC4
004A4:  MOVLW  A0
004A6:  MOVWF  xC3
004A8:  MOVLW  20
004AA:  MOVWF  xC5
004AC:  MOVLB  0
004AE:  RCALL  03D6
....................    delay_ms(1);
004B0:  MOVLW  01
004B2:  MOVLB  5
004B4:  MOVWF  xC4
004B6:  MOVLB  0
004B8:  RCALL  03AC
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
004BA:  MOVLB  5
004BC:  CLRF   xC2
004BE:  MOVLW  82
004C0:  MOVWF  xC1
004C2:  CLRF   xC4
004C4:  MOVLW  C0
004C6:  MOVWF  xC3
004C8:  MOVLW  30
004CA:  MOVWF  xC5
004CC:  MOVLB  0
004CE:  RCALL  03D6
....................    delay_ms(1);
004D0:  MOVLW  01
004D2:  MOVLB  5
004D4:  MOVWF  xC4
004D6:  MOVLB  0
004D8:  RCALL  03AC
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
004DA:  MOVLB  5
004DC:  CLRF   xC2
004DE:  MOVLW  B2
004E0:  MOVWF  xC1
004E2:  CLRF   xC4
004E4:  MOVLW  F0
004E6:  MOVWF  xC3
004E8:  MOVLW  38
004EA:  MOVWF  xC5
004EC:  MOVLB  0
004EE:  RCALL  03D6
....................    delay_ms(1);
004F0:  MOVLW  01
004F2:  MOVLB  5
004F4:  MOVWF  xC4
004F6:  MOVLB  0
004F8:  RCALL  03AC
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
004FA:  MOVLB  5
004FC:  CLRF   xC2
004FE:  MOVLW  F2
00500:  MOVWF  xC1
00502:  MOVLW  01
00504:  MOVWF  xC4
00506:  MOVLW  40
00508:  MOVWF  xC3
0050A:  MOVLW  01
0050C:  MOVWF  xC5
0050E:  MOVLB  0
00510:  RCALL  03D6
....................    delay_ms(1);
00512:  MOVLW  01
00514:  MOVLB  5
00516:  MOVWF  xC4
00518:  MOVLB  0
0051A:  RCALL  03AC
0051C:  GOTO   05EC (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
00520:  MOVLB  5
00522:  CLRF   xC2
00524:  MOVLW  20
00526:  MOVWF  xC1
00528:  CLRF   xC4
0052A:  CLRF   xC3
0052C:  MOVLW  80
0052E:  MOVWF  xC5
00530:  MOVLB  0
00532:  RCALL  035A
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
00534:  MOVLB  5
00536:  CLRF   xC2
00538:  MOVLW  60
0053A:  MOVWF  xC1
0053C:  CLRF   xC4
0053E:  MOVLW  80
00540:  MOVWF  xC3
00542:  MOVLW  02
00544:  MOVWF  xC5
00546:  MOVLB  0
00548:  RCALL  035A
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
0054A:  MOVLB  5
0054C:  CLRF   xC2
0054E:  MOVLW  61
00550:  MOVWF  xC1
00552:  CLRF   xC4
00554:  MOVLW  90
00556:  MOVWF  xC3
00558:  MOVLW  02
0055A:  MOVWF  xC5
0055C:  MOVLB  0
0055E:  RCALL  035A
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
00560:  MOVLB  5
00562:  CLRF   xC2
00564:  MOVLW  62
00566:  MOVWF  xC1
00568:  CLRF   xC4
0056A:  MOVLW  A0
0056C:  MOVWF  xC3
0056E:  MOVLW  20
00570:  MOVWF  xC5
00572:  MOVLB  0
00574:  RCALL  035A
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
00576:  MOVLB  5
00578:  CLRF   xC2
0057A:  MOVLW  82
0057C:  MOVWF  xC1
0057E:  CLRF   xC4
00580:  MOVLW  C0
00582:  MOVWF  xC3
00584:  MOVLW  30
00586:  MOVWF  xC5
00588:  MOVLB  0
0058A:  RCALL  035A
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
0058C:  MOVLB  5
0058E:  CLRF   xC2
00590:  MOVLW  B2
00592:  MOVWF  xC1
00594:  CLRF   xC4
00596:  MOVLW  F0
00598:  MOVWF  xC3
0059A:  MOVLW  38
0059C:  MOVWF  xC5
0059E:  MOVLB  0
005A0:  RCALL  035A
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005A2:  MOVLB  5
005A4:  CLRF   xC2
005A6:  MOVLW  F2
005A8:  MOVWF  xC1
005AA:  MOVLW  01
005AC:  MOVWF  xC4
005AE:  MOVLW  40
005B0:  MOVWF  xC3
005B2:  MOVLW  01
005B4:  MOVWF  xC5
005B6:  MOVLB  0
005B8:  RCALL  035A
005BA:  GOTO   05F0 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
005BE:  MOVLB  5
005C0:  CLRF   xC2
005C2:  MOVLW  F2
005C4:  MOVWF  xC1
005C6:  MOVLW  01
005C8:  MOVWF  xC4
005CA:  MOVLW  40
005CC:  MOVWF  xC3
005CE:  MOVLW  01
005D0:  MOVWF  xC5
005D2:  MOVLB  0
005D4:  RCALL  035A
....................    delay_ms(1);
005D6:  MOVLW  01
005D8:  MOVLB  5
005DA:  MOVWF  xC4
005DC:  MOVLB  0
005DE:  RCALL  03AC
....................    if (paramsValid != isValid)
005E0:  MOVF   xF2,W
005E2:  SUBLW  AA
005E4:  BZ    05EE
....................    {
....................       paramsValid = isValid;
005E6:  MOVLW  AA
005E8:  MOVWF  xF2
....................       params_save_to_ee(); // saves the base parameters on first boot
005EA:  BRA    043C
....................    }
005EC:  BRA    05F0
....................    else
....................    {
....................       params_load_from_ee();
005EE:  BRA    0520
....................    }
005F0:  GOTO   714C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <monitor.h>
.................... #ifndef monitor
.................... #define monitor
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <ADS1220.h>
.................... #ifndef ADS1220
.................... #define ADS1220
.................... 
.................... /*****************************************************************************/
.................... /* SET UP PORTS FOR USE WITH DRIVER                                          */
.................... /*****************************************************************************/
.................... #define _CS0  PIN_D5 // chip select pins 
.................... #define _CS1  PIN_D6
.................... #define _CS2  PIN_D7
.................... #define _CS3  PIN_B0
.................... 
.................... #pin_select SCK2=PIN_B1
.................... #pin_select SDI2=PIN_B2
.................... #pin_select SDO2=PIN_B3
.................... #use spi(MASTER, SPI2, BAUD=1000000, MODE=1, STREAM=SPI_mon)
*
00190:  MOVLB  E
00192:  MOVF   x8D,W
00194:  MOVFF  62E,E8D
00198:  RRCF   x90,W
0019A:  BNC   0198
0019C:  MOVF   x8D,W
0019E:  MOVWF  03
001A0:  MOVFF  62D,E8D
001A4:  RRCF   x90,W
001A6:  BNC   01A4
001A8:  MOVF   x8D,W
001AA:  MOVWF  02
001AC:  MOVFF  62C,E8D
001B0:  RRCF   x90,W
001B2:  BNC   01B0
001B4:  MOVF   x8D,W
001B6:  MOVWF  01
001B8:  MOVFF  62B,E8D
001BC:  RRCF   x90,W
001BE:  BNC   01BC
001C0:  MOVFF  E8D,00
001C4:  MOVLB  0
001C6:  RETURN 0
*
012CC:  CLRF   03
012CE:  MOVLB  E
012D0:  MOVF   x8D,W
012D2:  MOVFF  5D1,E8D
012D6:  RRCF   x90,W
012D8:  BNC   12D6
012DA:  MOVF   x8D,W
012DC:  MOVWF  02
012DE:  MOVFF  5D0,E8D
012E2:  RRCF   x90,W
012E4:  BNC   12E2
012E6:  MOVF   x8D,W
012E8:  MOVWF  01
012EA:  MOVFF  5CF,E8D
012EE:  RRCF   x90,W
012F0:  BNC   12EE
012F2:  MOVFF  E8D,00
012F6:  MOVLB  0
012F8:  GOTO   131A (RETURN)
.................... 
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* REGISTER DEFINITIONS                                                      */
.................... /*****************************************************************************/
.................... typedef enum {reg0 = 0x00,reg1 = 0x04 ,reg2 = 0x08, reg3 = 0x0C}adsReg;
.................... 
.................... //REGISTER 0 OPTIONS
.................... 
.................... #define IPp0n1 0x00
.................... #define IPp0n2 0x10
.................... #define IPp0n3 0x20
.................... #define IPp1n2 0x30
.................... #define IPp1n3 0x40
.................... #define IPp2n3 0x50
.................... #define IPp1n0 0x60
.................... #define IPp3n2 0x70
.................... #define IPp0nVss 0x80
.................... #define IPp1nVss 0x90
.................... #define IPp2nVss 0xA0
.................... #define IPp3nVss 0xB0
.................... #define IPVrpVrn 0xC0
.................... #define IPVddVss 0xD0
.................... #define IPhalfRail 0xE0
.................... 
.................... #define g1 0x00
.................... #define g2 0x02
.................... #define g4 0x04
.................... #define g8 0x06
.................... #define g16 0x08
.................... #define g32 0x0A
.................... #define g64 0x0C
.................... #define g128 0x0E
.................... 
.................... #define PGAenabled 0x00
.................... #define PGAbypass 0x01
.................... 
.................... //REGISTER 1 OPTIONS
.................... 
.................... #define DRn20 0x00
.................... #define DRn45 0x20
.................... #define DRn90 0x40
.................... #define DRn175 0x60
.................... #define DRn330 0x80
.................... #define DRn600 0xA0
.................... #define DRn1000 0xC0
.................... 
.................... #define MDnormal 0x00
.................... #define MDduty 0x80
.................... #define MDturbo 0x10
.................... 
.................... #define CMsingle 0x00
.................... #define CMcont 0x40
.................... 
.................... #define TSdisable 0x00
.................... #define TSenable 0x20
.................... 
.................... #define BCSoff 0x00
.................... #define BCSon 0x01
.................... 
.................... //REGISTER 2 OPTIONS
.................... 
.................... #define REFinternal 0x00
.................... #define REFp0n0 0x40
.................... #define REFp1n1 0x80
.................... #define REFVddVss 0xC0
.................... 
.................... #define FIRoff 0x00
.................... #define FIR5060 0x10
.................... #define FIR50 0x20
.................... #define FIR60 0x30
.................... 
.................... #define PSWopen 0x00
.................... #define PSWstart 0x08
.................... 
.................... #define Ioff 0x00
.................... #define Iu10 0x01
.................... #define Iu50 0x02
.................... #define Iu100 0x03
.................... #define Iu250 0x04
.................... #define Iu500 0x05
.................... #define Iu1000 0x06
.................... #define Iu1500 0x07  
.................... 
.................... //REGISTER 3 OPTIONS
.................... 
.................... #define I1disabled 0x00
.................... #define I1a0p1 0x20
.................... #define I1a1 0x40
.................... #define I1a2 0x60
.................... #define I1a3n1 0x80
.................... #define I1p0 0xA0
.................... #define I1n0 0xC0
.................... 
.................... #define I2disabled 0x00
.................... #define I2a0p1 0x04
.................... #define I2a1 0x08
.................... #define I2a2 0x0A
.................... #define I2a3n1 0x10
.................... #define I2p0 0x14
.................... #define I2n0 0x18
.................... 
.................... #define drdyPin 0x00
.................... #define doutPin 0x20
.................... 
.................... // REGISTER CONGIGURATIONS FOR THIS APP
.................... #define reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... //COMMANDS
.................... #define ADSreset 0x06
.................... #define ADSstart 0x08
.................... #define ADSpowerDn 0x02
.................... #define ADSreadData 0x10
.................... #define ADSreadReg 0x20
.................... #define ADSwriteReg 0x40
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* DESELECT ALL ADCs                                                         */
.................... /*****************************************************************************/
.................... void ads_deselect_all()
.................... {
....................    output_high(_CS0); // deselect all chip select pins
*
00136:  MOVLW  1F
00138:  MOVWF  F8A
0013A:  BSF    F85.5
....................    output_high(_CS1);
0013C:  MOVWF  F8A
0013E:  BSF    F85.6
....................    output_high(_CS2);
00140:  MOVWF  F8A
00142:  BSF    F85.7
....................    output_high(_CS3);
00144:  MOVLW  F4
00146:  MOVWF  F88
00148:  BSF    F83.0
0014A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT DESIRED ADC                                                        */
.................... /*****************************************************************************/
.................... void ads_select_ch(int8 ch)
.................... {
....................    ads_deselect_all();
*
005F4:  RCALL  0136
....................    switch(ch)
005F6:  MOVLB  5
005F8:  MOVF   xD1,W
005FA:  XORLW  00
005FC:  MOVLB  0
005FE:  BZ    060A
00600:  XORLW  01
00602:  BZ    0612
00604:  XORLW  03
00606:  BZ    061A
00608:  BRA    0622
....................    {
....................       case 0:
....................          output_low(_CS0);
0060A:  MOVLW  1F
0060C:  MOVWF  F8A
0060E:  BCF    F85.5
....................       break; 
00610:  BRA    0636
....................       case 1:
....................          output_low(_CS1);
00612:  MOVLW  1F
00614:  MOVWF  F8A
00616:  BCF    F85.6
....................       break;   
00618:  BRA    0636
....................       case 2:
....................          output_low(_CS2);
0061A:  MOVLW  1F
0061C:  MOVWF  F8A
0061E:  BCF    F85.7
....................       break;   
00620:  BRA    0636
....................       default: // select all
....................          output_low(_CS0);
00622:  MOVLW  1F
00624:  MOVWF  F8A
00626:  BCF    F85.5
....................          output_low(_CS1);
00628:  MOVWF  F8A
0062A:  BCF    F85.6
....................          output_low(_CS2);
0062C:  MOVWF  F8A
0062E:  BCF    F85.7
....................          output_low(_CS3);
00630:  MOVLW  F4
00632:  MOVWF  F88
00634:  BCF    F83.0
....................       break;             
....................    }
00636:  GOTO   0640 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* SELECT ADC BLOCK (2 ADCs/BLOCK)                                           */
.................... /*****************************************************************************/
.................... void ads_select_block(int8 block)
.................... {
....................    ads_deselect_all();
*
0014C:  RCALL  0136
....................    switch(block)
0014E:  MOVLB  6
00150:  MOVF   x2B,W
00152:  XORLW  00
00154:  MOVLB  0
00156:  BZ    015E
00158:  XORLW  01
0015A:  BZ    016A
0015C:  BRA    0178
....................    {
....................       case 0:
....................          output_low(_CS0);
0015E:  MOVLW  1F
00160:  MOVWF  F8A
00162:  BCF    F85.5
....................          output_low(_CS1);
00164:  MOVWF  F8A
00166:  BCF    F85.6
....................       break; 
00168:  BRA    018C
....................       case 1:
....................          output_low(_CS2);
0016A:  MOVLW  1F
0016C:  MOVWF  F8A
0016E:  BCF    F85.7
....................          output_low(_CS3);
00170:  MOVLW  F4
00172:  MOVWF  F88
00174:  BCF    F83.0
....................       break;   
00176:  BRA    018C
....................       default: // select all
....................          output_low(_CS0);
00178:  MOVLW  1F
0017A:  MOVWF  F8A
0017C:  BCF    F85.5
....................          output_low(_CS1);
0017E:  MOVWF  F8A
00180:  BCF    F85.6
....................          output_low(_CS2);
00182:  MOVWF  F8A
00184:  BCF    F85.7
....................          output_low(_CS3);
00186:  MOVLW  F4
00188:  MOVWF  F88
0018A:  BCF    F83.0
....................       break;             
....................    }
0018C:  GOTO   01CE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE                                                    */
.................... /*****************************************************************************/
.................... void ads_write_command(int8 ch, unsigned int8 command)
.................... {
....................    ads_select_ch(ch);
*
0063A:  MOVFF  5CF,5D1
0063E:  BRA    05F4
00640:  CLRF   19
00642:  BTFSC  FF2.7
00644:  BSF    19.7
00646:  BCF    FF2.7
....................    spi_xfer(SPI_mon, command);
00648:  MOVLB  6
0064A:  CLRF   x2E
0064C:  CLRF   x2D
0064E:  CLRF   x2C
00650:  MOVFF  5D0,62B
00654:  MOVLB  0
00656:  RCALL  0190
00658:  BTFSC  19.7
0065A:  BSF    FF2.7
0065C:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE THE COMMAND BYTE TO A BLOCK OF ADCs                                 */
.................... /*****************************************************************************/
.................... void ads_write_command_block(int8 block, unsigned int8 command)
.................... {
....................    ads_select_block(block);
*
001C8:  MOVFF  629,62B
001CC:  BRA    014C
....................    spi_xfer(SPI_mon, command);
001CE:  MOVLB  6
001D0:  CLRF   x2E
001D2:  CLRF   x2D
001D4:  CLRF   x2C
001D6:  MOVFF  62A,62B
001DA:  MOVLB  0
001DC:  RCALL  0190
001DE:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* WRITE REGISTER DATA                                                       */
.................... /*****************************************************************************/
.................... void ads_write_reg(int8 ch, adsReg regID, int8 data)
*
00684:  MOVLB  5
00686:  MOVF   xCC,W
00688:  IORLW  40
0068A:  MOVWF  xCE
.................... {
....................    unsigned int8 command = ADSwriteReg | regID | 0; // 0 is numbytes to write-1
....................    ads_write_command(ch, command);
0068C:  MOVFF  5CB,5CF
00690:  MOVFF  5CE,5D0
00694:  MOVLB  0
00696:  RCALL  063A
00698:  CLRF   19
0069A:  BTFSC  FF2.7
0069C:  BSF    19.7
0069E:  BCF    FF2.7
....................    spi_xfer(SPI_mon, data);
006A0:  MOVLB  6
006A2:  CLRF   x2E
006A4:  CLRF   x2D
006A6:  CLRF   x2C
006A8:  MOVFF  5CD,62B
006AC:  MOVLB  0
006AE:  RCALL  0190
006B0:  BTFSC  19.7
006B2:  BSF    FF2.7
....................    ads_deselect_all();
006B4:  RCALL  0136
006B6:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER REGISTER                                                    */
.................... /*****************************************************************************/
.................... unsigned int8 ads_read_reg(int8 ch, adsReg regID)
.................... {
....................    unsigned int8 command = ADSreadReg | regID | 0;
....................    ads_write_command(ch, command);
....................    unsigned int8 data = spi_xfer(SPI_mon, 0, 8);
....................    ads_deselect_all();
....................    return data;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* READ DATA                                                                 */
.................... /*****************************************************************************/
.................... unsigned int32 ads_read_data(int8 ch)
.................... {
....................    ads_write_command(ch, ADSreadData);
*
012FC:  MOVFF  5CA,5CF
01300:  MOVLW  10
01302:  MOVLB  5
01304:  MOVWF  xD0
01306:  MOVLB  0
01308:  CALL   063A
....................    unsigned int32 data = spi_xfer(SPI_mon, 0, 24);
0130C:  MOVLB  5
0130E:  CLRF   xD2
01310:  CLRF   xD1
01312:  CLRF   xD0
01314:  CLRF   xCF
01316:  MOVLB  0
01318:  BRA    12CC
0131A:  MOVF   01,W
0131C:  MOVFF  03,5CE
01320:  MOVFF  02,5CD
01324:  MOVFF  01,5CC
01328:  MOVFF  00,5CB
....................    ads_deselect_all();
0132C:  CALL   0136
....................    return data;
01330:  MOVFF  5CB,00
01334:  MOVFF  5CC,01
01338:  MOVFF  5CD,02
0133C:  MOVFF  5CE,03
01340:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE A CHANNEL                                                      */
.................... /*****************************************************************************/
.................... 
.................... void ADS1220init(int8 ch, rc0=reg0config, rc1=reg1config, rc2=reg2config, rc3=reg3config)
.................... {
....................    ads_write_command(ch, ADSreset);   //reset the device
*
006B8:  MOVFF  5C6,5CF
006BC:  MOVLW  06
006BE:  MOVLB  5
006C0:  MOVWF  xD0
006C2:  MOVLB  0
006C4:  RCALL  063A
....................    delay_us(100);                    
006C6:  MOVLW  64
006C8:  MOVLB  5
006CA:  MOVWF  xCB
006CC:  MOVLB  0
006CE:  BRA    065E
....................    ads_write_reg(ch, reg0, rc0);   //send default configurations
006D0:  MOVFF  5C6,5CB
006D4:  MOVLB  5
006D6:  CLRF   xCC
006D8:  MOVFF  5C7,5CD
006DC:  MOVLB  0
006DE:  RCALL  0684
....................    ads_write_reg(ch, reg1, rc1);
006E0:  MOVFF  5C6,5CB
006E4:  MOVLW  04
006E6:  MOVLB  5
006E8:  MOVWF  xCC
006EA:  MOVFF  5C8,5CD
006EE:  MOVLB  0
006F0:  RCALL  0684
....................    ads_write_reg(ch, reg2, rc2);
006F2:  MOVFF  5C6,5CB
006F6:  MOVLW  08
006F8:  MOVLB  5
006FA:  MOVWF  xCC
006FC:  MOVFF  5C9,5CD
00700:  MOVLB  0
00702:  RCALL  0684
....................    ads_write_reg(ch, reg3, rc3);  
00704:  MOVFF  5C6,5CB
00708:  MOVLW  0C
0070A:  MOVLB  5
0070C:  MOVWF  xCC
0070E:  MOVFF  5CA,5CD
00712:  MOVLB  0
00714:  RCALL  0684
00716:  GOTO   0752 (RETURN)
.................... }
.................... #endif 
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
*
01D60:  MOVLB  6
01D62:  BCF    x14.0
....................    y = x;
01D64:  MOVFF  608,60D
01D68:  MOVFF  607,60C
01D6C:  MOVFF  606,60B
01D70:  MOVFF  605,60A
.................... 
....................    if (x < 0)
01D74:  MOVFF  608,618
01D78:  MOVFF  607,617
01D7C:  MOVFF  606,616
01D80:  MOVFF  605,615
01D84:  CLRF   x1C
01D86:  CLRF   x1B
01D88:  CLRF   x1A
01D8A:  CLRF   x19
01D8C:  MOVLB  0
01D8E:  CALL   137A
01D92:  BNC   1DA0
....................    {
....................       s = 1;
01D94:  MOVLB  6
01D96:  BSF    x14.0
....................       y = -y;
01D98:  MOVF   x0B,W
01D9A:  XORLW  80
01D9C:  MOVWF  x0B
01D9E:  MOVLB  0
....................    }
.................... 
....................    if (y <= 32768.0)
01DA0:  MOVFF  60D,618
01DA4:  MOVFF  60C,617
01DA8:  MOVFF  60B,616
01DAC:  MOVFF  60A,615
01DB0:  MOVLB  6
01DB2:  CLRF   x1C
01DB4:  CLRF   x1B
01DB6:  CLRF   x1A
01DB8:  MOVLW  8E
01DBA:  MOVWF  x19
01DBC:  MOVLB  0
01DBE:  CALL   137A
01DC2:  BC    1DC6
01DC4:  BNZ   1DF6
....................       res = (float32)(unsigned int16)y;
01DC6:  MOVFF  60D,618
01DCA:  MOVFF  60C,617
01DCE:  MOVFF  60B,616
01DD2:  MOVFF  60A,615
01DD6:  RCALL  1D24
01DD8:  MOVFF  02,61A
01DDC:  MOVFF  01,619
01DE0:  CALL   0A12
01DE4:  MOVFF  03,611
01DE8:  MOVFF  02,610
01DEC:  MOVFF  01,60F
01DF0:  MOVFF  00,60E
01DF4:  BRA    1F98
.................... 
....................  else if (y < 10000000.0)
01DF6:  MOVFF  60D,618
01DFA:  MOVFF  60C,617
01DFE:  MOVFF  60B,616
01E02:  MOVFF  60A,615
01E06:  MOVLW  80
01E08:  MOVLB  6
01E0A:  MOVWF  x1C
01E0C:  MOVLW  96
01E0E:  MOVWF  x1B
01E10:  MOVLW  18
01E12:  MOVWF  x1A
01E14:  MOVLW  96
01E16:  MOVWF  x19
01E18:  MOVLB  0
01E1A:  CALL   137A
01E1E:  BTFSS  FD8.0
01E20:  BRA    1F88
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
01E22:  MOVFF  60D,618
01E26:  MOVFF  60C,617
01E2A:  MOVFF  60B,616
01E2E:  MOVFF  60A,615
01E32:  MOVLB  6
01E34:  CLRF   x1C
01E36:  CLRF   x1B
01E38:  CLRF   x1A
01E3A:  MOVLW  70
01E3C:  MOVWF  x19
01E3E:  MOVLB  0
01E40:  CALL   0A48
01E44:  MOVFF  03,618
01E48:  MOVFF  02,617
01E4C:  MOVFF  01,616
01E50:  MOVFF  00,615
01E54:  RCALL  1D24
01E56:  MOVFF  02,613
01E5A:  MOVFF  01,612
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
01E5E:  MOVFF  60D,618
01E62:  MOVFF  60C,617
01E66:  MOVFF  60B,616
01E6A:  MOVFF  60A,615
01E6E:  MOVLB  6
01E70:  CLRF   x1C
01E72:  CLRF   x1B
01E74:  CLRF   x1A
01E76:  MOVLW  70
01E78:  MOVWF  x19
01E7A:  MOVLB  0
01E7C:  CALL   0A48
01E80:  MOVFF  03,618
01E84:  MOVFF  02,617
01E88:  MOVFF  01,616
01E8C:  MOVFF  00,615
01E90:  MOVFF  613,61A
01E94:  MOVFF  612,619
01E98:  CALL   0A12
01E9C:  BSF    FD8.1
01E9E:  MOVFF  618,61C
01EA2:  MOVFF  617,61B
01EA6:  MOVFF  616,61A
01EAA:  MOVFF  615,619
01EAE:  MOVFF  03,620
01EB2:  MOVFF  02,61F
01EB6:  MOVFF  01,61E
01EBA:  MOVFF  00,61D
01EBE:  CALL   0B3E
01EC2:  MOVLB  6
01EC4:  CLRF   x18
01EC6:  CLRF   x17
01EC8:  CLRF   x16
01ECA:  MOVLW  8E
01ECC:  MOVWF  x15
01ECE:  MOVFF  03,61C
01ED2:  MOVFF  02,61B
01ED6:  MOVFF  01,61A
01EDA:  MOVFF  00,619
01EDE:  MOVLB  0
01EE0:  CALL   0A48
01EE4:  MOVFF  03,60D
01EE8:  MOVFF  02,60C
01EEC:  MOVFF  01,60B
01EF0:  MOVFF  00,60A
....................       res = 32768.0*(float32)l;
01EF4:  MOVFF  613,61A
01EF8:  MOVFF  612,619
01EFC:  CALL   0A12
01F00:  MOVLB  6
01F02:  CLRF   x18
01F04:  CLRF   x17
01F06:  CLRF   x16
01F08:  MOVLW  8E
01F0A:  MOVWF  x15
01F0C:  MOVFF  03,61C
01F10:  MOVFF  02,61B
01F14:  MOVFF  01,61A
01F18:  MOVFF  00,619
01F1C:  MOVLB  0
01F1E:  CALL   0A48
01F22:  MOVFF  03,611
01F26:  MOVFF  02,610
01F2A:  MOVFF  01,60F
01F2E:  MOVFF  00,60E
....................       res += (float32)(unsigned int16)y;
01F32:  MOVFF  60D,618
01F36:  MOVFF  60C,617
01F3A:  MOVFF  60B,616
01F3E:  MOVFF  60A,615
01F42:  RCALL  1D24
01F44:  MOVFF  02,61A
01F48:  MOVFF  01,619
01F4C:  CALL   0A12
01F50:  BCF    FD8.1
01F52:  MOVFF  611,61C
01F56:  MOVFF  610,61B
01F5A:  MOVFF  60F,61A
01F5E:  MOVFF  60E,619
01F62:  MOVFF  03,620
01F66:  MOVFF  02,61F
01F6A:  MOVFF  01,61E
01F6E:  MOVFF  00,61D
01F72:  CALL   0B3E
01F76:  MOVFF  03,611
01F7A:  MOVFF  02,610
01F7E:  MOVFF  01,60F
01F82:  MOVFF  00,60E
....................    }
01F86:  BRA    1F98
.................... 
....................  else
....................   res = y;
01F88:  MOVFF  60D,611
01F8C:  MOVFF  60C,610
01F90:  MOVFF  60B,60F
01F94:  MOVFF  60A,60E
.................... 
....................  y = y - (float32)(unsigned int16)y;
01F98:  MOVFF  60D,618
01F9C:  MOVFF  60C,617
01FA0:  MOVFF  60B,616
01FA4:  MOVFF  60A,615
01FA8:  RCALL  1D24
01FAA:  MOVFF  02,61A
01FAE:  MOVFF  01,619
01FB2:  CALL   0A12
01FB6:  BSF    FD8.1
01FB8:  MOVFF  60D,61C
01FBC:  MOVFF  60C,61B
01FC0:  MOVFF  60B,61A
01FC4:  MOVFF  60A,619
01FC8:  MOVFF  03,620
01FCC:  MOVFF  02,61F
01FD0:  MOVFF  01,61E
01FD4:  MOVFF  00,61D
01FD8:  CALL   0B3E
01FDC:  MOVFF  03,60D
01FE0:  MOVFF  02,60C
01FE4:  MOVFF  01,60B
01FE8:  MOVFF  00,60A
.................... 
....................  if (s)
01FEC:  MOVLB  6
01FEE:  BTFSS  x14.0
01FF0:  BRA    1FF8
....................   res = -res;
01FF2:  MOVF   x0F,W
01FF4:  XORLW  80
01FF6:  MOVWF  x0F
.................... 
....................  if (y != 0)
01FF8:  MOVFF  60D,618
01FFC:  MOVFF  60C,617
02000:  MOVFF  60B,616
02004:  MOVFF  60A,615
02008:  CLRF   x1C
0200A:  CLRF   x1B
0200C:  CLRF   x1A
0200E:  CLRF   x19
02010:  MOVLB  0
02012:  CALL   137A
02016:  BZ    2090
....................  {
....................   if (s == 1 && n == 0)
02018:  MOVLB  6
0201A:  BTFSS  x14.0
0201C:  BRA    2056
0201E:  MOVF   x09,F
02020:  BNZ   2056
....................    res -= 1.0;
02022:  BSF    FD8.1
02024:  MOVFF  611,61C
02028:  MOVFF  610,61B
0202C:  MOVFF  60F,61A
02030:  MOVFF  60E,619
02034:  CLRF   x20
02036:  CLRF   x1F
02038:  CLRF   x1E
0203A:  MOVLW  7F
0203C:  MOVWF  x1D
0203E:  MOVLB  0
02040:  CALL   0B3E
02044:  MOVFF  03,611
02048:  MOVFF  02,610
0204C:  MOVFF  01,60F
02050:  MOVFF  00,60E
02054:  MOVLB  6
.................... 
....................   if (s == 0 && n == 1)
02056:  BTFSC  x14.0
02058:  BRA    2092
0205A:  DECFSZ x09,W
0205C:  BRA    2092
....................    res += 1.0;
0205E:  BCF    FD8.1
02060:  MOVFF  611,61C
02064:  MOVFF  610,61B
02068:  MOVFF  60F,61A
0206C:  MOVFF  60E,619
02070:  CLRF   x20
02072:  CLRF   x1F
02074:  CLRF   x1E
02076:  MOVLW  7F
02078:  MOVWF  x1D
0207A:  MOVLB  0
0207C:  CALL   0B3E
02080:  MOVFF  03,611
02084:  MOVFF  02,610
02088:  MOVFF  01,60F
0208C:  MOVFF  00,60E
02090:  MOVLB  6
....................  }
....................  if (x == 0)
02092:  MOVFF  608,618
02096:  MOVFF  607,617
0209A:  MOVFF  606,616
0209E:  MOVFF  605,615
020A2:  CLRF   x1C
020A4:  CLRF   x1B
020A6:  CLRF   x1A
020A8:  CLRF   x19
020AA:  MOVLB  0
020AC:  CALL   137A
020B0:  BNZ   20BE
....................     res = 0;
020B2:  MOVLB  6
020B4:  CLRF   x11
020B6:  CLRF   x10
020B8:  CLRF   x0F
020BA:  CLRF   x0E
020BC:  MOVLB  0
.................... 
....................  return (res);
020BE:  MOVFF  60E,00
020C2:  MOVFF  60F,01
020C6:  MOVFF  610,02
020CA:  MOVFF  611,03
020CE:  RETURN 0
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
*
020EE:  MOVFF  604,608
020F2:  MOVFF  603,607
020F6:  MOVFF  602,606
020FA:  MOVFF  601,605
020FE:  MOVLB  6
02100:  CLRF   x09
02102:  MOVLB  0
02104:  RCALL  1D60
02106:  GOTO   2212 (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
*
020D0:  MOVFF  604,608
020D4:  MOVFF  603,607
020D8:  MOVFF  602,606
020DC:  MOVFF  601,605
020E0:  MOVLW  01
020E2:  MOVLB  6
020E4:  MOVWF  x09
020E6:  MOVLB  0
020E8:  RCALL  1D60
020EA:  GOTO   21CA (RETURN)
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
*
0210A:  MOVFF  5F8,618
0210E:  MOVFF  5F7,617
02112:  MOVFF  5F6,616
02116:  MOVFF  5F5,615
0211A:  MOVLB  6
0211C:  CLRF   x1C
0211E:  CLRF   x1B
02120:  CLRF   x1A
02122:  CLRF   x19
02124:  MOVLB  0
02126:  CALL   137A
0212A:  BTFSC  FD8.2
0212C:  BRA    226E
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
0212E:  MOVFF  5F4,611
02132:  MOVFF  5F3,610
02136:  MOVFF  5F2,60F
0213A:  MOVFF  5F1,60E
0213E:  MOVFF  5F8,615
02142:  MOVFF  5F7,614
02146:  MOVFF  5F6,613
0214A:  MOVFF  5F5,612
0214E:  CALL   13F4
02152:  MOVFF  03,600
02156:  MOVFF  02,5FF
0215A:  MOVFF  01,5FE
0215E:  MOVFF  00,5FD
02162:  MOVFF  03,618
02166:  MOVFF  02,617
0216A:  MOVFF  01,616
0216E:  MOVFF  00,615
02172:  MOVLB  6
02174:  CLRF   x1C
02176:  CLRF   x1B
02178:  CLRF   x1A
0217A:  CLRF   x19
0217C:  MOVLB  0
0217E:  CALL   137A
02182:  BNC   21CC
02184:  MOVFF  5F4,611
02188:  MOVFF  5F3,610
0218C:  MOVFF  5F2,60F
02190:  MOVFF  5F1,60E
02194:  MOVFF  5F8,615
02198:  MOVFF  5F7,614
0219C:  MOVFF  5F6,613
021A0:  MOVFF  5F5,612
021A4:  CALL   13F4
021A8:  MOVFF  03,600
021AC:  MOVFF  02,5FF
021B0:  MOVFF  01,5FE
021B4:  MOVFF  00,5FD
021B8:  MOVFF  03,604
021BC:  MOVFF  02,603
021C0:  MOVFF  01,602
021C4:  MOVFF  00,601
021C8:  BRA    20D0
021CA:  BRA    2212
021CC:  MOVFF  5F4,611
021D0:  MOVFF  5F3,610
021D4:  MOVFF  5F2,60F
021D8:  MOVFF  5F1,60E
021DC:  MOVFF  5F8,615
021E0:  MOVFF  5F7,614
021E4:  MOVFF  5F6,613
021E8:  MOVFF  5F5,612
021EC:  CALL   13F4
021F0:  MOVFF  03,600
021F4:  MOVFF  02,5FF
021F8:  MOVFF  01,5FE
021FC:  MOVFF  00,5FD
02200:  MOVFF  03,604
02204:  MOVFF  02,603
02208:  MOVFF  01,602
0220C:  MOVFF  00,601
02210:  BRA    20EE
02212:  MOVFF  03,5FC
02216:  MOVFF  02,5FB
0221A:  MOVFF  01,5FA
0221E:  MOVFF  00,5F9
....................       return(x-(i*y));
02222:  MOVFF  5FC,618
02226:  MOVFF  5FB,617
0222A:  MOVFF  5FA,616
0222E:  MOVFF  5F9,615
02232:  MOVFF  5F8,61C
02236:  MOVFF  5F7,61B
0223A:  MOVFF  5F6,61A
0223E:  MOVFF  5F5,619
02242:  CALL   0A48
02246:  BSF    FD8.1
02248:  MOVFF  5F4,61C
0224C:  MOVFF  5F3,61B
02250:  MOVFF  5F2,61A
02254:  MOVFF  5F1,619
02258:  MOVFF  03,620
0225C:  MOVFF  02,61F
02260:  MOVFF  01,61E
02264:  MOVFF  00,61D
02268:  CALL   0B3E
0226C:  BRA    226E
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
0226E:  RETURN 0
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
*
02652:  MOVFF  5F8,618
02656:  MOVFF  5F7,617
0265A:  MOVFF  5F6,616
0265E:  MOVFF  5F5,615
02662:  MOVLW  3B
02664:  MOVLB  6
02666:  MOVWF  x1C
02668:  MOVLW  AA
0266A:  MOVWF  x1B
0266C:  MOVLW  38
0266E:  MOVWF  x1A
02670:  MOVLW  7F
02672:  MOVWF  x19
02674:  MOVLB  0
02676:  CALL   0A48
0267A:  MOVFF  03,618
0267E:  MOVFF  02,617
02682:  MOVFF  01,616
02686:  MOVFF  00,615
0268A:  CALL   1D24
0268E:  MOVFF  01,605
....................    s = 0;
02692:  MOVLB  6
02694:  BCF    x06.0
....................    y = x;
02696:  MOVFF  5F8,5FC
0269A:  MOVFF  5F7,5FB
0269E:  MOVFF  5F6,5FA
026A2:  MOVFF  5F5,5F9
.................... 
....................    if (x < 0)
026A6:  MOVFF  5F8,618
026AA:  MOVFF  5F7,617
026AE:  MOVFF  5F6,616
026B2:  MOVFF  5F5,615
026B6:  CLRF   x1C
026B8:  CLRF   x1B
026BA:  CLRF   x1A
026BC:  CLRF   x19
026BE:  MOVLB  0
026C0:  CALL   137A
026C4:  BNC   26D6
....................    {
....................       s = 1;
026C6:  MOVLB  6
026C8:  BSF    x06.0
....................       n = -n;
026CA:  NEGF   x05
....................       y = -y;
026CC:  MOVLB  5
026CE:  MOVF   xFA,W
026D0:  XORLW  80
026D2:  MOVWF  xFA
026D4:  MOVLB  0
....................    }
.................... 
....................    res = 0.0;
026D6:  MOVLB  6
026D8:  CLRF   x00
026DA:  MOVLB  5
026DC:  CLRF   xFF
026DE:  CLRF   xFE
026E0:  CLRF   xFD
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
026E2:  MOVLW  05
026E4:  MOVLB  6
026E6:  MOVWF  x08
026E8:  MOVLW  FD
026EA:  MOVFF  608,FEA
026EE:  MOVWF  FE9
026F0:  MOVLW  7F
026F2:  ADDWF  x05,W
026F4:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
026F6:  MOVFF  5FC,618
026FA:  MOVFF  5FB,617
026FE:  MOVFF  5FA,616
02702:  MOVFF  5F9,615
02706:  MOVLW  3B
02708:  MOVWF  x1C
0270A:  MOVLW  AA
0270C:  MOVWF  x1B
0270E:  MOVLW  38
02710:  MOVWF  x1A
02712:  MOVLW  7F
02714:  MOVWF  x19
02716:  MOVLB  0
02718:  CALL   0A48
0271C:  MOVFF  03,60A
02720:  MOVFF  02,609
02724:  MOVFF  01,608
02728:  MOVFF  00,607
0272C:  MOVLB  6
0272E:  CLRF   x0C
02730:  MOVFF  605,60B
02734:  BTFSC  x0B.7
02736:  DECF   x0C,F
02738:  MOVLB  0
0273A:  RCALL  2270
0273C:  BSF    FD8.1
0273E:  MOVFF  60A,61C
02742:  MOVFF  609,61B
02746:  MOVFF  608,61A
0274A:  MOVFF  607,619
0274E:  MOVFF  03,620
02752:  MOVFF  02,61F
02756:  MOVFF  01,61E
0275A:  MOVFF  00,61D
0275E:  CALL   0B3E
02762:  MOVFF  03,5FC
02766:  MOVFF  02,5FB
0276A:  MOVFF  01,5FA
0276E:  MOVFF  00,5F9
.................... 
....................    r = pe[0]*y + pe[1];
02772:  MOVLW  7C
02774:  MOVLB  6
02776:  MOVWF  x18
02778:  MOVLW  88
0277A:  MOVWF  x17
0277C:  MOVLW  59
0277E:  MOVWF  x16
02780:  MOVLW  72
02782:  MOVWF  x15
02784:  MOVFF  5FC,61C
02788:  MOVFF  5FB,61B
0278C:  MOVFF  5FA,61A
02790:  MOVFF  5F9,619
02794:  MOVLB  0
02796:  CALL   0A48
0279A:  MOVFF  03,60A
0279E:  MOVFF  02,609
027A2:  MOVFF  01,608
027A6:  MOVFF  00,607
027AA:  BCF    FD8.1
027AC:  MOVFF  03,61C
027B0:  MOVFF  02,61B
027B4:  MOVFF  01,61A
027B8:  MOVFF  00,619
027BC:  MOVLW  E0
027BE:  MOVLB  6
027C0:  MOVWF  x20
027C2:  MOVLW  97
027C4:  MOVWF  x1F
027C6:  MOVLW  26
027C8:  MOVWF  x1E
027CA:  MOVLW  75
027CC:  MOVWF  x1D
027CE:  MOVLB  0
027D0:  CALL   0B3E
027D4:  MOVFF  03,604
027D8:  MOVFF  02,603
027DC:  MOVFF  01,602
027E0:  MOVFF  00,601
....................    r = r*y + pe[2];
027E4:  MOVFF  604,618
027E8:  MOVFF  603,617
027EC:  MOVFF  602,616
027F0:  MOVFF  601,615
027F4:  MOVFF  5FC,61C
027F8:  MOVFF  5FB,61B
027FC:  MOVFF  5FA,61A
02800:  MOVFF  5F9,619
02804:  CALL   0A48
02808:  MOVFF  03,60A
0280C:  MOVFF  02,609
02810:  MOVFF  01,608
02814:  MOVFF  00,607
02818:  BCF    FD8.1
0281A:  MOVFF  03,61C
0281E:  MOVFF  02,61B
02822:  MOVFF  01,61A
02826:  MOVFF  00,619
0282A:  MOVLW  C4
0282C:  MOVLB  6
0282E:  MOVWF  x20
02830:  MOVLW  1D
02832:  MOVWF  x1F
02834:  MOVLW  1E
02836:  MOVWF  x1E
02838:  MOVLW  78
0283A:  MOVWF  x1D
0283C:  MOVLB  0
0283E:  CALL   0B3E
02842:  MOVFF  03,604
02846:  MOVFF  02,603
0284A:  MOVFF  01,602
0284E:  MOVFF  00,601
....................    r = r*y + pe[3];
02852:  MOVFF  604,618
02856:  MOVFF  603,617
0285A:  MOVFF  602,616
0285E:  MOVFF  601,615
02862:  MOVFF  5FC,61C
02866:  MOVFF  5FB,61B
0286A:  MOVFF  5FA,61A
0286E:  MOVFF  5F9,619
02872:  CALL   0A48
02876:  MOVFF  03,60A
0287A:  MOVFF  02,609
0287E:  MOVFF  01,608
02882:  MOVFF  00,607
02886:  BCF    FD8.1
02888:  MOVFF  03,61C
0288C:  MOVFF  02,61B
02890:  MOVFF  01,61A
02894:  MOVFF  00,619
02898:  MOVLW  5E
0289A:  MOVLB  6
0289C:  MOVWF  x20
0289E:  MOVLW  50
028A0:  MOVWF  x1F
028A2:  MOVLW  63
028A4:  MOVWF  x1E
028A6:  MOVLW  7A
028A8:  MOVWF  x1D
028AA:  MOVLB  0
028AC:  CALL   0B3E
028B0:  MOVFF  03,604
028B4:  MOVFF  02,603
028B8:  MOVFF  01,602
028BC:  MOVFF  00,601
....................    r = r*y + pe[4];
028C0:  MOVFF  604,618
028C4:  MOVFF  603,617
028C8:  MOVFF  602,616
028CC:  MOVFF  601,615
028D0:  MOVFF  5FC,61C
028D4:  MOVFF  5FB,61B
028D8:  MOVFF  5FA,61A
028DC:  MOVFF  5F9,619
028E0:  CALL   0A48
028E4:  MOVFF  03,60A
028E8:  MOVFF  02,609
028EC:  MOVFF  01,608
028F0:  MOVFF  00,607
028F4:  BCF    FD8.1
028F6:  MOVFF  03,61C
028FA:  MOVFF  02,61B
028FE:  MOVFF  01,61A
02902:  MOVFF  00,619
02906:  MOVLW  1A
02908:  MOVLB  6
0290A:  MOVWF  x20
0290C:  MOVLW  FE
0290E:  MOVWF  x1F
02910:  MOVLW  75
02912:  MOVWF  x1E
02914:  MOVLW  7C
02916:  MOVWF  x1D
02918:  MOVLB  0
0291A:  CALL   0B3E
0291E:  MOVFF  03,604
02922:  MOVFF  02,603
02926:  MOVFF  01,602
0292A:  MOVFF  00,601
....................    r = r*y + pe[5];
0292E:  MOVFF  604,618
02932:  MOVFF  603,617
02936:  MOVFF  602,616
0293A:  MOVFF  601,615
0293E:  MOVFF  5FC,61C
02942:  MOVFF  5FB,61B
02946:  MOVFF  5FA,61A
0294A:  MOVFF  5F9,619
0294E:  CALL   0A48
02952:  MOVFF  03,60A
02956:  MOVFF  02,609
0295A:  MOVFF  01,608
0295E:  MOVFF  00,607
02962:  BCF    FD8.1
02964:  MOVFF  03,61C
02968:  MOVFF  02,61B
0296C:  MOVFF  01,61A
02970:  MOVFF  00,619
02974:  MOVLW  18
02976:  MOVLB  6
02978:  MOVWF  x20
0297A:  MOVLW  72
0297C:  MOVWF  x1F
0297E:  MOVLW  31
02980:  MOVWF  x1E
02982:  MOVLW  7E
02984:  MOVWF  x1D
02986:  MOVLB  0
02988:  CALL   0B3E
0298C:  MOVFF  03,604
02990:  MOVFF  02,603
02994:  MOVFF  01,602
02998:  MOVFF  00,601
.................... 
....................    res = res*(1.0 + y*r);
0299C:  MOVFF  5FC,618
029A0:  MOVFF  5FB,617
029A4:  MOVFF  5FA,616
029A8:  MOVFF  5F9,615
029AC:  MOVFF  604,61C
029B0:  MOVFF  603,61B
029B4:  MOVFF  602,61A
029B8:  MOVFF  601,619
029BC:  CALL   0A48
029C0:  BCF    FD8.1
029C2:  MOVLB  6
029C4:  CLRF   x1C
029C6:  CLRF   x1B
029C8:  CLRF   x1A
029CA:  MOVLW  7F
029CC:  MOVWF  x19
029CE:  MOVFF  03,620
029D2:  MOVFF  02,61F
029D6:  MOVFF  01,61E
029DA:  MOVFF  00,61D
029DE:  MOVLB  0
029E0:  CALL   0B3E
029E4:  MOVFF  600,618
029E8:  MOVFF  5FF,617
029EC:  MOVFF  5FE,616
029F0:  MOVFF  5FD,615
029F4:  MOVFF  03,61C
029F8:  MOVFF  02,61B
029FC:  MOVFF  01,61A
02A00:  MOVFF  00,619
02A04:  CALL   0A48
02A08:  MOVFF  03,600
02A0C:  MOVFF  02,5FF
02A10:  MOVFF  01,5FE
02A14:  MOVFF  00,5FD
.................... 
....................    if (s)
02A18:  MOVLB  6
02A1A:  BTFSS  x06.0
02A1C:  BRA    2A50
....................       res = 1.0/res;
02A1E:  CLRF   x11
02A20:  CLRF   x10
02A22:  CLRF   x0F
02A24:  MOVLW  7F
02A26:  MOVWF  x0E
02A28:  MOVFF  600,615
02A2C:  MOVFF  5FF,614
02A30:  MOVFF  5FE,613
02A34:  MOVFF  5FD,612
02A38:  MOVLB  0
02A3A:  CALL   13F4
02A3E:  MOVFF  03,600
02A42:  MOVFF  02,5FF
02A46:  MOVFF  01,5FE
02A4A:  MOVFF  00,5FD
02A4E:  MOVLB  6
....................    return(res);
02A50:  MOVFF  5FD,00
02A54:  MOVFF  5FE,01
02A58:  MOVFF  5FF,02
02A5C:  MOVFF  600,03
02A60:  MOVLB  0
02A62:  RETURN 0
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
*
022C0:  MOVFF  5F8,5FC
022C4:  MOVFF  5F7,5FB
022C8:  MOVFF  5F6,5FA
022CC:  MOVFF  5F5,5F9
.................... 
....................    if (y != 1.0)
022D0:  MOVFF  5FC,618
022D4:  MOVFF  5FB,617
022D8:  MOVFF  5FA,616
022DC:  MOVFF  5F9,615
022E0:  MOVLB  6
022E2:  CLRF   x1C
022E4:  CLRF   x1B
022E6:  CLRF   x1A
022E8:  MOVLW  7F
022EA:  MOVWF  x19
022EC:  MOVLB  0
022EE:  CALL   137A
022F2:  BTFSC  FD8.2
022F4:  BRA    2632
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
022F6:  MOVLW  05
022F8:  MOVLB  6
022FA:  MOVWF  x0B
022FC:  MOVLW  F9
022FE:  MOVFF  60B,FEA
02302:  MOVWF  FE9
02304:  MOVLW  7E
02306:  MOVWF  FEF
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
02308:  BSF    FD8.1
0230A:  MOVFF  5FC,61C
0230E:  MOVFF  5FB,61B
02312:  MOVFF  5FA,61A
02316:  MOVFF  5F9,619
0231A:  CLRF   x20
0231C:  CLRF   x1F
0231E:  CLRF   x1E
02320:  MOVLW  7F
02322:  MOVWF  x1D
02324:  MOVLB  0
02326:  CALL   0B3E
0232A:  MOVFF  03,60D
0232E:  MOVFF  02,60C
02332:  MOVFF  01,60B
02336:  MOVFF  00,60A
0233A:  BCF    FD8.1
0233C:  MOVFF  5FC,61C
02340:  MOVFF  5FB,61B
02344:  MOVFF  5FA,61A
02348:  MOVFF  5F9,619
0234C:  MOVLB  6
0234E:  CLRF   x20
02350:  CLRF   x1F
02352:  CLRF   x1E
02354:  MOVLW  7F
02356:  MOVWF  x1D
02358:  MOVLB  0
0235A:  CALL   0B3E
0235E:  MOVFF  60D,611
02362:  MOVFF  60C,610
02366:  MOVFF  60B,60F
0236A:  MOVFF  60A,60E
0236E:  MOVFF  03,615
02372:  MOVFF  02,614
02376:  MOVFF  01,613
0237A:  MOVFF  00,612
0237E:  CALL   13F4
02382:  MOVFF  03,5FC
02386:  MOVFF  02,5FB
0238A:  MOVFF  01,5FA
0238E:  MOVFF  00,5F9
.................... 
....................       y2=y*y;
02392:  MOVFF  5FC,618
02396:  MOVFF  5FB,617
0239A:  MOVFF  5FA,616
0239E:  MOVFF  5F9,615
023A2:  MOVFF  5FC,61C
023A6:  MOVFF  5FB,61B
023AA:  MOVFF  5FA,61A
023AE:  MOVFF  5F9,619
023B2:  CALL   0A48
023B6:  MOVFF  03,608
023BA:  MOVFF  02,607
023BE:  MOVFF  01,606
023C2:  MOVFF  00,605
.................... 
....................       res = pl[0]*y2 + pl[1];
023C6:  MOVLW  99
023C8:  MOVLB  6
023CA:  MOVWF  x18
023CC:  MOVLW  47
023CE:  MOVWF  x17
023D0:  MOVLW  8A
023D2:  MOVWF  x16
023D4:  MOVLW  7F
023D6:  MOVWF  x15
023D8:  MOVFF  608,61C
023DC:  MOVFF  607,61B
023E0:  MOVFF  606,61A
023E4:  MOVFF  605,619
023E8:  MOVLB  0
023EA:  CALL   0A48
023EE:  MOVFF  03,60D
023F2:  MOVFF  02,60C
023F6:  MOVFF  01,60B
023FA:  MOVFF  00,60A
023FE:  BCF    FD8.1
02400:  MOVFF  03,61C
02404:  MOVFF  02,61B
02408:  MOVFF  01,61A
0240C:  MOVFF  00,619
02410:  MOVLB  6
02412:  CLRF   x20
02414:  CLRF   x1F
02416:  CLRF   x1E
02418:  MOVLW  80
0241A:  MOVWF  x1D
0241C:  MOVLB  0
0241E:  CALL   0B3E
02422:  MOVFF  03,600
02426:  MOVFF  02,5FF
0242A:  MOVFF  01,5FE
0242E:  MOVFF  00,5FD
.................... 
....................       r = ql[0]*y2 + ql[1];
02432:  MOVLW  4C
02434:  MOVLB  6
02436:  MOVWF  x18
02438:  MOVLW  F3
0243A:  MOVWF  x17
0243C:  MOVLW  3A
0243E:  MOVWF  x16
02440:  MOVLW  7B
02442:  MOVWF  x15
02444:  MOVFF  608,61C
02448:  MOVFF  607,61B
0244C:  MOVFF  606,61A
02450:  MOVFF  605,619
02454:  MOVLB  0
02456:  CALL   0A48
0245A:  MOVFF  03,60D
0245E:  MOVFF  02,60C
02462:  MOVFF  01,60B
02466:  MOVFF  00,60A
0246A:  BCF    FD8.1
0246C:  MOVFF  03,61C
02470:  MOVFF  02,61B
02474:  MOVFF  01,61A
02478:  MOVFF  00,619
0247C:  MOVLW  2B
0247E:  MOVLB  6
02480:  MOVWF  x20
02482:  MOVLW  9D
02484:  MOVWF  x1F
02486:  MOVLW  DF
02488:  MOVWF  x1E
0248A:  MOVLW  7E
0248C:  MOVWF  x1D
0248E:  MOVLB  0
02490:  CALL   0B3E
02494:  MOVFF  03,604
02498:  MOVFF  02,603
0249C:  MOVFF  01,602
024A0:  MOVFF  00,601
....................       r = r*y2 + 1.0;
024A4:  MOVFF  604,618
024A8:  MOVFF  603,617
024AC:  MOVFF  602,616
024B0:  MOVFF  601,615
024B4:  MOVFF  608,61C
024B8:  MOVFF  607,61B
024BC:  MOVFF  606,61A
024C0:  MOVFF  605,619
024C4:  CALL   0A48
024C8:  MOVFF  03,60D
024CC:  MOVFF  02,60C
024D0:  MOVFF  01,60B
024D4:  MOVFF  00,60A
024D8:  BCF    FD8.1
024DA:  MOVFF  03,61C
024DE:  MOVFF  02,61B
024E2:  MOVFF  01,61A
024E6:  MOVFF  00,619
024EA:  MOVLB  6
024EC:  CLRF   x20
024EE:  CLRF   x1F
024F0:  CLRF   x1E
024F2:  MOVLW  7F
024F4:  MOVWF  x1D
024F6:  MOVLB  0
024F8:  CALL   0B3E
024FC:  MOVFF  03,604
02500:  MOVFF  02,603
02504:  MOVFF  01,602
02508:  MOVFF  00,601
.................... 
....................       res = y*res/r;
0250C:  MOVFF  5FC,618
02510:  MOVFF  5FB,617
02514:  MOVFF  5FA,616
02518:  MOVFF  5F9,615
0251C:  MOVFF  600,61C
02520:  MOVFF  5FF,61B
02524:  MOVFF  5FE,61A
02528:  MOVFF  5FD,619
0252C:  CALL   0A48
02530:  MOVFF  03,60D
02534:  MOVFF  02,60C
02538:  MOVFF  01,60B
0253C:  MOVFF  00,60A
02540:  MOVFF  03,611
02544:  MOVFF  02,610
02548:  MOVFF  01,60F
0254C:  MOVFF  00,60E
02550:  MOVFF  604,615
02554:  MOVFF  603,614
02558:  MOVFF  602,613
0255C:  MOVFF  601,612
02560:  CALL   13F4
02564:  MOVFF  03,600
02568:  MOVFF  02,5FF
0256C:  MOVFF  01,5FE
02570:  MOVFF  00,5FD
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
02574:  MOVLW  05
02576:  MOVLB  6
02578:  MOVWF  x0B
0257A:  MOVLW  F5
0257C:  MOVFF  60B,FEA
02580:  MOVWF  FE9
02582:  MOVLW  7E
02584:  SUBWF  FEF,W
02586:  MOVWF  x09
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
02588:  BTFSS  x09.7
0258A:  BRA    25B4
....................          r = -(float32)-n;
0258C:  MOVLW  00
0258E:  BSF    FD8.0
02590:  SUBFWB x09,W
02592:  CLRF   x0C
02594:  MOVWF  x0B
02596:  BTFSC  x0B.7
02598:  DECF   x0C,F
0259A:  MOVLB  0
0259C:  RCALL  2270
0259E:  MOVFF  00,601
025A2:  MOVF   01,W
025A4:  XORLW  80
025A6:  MOVLB  6
025A8:  MOVWF  x02
025AA:  MOVFF  02,603
025AE:  MOVFF  03,604
025B2:  BRA    25D4
....................       else
....................          r = (float32)n;
025B4:  CLRF   x0C
025B6:  MOVFF  609,60B
025BA:  BTFSC  x0B.7
025BC:  DECF   x0C,F
025BE:  MOVLB  0
025C0:  RCALL  2270
025C2:  MOVFF  03,604
025C6:  MOVFF  02,603
025CA:  MOVFF  01,602
025CE:  MOVFF  00,601
025D2:  MOVLB  6
.................... 
....................       res += r*LN2;
025D4:  MOVFF  604,618
025D8:  MOVFF  603,617
025DC:  MOVFF  602,616
025E0:  MOVFF  601,615
025E4:  MOVLW  18
025E6:  MOVWF  x1C
025E8:  MOVLW  72
025EA:  MOVWF  x1B
025EC:  MOVLW  31
025EE:  MOVWF  x1A
025F0:  MOVLW  7E
025F2:  MOVWF  x19
025F4:  MOVLB  0
025F6:  CALL   0A48
025FA:  BCF    FD8.1
025FC:  MOVFF  600,61C
02600:  MOVFF  5FF,61B
02604:  MOVFF  5FE,61A
02608:  MOVFF  5FD,619
0260C:  MOVFF  03,620
02610:  MOVFF  02,61F
02614:  MOVFF  01,61E
02618:  MOVFF  00,61D
0261C:  CALL   0B3E
02620:  MOVFF  03,600
02624:  MOVFF  02,5FF
02628:  MOVFF  01,5FE
0262C:  MOVFF  00,5FD
....................    }
02630:  BRA    2640
.................... 
....................    else
....................       res = 0.0;
02632:  MOVLB  6
02634:  CLRF   x00
02636:  MOVLB  5
02638:  CLRF   xFF
0263A:  CLRF   xFE
0263C:  CLRF   xFD
0263E:  MOVLB  0
.................... 
....................    return(res);
02640:  MOVFF  5FD,00
02644:  MOVFF  5FE,01
02648:  MOVFF  5FF,02
0264C:  MOVFF  600,03
02650:  RETURN 0
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
*
02A64:  MOVFF  5EC,618
02A68:  MOVFF  5EB,617
02A6C:  MOVFF  5EA,616
02A70:  MOVFF  5E9,615
02A74:  MOVLB  6
02A76:  CLRF   x1C
02A78:  CLRF   x1B
02A7A:  CLRF   x1A
02A7C:  CLRF   x19
02A7E:  MOVLB  0
02A80:  CALL   137A
02A84:  BTFSS  FD8.0
02A86:  BRA    2C22
02A88:  MOVFF  5F0,5F4
02A8C:  MOVFF  5EF,5F3
02A90:  MOVFF  5EE,5F2
02A94:  MOVFF  5ED,5F1
02A98:  MOVLB  5
02A9A:  CLRF   xF8
02A9C:  CLRF   xF7
02A9E:  CLRF   xF6
02AA0:  MOVLW  7F
02AA2:  MOVWF  xF5
02AA4:  MOVLB  0
02AA6:  CALL   210A
02AAA:  MOVFF  03,5F4
02AAE:  MOVFF  02,5F3
02AB2:  MOVFF  01,5F2
02AB6:  MOVFF  00,5F1
02ABA:  MOVFF  03,618
02ABE:  MOVFF  02,617
02AC2:  MOVFF  01,616
02AC6:  MOVFF  00,615
02ACA:  MOVLB  6
02ACC:  CLRF   x1C
02ACE:  CLRF   x1B
02AD0:  CLRF   x1A
02AD2:  CLRF   x19
02AD4:  MOVLB  0
02AD6:  CALL   137A
02ADA:  BTFSS  FD8.2
02ADC:  BRA    2C22
....................       if(fmod(y, 2) == 0) {
02ADE:  MOVFF  5F0,5F4
02AE2:  MOVFF  5EF,5F3
02AE6:  MOVFF  5EE,5F2
02AEA:  MOVFF  5ED,5F1
02AEE:  MOVLB  5
02AF0:  CLRF   xF8
02AF2:  CLRF   xF7
02AF4:  CLRF   xF6
02AF6:  MOVLW  80
02AF8:  MOVWF  xF5
02AFA:  MOVLB  0
02AFC:  CALL   210A
02B00:  MOVFF  03,5F4
02B04:  MOVFF  02,5F3
02B08:  MOVFF  01,5F2
02B0C:  MOVFF  00,5F1
02B10:  MOVFF  03,618
02B14:  MOVFF  02,617
02B18:  MOVFF  01,616
02B1C:  MOVFF  00,615
02B20:  MOVLB  6
02B22:  CLRF   x1C
02B24:  CLRF   x1B
02B26:  CLRF   x1A
02B28:  CLRF   x19
02B2A:  MOVLB  0
02B2C:  CALL   137A
02B30:  BNZ   2BA8
....................          return (exp(log(-x) * y));
02B32:  MOVLB  5
02B34:  MOVF   xEA,W
02B36:  XORLW  80
02B38:  MOVWF  xF2
02B3A:  MOVFF  5EC,5F8
02B3E:  MOVFF  5EB,5F7
02B42:  MOVWF  xF6
02B44:  MOVFF  5E9,5F5
02B48:  MOVLB  0
02B4A:  CALL   22C0
02B4E:  MOVFF  03,5F4
02B52:  MOVFF  02,5F3
02B56:  MOVFF  01,5F2
02B5A:  MOVFF  00,5F1
02B5E:  MOVFF  03,618
02B62:  MOVFF  02,617
02B66:  MOVFF  01,616
02B6A:  MOVFF  00,615
02B6E:  MOVFF  5F0,61C
02B72:  MOVFF  5EF,61B
02B76:  MOVFF  5EE,61A
02B7A:  MOVFF  5ED,619
02B7E:  CALL   0A48
02B82:  MOVFF  03,5F4
02B86:  MOVFF  02,5F3
02B8A:  MOVFF  01,5F2
02B8E:  MOVFF  00,5F1
02B92:  MOVFF  03,5F8
02B96:  MOVFF  02,5F7
02B9A:  MOVFF  01,5F6
02B9E:  MOVFF  00,5F5
02BA2:  RCALL  2652
02BA4:  BRA    2D60
....................       } else {
02BA6:  BRA    2C20
....................          return (-exp(log(-x) * y));
02BA8:  MOVLB  5
02BAA:  MOVF   xEA,W
02BAC:  XORLW  80
02BAE:  MOVWF  xF2
02BB0:  MOVFF  5EC,5F8
02BB4:  MOVFF  5EB,5F7
02BB8:  MOVWF  xF6
02BBA:  MOVFF  5E9,5F5
02BBE:  MOVLB  0
02BC0:  CALL   22C0
02BC4:  MOVFF  03,5F4
02BC8:  MOVFF  02,5F3
02BCC:  MOVFF  01,5F2
02BD0:  MOVFF  00,5F1
02BD4:  MOVFF  03,618
02BD8:  MOVFF  02,617
02BDC:  MOVFF  01,616
02BE0:  MOVFF  00,615
02BE4:  MOVFF  5F0,61C
02BE8:  MOVFF  5EF,61B
02BEC:  MOVFF  5EE,61A
02BF0:  MOVFF  5ED,619
02BF4:  CALL   0A48
02BF8:  MOVFF  03,5F4
02BFC:  MOVFF  02,5F3
02C00:  MOVFF  01,5F2
02C04:  MOVFF  00,5F1
02C08:  MOVFF  03,5F8
02C0C:  MOVFF  02,5F7
02C10:  MOVFF  01,5F6
02C14:  MOVFF  00,5F5
02C18:  RCALL  2652
02C1A:  MOVLW  80
02C1C:  XORWF  01,F
02C1E:  BRA    2D60
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
02C20:  BRA    2D60
02C22:  MOVFF  5EC,618
02C26:  MOVFF  5EB,617
02C2A:  MOVFF  5EA,616
02C2E:  MOVFF  5E9,615
02C32:  MOVLB  6
02C34:  CLRF   x1C
02C36:  CLRF   x1B
02C38:  CLRF   x1A
02C3A:  CLRF   x19
02C3C:  MOVLB  0
02C3E:  CALL   137A
02C42:  BNC   2CA4
02C44:  MOVFF  5F0,5F4
02C48:  MOVFF  5EF,5F3
02C4C:  MOVFF  5EE,5F2
02C50:  MOVFF  5ED,5F1
02C54:  MOVLB  5
02C56:  CLRF   xF8
02C58:  CLRF   xF7
02C5A:  CLRF   xF6
02C5C:  MOVLW  7F
02C5E:  MOVWF  xF5
02C60:  MOVLB  0
02C62:  CALL   210A
02C66:  MOVFF  03,5F4
02C6A:  MOVFF  02,5F3
02C6E:  MOVFF  01,5F2
02C72:  MOVFF  00,5F1
02C76:  MOVFF  03,618
02C7A:  MOVFF  02,617
02C7E:  MOVFF  01,616
02C82:  MOVFF  00,615
02C86:  MOVLB  6
02C88:  CLRF   x1C
02C8A:  CLRF   x1B
02C8C:  CLRF   x1A
02C8E:  CLRF   x19
02C90:  MOVLB  0
02C92:  CALL   137A
02C96:  BZ    2CA4
....................       return 0;
02C98:  CLRF   00
02C9A:  CLRF   01
02C9C:  CLRF   02
02C9E:  CLRF   03
02CA0:  BRA    2D60
....................    } else {
02CA2:  BRA    2D60
....................       if(x != 0 || 0 >= y) {
02CA4:  MOVFF  5EC,618
02CA8:  MOVFF  5EB,617
02CAC:  MOVFF  5EA,616
02CB0:  MOVFF  5E9,615
02CB4:  MOVLB  6
02CB6:  CLRF   x1C
02CB8:  CLRF   x1B
02CBA:  CLRF   x1A
02CBC:  CLRF   x19
02CBE:  MOVLB  0
02CC0:  CALL   137A
02CC4:  BNZ   2CEA
02CC6:  MOVFF  5F0,618
02CCA:  MOVFF  5EF,617
02CCE:  MOVFF  5EE,616
02CD2:  MOVFF  5ED,615
02CD6:  MOVLB  6
02CD8:  CLRF   x1C
02CDA:  CLRF   x1B
02CDC:  CLRF   x1A
02CDE:  CLRF   x19
02CE0:  MOVLB  0
02CE2:  CALL   137A
02CE6:  BC    2CEA
02CE8:  BNZ   2D58
....................          return (exp(log(x) * y));
02CEA:  MOVFF  5EC,5F8
02CEE:  MOVFF  5EB,5F7
02CF2:  MOVFF  5EA,5F6
02CF6:  MOVFF  5E9,5F5
02CFA:  CALL   22C0
02CFE:  MOVFF  03,5F4
02D02:  MOVFF  02,5F3
02D06:  MOVFF  01,5F2
02D0A:  MOVFF  00,5F1
02D0E:  MOVFF  03,618
02D12:  MOVFF  02,617
02D16:  MOVFF  01,616
02D1A:  MOVFF  00,615
02D1E:  MOVFF  5F0,61C
02D22:  MOVFF  5EF,61B
02D26:  MOVFF  5EE,61A
02D2A:  MOVFF  5ED,619
02D2E:  CALL   0A48
02D32:  MOVFF  03,5F4
02D36:  MOVFF  02,5F3
02D3A:  MOVFF  01,5F2
02D3E:  MOVFF  00,5F1
02D42:  MOVFF  03,5F8
02D46:  MOVFF  02,5F7
02D4A:  MOVFF  01,5F6
02D4E:  MOVFF  00,5F5
02D52:  RCALL  2652
02D54:  BRA    2D60
....................       } else return 0;
02D56:  BRA    2D60
02D58:  CLRF   00
02D5A:  CLRF   01
02D5C:  CLRF   02
02D5E:  CLRF   03
....................    }
02D60:  RETURN 0
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
*
01552:  MOVLB  6
01554:  BCF    x07.0
....................    flag = 0;
01556:  BCF    x07.1
....................    y = x;
01558:  MOVFF  5FA,5FE
0155C:  MOVFF  5F9,5FD
01560:  MOVFF  5F8,5FC
01564:  MOVFF  5F7,5FB
.................... 
....................    if (x < 0)
01568:  MOVFF  5FA,618
0156C:  MOVFF  5F9,617
01570:  MOVFF  5F8,616
01574:  MOVFF  5F7,615
01578:  CLRF   x1C
0157A:  CLRF   x1B
0157C:  CLRF   x1A
0157E:  CLRF   x19
01580:  MOVLB  0
01582:  RCALL  137A
01584:  BNC   1594
....................    {
....................       s = 1;
01586:  MOVLB  6
01588:  BSF    x07.0
....................       y = -y;
0158A:  MOVLB  5
0158C:  MOVF   xFC,W
0158E:  XORLW  80
01590:  MOVWF  xFC
01592:  MOVLB  0
....................    }
.................... 
....................    if (y > 1.0)
01594:  MOVLB  6
01596:  CLRF   x18
01598:  CLRF   x17
0159A:  CLRF   x16
0159C:  MOVLW  7F
0159E:  MOVWF  x15
015A0:  MOVFF  5FE,61C
015A4:  MOVFF  5FD,61B
015A8:  MOVFF  5FC,61A
015AC:  MOVFF  5FB,619
015B0:  MOVLB  0
015B2:  RCALL  137A
015B4:  BNC   15EC
....................    {
....................       y = 1.0/y;
015B6:  MOVLB  6
015B8:  CLRF   x11
015BA:  CLRF   x10
015BC:  CLRF   x0F
015BE:  MOVLW  7F
015C0:  MOVWF  x0E
015C2:  MOVFF  5FE,615
015C6:  MOVFF  5FD,614
015CA:  MOVFF  5FC,613
015CE:  MOVFF  5FB,612
015D2:  MOVLB  0
015D4:  RCALL  13F4
015D6:  MOVFF  03,5FE
015DA:  MOVFF  02,5FD
015DE:  MOVFF  01,5FC
015E2:  MOVFF  00,5FB
....................       flag = 1;
015E6:  MOVLB  6
015E8:  BSF    x07.1
015EA:  MOVLB  0
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
015EC:  MOVLW  0A
015EE:  MOVLB  6
015F0:  MOVWF  x18
015F2:  MOVLW  89
015F4:  MOVWF  x17
015F6:  MOVLW  34
015F8:  MOVWF  x16
015FA:  MOVLW  7C
015FC:  MOVWF  x15
015FE:  MOVFF  5FE,61C
01602:  MOVFF  5FD,61B
01606:  MOVFF  5FC,61A
0160A:  MOVFF  5FB,619
0160E:  MOVLB  0
01610:  CALL   0A48
01614:  MOVFF  03,60B
01618:  MOVFF  02,60A
0161C:  MOVFF  01,609
01620:  MOVFF  00,608
01624:  MOVFF  03,618
01628:  MOVFF  02,617
0162C:  MOVFF  01,616
01630:  MOVFF  00,615
01634:  MOVFF  5FE,61C
01638:  MOVFF  5FD,61B
0163C:  MOVFF  5FC,61A
01640:  MOVFF  5FB,619
01644:  CALL   0A48
01648:  MOVFF  03,60B
0164C:  MOVFF  02,60A
01650:  MOVFF  01,609
01654:  MOVFF  00,608
01658:  BCF    FD8.1
0165A:  MOVFF  03,61C
0165E:  MOVFF  02,61B
01662:  MOVFF  01,61A
01666:  MOVFF  00,619
0166A:  MOVLW  7C
0166C:  MOVLB  6
0166E:  MOVWF  x20
01670:  MOVLW  79
01672:  MOVWF  x1F
01674:  MOVLW  35
01676:  MOVWF  x1E
01678:  MOVLW  81
0167A:  MOVWF  x1D
0167C:  MOVLB  0
0167E:  CALL   0B3E
01682:  MOVFF  03,602
01686:  MOVFF  02,601
0168A:  MOVFF  01,600
0168E:  MOVFF  00,5FF
....................    res = res*y*y + pat[2];
01692:  MOVFF  602,618
01696:  MOVFF  601,617
0169A:  MOVFF  600,616
0169E:  MOVFF  5FF,615
016A2:  MOVFF  5FE,61C
016A6:  MOVFF  5FD,61B
016AA:  MOVFF  5FC,61A
016AE:  MOVFF  5FB,619
016B2:  CALL   0A48
016B6:  MOVFF  03,60B
016BA:  MOVFF  02,60A
016BE:  MOVFF  01,609
016C2:  MOVFF  00,608
016C6:  MOVFF  03,618
016CA:  MOVFF  02,617
016CE:  MOVFF  01,616
016D2:  MOVFF  00,615
016D6:  MOVFF  5FE,61C
016DA:  MOVFF  5FD,61B
016DE:  MOVFF  5FC,61A
016E2:  MOVFF  5FB,619
016E6:  CALL   0A48
016EA:  MOVFF  03,60B
016EE:  MOVFF  02,60A
016F2:  MOVFF  01,609
016F6:  MOVFF  00,608
016FA:  BCF    FD8.1
016FC:  MOVFF  03,61C
01700:  MOVFF  02,61B
01704:  MOVFF  01,61A
01708:  MOVFF  00,619
0170C:  MOVLW  3F
0170E:  MOVLB  6
01710:  MOVWF  x20
01712:  MOVLW  02
01714:  MOVWF  x1F
01716:  MOVLW  33
01718:  MOVWF  x1E
0171A:  MOVLW  83
0171C:  MOVWF  x1D
0171E:  MOVLB  0
01720:  CALL   0B3E
01724:  MOVFF  03,602
01728:  MOVFF  02,601
0172C:  MOVFF  01,600
01730:  MOVFF  00,5FF
....................    res = res*y*y + pat[3];
01734:  MOVFF  602,618
01738:  MOVFF  601,617
0173C:  MOVFF  600,616
01740:  MOVFF  5FF,615
01744:  MOVFF  5FE,61C
01748:  MOVFF  5FD,61B
0174C:  MOVFF  5FC,61A
01750:  MOVFF  5FB,619
01754:  CALL   0A48
01758:  MOVFF  03,60B
0175C:  MOVFF  02,60A
01760:  MOVFF  01,609
01764:  MOVFF  00,608
01768:  MOVFF  03,618
0176C:  MOVFF  02,617
01770:  MOVFF  01,616
01774:  MOVFF  00,615
01778:  MOVFF  5FE,61C
0177C:  MOVFF  5FD,61B
01780:  MOVFF  5FC,61A
01784:  MOVFF  5FB,619
01788:  CALL   0A48
0178C:  MOVFF  03,60B
01790:  MOVFF  02,60A
01794:  MOVFF  01,609
01798:  MOVFF  00,608
0179C:  BCF    FD8.1
0179E:  MOVFF  03,61C
017A2:  MOVFF  02,61B
017A6:  MOVFF  01,61A
017AA:  MOVFF  00,619
017AE:  MOVLW  33
017B0:  MOVLB  6
017B2:  MOVWF  x20
017B4:  MOVLW  8C
017B6:  MOVWF  x1F
017B8:  MOVLW  1E
017BA:  MOVWF  x1E
017BC:  MOVLW  83
017BE:  MOVWF  x1D
017C0:  MOVLB  0
017C2:  CALL   0B3E
017C6:  MOVFF  03,602
017CA:  MOVFF  02,601
017CE:  MOVFF  01,600
017D2:  MOVFF  00,5FF
.................... 
....................    r = qat[0]*y*y + qat[1];
017D6:  MOVLB  6
017D8:  CLRF   x18
017DA:  CLRF   x17
017DC:  CLRF   x16
017DE:  MOVLW  7F
017E0:  MOVWF  x15
017E2:  MOVFF  5FE,61C
017E6:  MOVFF  5FD,61B
017EA:  MOVFF  5FC,61A
017EE:  MOVFF  5FB,619
017F2:  MOVLB  0
017F4:  CALL   0A48
017F8:  MOVFF  03,60B
017FC:  MOVFF  02,60A
01800:  MOVFF  01,609
01804:  MOVFF  00,608
01808:  MOVFF  03,618
0180C:  MOVFF  02,617
01810:  MOVFF  01,616
01814:  MOVFF  00,615
01818:  MOVFF  5FE,61C
0181C:  MOVFF  5FD,61B
01820:  MOVFF  5FC,61A
01824:  MOVFF  5FB,619
01828:  CALL   0A48
0182C:  MOVFF  03,60B
01830:  MOVFF  02,60A
01834:  MOVFF  01,609
01838:  MOVFF  00,608
0183C:  BCF    FD8.1
0183E:  MOVFF  03,61C
01842:  MOVFF  02,61B
01846:  MOVFF  01,61A
0184A:  MOVFF  00,619
0184E:  MOVLW  1B
01850:  MOVLB  6
01852:  MOVWF  x20
01854:  MOVLW  E4
01856:  MOVWF  x1F
01858:  MOVLW  35
0185A:  MOVWF  x1E
0185C:  MOVLW  82
0185E:  MOVWF  x1D
01860:  MOVLB  0
01862:  CALL   0B3E
01866:  MOVFF  03,606
0186A:  MOVFF  02,605
0186E:  MOVFF  01,604
01872:  MOVFF  00,603
....................    r = r*y*y + qat[2];
01876:  MOVFF  606,618
0187A:  MOVFF  605,617
0187E:  MOVFF  604,616
01882:  MOVFF  603,615
01886:  MOVFF  5FE,61C
0188A:  MOVFF  5FD,61B
0188E:  MOVFF  5FC,61A
01892:  MOVFF  5FB,619
01896:  CALL   0A48
0189A:  MOVFF  03,60B
0189E:  MOVFF  02,60A
018A2:  MOVFF  01,609
018A6:  MOVFF  00,608
018AA:  MOVFF  03,618
018AE:  MOVFF  02,617
018B2:  MOVFF  01,616
018B6:  MOVFF  00,615
018BA:  MOVFF  5FE,61C
018BE:  MOVFF  5FD,61B
018C2:  MOVFF  5FC,61A
018C6:  MOVFF  5FB,619
018CA:  CALL   0A48
018CE:  MOVFF  03,60B
018D2:  MOVFF  02,60A
018D6:  MOVFF  01,609
018DA:  MOVFF  00,608
018DE:  BCF    FD8.1
018E0:  MOVFF  03,61C
018E4:  MOVFF  02,61B
018E8:  MOVFF  01,61A
018EC:  MOVFF  00,619
018F0:  MOVLW  A4
018F2:  MOVLB  6
018F4:  MOVWF  x20
018F6:  MOVLW  DB
018F8:  MOVWF  x1F
018FA:  MOVLW  67
018FC:  MOVWF  x1E
018FE:  MOVLW  83
01900:  MOVWF  x1D
01902:  MOVLB  0
01904:  CALL   0B3E
01908:  MOVFF  03,606
0190C:  MOVFF  02,605
01910:  MOVFF  01,604
01914:  MOVFF  00,603
....................    r = r*y*y + qat[3];
01918:  MOVFF  606,618
0191C:  MOVFF  605,617
01920:  MOVFF  604,616
01924:  MOVFF  603,615
01928:  MOVFF  5FE,61C
0192C:  MOVFF  5FD,61B
01930:  MOVFF  5FC,61A
01934:  MOVFF  5FB,619
01938:  CALL   0A48
0193C:  MOVFF  03,60B
01940:  MOVFF  02,60A
01944:  MOVFF  01,609
01948:  MOVFF  00,608
0194C:  MOVFF  03,618
01950:  MOVFF  02,617
01954:  MOVFF  01,616
01958:  MOVFF  00,615
0195C:  MOVFF  5FE,61C
01960:  MOVFF  5FD,61B
01964:  MOVFF  5FC,61A
01968:  MOVFF  5FB,619
0196C:  CALL   0A48
01970:  MOVFF  03,60B
01974:  MOVFF  02,60A
01978:  MOVFF  01,609
0197C:  MOVFF  00,608
01980:  BCF    FD8.1
01982:  MOVFF  03,61C
01986:  MOVFF  02,61B
0198A:  MOVFF  01,61A
0198E:  MOVFF  00,619
01992:  MOVLW  33
01994:  MOVLB  6
01996:  MOVWF  x20
01998:  MOVLW  8C
0199A:  MOVWF  x1F
0199C:  MOVLW  1E
0199E:  MOVWF  x1E
019A0:  MOVLW  83
019A2:  MOVWF  x1D
019A4:  MOVLB  0
019A6:  CALL   0B3E
019AA:  MOVFF  03,606
019AE:  MOVFF  02,605
019B2:  MOVFF  01,604
019B6:  MOVFF  00,603
.................... 
....................    res = y*res/r;
019BA:  MOVFF  5FE,618
019BE:  MOVFF  5FD,617
019C2:  MOVFF  5FC,616
019C6:  MOVFF  5FB,615
019CA:  MOVFF  602,61C
019CE:  MOVFF  601,61B
019D2:  MOVFF  600,61A
019D6:  MOVFF  5FF,619
019DA:  CALL   0A48
019DE:  MOVFF  03,60B
019E2:  MOVFF  02,60A
019E6:  MOVFF  01,609
019EA:  MOVFF  00,608
019EE:  MOVFF  03,611
019F2:  MOVFF  02,610
019F6:  MOVFF  01,60F
019FA:  MOVFF  00,60E
019FE:  MOVFF  606,615
01A02:  MOVFF  605,614
01A06:  MOVFF  604,613
01A0A:  MOVFF  603,612
01A0E:  RCALL  13F4
01A10:  MOVFF  03,602
01A14:  MOVFF  02,601
01A18:  MOVFF  01,600
01A1C:  MOVFF  00,5FF
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
01A20:  MOVLB  6
01A22:  BTFSS  x07.1
01A24:  BRA    1A60
....................       res = PI_DIV_BY_TWO - res;
01A26:  BSF    FD8.1
01A28:  MOVLW  DB
01A2A:  MOVWF  x1C
01A2C:  MOVLW  0F
01A2E:  MOVWF  x1B
01A30:  MOVLW  49
01A32:  MOVWF  x1A
01A34:  MOVLW  7F
01A36:  MOVWF  x19
01A38:  MOVFF  602,620
01A3C:  MOVFF  601,61F
01A40:  MOVFF  600,61E
01A44:  MOVFF  5FF,61D
01A48:  MOVLB  0
01A4A:  CALL   0B3E
01A4E:  MOVFF  03,602
01A52:  MOVFF  02,601
01A56:  MOVFF  01,600
01A5A:  MOVFF  00,5FF
01A5E:  MOVLB  6
....................    if (s)
01A60:  BTFSS  x07.0
01A62:  BRA    1A6A
....................       res = -res;
01A64:  MOVF   x00,W
01A66:  XORLW  80
01A68:  MOVWF  x00
.................... 
....................    return(res);
01A6A:  MOVFF  5FF,00
01A6E:  MOVFF  600,01
01A72:  MOVFF  601,02
01A76:  MOVFF  602,03
01A7A:  MOVLB  0
01A7C:  RETURN 0
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
01A7E:  MOVLB  5
01A80:  BCF    xF5.0
....................    quad=0; //quadrant
01A82:  CLRF   xF6
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
01A84:  MOVFF  5EC,618
01A88:  MOVFF  5EB,617
01A8C:  MOVFF  5EA,616
01A90:  MOVFF  5E9,615
01A94:  MOVLB  6
01A96:  CLRF   x1C
01A98:  CLRF   x1B
01A9A:  CLRF   x1A
01A9C:  CLRF   x19
01A9E:  MOVLB  0
01AA0:  RCALL  137A
01AA2:  BC    1AA6
01AA4:  BNZ   1AD0
01AA6:  MOVFF  5F0,618
01AAA:  MOVFF  5EF,617
01AAE:  MOVFF  5EE,616
01AB2:  MOVFF  5ED,615
01AB6:  MOVLB  6
01AB8:  CLRF   x1C
01ABA:  CLRF   x1B
01ABC:  CLRF   x1A
01ABE:  CLRF   x19
01AC0:  MOVLB  0
01AC2:  RCALL  137A
01AC4:  BC    1AC8
01AC6:  BNZ   1ACC
01AC8:  MOVLW  03
01ACA:  BRA    1ACE
01ACC:  MOVLW  04
01ACE:  BRA    1AF6
01AD0:  MOVFF  5F0,618
01AD4:  MOVFF  5EF,617
01AD8:  MOVFF  5EE,616
01ADC:  MOVFF  5ED,615
01AE0:  MOVLB  6
01AE2:  CLRF   x1C
01AE4:  CLRF   x1B
01AE6:  CLRF   x1A
01AE8:  CLRF   x19
01AEA:  MOVLB  0
01AEC:  RCALL  137A
01AEE:  BNC   1AF4
01AF0:  MOVLW  02
01AF2:  BRA    1AF6
01AF4:  MOVLW  01
01AF6:  MOVLB  5
01AF8:  MOVWF  xF6
....................    if(y<0.0)
01AFA:  MOVFF  5EC,618
01AFE:  MOVFF  5EB,617
01B02:  MOVFF  5EA,616
01B06:  MOVFF  5E9,615
01B0A:  MOVLB  6
01B0C:  CLRF   x1C
01B0E:  CLRF   x1B
01B10:  CLRF   x1A
01B12:  CLRF   x19
01B14:  MOVLB  0
01B16:  RCALL  137A
01B18:  BNC   1B26
....................    {
....................       sign=1;
01B1A:  MOVLB  5
01B1C:  BSF    xF5.0
....................       y=-y;
01B1E:  MOVF   xEA,W
01B20:  XORLW  80
01B22:  MOVWF  xEA
01B24:  MOVLB  0
....................    }
....................    if(x<0.0)
01B26:  MOVFF  5F0,618
01B2A:  MOVFF  5EF,617
01B2E:  MOVFF  5EE,616
01B32:  MOVFF  5ED,615
01B36:  MOVLB  6
01B38:  CLRF   x1C
01B3A:  CLRF   x1B
01B3C:  CLRF   x1A
01B3E:  CLRF   x19
01B40:  MOVLB  0
01B42:  RCALL  137A
01B44:  BNC   1B50
....................    {
....................       x=-x;
01B46:  MOVLB  5
01B48:  MOVF   xEE,W
01B4A:  XORLW  80
01B4C:  MOVWF  xEE
01B4E:  MOVLB  0
....................    }
....................    if (x==0.0)
01B50:  MOVFF  5F0,618
01B54:  MOVFF  5EF,617
01B58:  MOVFF  5EE,616
01B5C:  MOVFF  5ED,615
01B60:  MOVLB  6
01B62:  CLRF   x1C
01B64:  CLRF   x1B
01B66:  CLRF   x1A
01B68:  CLRF   x19
01B6A:  MOVLB  0
01B6C:  RCALL  137A
01B6E:  BNZ   1BC4
....................    {
....................       if(y==0.0)
01B70:  MOVFF  5EC,618
01B74:  MOVFF  5EB,617
01B78:  MOVFF  5EA,616
01B7C:  MOVFF  5E9,615
01B80:  MOVLB  6
01B82:  CLRF   x1C
01B84:  CLRF   x1B
01B86:  CLRF   x1A
01B88:  CLRF   x19
01B8A:  MOVLB  0
01B8C:  CALL   137A
01B90:  BNZ   1B94
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
01B92:  BRA    1BC2
....................       else
....................       {
....................          if(sign)
01B94:  MOVLB  5
01B96:  BTFSS  xF5.0
01B98:  BRA    1BAE
....................          {
....................          return (-(PI_DIV_BY_TWO));
01B9A:  MOVLW  7F
01B9C:  MOVWF  00
01B9E:  MOVLW  C9
01BA0:  MOVWF  01
01BA2:  MOVLW  0F
01BA4:  MOVWF  02
01BA6:  MOVLW  DB
01BA8:  MOVWF  03
01BAA:  BRA    1CFC
....................          }
01BAC:  BRA    1BC0
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
01BAE:  MOVLW  7F
01BB0:  MOVWF  00
01BB2:  MOVLW  49
01BB4:  MOVWF  01
01BB6:  MOVLW  0F
01BB8:  MOVWF  02
01BBA:  MOVLW  DB
01BBC:  MOVWF  03
01BBE:  BRA    1CFC
01BC0:  MOVLB  0
....................          }
....................       }
....................    }
01BC2:  BRA    1CFA
....................    else
....................    {
....................       z=y/x;
01BC4:  MOVFF  5EC,611
01BC8:  MOVFF  5EB,610
01BCC:  MOVFF  5EA,60F
01BD0:  MOVFF  5E9,60E
01BD4:  MOVFF  5F0,615
01BD8:  MOVFF  5EF,614
01BDC:  MOVFF  5EE,613
01BE0:  MOVFF  5ED,612
01BE4:  RCALL  13F4
01BE6:  MOVFF  03,5F4
01BEA:  MOVFF  02,5F3
01BEE:  MOVFF  01,5F2
01BF2:  MOVFF  00,5F1
....................       switch(quad)
01BF6:  MOVLW  01
01BF8:  MOVLB  5
01BFA:  SUBWF  xF6,W
01BFC:  ADDLW  FC
01BFE:  BTFSC  FD8.0
01C00:  BRA    1CFC
01C02:  ADDLW  04
01C04:  MOVLB  0
01C06:  GOTO   1D02
....................       {
....................          case 1:
....................          {
....................             return atan(z);
01C0A:  MOVFF  5F4,5FA
01C0E:  MOVFF  5F3,5F9
01C12:  MOVFF  5F2,5F8
01C16:  MOVFF  5F1,5F7
01C1A:  RCALL  1552
01C1C:  MOVLB  5
01C1E:  BRA    1CFC
....................             break;
01C20:  BRA    1CFC
01C22:  MOVLB  0
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
01C24:  MOVFF  5F4,5FA
01C28:  MOVFF  5F3,5F9
01C2C:  MOVFF  5F2,5F8
01C30:  MOVFF  5F1,5F7
01C34:  RCALL  1552
01C36:  MOVFF  FEA,5F8
01C3A:  MOVFF  FE9,5F7
01C3E:  BSF    FD8.1
01C40:  MOVLW  DB
01C42:  MOVLB  6
01C44:  MOVWF  x1C
01C46:  MOVLW  0F
01C48:  MOVWF  x1B
01C4A:  MOVLW  49
01C4C:  MOVWF  x1A
01C4E:  MOVLW  80
01C50:  MOVWF  x19
01C52:  MOVFF  03,620
01C56:  MOVFF  02,61F
01C5A:  MOVFF  01,61E
01C5E:  MOVFF  00,61D
01C62:  MOVLB  0
01C64:  CALL   0B3E
01C68:  MOVFF  5F8,FEA
01C6C:  MOVFF  5F7,FE9
01C70:  MOVLB  5
01C72:  BRA    1CFC
....................             break;
01C74:  BRA    1CFC
01C76:  MOVLB  0
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
01C78:  MOVFF  5F4,5FA
01C7C:  MOVFF  5F3,5F9
01C80:  MOVFF  5F2,5F8
01C84:  MOVFF  5F1,5F7
01C88:  RCALL  1552
01C8A:  MOVFF  03,5FA
01C8E:  MOVFF  02,5F9
01C92:  MOVFF  01,5F8
01C96:  MOVFF  00,5F7
01C9A:  MOVFF  FEA,5FC
01C9E:  MOVFF  FE9,5FB
01CA2:  BSF    FD8.1
01CA4:  MOVFF  03,61C
01CA8:  MOVFF  02,61B
01CAC:  MOVFF  01,61A
01CB0:  MOVFF  00,619
01CB4:  MOVLW  DB
01CB6:  MOVLB  6
01CB8:  MOVWF  x20
01CBA:  MOVLW  0F
01CBC:  MOVWF  x1F
01CBE:  MOVLW  49
01CC0:  MOVWF  x1E
01CC2:  MOVLW  80
01CC4:  MOVWF  x1D
01CC6:  MOVLB  0
01CC8:  CALL   0B3E
01CCC:  MOVFF  5FC,FEA
01CD0:  MOVFF  5FB,FE9
01CD4:  MOVLB  5
01CD6:  BRA    1CFC
....................             break;
01CD8:  BRA    1CFC
01CDA:  MOVLB  0
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
01CDC:  MOVFF  5F4,5FA
01CE0:  MOVFF  5F3,5F9
01CE4:  MOVFF  5F2,5F8
01CE8:  MOVFF  5F1,5F7
01CEC:  RCALL  1552
01CEE:  MOVLW  80
01CF0:  XORWF  01,F
01CF2:  MOVLB  5
01CF4:  BRA    1CFC
....................             break;
01CF6:  BRA    1CFC
01CF8:  MOVLB  0
01CFA:  MOVLB  5
....................          }
....................       }
....................    }
01CFC:  MOVLB  0
01CFE:  GOTO   3102 (RETURN)
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... #define sensorSampleRate 50 // 50mS delay between each sensor sample = 200ms cadence 
.................... 
.................... #define maxCount 16777216.0   // ADC max count
.................... //!#define vRef 2.048            // ADC vRef
.................... 
.................... #define sc sensorCal
.................... 
.................... // adc settings for magnetoresistive sensors
.................... #define KMXP1000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP1000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP1000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP1000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define KMXP2000reg0config IPp1n2|g16|PGAenabled // 0x3A//
.................... #define KMXP2000reg1config DRn20|MDturbo|CMsingle|TSDisable|BCSoff //0x00
.................... #define KMXP2000reg2config REFinternal|FIR60|PSWopen|Ioff //0x30
.................... #define KMXP2000reg3config I1disabled|I2disabled|drdyPin //0x00
.................... 
.................... #define vMonN15   6
.................... #define vMon200   16
.................... #define vMon5V6   24
.................... #define vMon5VA   25
.................... #define vMon3V6X  17
.................... #define vMon3V3A  27
.................... #define vMon3V3D  26
.................... 
.................... struct sensorMonitorData
.................... {
....................    boolean dataReady;
....................    boolean adcBusy;
....................    int8 channel; // DEFAULT: 0=chX | 1=chY
.................... } smData = {false, false, 0};
.................... 
.................... /*****************************************************************************/
.................... /* INTERNAL MONITOR task - gets voltages                                     */
.................... /* gets one value each time the task is run                                  */
.................... /*****************************************************************************/
.................... void internal_monitor_task()
.................... {
....................    static int8 state = 0;
....................    if (adc_done())
*
00DB6:  MOVLB  F
00DB8:  BTFSC  x5B.0
00DBA:  BRA    12C6
....................    {
....................       switch (state)
00DBC:  MOVLB  1
00DBE:  MOVF   x51,W
00DC0:  XORLW  00
00DC2:  MOVLB  0
00DC4:  BZ    0DE4
00DC6:  XORLW  01
00DC8:  BZ    0E96
00DCA:  XORLW  03
00DCC:  BTFSC  FD8.2
00DCE:  BRA    0F48
00DD0:  XORLW  01
00DD2:  BTFSC  FD8.2
00DD4:  BRA    0FFA
00DD6:  XORLW  07
00DD8:  BTFSC  FD8.2
00DDA:  BRA    10AC
00DDC:  XORLW  01
00DDE:  BTFSC  FD8.2
00DE0:  BRA    115E
00DE2:  BRA    1212
....................       {
....................          case 0:     // vMonN15
....................             monitorVals.vN15 = read_adc(ADC_READ_ONLY) * monCal.vN15[1] + monCal.vN15[0];
00DE4:  MOVLB  F
00DE6:  BTFSC  x5B.0
00DE8:  BRA    0DE6
00DEA:  MOVFF  F5F,02
00DEE:  MOVFF  F5E,01
00DF2:  MOVFF  02,5C2
00DF6:  MOVFF  01,5C1
00DFA:  MOVFF  02,61A
00DFE:  MOVFF  01,619
00E02:  MOVLB  0
00E04:  RCALL  0A12
00E06:  MOVFF  03,618
00E0A:  MOVFF  02,617
00E0E:  MOVFF  01,616
00E12:  MOVFF  00,615
00E16:  MOVFF  B9,61C
00E1A:  MOVFF  B8,61B
00E1E:  MOVFF  B7,61A
00E22:  MOVFF  B6,619
00E26:  RCALL  0A48
00E28:  MOVFF  03,5C4
00E2C:  MOVFF  02,5C3
00E30:  MOVFF  01,5C2
00E34:  MOVFF  00,5C1
00E38:  BCF    FD8.1
00E3A:  MOVFF  03,61C
00E3E:  MOVFF  02,61B
00E42:  MOVFF  01,61A
00E46:  MOVFF  00,619
00E4A:  MOVFF  B5,620
00E4E:  MOVFF  B4,61F
00E52:  MOVFF  B3,61E
00E56:  MOVFF  B2,61D
00E5A:  RCALL  0B3E
00E5C:  MOVFF  03,F6
00E60:  MOVFF  02,F5
00E64:  MOVFF  01,F4
00E68:  MOVFF  00,F3
....................             set_adc_channel(vMon200);
00E6C:  MOVLB  F
00E6E:  MOVF   x5A,W
00E70:  ANDLW  3F
00E72:  MOVWF  01
00E74:  MOVLW  10
00E76:  MOVWF  x5A
00E78:  BTFSS  x5B.7
00E7A:  BRA    0E8A
00E7C:  MOVF   01,W
00E7E:  SUBLW  10
00E80:  BZ    0E8A
00E82:  BSF    x5B.0
00E84:  NOP   
00E86:  BTFSC  x5B.0
00E88:  BRA    0E86
....................             read_adc(ADC_START_ONLY);
00E8A:  BSF    x5B.0
00E8C:  NOP   
....................             state = 1;
00E8E:  MOVLW  01
00E90:  MOVLB  1
00E92:  MOVWF  x51
....................          break;
00E94:  BRA    12C4
....................          
....................          case 1:     // vMon200
....................             monitorVals.v200 = read_adc(ADC_READ_ONLY) * monCal.v200[1] + monCal.v200[0];
00E96:  MOVLB  F
00E98:  BTFSC  x5B.0
00E9A:  BRA    0E98
00E9C:  MOVFF  F5F,02
00EA0:  MOVFF  F5E,01
00EA4:  MOVFF  02,5C2
00EA8:  MOVFF  01,5C1
00EAC:  MOVFF  02,61A
00EB0:  MOVFF  01,619
00EB4:  MOVLB  0
00EB6:  RCALL  0A12
00EB8:  MOVFF  03,618
00EBC:  MOVFF  02,617
00EC0:  MOVFF  01,616
00EC4:  MOVFF  00,615
00EC8:  MOVFF  C1,61C
00ECC:  MOVFF  C0,61B
00ED0:  MOVFF  BF,61A
00ED4:  MOVFF  BE,619
00ED8:  RCALL  0A48
00EDA:  MOVFF  03,5C4
00EDE:  MOVFF  02,5C3
00EE2:  MOVFF  01,5C2
00EE6:  MOVFF  00,5C1
00EEA:  BCF    FD8.1
00EEC:  MOVFF  03,61C
00EF0:  MOVFF  02,61B
00EF4:  MOVFF  01,61A
00EF8:  MOVFF  00,619
00EFC:  MOVFF  BD,620
00F00:  MOVFF  BC,61F
00F04:  MOVFF  BB,61E
00F08:  MOVFF  BA,61D
00F0C:  RCALL  0B3E
00F0E:  MOVFF  03,FA
00F12:  MOVFF  02,F9
00F16:  MOVFF  01,F8
00F1A:  MOVFF  00,F7
....................             set_adc_channel(vMon5V6);
00F1E:  MOVLB  F
00F20:  MOVF   x5A,W
00F22:  ANDLW  3F
00F24:  MOVWF  01
00F26:  MOVLW  18
00F28:  MOVWF  x5A
00F2A:  BTFSS  x5B.7
00F2C:  BRA    0F3C
00F2E:  MOVF   01,W
00F30:  SUBLW  18
00F32:  BZ    0F3C
00F34:  BSF    x5B.0
00F36:  NOP   
00F38:  BTFSC  x5B.0
00F3A:  BRA    0F38
....................             read_adc(ADC_START_ONLY);
00F3C:  BSF    x5B.0
00F3E:  NOP   
....................             state = 2;
00F40:  MOVLW  02
00F42:  MOVLB  1
00F44:  MOVWF  x51
....................          break;
00F46:  BRA    12C4
....................          
....................          case 2:     // vMon5V6
....................             monitorVals.v5V6 = read_adc(ADC_READ_ONLY) * monCal.v5V6[1] + monCal.v5V6[0];
00F48:  MOVLB  F
00F4A:  BTFSC  x5B.0
00F4C:  BRA    0F4A
00F4E:  MOVFF  F5F,02
00F52:  MOVFF  F5E,01
00F56:  MOVFF  02,5C2
00F5A:  MOVFF  01,5C1
00F5E:  MOVFF  02,61A
00F62:  MOVFF  01,619
00F66:  MOVLB  0
00F68:  RCALL  0A12
00F6A:  MOVFF  03,618
00F6E:  MOVFF  02,617
00F72:  MOVFF  01,616
00F76:  MOVFF  00,615
00F7A:  MOVFF  C9,61C
00F7E:  MOVFF  C8,61B
00F82:  MOVFF  C7,61A
00F86:  MOVFF  C6,619
00F8A:  RCALL  0A48
00F8C:  MOVFF  03,5C4
00F90:  MOVFF  02,5C3
00F94:  MOVFF  01,5C2
00F98:  MOVFF  00,5C1
00F9C:  BCF    FD8.1
00F9E:  MOVFF  03,61C
00FA2:  MOVFF  02,61B
00FA6:  MOVFF  01,61A
00FAA:  MOVFF  00,619
00FAE:  MOVFF  C5,620
00FB2:  MOVFF  C4,61F
00FB6:  MOVFF  C3,61E
00FBA:  MOVFF  C2,61D
00FBE:  RCALL  0B3E
00FC0:  MOVFF  03,FE
00FC4:  MOVFF  02,FD
00FC8:  MOVFF  01,FC
00FCC:  MOVFF  00,FB
....................             set_adc_channel(vMon5VA);
00FD0:  MOVLB  F
00FD2:  MOVF   x5A,W
00FD4:  ANDLW  3F
00FD6:  MOVWF  01
00FD8:  MOVLW  19
00FDA:  MOVWF  x5A
00FDC:  BTFSS  x5B.7
00FDE:  BRA    0FEE
00FE0:  MOVF   01,W
00FE2:  SUBLW  19
00FE4:  BZ    0FEE
00FE6:  BSF    x5B.0
00FE8:  NOP   
00FEA:  BTFSC  x5B.0
00FEC:  BRA    0FEA
....................             read_adc(ADC_START_ONLY);
00FEE:  BSF    x5B.0
00FF0:  NOP   
....................             state = 3;
00FF2:  MOVLW  03
00FF4:  MOVLB  1
00FF6:  MOVWF  x51
....................          break;
00FF8:  BRA    12C4
....................          
....................          case 3:     // vMon5VA
....................             monitorVals.v5VA = read_adc(ADC_READ_ONLY) * monCal.v5VA[1] + monCal.v5VA[0];
00FFA:  MOVLB  F
00FFC:  BTFSC  x5B.0
00FFE:  BRA    0FFC
01000:  MOVFF  F5F,02
01004:  MOVFF  F5E,01
01008:  MOVFF  02,5C2
0100C:  MOVFF  01,5C1
01010:  MOVFF  02,61A
01014:  MOVFF  01,619
01018:  MOVLB  0
0101A:  RCALL  0A12
0101C:  MOVFF  03,618
01020:  MOVFF  02,617
01024:  MOVFF  01,616
01028:  MOVFF  00,615
0102C:  MOVFF  D1,61C
01030:  MOVFF  D0,61B
01034:  MOVFF  CF,61A
01038:  MOVFF  CE,619
0103C:  RCALL  0A48
0103E:  MOVFF  03,5C4
01042:  MOVFF  02,5C3
01046:  MOVFF  01,5C2
0104A:  MOVFF  00,5C1
0104E:  BCF    FD8.1
01050:  MOVFF  03,61C
01054:  MOVFF  02,61B
01058:  MOVFF  01,61A
0105C:  MOVFF  00,619
01060:  MOVFF  CD,620
01064:  MOVFF  CC,61F
01068:  MOVFF  CB,61E
0106C:  MOVFF  CA,61D
01070:  RCALL  0B3E
01072:  MOVFF  03,102
01076:  MOVFF  02,101
0107A:  MOVFF  01,100
0107E:  MOVFF  00,FF
....................             set_adc_channel(vMon3V6X);
01082:  MOVLB  F
01084:  MOVF   x5A,W
01086:  ANDLW  3F
01088:  MOVWF  01
0108A:  MOVLW  11
0108C:  MOVWF  x5A
0108E:  BTFSS  x5B.7
01090:  BRA    10A0
01092:  MOVF   01,W
01094:  SUBLW  11
01096:  BZ    10A0
01098:  BSF    x5B.0
0109A:  NOP   
0109C:  BTFSC  x5B.0
0109E:  BRA    109C
....................             read_adc(ADC_START_ONLY);
010A0:  BSF    x5B.0
010A2:  NOP   
....................             state = 4;
010A4:  MOVLW  04
010A6:  MOVLB  1
010A8:  MOVWF  x51
....................          break;
010AA:  BRA    12C4
....................          
....................          case 4:     // vMon3V6X
....................             monitorVals.v3V6X = read_adc(ADC_READ_ONLY) * monCal.v3V6X[1] + monCal.v3V6X[0];
010AC:  MOVLB  F
010AE:  BTFSC  x5B.0
010B0:  BRA    10AE
010B2:  MOVFF  F5F,02
010B6:  MOVFF  F5E,01
010BA:  MOVFF  02,5C2
010BE:  MOVFF  01,5C1
010C2:  MOVFF  02,61A
010C6:  MOVFF  01,619
010CA:  MOVLB  0
010CC:  RCALL  0A12
010CE:  MOVFF  03,618
010D2:  MOVFF  02,617
010D6:  MOVFF  01,616
010DA:  MOVFF  00,615
010DE:  MOVFF  D9,61C
010E2:  MOVFF  D8,61B
010E6:  MOVFF  D7,61A
010EA:  MOVFF  D6,619
010EE:  RCALL  0A48
010F0:  MOVFF  03,5C4
010F4:  MOVFF  02,5C3
010F8:  MOVFF  01,5C2
010FC:  MOVFF  00,5C1
01100:  BCF    FD8.1
01102:  MOVFF  03,61C
01106:  MOVFF  02,61B
0110A:  MOVFF  01,61A
0110E:  MOVFF  00,619
01112:  MOVFF  D5,620
01116:  MOVFF  D4,61F
0111A:  MOVFF  D3,61E
0111E:  MOVFF  D2,61D
01122:  RCALL  0B3E
01124:  MOVFF  03,106
01128:  MOVFF  02,105
0112C:  MOVFF  01,104
01130:  MOVFF  00,103
....................             set_adc_channel(vMon3V3A);
01134:  MOVLB  F
01136:  MOVF   x5A,W
01138:  ANDLW  3F
0113A:  MOVWF  01
0113C:  MOVLW  1B
0113E:  MOVWF  x5A
01140:  BTFSS  x5B.7
01142:  BRA    1152
01144:  MOVF   01,W
01146:  SUBLW  1B
01148:  BZ    1152
0114A:  BSF    x5B.0
0114C:  NOP   
0114E:  BTFSC  x5B.0
01150:  BRA    114E
....................             read_adc(ADC_START_ONLY);
01152:  BSF    x5B.0
01154:  NOP   
....................             state = 5;
01156:  MOVLW  05
01158:  MOVLB  1
0115A:  MOVWF  x51
....................          break;
0115C:  BRA    12C4
....................          
....................          case 5:     // vMon3V3A
....................             monitorVals.v3V3A = read_adc(ADC_READ_ONLY) * monCal.v3V3A[1] + monCal.v3V3A[0];
0115E:  MOVLB  F
01160:  BTFSC  x5B.0
01162:  BRA    1160
01164:  MOVFF  F5F,02
01168:  MOVFF  F5E,01
0116C:  MOVFF  02,5C2
01170:  MOVFF  01,5C1
01174:  MOVFF  02,61A
01178:  MOVFF  01,619
0117C:  MOVLB  0
0117E:  RCALL  0A12
01180:  MOVFF  03,618
01184:  MOVFF  02,617
01188:  MOVFF  01,616
0118C:  MOVFF  00,615
01190:  MOVFF  E1,61C
01194:  MOVFF  E0,61B
01198:  MOVFF  DF,61A
0119C:  MOVFF  DE,619
011A0:  RCALL  0A48
011A2:  MOVFF  03,5C4
011A6:  MOVFF  02,5C3
011AA:  MOVFF  01,5C2
011AE:  MOVFF  00,5C1
011B2:  BCF    FD8.1
011B4:  MOVFF  03,61C
011B8:  MOVFF  02,61B
011BC:  MOVFF  01,61A
011C0:  MOVFF  00,619
011C4:  MOVFF  DD,620
011C8:  MOVFF  DC,61F
011CC:  MOVFF  DB,61E
011D0:  MOVFF  DA,61D
011D4:  RCALL  0B3E
011D6:  MOVFF  03,10A
011DA:  MOVFF  02,109
011DE:  MOVFF  01,108
011E2:  MOVFF  00,107
....................             set_adc_channel(vMon3V3D);
011E6:  MOVLB  F
011E8:  MOVF   x5A,W
011EA:  ANDLW  3F
011EC:  MOVWF  01
011EE:  MOVLW  1A
011F0:  MOVWF  x5A
011F2:  BTFSS  x5B.7
011F4:  BRA    1204
011F6:  MOVF   01,W
011F8:  SUBLW  1A
011FA:  BZ    1204
011FC:  BSF    x5B.0
011FE:  NOP   
01200:  BTFSC  x5B.0
01202:  BRA    1200
....................             read_adc(ADC_START_ONLY);
01204:  BSF    x5B.0
01206:  NOP   
....................             state = 6;
01208:  MOVLW  06
0120A:  MOVLB  1
0120C:  MOVWF  x51
....................          break;
0120E:  BRA    12C4
01210:  MOVLB  0
....................          
....................          default:    // vMon3V3D
....................             monitorVals.v3V3D = read_adc(ADC_READ_ONLY) * monCal.v3V3D[1] + monCal.v3V3D[0];
01212:  MOVLB  F
01214:  BTFSC  x5B.0
01216:  BRA    1214
01218:  MOVFF  F5F,02
0121C:  MOVFF  F5E,01
01220:  MOVFF  02,5C2
01224:  MOVFF  01,5C1
01228:  MOVFF  02,61A
0122C:  MOVFF  01,619
01230:  MOVLB  0
01232:  CALL   0A12
01236:  MOVFF  03,618
0123A:  MOVFF  02,617
0123E:  MOVFF  01,616
01242:  MOVFF  00,615
01246:  MOVFF  E9,61C
0124A:  MOVFF  E8,61B
0124E:  MOVFF  E7,61A
01252:  MOVFF  E6,619
01256:  CALL   0A48
0125A:  MOVFF  03,5C4
0125E:  MOVFF  02,5C3
01262:  MOVFF  01,5C2
01266:  MOVFF  00,5C1
0126A:  BCF    FD8.1
0126C:  MOVFF  03,61C
01270:  MOVFF  02,61B
01274:  MOVFF  01,61A
01278:  MOVFF  00,619
0127C:  MOVFF  E5,620
01280:  MOVFF  E4,61F
01284:  MOVFF  E3,61E
01288:  MOVFF  E2,61D
0128C:  RCALL  0B3E
0128E:  MOVFF  03,10E
01292:  MOVFF  02,10D
01296:  MOVFF  01,10C
0129A:  MOVFF  00,10B
....................             set_adc_channel(vMonN15);
0129E:  MOVLB  F
012A0:  MOVF   x5A,W
012A2:  ANDLW  3F
012A4:  MOVWF  01
012A6:  MOVLW  06
012A8:  MOVWF  x5A
012AA:  BTFSS  x5B.7
012AC:  BRA    12BC
012AE:  MOVF   01,W
012B0:  SUBLW  06
012B2:  BZ    12BC
012B4:  BSF    x5B.0
012B6:  NOP   
012B8:  BTFSC  x5B.0
012BA:  BRA    12B8
....................             read_adc(ADC_START_ONLY);
012BC:  BSF    x5B.0
012BE:  NOP   
....................             state = 0;
012C0:  MOVLB  1
012C2:  CLRF   x51
....................          break;   
012C4:  MOVLB  F
....................       }
....................    }
012C6:  MOVLB  0
012C8:  GOTO   7164 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* PROCESS ADC SENSOR DATA                                                   */
.................... /*****************************************************************************/
.................... void sensor_process_data(int8 ch, unsigned int32 sinRawCounts, unsigned int32 cosRawCounts)
.................... {
....................    adcVals[ch].sinRaw = (float)sinRawCounts;
*
02D62:  MOVLB  5
02D64:  MOVF   xCA,W
02D66:  MULLW  19
02D68:  MOVF   FF3,W
02D6A:  CLRF   xDC
02D6C:  MOVWF  xDB
02D6E:  MOVLW  0F
02D70:  ADDWF  xDB,W
02D72:  MOVWF  FE9
02D74:  MOVLW  01
02D76:  ADDWFC xDC,W
02D78:  MOVWF  FEA
02D7A:  MOVFF  5CE,5E2
02D7E:  MOVFF  5CD,5E1
02D82:  MOVFF  5CC,5E0
02D86:  MOVFF  5CB,5DF
02D8A:  MOVLB  0
02D8C:  CALL   1342
02D90:  MOVFF  00,FEF
02D94:  MOVFF  01,FEC
02D98:  MOVFF  02,FEC
02D9C:  MOVFF  03,FEC
....................    adcVals[ch].cosRaw = (float)cosRawCounts;
02DA0:  MOVLB  5
02DA2:  MOVF   xCA,W
02DA4:  MULLW  19
02DA6:  MOVF   FF3,W
02DA8:  CLRF   xDC
02DAA:  MOVWF  xDB
02DAC:  MOVLW  04
02DAE:  ADDWF  xDB,W
02DB0:  MOVWF  01
02DB2:  MOVLW  00
02DB4:  ADDWFC xDC,W
02DB6:  MOVWF  03
02DB8:  MOVF   01,W
02DBA:  ADDLW  0F
02DBC:  MOVWF  FE9
02DBE:  MOVLW  01
02DC0:  ADDWFC 03,W
02DC2:  MOVWF  FEA
02DC4:  MOVFF  5D2,5E2
02DC8:  MOVFF  5D1,5E1
02DCC:  MOVFF  5D0,5E0
02DD0:  MOVFF  5CF,5DF
02DD4:  MOVLB  0
02DD6:  CALL   1342
02DDA:  MOVFF  00,FEF
02DDE:  MOVFF  01,FEC
02DE2:  MOVFF  02,FEC
02DE6:  MOVFF  03,FEC
....................    
....................    adcVals[ch].sinCounts = adcVals[ch].sinRaw * adcCal[ch].sinGain + adcCal[ch].sinOS;
02DEA:  MOVLB  5
02DEC:  MOVF   xCA,W
02DEE:  MULLW  19
02DF0:  MOVF   FF3,W
02DF2:  CLRF   xDC
02DF4:  MOVWF  xDB
02DF6:  MOVLW  08
02DF8:  ADDWF  xDB,W
02DFA:  MOVWF  01
02DFC:  MOVLW  00
02DFE:  ADDWFC xDC,W
02E00:  MOVWF  03
02E02:  MOVF   01,W
02E04:  ADDLW  0F
02E06:  MOVWF  01
02E08:  MOVLW  01
02E0A:  ADDWFC 03,F
02E0C:  MOVFF  01,5DB
02E10:  MOVFF  03,5DC
02E14:  MOVF   xCA,W
02E16:  MULLW  19
02E18:  MOVF   FF3,W
02E1A:  CLRF   xDE
02E1C:  MOVWF  xDD
02E1E:  MOVLW  0F
02E20:  ADDWF  xDD,W
02E22:  MOVWF  FE9
02E24:  MOVLW  01
02E26:  ADDWFC xDE,W
02E28:  MOVWF  FEA
02E2A:  MOVFF  FEF,615
02E2E:  MOVFF  FEC,616
02E32:  MOVFF  FEC,617
02E36:  MOVFF  FEC,618
02E3A:  MOVF   xCA,W
02E3C:  MULLW  10
02E3E:  MOVF   FF3,W
02E40:  CLRF   xE4
02E42:  MOVWF  xE3
02E44:  MOVLW  08
02E46:  ADDWF  xE3,W
02E48:  MOVWF  01
02E4A:  MOVLW  00
02E4C:  ADDWFC xE4,W
02E4E:  MOVWF  03
02E50:  MOVF   01,W
02E52:  ADDLW  62
02E54:  MOVWF  FE9
02E56:  MOVLW  00
02E58:  ADDWFC 03,W
02E5A:  MOVWF  FEA
02E5C:  MOVFF  FEF,619
02E60:  MOVFF  FEC,01
02E64:  MOVFF  FEC,02
02E68:  MOVFF  FEC,03
02E6C:  MOVFF  03,61C
02E70:  MOVFF  02,61B
02E74:  MOVFF  01,61A
02E78:  MOVLB  0
02E7A:  CALL   0A48
02E7E:  MOVFF  03,61C
02E82:  MOVFF  02,61B
02E86:  MOVFF  01,61A
02E8A:  MOVFF  00,619
02E8E:  MOVLB  5
02E90:  MOVF   xCA,W
02E92:  MULLW  10
02E94:  MOVF   FF3,W
02E96:  CLRF   xE4
02E98:  MOVWF  xE3
02E9A:  MOVLW  62
02E9C:  ADDWF  xE3,W
02E9E:  MOVWF  FE9
02EA0:  MOVLW  00
02EA2:  ADDWFC xE4,W
02EA4:  MOVWF  FEA
02EA6:  MOVFF  FEF,61D
02EAA:  MOVFF  FEC,01
02EAE:  MOVFF  FEC,02
02EB2:  MOVFF  FEC,03
02EB6:  BCF    FD8.1
02EB8:  MOVFF  03,620
02EBC:  MOVFF  02,61F
02EC0:  MOVFF  01,61E
02EC4:  MOVLB  0
02EC6:  CALL   0B3E
02ECA:  MOVFF  5DC,FEA
02ECE:  MOVFF  5DB,FE9
02ED2:  MOVFF  00,FEF
02ED6:  MOVFF  01,FEC
02EDA:  MOVFF  02,FEC
02EDE:  MOVFF  03,FEC
....................    adcVals[ch].cosCounts = adcVals[ch].cosRaw * adcCal[ch].cosGain + adcCal[ch].cosOS;
02EE2:  MOVLB  5
02EE4:  MOVF   xCA,W
02EE6:  MULLW  19
02EE8:  MOVF   FF3,W
02EEA:  CLRF   xDC
02EEC:  MOVWF  xDB
02EEE:  MOVLW  0C
02EF0:  ADDWF  xDB,W
02EF2:  MOVWF  01
02EF4:  MOVLW  00
02EF6:  ADDWFC xDC,W
02EF8:  MOVWF  03
02EFA:  MOVF   01,W
02EFC:  ADDLW  0F
02EFE:  MOVWF  01
02F00:  MOVLW  01
02F02:  ADDWFC 03,F
02F04:  MOVFF  01,5DB
02F08:  MOVFF  03,5DC
02F0C:  MOVF   xCA,W
02F0E:  MULLW  19
02F10:  MOVF   FF3,W
02F12:  CLRF   xDE
02F14:  MOVWF  xDD
02F16:  MOVLW  04
02F18:  ADDWF  xDD,W
02F1A:  MOVWF  01
02F1C:  MOVLW  00
02F1E:  ADDWFC xDE,W
02F20:  MOVWF  03
02F22:  MOVF   01,W
02F24:  ADDLW  0F
02F26:  MOVWF  FE9
02F28:  MOVLW  01
02F2A:  ADDWFC 03,W
02F2C:  MOVWF  FEA
02F2E:  MOVFF  FEF,615
02F32:  MOVFF  FEC,616
02F36:  MOVFF  FEC,617
02F3A:  MOVFF  FEC,618
02F3E:  MOVF   xCA,W
02F40:  MULLW  10
02F42:  MOVF   FF3,W
02F44:  CLRF   xE2
02F46:  MOVWF  xE1
02F48:  MOVLW  0C
02F4A:  ADDWF  xE1,W
02F4C:  MOVWF  01
02F4E:  MOVLW  00
02F50:  ADDWFC xE2,W
02F52:  MOVWF  03
02F54:  MOVF   01,W
02F56:  ADDLW  62
02F58:  MOVWF  FE9
02F5A:  MOVLW  00
02F5C:  ADDWFC 03,W
02F5E:  MOVWF  FEA
02F60:  MOVFF  FEF,619
02F64:  MOVFF  FEC,01
02F68:  MOVFF  FEC,02
02F6C:  MOVFF  FEC,03
02F70:  MOVFF  03,61C
02F74:  MOVFF  02,61B
02F78:  MOVFF  01,61A
02F7C:  MOVLB  0
02F7E:  CALL   0A48
02F82:  MOVFF  03,61C
02F86:  MOVFF  02,61B
02F8A:  MOVFF  01,61A
02F8E:  MOVFF  00,619
02F92:  MOVLB  5
02F94:  MOVF   xCA,W
02F96:  MULLW  10
02F98:  MOVF   FF3,W
02F9A:  CLRF   xE2
02F9C:  MOVWF  xE1
02F9E:  MOVLW  04
02FA0:  ADDWF  xE1,W
02FA2:  MOVWF  01
02FA4:  MOVLW  00
02FA6:  ADDWFC xE2,W
02FA8:  MOVWF  03
02FAA:  MOVF   01,W
02FAC:  ADDLW  62
02FAE:  MOVWF  FE9
02FB0:  MOVLW  00
02FB2:  ADDWFC 03,W
02FB4:  MOVWF  FEA
02FB6:  MOVFF  FEF,61D
02FBA:  MOVFF  FEC,01
02FBE:  MOVFF  FEC,02
02FC2:  MOVFF  FEC,03
02FC6:  BCF    FD8.1
02FC8:  MOVFF  03,620
02FCC:  MOVFF  02,61F
02FD0:  MOVFF  01,61E
02FD4:  MOVLB  0
02FD6:  CALL   0B3E
02FDA:  MOVFF  5DC,FEA
02FDE:  MOVFF  5DB,FE9
02FE2:  MOVFF  00,FEF
02FE6:  MOVFF  01,FEC
02FEA:  MOVFF  02,FEC
02FEE:  MOVFF  03,FEC
....................    float pTmp = 0;
....................    float polePitch = magPP;
02FF2:  MOVLB  5
02FF4:  CLRF   xD6
02FF6:  CLRF   xD5
02FF8:  CLRF   xD4
02FFA:  CLRF   xD3
02FFC:  CLRF   xDA
02FFE:  CLRF   xD9
03000:  CLRF   xD8
03002:  MOVLW  7F
03004:  MOVWF  xD7
....................    
....................    adcVals[ch].p0 = polePitch * ( 1000 / (2*PI) ) * atan2( (float)adcVals[ch].sinCounts, (float)adcVals[ch].cosCounts );
03006:  MOVF   xCA,W
03008:  MULLW  19
0300A:  MOVF   FF3,W
0300C:  CLRF   xDC
0300E:  MOVWF  xDB
03010:  MOVLW  10
03012:  ADDWF  xDB,W
03014:  MOVWF  01
03016:  MOVLW  00
03018:  ADDWFC xDC,W
0301A:  MOVWF  03
0301C:  MOVF   01,W
0301E:  ADDLW  0F
03020:  MOVWF  01
03022:  MOVLW  01
03024:  ADDWFC 03,F
03026:  MOVFF  01,5DB
0302A:  MOVFF  03,5DC
0302E:  MOVFF  5DA,618
03032:  MOVFF  5D9,617
03036:  MOVFF  5D8,616
0303A:  MOVFF  5D7,615
0303E:  MOVLW  AA
03040:  MOVLB  6
03042:  MOVWF  x1C
03044:  MOVLW  27
03046:  MOVWF  x1B
03048:  MOVLW  1F
0304A:  MOVWF  x1A
0304C:  MOVLW  86
0304E:  MOVWF  x19
03050:  MOVLB  0
03052:  CALL   0A48
03056:  MOVFF  03,5E0
0305A:  MOVFF  02,5DF
0305E:  MOVFF  01,5DE
03062:  MOVFF  00,5DD
03066:  MOVLB  5
03068:  MOVF   xCA,W
0306A:  MULLW  19
0306C:  MOVF   FF3,W
0306E:  CLRF   xE2
03070:  MOVWF  xE1
03072:  MOVLW  08
03074:  ADDWF  xE1,W
03076:  MOVWF  01
03078:  MOVLW  00
0307A:  ADDWFC xE2,W
0307C:  MOVWF  03
0307E:  MOVF   01,W
03080:  ADDLW  0F
03082:  MOVWF  FE9
03084:  MOVLW  01
03086:  ADDWFC 03,W
03088:  MOVWF  FEA
0308A:  MOVFF  FEF,5E1
0308E:  MOVFF  FEC,5E2
03092:  MOVFF  FEC,5E3
03096:  MOVFF  FEC,5E4
0309A:  MOVF   xCA,W
0309C:  MULLW  19
0309E:  MOVF   FF3,W
030A0:  CLRF   xE6
030A2:  MOVWF  xE5
030A4:  MOVLW  0C
030A6:  ADDWF  xE5,W
030A8:  MOVWF  01
030AA:  MOVLW  00
030AC:  ADDWFC xE6,W
030AE:  MOVWF  03
030B0:  MOVF   01,W
030B2:  ADDLW  0F
030B4:  MOVWF  FE9
030B6:  MOVLW  01
030B8:  ADDWFC 03,W
030BA:  MOVWF  FEA
030BC:  MOVFF  FEF,00
030C0:  MOVFF  FEC,01
030C4:  MOVFF  FEC,02
030C8:  MOVFF  FEC,03
030CC:  MOVFF  03,5E8
030D0:  MOVFF  02,5E7
030D4:  MOVFF  01,5E6
030D8:  MOVFF  00,5E5
030DC:  MOVFF  5E4,5EC
030E0:  MOVFF  5E3,5EB
030E4:  MOVFF  5E2,5EA
030E8:  MOVFF  5E1,5E9
030EC:  MOVFF  03,5F0
030F0:  MOVFF  02,5EF
030F4:  MOVFF  01,5EE
030F8:  MOVFF  00,5ED
030FC:  MOVLB  0
030FE:  GOTO   1A7E
03102:  MOVFF  5E0,618
03106:  MOVFF  5DF,617
0310A:  MOVFF  5DE,616
0310E:  MOVFF  5DD,615
03112:  MOVFF  03,61C
03116:  MOVFF  02,61B
0311A:  MOVFF  01,61A
0311E:  MOVFF  00,619
03122:  CALL   0A48
03126:  MOVFF  5DC,FEA
0312A:  MOVFF  5DB,FE9
0312E:  MOVFF  00,FEF
03132:  MOVFF  01,FEC
03136:  MOVFF  02,FEC
0313A:  MOVFF  03,FEC
....................    pTmp = adcVals[ch].p0 + ( polePitch * adcVals[ch].npoles );
0313E:  MOVLB  5
03140:  MOVF   xCA,W
03142:  MULLW  19
03144:  MOVF   FF3,W
03146:  CLRF   xDC
03148:  MOVWF  xDB
0314A:  MOVLW  10
0314C:  ADDWF  xDB,W
0314E:  MOVWF  01
03150:  MOVLW  00
03152:  ADDWFC xDC,W
03154:  MOVWF  03
03156:  MOVF   01,W
03158:  ADDLW  0F
0315A:  MOVWF  FE9
0315C:  MOVLW  01
0315E:  ADDWFC 03,W
03160:  MOVWF  FEA
03162:  MOVFF  FEF,5DB
03166:  MOVFF  FEC,5DC
0316A:  MOVFF  FEC,5DD
0316E:  MOVFF  FEC,5DE
03172:  MOVF   xCA,W
03174:  MULLW  19
03176:  MOVF   FF3,W
03178:  CLRF   xE0
0317A:  MOVWF  xDF
0317C:  MOVLW  14
0317E:  ADDWF  xDF,W
03180:  MOVWF  01
03182:  MOVLW  00
03184:  ADDWFC xE0,W
03186:  MOVWF  03
03188:  MOVF   01,W
0318A:  ADDLW  0F
0318C:  MOVWF  FE9
0318E:  MOVLW  01
03190:  ADDWFC 03,W
03192:  MOVWF  FEA
03194:  MOVF   FEF,W
03196:  MOVLB  6
03198:  CLRF   x1A
0319A:  MOVWF  x19
0319C:  MOVLB  0
0319E:  CALL   0A12
031A2:  MOVFF  5DA,618
031A6:  MOVFF  5D9,617
031AA:  MOVFF  5D8,616
031AE:  MOVFF  5D7,615
031B2:  MOVFF  03,61C
031B6:  MOVFF  02,61B
031BA:  MOVFF  01,61A
031BE:  MOVFF  00,619
031C2:  CALL   0A48
031C6:  MOVFF  FEA,5E0
031CA:  MOVFF  FE9,5DF
031CE:  BCF    FD8.1
031D0:  MOVFF  5DE,61C
031D4:  MOVFF  5DD,61B
031D8:  MOVFF  5DC,61A
031DC:  MOVFF  5DB,619
031E0:  MOVFF  03,620
031E4:  MOVFF  02,61F
031E8:  MOVFF  01,61E
031EC:  MOVFF  00,61D
031F0:  CALL   0B3E
031F4:  MOVFF  5E0,FEA
031F8:  MOVFF  5DF,FE9
031FC:  MOVFF  03,5D6
03200:  MOVFF  02,5D5
03204:  MOVFF  01,5D4
03208:  MOVFF  00,5D3
....................    
....................    adcVals[ch].pReal = (pow(pTmp*sc[ch].c5,5) + pow(pTmp*sc[ch].c4,4) + pow(pTmp*sc[ch].c3,3) + pow(pTmp*sc[ch].c2,2) + pTmp*sc[ch].c1 + sc[ch].c0);
0320C:  MOVLB  5
0320E:  MOVF   xCA,W
03210:  MULLW  19
03212:  MOVF   FF3,W
03214:  CLRF   xDC
03216:  MOVWF  xDB
03218:  MOVLW  15
0321A:  ADDWF  xDB,W
0321C:  MOVWF  01
0321E:  MOVLW  00
03220:  ADDWFC xDC,W
03222:  MOVWF  03
03224:  MOVF   01,W
03226:  ADDLW  0F
03228:  MOVWF  01
0322A:  MOVLW  01
0322C:  ADDWFC 03,F
0322E:  MOVFF  01,5DB
03232:  MOVFF  03,5DC
03236:  MOVF   xCA,W
03238:  MULLW  18
0323A:  MOVF   FF3,W
0323C:  CLRF   xDE
0323E:  MOVWF  xDD
03240:  MOVLW  14
03242:  ADDWF  xDD,W
03244:  MOVWF  01
03246:  MOVLW  00
03248:  ADDWFC xDE,W
0324A:  MOVWF  03
0324C:  MOVF   01,W
0324E:  ADDLW  82
03250:  MOVWF  FE9
03252:  MOVLW  00
03254:  ADDWFC 03,W
03256:  MOVWF  FEA
03258:  MOVFF  FEF,619
0325C:  MOVFF  FEC,01
03260:  MOVFF  FEC,02
03264:  MOVFF  FEC,03
03268:  MOVFF  5D6,618
0326C:  MOVFF  5D5,617
03270:  MOVFF  5D4,616
03274:  MOVFF  5D3,615
03278:  MOVFF  03,61C
0327C:  MOVFF  02,61B
03280:  MOVFF  01,61A
03284:  MOVLB  0
03286:  CALL   0A48
0328A:  MOVFF  03,5E0
0328E:  MOVFF  02,5DF
03292:  MOVFF  01,5DE
03296:  MOVFF  00,5DD
0329A:  MOVFF  03,5EC
0329E:  MOVFF  02,5EB
032A2:  MOVFF  01,5EA
032A6:  MOVFF  00,5E9
032AA:  MOVLB  5
032AC:  CLRF   xF0
032AE:  CLRF   xEF
032B0:  MOVLW  20
032B2:  MOVWF  xEE
032B4:  MOVLW  81
032B6:  MOVWF  xED
032B8:  MOVLB  0
032BA:  CALL   2A64
032BE:  MOVFF  03,5E0
032C2:  MOVFF  02,5DF
032C6:  MOVFF  01,5DE
032CA:  MOVFF  00,5DD
032CE:  MOVLB  5
032D0:  MOVF   xCA,W
032D2:  MULLW  18
032D4:  MOVF   FF3,W
032D6:  CLRF   xE2
032D8:  MOVWF  xE1
032DA:  MOVLW  10
032DC:  ADDWF  xE1,W
032DE:  MOVWF  01
032E0:  MOVLW  00
032E2:  ADDWFC xE2,W
032E4:  MOVWF  03
032E6:  MOVF   01,W
032E8:  ADDLW  82
032EA:  MOVWF  FE9
032EC:  MOVLW  00
032EE:  ADDWFC 03,W
032F0:  MOVWF  FEA
032F2:  MOVFF  FEF,619
032F6:  MOVFF  FEC,01
032FA:  MOVFF  FEC,02
032FE:  MOVFF  FEC,03
03302:  MOVFF  5D6,618
03306:  MOVFF  5D5,617
0330A:  MOVFF  5D4,616
0330E:  MOVFF  5D3,615
03312:  MOVFF  03,61C
03316:  MOVFF  02,61B
0331A:  MOVFF  01,61A
0331E:  MOVLB  0
03320:  CALL   0A48
03324:  MOVFF  03,5E4
03328:  MOVFF  02,5E3
0332C:  MOVFF  01,5E2
03330:  MOVFF  00,5E1
03334:  MOVFF  03,5EC
03338:  MOVFF  02,5EB
0333C:  MOVFF  01,5EA
03340:  MOVFF  00,5E9
03344:  MOVLB  5
03346:  CLRF   xF0
03348:  CLRF   xEF
0334A:  CLRF   xEE
0334C:  MOVLW  81
0334E:  MOVWF  xED
03350:  MOVLB  0
03352:  CALL   2A64
03356:  MOVFF  FEA,5E2
0335A:  MOVFF  FE9,5E1
0335E:  BCF    FD8.1
03360:  MOVFF  5E0,61C
03364:  MOVFF  5DF,61B
03368:  MOVFF  5DE,61A
0336C:  MOVFF  5DD,619
03370:  MOVFF  03,620
03374:  MOVFF  02,61F
03378:  MOVFF  01,61E
0337C:  MOVFF  00,61D
03380:  CALL   0B3E
03384:  MOVFF  5E2,FEA
03388:  MOVFF  5E1,FE9
0338C:  MOVFF  03,5E0
03390:  MOVFF  02,5DF
03394:  MOVFF  01,5DE
03398:  MOVFF  00,5DD
0339C:  MOVLB  5
0339E:  MOVF   xCA,W
033A0:  MULLW  18
033A2:  MOVF   FF3,W
033A4:  CLRF   xE4
033A6:  MOVWF  xE3
033A8:  MOVLW  0C
033AA:  ADDWF  xE3,W
033AC:  MOVWF  01
033AE:  MOVLW  00
033B0:  ADDWFC xE4,W
033B2:  MOVWF  03
033B4:  MOVF   01,W
033B6:  ADDLW  82
033B8:  MOVWF  FE9
033BA:  MOVLW  00
033BC:  ADDWFC 03,W
033BE:  MOVWF  FEA
033C0:  MOVFF  FEF,619
033C4:  MOVFF  FEC,01
033C8:  MOVFF  FEC,02
033CC:  MOVFF  FEC,03
033D0:  MOVFF  5D6,618
033D4:  MOVFF  5D5,617
033D8:  MOVFF  5D4,616
033DC:  MOVFF  5D3,615
033E0:  MOVFF  03,61C
033E4:  MOVFF  02,61B
033E8:  MOVFF  01,61A
033EC:  MOVLB  0
033EE:  CALL   0A48
033F2:  MOVFF  03,5E6
033F6:  MOVFF  02,5E5
033FA:  MOVFF  01,5E4
033FE:  MOVFF  00,5E3
03402:  MOVFF  03,5EC
03406:  MOVFF  02,5EB
0340A:  MOVFF  01,5EA
0340E:  MOVFF  00,5E9
03412:  MOVLB  5
03414:  CLRF   xF0
03416:  CLRF   xEF
03418:  MOVLW  40
0341A:  MOVWF  xEE
0341C:  MOVLW  80
0341E:  MOVWF  xED
03420:  MOVLB  0
03422:  CALL   2A64
03426:  MOVFF  FEA,5E4
0342A:  MOVFF  FE9,5E3
0342E:  BCF    FD8.1
03430:  MOVFF  5E0,61C
03434:  MOVFF  5DF,61B
03438:  MOVFF  5DE,61A
0343C:  MOVFF  5DD,619
03440:  MOVFF  03,620
03444:  MOVFF  02,61F
03448:  MOVFF  01,61E
0344C:  MOVFF  00,61D
03450:  CALL   0B3E
03454:  MOVFF  5E4,FEA
03458:  MOVFF  5E3,FE9
0345C:  MOVFF  03,5E0
03460:  MOVFF  02,5DF
03464:  MOVFF  01,5DE
03468:  MOVFF  00,5DD
0346C:  MOVLB  5
0346E:  MOVF   xCA,W
03470:  MULLW  18
03472:  MOVF   FF3,W
03474:  CLRF   xE6
03476:  MOVWF  xE5
03478:  MOVLW  08
0347A:  ADDWF  xE5,W
0347C:  MOVWF  01
0347E:  MOVLW  00
03480:  ADDWFC xE6,W
03482:  MOVWF  03
03484:  MOVF   01,W
03486:  ADDLW  82
03488:  MOVWF  FE9
0348A:  MOVLW  00
0348C:  ADDWFC 03,W
0348E:  MOVWF  FEA
03490:  MOVFF  FEF,619
03494:  MOVFF  FEC,01
03498:  MOVFF  FEC,02
0349C:  MOVFF  FEC,03
034A0:  MOVFF  5D6,618
034A4:  MOVFF  5D5,617
034A8:  MOVFF  5D4,616
034AC:  MOVFF  5D3,615
034B0:  MOVFF  03,61C
034B4:  MOVFF  02,61B
034B8:  MOVFF  01,61A
034BC:  MOVLB  0
034BE:  CALL   0A48
034C2:  MOVFF  03,5E8
034C6:  MOVFF  02,5E7
034CA:  MOVFF  01,5E6
034CE:  MOVFF  00,5E5
034D2:  MOVFF  03,5EC
034D6:  MOVFF  02,5EB
034DA:  MOVFF  01,5EA
034DE:  MOVFF  00,5E9
034E2:  MOVLB  5
034E4:  CLRF   xF0
034E6:  CLRF   xEF
034E8:  CLRF   xEE
034EA:  MOVLW  80
034EC:  MOVWF  xED
034EE:  MOVLB  0
034F0:  CALL   2A64
034F4:  MOVFF  FEA,5E6
034F8:  MOVFF  FE9,5E5
034FC:  BCF    FD8.1
034FE:  MOVFF  5E0,61C
03502:  MOVFF  5DF,61B
03506:  MOVFF  5DE,61A
0350A:  MOVFF  5DD,619
0350E:  MOVFF  03,620
03512:  MOVFF  02,61F
03516:  MOVFF  01,61E
0351A:  MOVFF  00,61D
0351E:  CALL   0B3E
03522:  MOVFF  5E6,FEA
03526:  MOVFF  5E5,FE9
0352A:  MOVFF  03,5E0
0352E:  MOVFF  02,5DF
03532:  MOVFF  01,5DE
03536:  MOVFF  00,5DD
0353A:  MOVLB  5
0353C:  MOVF   xCA,W
0353E:  MULLW  18
03540:  MOVF   FF3,W
03542:  CLRF   xE8
03544:  MOVWF  xE7
03546:  MOVLW  04
03548:  ADDWF  xE7,W
0354A:  MOVWF  01
0354C:  MOVLW  00
0354E:  ADDWFC xE8,W
03550:  MOVWF  03
03552:  MOVF   01,W
03554:  ADDLW  82
03556:  MOVWF  FE9
03558:  MOVLW  00
0355A:  ADDWFC 03,W
0355C:  MOVWF  FEA
0355E:  MOVFF  FEF,619
03562:  MOVFF  FEC,01
03566:  MOVFF  FEC,02
0356A:  MOVFF  FEC,03
0356E:  MOVFF  5D6,618
03572:  MOVFF  5D5,617
03576:  MOVFF  5D4,616
0357A:  MOVFF  5D3,615
0357E:  MOVFF  03,61C
03582:  MOVFF  02,61B
03586:  MOVFF  01,61A
0358A:  MOVLB  0
0358C:  CALL   0A48
03590:  MOVFF  FEA,5E8
03594:  MOVFF  FE9,5E7
03598:  BCF    FD8.1
0359A:  MOVFF  5E0,61C
0359E:  MOVFF  5DF,61B
035A2:  MOVFF  5DE,61A
035A6:  MOVFF  5DD,619
035AA:  MOVFF  03,620
035AE:  MOVFF  02,61F
035B2:  MOVFF  01,61E
035B6:  MOVFF  00,61D
035BA:  CALL   0B3E
035BE:  MOVFF  5E8,FEA
035C2:  MOVFF  5E7,FE9
035C6:  MOVFF  03,61C
035CA:  MOVFF  02,61B
035CE:  MOVFF  01,61A
035D2:  MOVFF  00,619
035D6:  MOVLB  5
035D8:  MOVF   xCA,W
035DA:  MULLW  18
035DC:  MOVF   FF3,W
035DE:  CLRF   xEA
035E0:  MOVWF  xE9
035E2:  MOVLW  82
035E4:  ADDWF  xE9,W
035E6:  MOVWF  FE9
035E8:  MOVLW  00
035EA:  ADDWFC xEA,W
035EC:  MOVWF  FEA
035EE:  MOVFF  FEF,61D
035F2:  MOVFF  FEC,01
035F6:  MOVFF  FEC,02
035FA:  MOVFF  FEC,03
035FE:  BCF    FD8.1
03600:  MOVFF  03,620
03604:  MOVFF  02,61F
03608:  MOVFF  01,61E
0360C:  MOVLB  0
0360E:  CALL   0B3E
03612:  MOVFF  5DC,FEA
03616:  MOVFF  5DB,FE9
0361A:  MOVFF  00,FEF
0361E:  MOVFF  01,FEC
03622:  MOVFF  02,FEC
03626:  MOVFF  03,FEC
....................    
....................    PID[ch].PVold = PID[ch].PV;
0362A:  MOVLB  5
0362C:  MOVF   xCA,W
0362E:  MULLW  20
03630:  MOVF   FF3,W
03632:  CLRF   xDC
03634:  MOVWF  xDB
03636:  MOVLW  14
03638:  ADDWF  xDB,W
0363A:  MOVWF  01
0363C:  MOVLW  00
0363E:  ADDWFC xDC,W
03640:  MOVWF  03
03642:  MOVF   01,W
03644:  ADDLW  20
03646:  MOVWF  01
03648:  MOVLW  00
0364A:  ADDWFC 03,F
0364C:  MOVFF  01,5DB
03650:  MOVFF  03,5DC
03654:  MOVF   xCA,W
03656:  MULLW  20
03658:  MOVF   FF3,W
0365A:  CLRF   xDE
0365C:  MOVWF  xDD
0365E:  MOVLW  10
03660:  ADDWF  xDD,W
03662:  MOVWF  01
03664:  MOVLW  00
03666:  ADDWFC xDE,W
03668:  MOVWF  03
0366A:  MOVF   01,W
0366C:  ADDLW  20
0366E:  MOVWF  FE9
03670:  MOVLW  00
03672:  ADDWFC 03,W
03674:  MOVWF  FEA
03676:  MOVFF  FEF,00
0367A:  MOVFF  FEC,01
0367E:  MOVFF  FEC,02
03682:  MOVFF  FEC,03
03686:  MOVFF  5DC,FEA
0368A:  MOVFF  5DB,FE9
0368E:  MOVFF  00,FEF
03692:  MOVFF  01,FEC
03696:  MOVFF  02,FEC
0369A:  MOVFF  03,FEC
....................    PID[ch].PV = adcVals[ch].pReal;
0369E:  MOVF   xCA,W
036A0:  MULLW  20
036A2:  MOVF   FF3,W
036A4:  CLRF   xDC
036A6:  MOVWF  xDB
036A8:  MOVLW  10
036AA:  ADDWF  xDB,W
036AC:  MOVWF  01
036AE:  MOVLW  00
036B0:  ADDWFC xDC,W
036B2:  MOVWF  03
036B4:  MOVF   01,W
036B6:  ADDLW  20
036B8:  MOVWF  01
036BA:  MOVLW  00
036BC:  ADDWFC 03,F
036BE:  MOVFF  01,5DB
036C2:  MOVFF  03,5DC
036C6:  MOVF   xCA,W
036C8:  MULLW  19
036CA:  MOVF   FF3,W
036CC:  CLRF   xDE
036CE:  MOVWF  xDD
036D0:  MOVLW  15
036D2:  ADDWF  xDD,W
036D4:  MOVWF  01
036D6:  MOVLW  00
036D8:  ADDWFC xDE,W
036DA:  MOVWF  03
036DC:  MOVF   01,W
036DE:  ADDLW  0F
036E0:  MOVWF  FE9
036E2:  MOVLW  01
036E4:  ADDWFC 03,W
036E6:  MOVWF  FEA
036E8:  MOVFF  FEF,00
036EC:  MOVFF  FEC,01
036F0:  MOVFF  FEC,02
036F4:  MOVFF  FEC,03
036F8:  MOVFF  5DC,FEA
036FC:  MOVFF  5DB,FE9
03700:  MOVFF  00,FEF
03704:  MOVFF  01,FEC
03708:  MOVFF  02,FEC
0370C:  MOVFF  03,FEC
03710:  MOVLB  0
03712:  GOTO   37EE (RETURN)
.................... }  
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR INTERRUPT TASK                                             */
.................... /* starts conversion of the other two ADCs                                   */
.................... /*****************************************************************************/
.................... void sensor_monitor_interrupt_task()
.................... {
....................    if (!smData.adcBusy)
*
001E0:  MOVLB  1
001E2:  BTFSC  x4F.1
001E4:  BRA    0218
....................    {
....................       smData.adcBusy = true;
001E6:  BSF    x4F.1
....................       switch (smData.channel)
001E8:  MOVF   x50,W
001EA:  XORLW  00
001EC:  MOVLB  0
001EE:  BZ    01F6
001F0:  XORLW  01
001F2:  BZ    0206
001F4:  BRA    0212
....................       {
....................          case 0:
....................             ads_write_command_block(1, ADSstart);
001F6:  MOVLW  01
001F8:  MOVLB  6
001FA:  MOVWF  x29
001FC:  MOVLW  08
001FE:  MOVWF  x2A
00200:  MOVLB  0
00202:  RCALL  01C8
....................          break;
00204:  BRA    0212
....................          
....................          case 1:
....................             ads_write_command_block(0, ADSstart);
00206:  MOVLB  6
00208:  CLRF   x29
0020A:  MOVLW  08
0020C:  MOVWF  x2A
0020E:  MOVLB  0
00210:  RCALL  01C8
....................          break;
....................       }
....................       smData.adcBusy = false;
00212:  MOVLB  1
00214:  BCF    x4F.1
....................       smData.dataReady = true;
00216:  BSF    x4F.0
....................    }
00218:  MOVLB  0
0021A:  GOTO   02DC (RETURN)
.................... }
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* SENSOR MONITOR task - gets magnetoresistive sensor counts                 */
.................... /* gets two values each time the task is run                                  */
.................... /*****************************************************************************/
.................... void sensor_monitor_task()
.................... {
....................    if (smData.dataReady)
*
03716:  MOVLB  1
03718:  BTFSS  x4F.0
0371A:  BRA    37F0
....................    {
....................       unsigned int32 sinRaw=0;
....................       unsigned int32 cosRaw=0;
....................       int8 ch=0;
0371C:  MOVLB  5
0371E:  CLRF   xC4
03720:  CLRF   xC3
03722:  CLRF   xC2
03724:  CLRF   xC1
03726:  CLRF   xC8
03728:  CLRF   xC7
0372A:  CLRF   xC6
0372C:  CLRF   xC5
0372E:  CLRF   xC9
....................       
....................       smData.adcBusy = true;
03730:  MOVLB  1
03732:  BSF    x4F.1
....................       switch (smData.channel)
03734:  MOVF   x50,W
03736:  XORLW  00
03738:  MOVLB  0
0373A:  BZ    373E
0373C:  BRA    3780
....................       {
....................          case 0:
....................             ch = 0;
0373E:  MOVLB  5
03740:  CLRF   xC9
....................             sinRaw = ads_read_data(0);
03742:  CLRF   xCA
03744:  MOVLB  0
03746:  CALL   12FC
0374A:  MOVFF  03,5C4
0374E:  MOVFF  02,5C3
03752:  MOVFF  01,5C2
03756:  MOVFF  00,5C1
....................             cosRaw = ads_read_data(1);
0375A:  MOVLW  01
0375C:  MOVLB  5
0375E:  MOVWF  xCA
03760:  MOVLB  0
03762:  CALL   12FC
03766:  MOVFF  03,5C8
0376A:  MOVFF  02,5C7
0376E:  MOVFF  01,5C6
03772:  MOVFF  00,5C5
....................             smData.channel = 1;
03776:  MOVLW  01
03778:  MOVLB  1
0377A:  MOVWF  x50
....................          break;
0377C:  BRA    37C0
0377E:  MOVLB  0
....................          
....................          default:
....................             ch = 1;
03780:  MOVLW  01
03782:  MOVLB  5
03784:  MOVWF  xC9
....................             sinRaw = ads_read_data(2);
03786:  MOVLW  02
03788:  MOVWF  xCA
0378A:  MOVLB  0
0378C:  CALL   12FC
03790:  MOVFF  03,5C4
03794:  MOVFF  02,5C3
03798:  MOVFF  01,5C2
0379C:  MOVFF  00,5C1
....................             cosRaw = ads_read_data(3);
037A0:  MOVLW  03
037A2:  MOVLB  5
037A4:  MOVWF  xCA
037A6:  MOVLB  0
037A8:  CALL   12FC
037AC:  MOVFF  03,5C8
037B0:  MOVFF  02,5C7
037B4:  MOVFF  01,5C6
037B8:  MOVFF  00,5C5
....................             smData.channel = 0;
037BC:  MOVLB  1
037BE:  CLRF   x50
....................          break;
....................       }
....................       smData.adcBusy = false;
037C0:  BCF    x4F.1
....................       smData.dataReady = false;
037C2:  BCF    x4F.0
....................       sensor_process_data(ch, sinRaw, cosRaw);
037C4:  MOVFF  5C9,5CA
037C8:  MOVFF  5C4,5CE
037CC:  MOVFF  5C3,5CD
037D0:  MOVFF  5C2,5CC
037D4:  MOVFF  5C1,5CB
037D8:  MOVFF  5C8,5D2
037DC:  MOVFF  5C7,5D1
037E0:  MOVFF  5C6,5D0
037E4:  MOVFF  5C5,5CF
037E8:  MOVLB  0
037EA:  GOTO   2D62
037EE:  MOVLB  1
....................    }
037F0:  MOVLB  0
037F2:  GOTO   7168 (RETURN)
.................... }
.................... /*****************************************************************************/
.................... /* INITIALIZE ADC's                                                          */
.................... /*****************************************************************************/
.................... void setup_external_ADCs()
*
0071A:  MOVLB  5
0071C:  CLRF   xC1
0071E:  CLRF   xC2
00720:  CLRF   xC3
00722:  CLRF   xC4
.................... {
....................    unsigned int8 rc0=0;
....................    unsigned int8 rc1=0;
....................    unsigned int8 rc2=0;
....................    unsigned int8 rc3=0;
....................    
....................    for(int ch = 0; ch < 4; ch++)
00724:  CLRF   xC5
00726:  MOVF   xC5,W
00728:  SUBLW  03
0072A:  BNC   0758
....................    {
....................       switch (magPP)
....................       {         
....................          case 1:
....................             rc0=KMXP1000reg0config;
0072C:  MOVLW  38
0072E:  MOVWF  xC1
....................             rc1=KMXP1000reg1config;
00730:  MOVLW  10
00732:  MOVWF  xC2
....................             rc2=KMXP1000reg2config;
00734:  MOVLW  30
00736:  MOVWF  xC3
....................             rc3=KMXP1000reg3config;
00738:  CLRF   xC4
....................          break;
....................          
....................          case 2:
....................             rc0=KMXP2000reg0config;
....................             rc1=KMXP2000reg1config;
....................             rc2=KMXP2000reg2config;
....................             rc3=KMXP2000reg3config;
....................          break;
....................          
....................          default:
....................             rc0=reg0config;
....................             rc1=reg1config;
....................             rc2=reg2config;
....................             rc3=reg3config;      
....................          break;
....................       }
....................       ADS1220init(ch, rc0, rc1, rc2, rc3);
0073A:  MOVFF  5C5,5C6
0073E:  MOVFF  5C1,5C7
00742:  MOVFF  5C2,5C8
00746:  MOVFF  5C3,5C9
0074A:  MOVFF  5C4,5CA
0074E:  MOVLB  0
00750:  BRA    06B8
00752:  MOVLB  5
00754:  INCF   xC5,F
00756:  BRA    0726
....................    }   
00758:  MOVLB  0
0075A:  GOTO   07BE (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE MONITOR -- sets up ADC channels                                */
.................... /*****************************************************************************/
.................... void monitor_init()
.................... {
....................    setup_adc_ports(sAN6 | sAN16 | sAN17 | sAN24 | sAN25 | sAN26 | sAN27, NO_ANALOGS_P2, VSS_VDD);
0075E:  MOVLW  00
00760:  MOVLB  F
00762:  MOVWF  x53
00764:  MOVLW  40
00766:  MOVWF  x0C
00768:  MOVLW  00
0076A:  MOVWF  x14
0076C:  MOVLW  03
0076E:  MOVWF  x1C
00770:  MOVLW  0F
00772:  MOVWF  x21
00774:  MOVLW  00
00776:  MOVWF  x29
....................    setup_adc(ADC_CLOCK_INTERNAL | ADC_TAD_MUL_255 | ADC_LEGACY_MODE | ADC_THRESHOLD_INT_DISABLED);
00778:  MOVLW  08
0077A:  MOVWF  x55
0077C:  CLRF   x56
0077E:  CLRF   x52
00780:  SETF   x57
00782:  CLRF   F61
00784:  MOVLW  94
00786:  MOVWF  x5B
....................    output_high(EN_EXC);
00788:  MOVLW  E8
0078A:  MOVWF  F8B
0078C:  BSF    F86.0
....................    set_adc_channel(vMonN15); // internal MUX
0078E:  MOVF   x5A,W
00790:  ANDLW  3F
00792:  MOVWF  01
00794:  MOVLW  06
00796:  MOVWF  x5A
00798:  BTFSS  x5B.7
0079A:  BRA    07AA
0079C:  MOVF   01,W
0079E:  SUBLW  06
007A0:  BZ    07AA
007A2:  BSF    x5B.0
007A4:  NOP   
007A6:  BTFSC  x5B.0
007A8:  BRA    07A6
....................    delay_ms(10);
007AA:  MOVLW  0A
007AC:  MOVLB  5
007AE:  MOVWF  xC4
007B0:  MOVLB  0
007B2:  RCALL  03AC
....................    read_adc(ADC_START_ONLY);
007B4:  MOVLB  F
007B6:  BSF    x5B.0
007B8:  NOP   
....................    setup_external_ADCs();
007BA:  MOVLB  0
007BC:  BRA    071A
....................    intTimeoutReg = sensorSampleRate;
007BE:  MOVLB  1
007C0:  CLRF   x4E
007C2:  MOVLW  32
007C4:  MOVWF  x4D
007C6:  MOVLB  0
007C8:  GOTO   7150 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... #include <control.h>
.................... #ifndef control
.................... #define control
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <stdbool.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                                                                   ////
.................... ////                          stdbool.h                                ////
.................... ////                                                                   ////
.................... //// Standard boolean definitions                                      ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2012 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __STDBOOL_H__
.................... #define __STDBOOL_H__
.................... 
.................... #if !getenv("CASE")
....................    // remove TRUE and FALSE added by CCS's device .h file, only if
....................    // compiler has case sensitivty off.
.................... 
....................    #if defined(TRUE)
....................       #undef TRUE
....................    #endif
....................    
....................    #if defined(FALSE)
....................       #undef FALSE
....................    #endif
.................... #endif
.................... 
.................... typedef int1   bool;
.................... #define true   1
.................... #define false  0
.................... #define __bool_true_false_are_defined  1
.................... 
.................... #endif
.................... 
.................... 
.................... //!#pin_select U1TX = TX_PIN
.................... //!#pin_select U1RX = RX_PIN
.................... #pin_select SCK1=PIN_C3
.................... #pin_select SDO1=PIN_C2
.................... #use spi (MASTER, SPI1, BAUD=100000, MODE=0, STREAM=SPI_ctrl)
007CC:  CLRF   03
007CE:  MOVF   F91,W
007D0:  MOVFF  5C6,F91
007D4:  RRCF   F94,W
007D6:  BNC   07D4
007D8:  MOVF   F91,W
007DA:  MOVWF  02
007DC:  MOVFF  5C5,F91
007E0:  RRCF   F94,W
007E2:  BNC   07E0
007E4:  MOVF   F91,W
007E6:  MOVWF  01
007E8:  MOVFF  5C4,F91
007EC:  RRCF   F94,W
007EE:  BNC   07EC
007F0:  MOVFF  F91,00
007F4:  RETURN 0
.................... 
.................... #define DACfullScale 655.36 // full scale/100 because CV = %
.................... 
.................... //!typedef enum {pid, off, manual}OpModeMap_t;
.................... //!   
.................... //!typedef struct {
.................... //!   OpModeMap_t chMap;
.................... //!   int16 syncPin;
.................... //!   int16 enPin;
.................... //!   int16 man_CV;
.................... //!   PID_Ctrl_t* hPID;
.................... //!   }control_ch_t;
.................... //!   
.................... //!extern control_ch_t hPzo[];   
.................... 
.................... /*****************************************************************************/
.................... /*  Nano DAC's have a 16bit serial shift register. Data is sync'ed to output */ 
.................... /*****************************************************************************/
.................... //!void set_nanoDAC_output(control_ch_t *hPzo) 
.................... //!{
.................... //!   unsigned int16 txData = 0;
.................... //!   if (hPzo->chMap == manual)
.................... //!   {
.................... //!      txData = hPzo->man_CV;
.................... //!      output_high(hPzo->enPin);
.................... //!   }
.................... //!   else if (hPzo->chMap == pid)
.................... //!   {
.................... //!      txData = hPzo->hPID->CV;
.................... //!      output_high(hPzo->enPin);
.................... //!   }
.................... //!   else
.................... //!   {
.................... //!      output_low(hHtr->enPin);
.................... //!   }   
.................... //!   output_high(hPzo->syncPin);
.................... //!   delay_ms(1);
.................... //!   spi_xfer(SPI_ctrl, (unsigned int32)txData, 24);
.................... //!   delay_ms(1);
.................... //!   output_low(hPzo->syncPin);
.................... //!   delay_ms(1);
.................... //!   output_high(hPzo->syncPin);
.................... //!}
.................... 
.................... void set_nanoDAC_outputs(channelMap ch)
*
0382C:  MOVLB  5
0382E:  CLRF   xC3
03830:  CLRF   xC2
.................... {
....................    unsigned int16 txData = 0;
.................... 
....................    // use manualOutputValues if channel is manual mode
....................    // else, use PID control variable
....................    if (chMode[ch] == MANUAL)  txData = (unsigned int16)(manualOutputValues[ch] * DACfullScale);
03832:  MOVFF  5C1,5CE
03836:  CLRF   xD0
03838:  MOVLW  61
0383A:  MOVWF  xCF
0383C:  MOVLB  0
0383E:  RCALL  37F6
03840:  MOVF   01,F
03842:  BNZ   389E
03844:  MOVLB  5
03846:  MOVF   xC1,W
03848:  MULLW  04
0384A:  MOVF   FF3,W
0384C:  CLRF   03
0384E:  ADDLW  EA
03850:  MOVWF  FE9
03852:  MOVLW  00
03854:  ADDWFC 03,W
03856:  MOVWF  FEA
03858:  MOVFF  FEF,615
0385C:  MOVFF  FEC,616
03860:  MOVFF  FEC,617
03864:  MOVFF  FEC,618
03868:  MOVLW  0A
0386A:  MOVLB  6
0386C:  MOVWF  x1C
0386E:  MOVLW  D7
03870:  MOVWF  x1B
03872:  MOVLW  23
03874:  MOVWF  x1A
03876:  MOVLW  88
03878:  MOVWF  x19
0387A:  MOVLB  0
0387C:  CALL   0A48
03880:  MOVFF  03,618
03884:  MOVFF  02,617
03888:  MOVFF  01,616
0388C:  MOVFF  00,615
03890:  CALL   1D24
03894:  MOVFF  02,5C3
03898:  MOVFF  01,5C2
0389C:  BRA    3906
....................    else                       txData = (unsigned int16)(PID[(int)ch].CV * DACfullScale);
0389E:  MOVLB  5
038A0:  MOVF   xC1,W
038A2:  MULLW  20
038A4:  MOVF   FF3,W
038A6:  CLRF   xC5
038A8:  MOVWF  xC4
038AA:  MOVLW  18
038AC:  ADDWF  xC4,W
038AE:  MOVWF  01
038B0:  MOVLW  00
038B2:  ADDWFC xC5,W
038B4:  MOVWF  03
038B6:  MOVF   01,W
038B8:  ADDLW  20
038BA:  MOVWF  FE9
038BC:  MOVLW  00
038BE:  ADDWFC 03,W
038C0:  MOVWF  FEA
038C2:  MOVFF  FEF,615
038C6:  MOVFF  FEC,616
038CA:  MOVFF  FEC,617
038CE:  MOVFF  FEC,618
038D2:  MOVLW  0A
038D4:  MOVLB  6
038D6:  MOVWF  x1C
038D8:  MOVLW  D7
038DA:  MOVWF  x1B
038DC:  MOVLW  23
038DE:  MOVWF  x1A
038E0:  MOVLW  88
038E2:  MOVWF  x19
038E4:  MOVLB  0
038E6:  CALL   0A48
038EA:  MOVFF  03,618
038EE:  MOVFF  02,617
038F2:  MOVFF  01,616
038F6:  MOVFF  00,615
038FA:  CALL   1D24
038FE:  MOVFF  02,5C3
03902:  MOVFF  01,5C2
....................    
....................    // shift 16 bits of data
....................    spi_xfer(SPI_ctrl, txData, 24);
03906:  MOVLB  5
03908:  CLRF   xC7
0390A:  CLRF   xC6
0390C:  MOVFF  5C3,5C5
03910:  MOVFF  5C2,5C4
03914:  MOVLB  0
03916:  CALL   07CC
....................    
....................    // use channel map to decide which outputs channels to update
....................    // strobe _sync low to push data to the outputs
....................    output_high(_SYNC_X);
0391A:  MOVLW  E8
0391C:  MOVWF  F8B
0391E:  BSF    F86.2
....................    output_high(_SYNC_Y);
03920:  MOVWF  F8B
03922:  BSF    F86.1
....................    delay_ms(1);
03924:  MOVLW  01
03926:  MOVLB  5
03928:  MOVWF  xC4
0392A:  MOVLB  0
0392C:  CALL   03AC
....................    
....................    if (chMap[0] == ch) output_low(_SYNC_X);
03930:  MOVLW  00
03932:  BTFSC  x60.0
03934:  MOVLW  01
03936:  MOVLB  5
03938:  SUBWF  xC1,W
0393A:  BNZ   3942
0393C:  MOVLW  E8
0393E:  MOVWF  F8B
03940:  BCF    F86.2
....................    if (chMap[1] == ch) output_low(_SYNC_Y);
03942:  MOVLW  00
03944:  MOVLB  0
03946:  BTFSC  x60.1
03948:  MOVLW  01
0394A:  MOVLB  5
0394C:  SUBWF  xC1,W
0394E:  BNZ   3956
03950:  MOVLW  E8
03952:  MOVWF  F8B
03954:  BCF    F86.1
....................    
....................    delay_ms(1);
03956:  MOVLW  01
03958:  MOVWF  xC4
0395A:  MOVLB  0
0395C:  CALL   03AC
....................    output_high(_SYNC_X);
03960:  MOVLW  E8
03962:  MOVWF  F8B
03964:  BSF    F86.2
....................    output_high(_SYNC_Y);
03966:  MOVWF  F8B
03968:  BSF    F86.1
0396A:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_task()
.................... {
....................    static int state = 0;
....................    
....................    switch (state)
0396C:  MOVLB  1
0396E:  MOVF   x52,W
03970:  XORLW  00
03972:  MOVLB  0
03974:  BZ    3978
03976:  BRA    398A
....................    {
....................       case 0:       
....................          set_nanoDAC_outputs(chX);
03978:  MOVLB  5
0397A:  CLRF   xC1
0397C:  MOVLB  0
0397E:  RCALL  382C
....................          state = 1;
03980:  MOVLW  01
03982:  MOVLB  1
03984:  MOVWF  x52
....................       break;
03986:  BRA    3998
03988:  MOVLB  0
....................       default:
....................          set_nanoDAC_outputs(chY);
0398A:  MOVLW  01
0398C:  MOVLB  5
0398E:  MOVWF  xC1
03990:  MOVLB  0
03992:  RCALL  382C
....................          state = 0;
03994:  MOVLB  1
03996:  CLRF   x52
....................       break;
....................    }
03998:  MOVLB  0
0399A:  GOTO   716C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /*  control task sets up the outputs channels                                */ 
.................... /*****************************************************************************/
.................... void control_init()
.................... {
....................    spi_xfer(SPI_ctrl, 0, 24);
*
007F6:  MOVLB  5
007F8:  CLRF   xC7
007FA:  CLRF   xC6
007FC:  CLRF   xC5
007FE:  CLRF   xC4
00800:  MOVLB  0
00802:  RCALL  07CC
....................    output_low(_SYNC_X);
00804:  MOVLW  E8
00806:  MOVWF  F8B
00808:  BCF    F86.2
....................    output_low(_SYNC_Y);
0080A:  MOVWF  F8B
0080C:  BCF    F86.1
....................    output_high(_SYNC_X);
0080E:  MOVWF  F8B
00810:  BSF    F86.2
....................    output_high(_SYNC_Y);
00812:  MOVWF  F8B
00814:  BSF    F86.1
00816:  GOTO   7154 (RETURN)
.................... }
.................... #endif
.................... 
.................... #include <serialport.h>
.................... #ifndef serialPort
.................... #define serialPort
.................... #include <cmdBuffer.h>
.................... #ifndef cmd_buffer
.................... #define cmd_buffer
.................... 
.................... /*****************************************************************************/
.................... /* DIFCS COMMAND BUFFER                                                      */
.................... /* The beginning of a message is signified by an address record. The address */
.................... /* is 4 characters. The first 2 are the hardware identifier (TC - temperature*/
.................... /* controller, DC - difics controller, etc..) The second 2 characters dev-   */
.................... /* ice ID... Valid values are 00 thru 0F. A device ID of FF writes to all    */
.................... /* boards. This might be used to feed angles data to all listeners.          */
.................... /*****************************************************************************/
.................... 
.................... // t,p0,p1,p2,p3,p4,p5,p6
.................... // t is the start character, p0 is the address, p1 is command, p2-6 are params
.................... // these characters used for storing messages
.................... 
.................... #define startChr '~' // start character. Also diagnostic command type
.................... #define diagCmdType startChr
.................... #define endChr '\n'
.................... #define delimiter ','
.................... #define ignoreChr1 '\r'
.................... #define ignoreChr2 ' '
.................... #define noRecordFound (char)0xFF
.................... 
.................... #define numRecords 4
.................... #define numParam 7
.................... #define lenParam 25
.................... 
.................... #define useSerial
.................... //#define useTCPIP
.................... 
.................... typedef enum cmdMode {tcp, ser};
.................... 
.................... // this structure holds a command. This is used by the serial routine as well
.................... // as the TCP routine to store an incoming command + parameters
.................... // in the case of TCP socket id is also passed in this structure
.................... typedef struct cmd 
.................... {
....................    BOOLEAN full;        // if full, command is ready to execute
....................    unsigned int8 chrIndex;
....................    unsigned int8 paramIndex;
....................    unsigned int8 recReadIndex;
....................    unsigned int8 recWriteIndex;
....................    #ifdef useTCPIP
....................    TCP_SOCKET s;              // socket ID for TCP commands 
....................    #endif
....................    char t;
....................    char p[numParam][lenParam];   // only used with ~ type command
.................... };
.................... 
.................... #ifdef useSerial
.................... struct cmd SERcmd[numRecords]; // holds serial command 
.................... unsigned int8 SRI = 0; //usb readindex
.................... unsigned int8 SWI = 0; //usb write index
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... struct cmd TCPcmd[numRecords]; // holds TCP command
.................... unsigned int8 TRI = 0; //usb readindex
.................... unsigned int8 TWI = 0; //usb write index
.................... #endif
.................... 
.................... char retData[100]; // this is used to hold return data 
.................... 
.................... #ifdef useSerial
.................... /*****************************************************************************/
.................... /* RESET SER COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetSERcmd(unsigned int8 recNum)
.................... {
....................    if (recNum < numRecords)
*
0083C:  MOVLB  5
0083E:  MOVF   xC2,W
00840:  SUBLW  03
00842:  BTFSS  FD8.0
00844:  BRA    09B2
....................    {
....................       for (int i = 0; i <numParam; i ++)
00846:  CLRF   xC3
00848:  MOVF   xC3,W
0084A:  SUBLW  06
0084C:  BNC   089C
....................       {
....................          SERcmd[recNum].p[i][0] = '\0';
0084E:  CLRF   xE5
00850:  MOVFF  5C2,5E4
00854:  CLRF   xE7
00856:  MOVLW  B5
00858:  MOVWF  xE6
0085A:  MOVLB  0
0085C:  RCALL  081A
0085E:  MOVFF  02,5C5
00862:  MOVFF  01,5C4
00866:  MOVLW  06
00868:  MOVLB  5
0086A:  ADDWF  xC4,F
0086C:  MOVLW  00
0086E:  ADDWFC xC5,F
00870:  CLRF   xE5
00872:  MOVFF  5C3,5E4
00876:  CLRF   xE7
00878:  MOVLW  19
0087A:  MOVWF  xE6
0087C:  MOVLB  0
0087E:  RCALL  081A
00880:  MOVF   01,W
00882:  MOVLB  5
00884:  ADDWF  xC4,F
00886:  MOVF   02,W
00888:  ADDWFC xC5,F
0088A:  MOVLW  53
0088C:  ADDWF  xC4,W
0088E:  MOVWF  FE9
00890:  MOVLW  01
00892:  ADDWFC xC5,W
00894:  MOVWF  FEA
00896:  CLRF   FEF
00898:  INCF   xC3,F
0089A:  BRA    0848
....................       }
....................       SERcmd[recNum].t = 0;
0089C:  CLRF   xE5
0089E:  MOVFF  5C2,5E4
008A2:  CLRF   xE7
008A4:  MOVLW  B5
008A6:  MOVWF  xE6
008A8:  MOVLB  0
008AA:  RCALL  081A
008AC:  MOVFF  01,5C4
008B0:  MOVLW  05
008B2:  MOVLB  5
008B4:  ADDWF  01,W
008B6:  MOVWF  01
008B8:  MOVLW  00
008BA:  ADDWFC 02,W
008BC:  MOVWF  03
008BE:  MOVF   01,W
008C0:  ADDLW  53
008C2:  MOVWF  FE9
008C4:  MOVLW  01
008C6:  ADDWFC 03,W
008C8:  MOVWF  FEA
008CA:  CLRF   FEF
....................       SERcmd[recNum].chrIndex = 0;
008CC:  CLRF   xE5
008CE:  MOVFF  5C2,5E4
008D2:  CLRF   xE7
008D4:  MOVLW  B5
008D6:  MOVWF  xE6
008D8:  MOVLB  0
008DA:  RCALL  081A
008DC:  MOVFF  01,5C4
008E0:  MOVLW  01
008E2:  MOVLB  5
008E4:  ADDWF  01,W
008E6:  MOVWF  01
008E8:  MOVLW  00
008EA:  ADDWFC 02,W
008EC:  MOVWF  03
008EE:  MOVF   01,W
008F0:  ADDLW  53
008F2:  MOVWF  FE9
008F4:  MOVLW  01
008F6:  ADDWFC 03,W
008F8:  MOVWF  FEA
008FA:  CLRF   FEF
....................       SERcmd[recNum].paramIndex = 0;
008FC:  CLRF   xE5
008FE:  MOVFF  5C2,5E4
00902:  CLRF   xE7
00904:  MOVLW  B5
00906:  MOVWF  xE6
00908:  MOVLB  0
0090A:  RCALL  081A
0090C:  MOVFF  01,5C4
00910:  MOVLW  02
00912:  MOVLB  5
00914:  ADDWF  01,W
00916:  MOVWF  01
00918:  MOVLW  00
0091A:  ADDWFC 02,W
0091C:  MOVWF  03
0091E:  MOVF   01,W
00920:  ADDLW  53
00922:  MOVWF  FE9
00924:  MOVLW  01
00926:  ADDWFC 03,W
00928:  MOVWF  FEA
0092A:  CLRF   FEF
....................       SERcmd[recNum].recReadIndex = 0;
0092C:  CLRF   xE5
0092E:  MOVFF  5C2,5E4
00932:  CLRF   xE7
00934:  MOVLW  B5
00936:  MOVWF  xE6
00938:  MOVLB  0
0093A:  RCALL  081A
0093C:  MOVFF  01,5C4
00940:  MOVLW  03
00942:  MOVLB  5
00944:  ADDWF  01,W
00946:  MOVWF  01
00948:  MOVLW  00
0094A:  ADDWFC 02,W
0094C:  MOVWF  03
0094E:  MOVF   01,W
00950:  ADDLW  53
00952:  MOVWF  FE9
00954:  MOVLW  01
00956:  ADDWFC 03,W
00958:  MOVWF  FEA
0095A:  CLRF   FEF
....................       SERcmd[recNum].recWriteIndex = 0;
0095C:  CLRF   xE5
0095E:  MOVFF  5C2,5E4
00962:  CLRF   xE7
00964:  MOVLW  B5
00966:  MOVWF  xE6
00968:  MOVLB  0
0096A:  RCALL  081A
0096C:  MOVFF  01,5C4
00970:  MOVLW  04
00972:  MOVLB  5
00974:  ADDWF  01,W
00976:  MOVWF  01
00978:  MOVLW  00
0097A:  ADDWFC 02,W
0097C:  MOVWF  03
0097E:  MOVF   01,W
00980:  ADDLW  53
00982:  MOVWF  FE9
00984:  MOVLW  01
00986:  ADDWFC 03,W
00988:  MOVWF  FEA
0098A:  CLRF   FEF
....................       SERcmd[recNum].full = FALSE;
0098C:  CLRF   xE5
0098E:  MOVFF  5C2,5E4
00992:  CLRF   xE7
00994:  MOVLW  B5
00996:  MOVWF  xE6
00998:  MOVLB  0
0099A:  RCALL  081A
0099C:  MOVLW  53
0099E:  MOVLB  5
009A0:  ADDWF  01,W
009A2:  MOVWF  FE9
009A4:  MOVLW  01
009A6:  ADDWFC 02,W
009A8:  MOVWF  FEA
009AA:  BCF    FEF.0
....................       retData[0] = '\0';
009AC:  MOVLB  4
009AE:  CLRF   x29
009B0:  MOVLB  5
....................    }
009B2:  MOVLB  0
009B4:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial read index (SRI)                                          */
.................... /*****************************************************************************/
.................... BOOLEAN getNextSERReadIndex()
.................... {
....................    while (!SERcmd[SRI].full)
*
03F28:  MOVLB  5
03F2A:  CLRF   xE5
03F2C:  MOVFF  427,5E4
03F30:  CLRF   xE7
03F32:  MOVLW  B5
03F34:  MOVWF  xE6
03F36:  MOVLB  0
03F38:  CALL   081A
03F3C:  MOVFF  02,5C3
03F40:  MOVFF  01,5C2
03F44:  MOVLW  53
03F46:  MOVLB  5
03F48:  ADDWF  01,W
03F4A:  MOVWF  FE9
03F4C:  MOVLW  01
03F4E:  ADDWFC 02,W
03F50:  MOVWF  FEA
03F52:  BTFSC  FEF.0
03F54:  BRA    3F76
....................    {
....................       if (SRI == SWI) return FALSE;
03F56:  MOVLB  4
03F58:  MOVF   x28,W
03F5A:  SUBWF  x27,W
03F5C:  BNZ   3F64
03F5E:  MOVLW  00
03F60:  MOVWF  01
03F62:  BRA    3F7C
....................       SRI +=1;
03F64:  MOVLW  01
03F66:  ADDWF  x27,F
....................       if (SRI >= numRecords) SRI=0;
03F68:  MOVF   x27,W
03F6A:  SUBLW  03
03F6C:  BC    3F70
03F6E:  CLRF   x27
03F70:  MOVLB  0
03F72:  BRA    3F28
03F74:  MOVLB  5
....................    }
....................    return TRUE;
03F76:  MOVLW  01
03F78:  MOVWF  01
03F7A:  MOVLB  4
03F7C:  MOVLB  0
03F7E:  GOTO   6D2C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next serial write index (SWI)                                         */
.................... /*****************************************************************************/
.................... void setNextSERWriteIndex()
.................... {
....................    SWI +=1;
*
039D2:  MOVLW  01
039D4:  MOVLB  4
039D6:  ADDWF  x28,F
....................    if (SWI >= numRecords) SWI=0;
039D8:  MOVF   x28,W
039DA:  SUBLW  03
039DC:  BC    39E0
039DE:  CLRF   x28
039E0:  MOVLB  0
039E2:  RETURN 0
.................... }
.................... #endif
.................... 
.................... #ifdef useTCPIP
.................... /*****************************************************************************/
.................... /* RESET TCP COMMAND -- ready for a new command                              */
.................... /*****************************************************************************/
.................... void resetTCPcmd(unsigned int8 recNum)
.................... {
....................    if(recNum < numRecords)
....................    {
....................       for (int i = 0; i <numParam; i ++)
....................       {
....................          TCPcmd[recNum].p[i][0] = '\0';
....................       }
....................       TCPcmd[recNum].t = 0;
....................       TCPcmd[recNum].chrIndex = 0;
....................       TCPcmd[recNum].paramIndex = 0;
....................       TCPcmd[recNum].full = FALSE;
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP read index (TRI)                                             */
.................... /*****************************************************************************/
.................... BOOLEAN getNextTCPReadIndex()
.................... {
....................    while (!TCPcmd[TRI].full)
....................    {
....................       if (TRI == TWI) return FALSE;
....................       TRI +=1;
....................       if (TRI >= numRecords) TRI=0;
....................    }
....................    return TRUE;
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get next TCP write index (TWI)                                            */
.................... /*****************************************************************************/
.................... void setNextTCPWriteIndex()
.................... {
....................    TWI +=1;
....................    if (TWI >= numRecords) TWI=0;
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... #include <io.h>
.................... #ifndef IO
.................... #define IO
.................... 
.................... #use FIXED_IO( A_outputs=PIN_A5,PIN_A4 )
.................... #use FIXED_IO( B_outputs=PIN_B3,PIN_B1,PIN_B0 )
.................... #use FIXED_IO( C_outputs=PIN_C6,PIN_C5,PIN_C3,PIN_C2 )
.................... #use FIXED_IO( D_outputs=PIN_D7,PIN_D6,PIN_D5 )
.................... #use FIXED_IO( E_outputs=PIN_E2,PIN_E1,PIN_E0 )
.................... 
.................... #define A0           PIN_A0
.................... #define A1           PIN_A1
.................... #define A2           PIN_A2
.................... #define A3           PIN_A3
.................... #define _CS_ACC1     PIN_A4
.................... #define _CS_ACC0     PIN_A5
.................... #define MON_N15V     PIN_A6
.................... 
.................... #define _CS_YCOS     PIN_B0
.................... #define SCLK_B       PIN_B1
.................... #define MISO_B       PIN_B2
.................... #define MOSI_B       PIN_B3
.................... #define _LE          PIN_B4
.................... #define CLR          PIN_B5
.................... 
.................... #define MON_200V     PIN_C0
.................... #define MON_3V6X     PIN_C1
.................... #define MOSI_A       PIN_C2
.................... #define SCLK_A       PIN_C3
.................... #define MISO_A       PIN_C4
.................... #define TX_ENABLE    PIN_C5
.................... #define TX_PIN       PIN_C6
.................... #define RX_PIN       PIN_C7
.................... 
.................... #define MON_5V6      PIN_D0
.................... #define MON_5VA      PIN_D1
.................... #define MON_3V3D     PIN_D2
.................... #define MON_3V3A     PIN_D3
.................... #define RS485_FLT    PIN_D4
.................... #define _CS_XSIN     PIN_D5
.................... #define _CS_XCOS     PIN_D6
.................... #define _CS_YSIN     PIN_D7
.................... 
.................... #define EN_EXC       PIN_E0
.................... #define _SYNC_Y      PIN_E1
.................... #define _SYNC_X      PIN_E2
.................... 
.................... #pin_select U1TX = PIN_C6
.................... #pin_select U1RX = PIN_C7
.................... 
.................... // initialization states
.................... #define portA_reset 0x00
.................... #define portB_reset 0x00
.................... #define portC_reset 0x00
.................... #define portD_reset 0x00
.................... #define portE_reset 0x00
.................... 
.................... #define portA_pullups 0xFF
.................... #define portB_pullups 0x00
.................... #define portC_pullups 0x00
.................... #define portD_pullups 0xFF
.................... #define portE_pullups 0x00
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE IO                                                             */
.................... /*****************************************************************************/
.................... void IO_init()
.................... {
....................    output_a(portA_reset);
....................    output_b(portB_reset);
....................    output_c(portC_reset);
....................    output_d(portD_reset);
....................    output_e(portE_reset);
....................    
....................    port_a_pullups(portA_pullups);
....................    port_b_pullups(portB_pullups);
....................    port_c_pullups(portC_pullups);
....................    port_d_pullups(portD_pullups);
....................    port_e_pullups(portE_pullups);
....................    
....................    set_analog_pins(MON_N15V, MON_200V, MON_5V6, MON_5VA, MON_3V6X, MON_3V3A, MON_3V3D);
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... #define use_RS485 // adds RX enable pin//
.................... 
.................... #define oneByteCmdTestValue 128
.................... #define UART_BUFFER_SIZE 60
.................... #define UART_EOT_CHAR1 0x0D //Carriage Return
.................... #define UART_EOT_CHAR2 0x0A //Line Feed
.................... #define UART_SOT_CHAR  '~' // START CHARACTER
.................... #define line_turnaround_char 0xFF
.................... 
.................... #bit UART_TXBuffer_Empty = 0x0FAC.1
.................... 
.................... char UART_BUFFER[UART_BUFFER_SIZE] = {0};
.................... unsigned int8 UART_WR_PTR = 0;
.................... unsigned int8 UART_RD_PTR = 0;
.................... boolean BYTES_AVAILABLE= FALSE;
.................... 
.................... #ifdef use_RS485
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, enable=TX_ENABLE, stream=SERIAL, ERRORS)
*
000CA:  MOVLB  E
000CC:  BTFSS  xC8.5
000CE:  BRA    00CC
000D0:  MOVFF  F9C,4CC
000D4:  MOVLB  4
000D6:  MOVFF  F98,01
000DA:  BTFSS  xCC.1
000DC:  BRA    00E2
000DE:  BCF    F9C.4
000E0:  BSF    F9C.4
000E2:  MOVLB  0
000E4:  GOTO   010C (RETURN)
*
039E4:  MOVLW  93
039E6:  MOVWF  F89
039E8:  BSF    F84.5
039EA:  MOVLB  E
039EC:  BTFSS  xC8.4
039EE:  BRA    39EC
039F0:  MOVLW  93
039F2:  MOVWF  F89
039F4:  BSF    F84.5
039F6:  MOVLB  5
039F8:  MOVFF  5C8,F99
039FC:  NOP   
039FE:  BTFSS  F9D.1
03A00:  BRA    39FE
03A02:  MOVLW  93
03A04:  MOVWF  F89
03A06:  BCF    F84.5
03A08:  MOVLB  0
03A0A:  RETURN 0
.................... #else
.................... #use rs232(baud=baudRate, xmit=TX_PIN, rcv=RX_PIN, stream=SERIAL)
.................... #endif
.................... 
.................... // Message format: [SOT]addr ,cmd, arg1, arg2, arg3[EOT]} 
.................... // arguments are optional
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* SERIAL PORT ISR                                                           */
.................... /*****************************************************************************/
.................... #INT_RDA
.................... void RX_isr()
*
000E8:  MOVLB  0
.................... {
....................    while (kbhit())
000EA:  MOVLB  E
000EC:  BTFSS  xC8.5
000EE:  BRA    012E
....................    {
....................       UART_BUFFER[UART_WR_PTR]=getch();
000F0:  CLRF   03
000F2:  MOVLB  4
000F4:  MOVF   xC9,W
000F6:  ADDLW  8D
000F8:  MOVWF  FE9
000FA:  MOVLW  04
000FC:  ADDWFC 03,W
000FE:  MOVWF  FEA
00100:  MOVFF  FEA,62C
00104:  MOVFF  FE9,62B
00108:  MOVLB  0
0010A:  BRA    00CA
0010C:  MOVFF  62C,FEA
00110:  MOVFF  62B,FE9
00114:  MOVFF  01,FEF
....................       UART_WR_PTR +=1;
00118:  MOVLW  01
0011A:  MOVLB  4
0011C:  ADDWF  xC9,F
....................       if (UART_WR_PTR>=UART_BUFFER_SIZE) UART_WR_PTR=0;
0011E:  MOVF   xC9,W
00120:  SUBLW  3B
00122:  BC    0126
00124:  CLRF   xC9
....................       BYTES_AVAILABLE=TRUE;
00126:  BSF    xCB.0
00128:  MOVLB  0
0012A:  BRA    00EA
0012C:  MOVLB  E
....................    }
0012E:  BCF    xC8.5
00130:  MOVLB  0
00132:  GOTO   006E
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Get character from buffer                                                 */
.................... /*****************************************************************************/
.................... char getchFromBuffer()
*
0399E:  CLRF   03
039A0:  MOVLB  4
039A2:  MOVF   xCA,W
039A4:  ADDLW  8D
039A6:  MOVWF  FE9
039A8:  MOVLW  04
039AA:  ADDWFC 03,W
039AC:  MOVWF  FEA
039AE:  MOVFF  FEF,5C2
.................... {
....................    char data = UART_BUFFER[UART_RD_PTR];
....................    UART_RD_PTR +=1;
039B2:  MOVLW  01
039B4:  ADDWF  xCA,F
....................    if (UART_RD_PTR>=UART_BUFFER_SIZE) UART_RD_PTR=0;
039B6:  MOVF   xCA,W
039B8:  SUBLW  3B
039BA:  BC    39BE
039BC:  CLRF   xCA
....................    if (UART_RD_PTR == UART_WR_PTR) BYTES_AVAILABLE=FALSE;
039BE:  MOVF   xC9,W
039C0:  SUBWF  xCA,W
039C2:  BNZ   39C6
039C4:  BCF    xCB.0
....................    return data;
039C6:  MOVLB  5
039C8:  MOVFF  5C2,01
039CC:  MOVLB  0
039CE:  GOTO   3A72 (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* Serial Task transfers bytes to command buffer                             */
.................... /*****************************************************************************/
.................... void serial_task()
.................... {
....................    while(BYTES_AVAILABLE && SERcmd[SWI].full==FALSE)
*
03A30:  MOVLB  4
03A32:  BTFSS  xCB.0
03A34:  BRA    3F22
03A36:  MOVLB  5
03A38:  CLRF   xE5
03A3A:  MOVFF  428,5E4
03A3E:  CLRF   xE7
03A40:  MOVLW  B5
03A42:  MOVWF  xE6
03A44:  MOVLB  0
03A46:  CALL   081A
03A4A:  MOVFF  02,5C3
03A4E:  MOVFF  01,5C2
03A52:  MOVLW  53
03A54:  MOVLB  5
03A56:  ADDWF  01,W
03A58:  MOVWF  01
03A5A:  MOVLW  01
03A5C:  ADDWFC 02,W
03A5E:  MOVWF  03
03A60:  MOVFF  01,FE9
03A64:  MOVWF  FEA
03A66:  BTFSS  FEF.0
03A68:  BRA    3A6E
03A6A:  MOVLB  4
03A6C:  BRA    3F22
....................    {  
....................       unsigned int8 rxChar = getchFromBuffer();
03A6E:  MOVLB  0
03A70:  BRA    399E
03A72:  MOVFF  01,5C1
....................       if (rxChar == ignoreChr1 || rxChar == ignoreChr2)
03A76:  MOVLB  5
03A78:  MOVF   xC1,W
03A7A:  SUBLW  0D
03A7C:  BZ    3A84
03A7E:  MOVF   xC1,W
03A80:  SUBLW  20
03A82:  BNZ   3A86
....................       {
....................       }
03A84:  BRA    3F1C
....................       else if (rxChar == UART_SOT_CHAR)
03A86:  MOVF   xC1,W
03A88:  SUBLW  7E
03A8A:  BNZ   3ACE
....................       {
....................          resetSERcmd(SWI);
03A8C:  MOVFF  428,5C2
03A90:  MOVLB  0
03A92:  CALL   083C
....................          SERcmd[SWI].t = rxChar;
03A96:  MOVLB  5
03A98:  CLRF   xE5
03A9A:  MOVFF  428,5E4
03A9E:  CLRF   xE7
03AA0:  MOVLW  B5
03AA2:  MOVWF  xE6
03AA4:  MOVLB  0
03AA6:  CALL   081A
03AAA:  MOVFF  01,5C2
03AAE:  MOVLW  05
03AB0:  MOVLB  5
03AB2:  ADDWF  01,W
03AB4:  MOVWF  01
03AB6:  MOVLW  00
03AB8:  ADDWFC 02,W
03ABA:  MOVWF  03
03ABC:  MOVF   01,W
03ABE:  ADDLW  53
03AC0:  MOVWF  FE9
03AC2:  MOVLW  01
03AC4:  ADDWFC 03,W
03AC6:  MOVWF  FEA
03AC8:  MOVFF  5C1,FEF
....................       }
03ACC:  BRA    3F1C
....................       else if (rxChar >= oneByteCmdTestValue)
03ACE:  MOVF   xC1,W
03AD0:  SUBLW  7F
03AD2:  BC    3B3E
....................       {
....................          resetSERcmd(SWI);
03AD4:  MOVFF  428,5C2
03AD8:  MOVLB  0
03ADA:  CALL   083C
....................          SERcmd[SWI].t = rxChar;
03ADE:  MOVLB  5
03AE0:  CLRF   xE5
03AE2:  MOVFF  428,5E4
03AE6:  CLRF   xE7
03AE8:  MOVLW  B5
03AEA:  MOVWF  xE6
03AEC:  MOVLB  0
03AEE:  CALL   081A
03AF2:  MOVFF  01,5C2
03AF6:  MOVLW  05
03AF8:  MOVLB  5
03AFA:  ADDWF  01,W
03AFC:  MOVWF  01
03AFE:  MOVLW  00
03B00:  ADDWFC 02,W
03B02:  MOVWF  03
03B04:  MOVF   01,W
03B06:  ADDLW  53
03B08:  MOVWF  FE9
03B0A:  MOVLW  01
03B0C:  ADDWFC 03,W
03B0E:  MOVWF  FEA
03B10:  MOVFF  5C1,FEF
....................          SERcmd[SWI].full = TRUE;
03B14:  CLRF   xE5
03B16:  MOVFF  428,5E4
03B1A:  CLRF   xE7
03B1C:  MOVLW  B5
03B1E:  MOVWF  xE6
03B20:  MOVLB  0
03B22:  CALL   081A
03B26:  MOVLW  53
03B28:  MOVLB  5
03B2A:  ADDWF  01,W
03B2C:  MOVWF  FE9
03B2E:  MOVLW  01
03B30:  ADDWFC 02,W
03B32:  MOVWF  FEA
03B34:  BSF    FEF.0
....................          setNextSERWriteIndex();
03B36:  MOVLB  0
03B38:  RCALL  39D2
....................       }
03B3A:  BRA    3F1A
03B3C:  MOVLB  5
....................       else if (rxChar == UART_EOT_CHAR2)
03B3E:  MOVF   xC1,W
03B40:  SUBLW  0A
03B42:  BTFSS  FD8.2
03B44:  BRA    3C4A
....................       {
....................          SERcmd[SWI].full = TRUE;
03B46:  CLRF   xE5
03B48:  MOVFF  428,5E4
03B4C:  CLRF   xE7
03B4E:  MOVLW  B5
03B50:  MOVWF  xE6
03B52:  MOVLB  0
03B54:  CALL   081A
03B58:  MOVLW  53
03B5A:  MOVLB  5
03B5C:  ADDWF  01,W
03B5E:  MOVWF  FE9
03B60:  MOVLW  01
03B62:  ADDWFC 02,W
03B64:  MOVWF  FEA
03B66:  BSF    FEF.0
....................          SERcmd[SWI].recWriteIndex = SERcmd[SWI].paramIndex;
03B68:  CLRF   xE5
03B6A:  MOVFF  428,5E4
03B6E:  CLRF   xE7
03B70:  MOVLW  B5
03B72:  MOVWF  xE6
03B74:  MOVLB  0
03B76:  CALL   081A
03B7A:  MOVFF  01,5C2
03B7E:  MOVLW  04
03B80:  MOVLB  5
03B82:  ADDWF  01,W
03B84:  MOVWF  01
03B86:  MOVLW  00
03B88:  ADDWFC 02,W
03B8A:  MOVWF  03
03B8C:  MOVF   01,W
03B8E:  ADDLW  53
03B90:  MOVWF  01
03B92:  MOVLW  01
03B94:  ADDWFC 03,F
03B96:  MOVFF  01,5C2
03B9A:  MOVFF  03,5C3
03B9E:  CLRF   xE5
03BA0:  MOVFF  428,5E4
03BA4:  CLRF   xE7
03BA6:  MOVLW  B5
03BA8:  MOVWF  xE6
03BAA:  MOVLB  0
03BAC:  CALL   081A
03BB0:  MOVFF  01,5C4
03BB4:  MOVLW  02
03BB6:  MOVLB  5
03BB8:  ADDWF  01,W
03BBA:  MOVWF  01
03BBC:  MOVLW  00
03BBE:  ADDWFC 02,W
03BC0:  MOVWF  03
03BC2:  MOVF   01,W
03BC4:  ADDLW  53
03BC6:  MOVWF  FE9
03BC8:  MOVLW  01
03BCA:  ADDWFC 03,W
03BCC:  MOVWF  FEA
03BCE:  MOVFF  FEF,5C4
03BD2:  MOVFF  5C3,FEA
03BD6:  MOVFF  5C2,FE9
03BDA:  MOVFF  5C4,FEF
....................          SERcmd[SWI].chrIndex = 0;
03BDE:  CLRF   xE5
03BE0:  MOVFF  428,5E4
03BE4:  CLRF   xE7
03BE6:  MOVLW  B5
03BE8:  MOVWF  xE6
03BEA:  MOVLB  0
03BEC:  CALL   081A
03BF0:  MOVFF  01,5C2
03BF4:  MOVLW  01
03BF6:  MOVLB  5
03BF8:  ADDWF  01,W
03BFA:  MOVWF  01
03BFC:  MOVLW  00
03BFE:  ADDWFC 02,W
03C00:  MOVWF  03
03C02:  MOVF   01,W
03C04:  ADDLW  53
03C06:  MOVWF  FE9
03C08:  MOVLW  01
03C0A:  ADDWFC 03,W
03C0C:  MOVWF  FEA
03C0E:  CLRF   FEF
....................          SERcmd[SWI].paramIndex = 0;
03C10:  CLRF   xE5
03C12:  MOVFF  428,5E4
03C16:  CLRF   xE7
03C18:  MOVLW  B5
03C1A:  MOVWF  xE6
03C1C:  MOVLB  0
03C1E:  CALL   081A
03C22:  MOVFF  01,5C2
03C26:  MOVLW  02
03C28:  MOVLB  5
03C2A:  ADDWF  01,W
03C2C:  MOVWF  01
03C2E:  MOVLW  00
03C30:  ADDWFC 02,W
03C32:  MOVWF  03
03C34:  MOVF   01,W
03C36:  ADDLW  53
03C38:  MOVWF  FE9
03C3A:  MOVLW  01
03C3C:  ADDWFC 03,W
03C3E:  MOVWF  FEA
03C40:  CLRF   FEF
....................          setNextSERWriteIndex();
03C42:  MOVLB  0
03C44:  RCALL  39D2
....................       }
03C46:  BRA    3F1A
03C48:  MOVLB  5
....................       else if (rxChar == delimiter)
03C4A:  MOVF   xC1,W
03C4C:  SUBLW  2C
03C4E:  BNZ   3D0C
....................       {
....................          if (SERcmd[SWI].paramIndex < numParam-1)
03C50:  CLRF   xE5
03C52:  MOVFF  428,5E4
03C56:  CLRF   xE7
03C58:  MOVLW  B5
03C5A:  MOVWF  xE6
03C5C:  MOVLB  0
03C5E:  CALL   081A
03C62:  MOVFF  02,5C3
03C66:  MOVFF  01,5C2
03C6A:  MOVLW  02
03C6C:  MOVLB  5
03C6E:  ADDWF  01,W
03C70:  MOVWF  01
03C72:  MOVLW  00
03C74:  ADDWFC 02,W
03C76:  MOVWF  03
03C78:  MOVF   01,W
03C7A:  ADDLW  53
03C7C:  MOVWF  FE9
03C7E:  MOVLW  01
03C80:  ADDWFC 03,W
03C82:  MOVWF  FEA
03C84:  MOVF   FEF,W
03C86:  SUBLW  05
03C88:  BNC   3CF4
....................          {
....................             SERcmd[SWI].paramIndex +=1;
03C8A:  CLRF   xE5
03C8C:  MOVFF  428,5E4
03C90:  CLRF   xE7
03C92:  MOVLW  B5
03C94:  MOVWF  xE6
03C96:  MOVLB  0
03C98:  CALL   081A
03C9C:  MOVFF  01,5C2
03CA0:  MOVLW  02
03CA2:  MOVLB  5
03CA4:  ADDWF  01,W
03CA6:  MOVWF  01
03CA8:  MOVLW  00
03CAA:  ADDWFC 02,W
03CAC:  MOVWF  03
03CAE:  MOVF   01,W
03CB0:  ADDLW  53
03CB2:  MOVWF  FE9
03CB4:  MOVLW  01
03CB6:  ADDWFC 03,W
03CB8:  MOVWF  FEA
03CBA:  MOVLW  01
03CBC:  ADDWF  FEF,W
03CBE:  MOVWF  FEF
....................             SERcmd[SWI].chrIndex = 0;
03CC0:  CLRF   xE5
03CC2:  MOVFF  428,5E4
03CC6:  CLRF   xE7
03CC8:  MOVLW  B5
03CCA:  MOVWF  xE6
03CCC:  MOVLB  0
03CCE:  CALL   081A
03CD2:  MOVFF  01,5C2
03CD6:  MOVLW  01
03CD8:  MOVLB  5
03CDA:  ADDWF  01,W
03CDC:  MOVWF  01
03CDE:  MOVLW  00
03CE0:  ADDWFC 02,W
03CE2:  MOVWF  03
03CE4:  MOVF   01,W
03CE6:  ADDLW  53
03CE8:  MOVWF  FE9
03CEA:  MOVLW  01
03CEC:  ADDWFC 03,W
03CEE:  MOVWF  FEA
03CF0:  CLRF   FEF
....................          }
03CF2:  BRA    3D0A
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of params... reset capture
03CF4:  MOVFF  428,5C2
03CF8:  MOVLB  0
03CFA:  CALL   083C
....................             fprintf(SERIAL, retData);
03CFE:  MOVLW  04
03D00:  MOVWF  FEA
03D02:  MOVLW  29
03D04:  MOVWF  FE9
03D06:  RCALL  3A0C
03D08:  MOVLB  5
....................          }
....................       }
03D0A:  BRA    3F1C
....................       
....................       else
....................       {
....................          if (SERcmd[SWI].chrIndex < lenParam)
03D0C:  CLRF   xE5
03D0E:  MOVFF  428,5E4
03D12:  CLRF   xE7
03D14:  MOVLW  B5
03D16:  MOVWF  xE6
03D18:  MOVLB  0
03D1A:  CALL   081A
03D1E:  MOVFF  02,5C3
03D22:  MOVFF  01,5C2
03D26:  MOVLW  01
03D28:  MOVLB  5
03D2A:  ADDWF  01,W
03D2C:  MOVWF  01
03D2E:  MOVLW  00
03D30:  ADDWFC 02,W
03D32:  MOVWF  03
03D34:  MOVF   01,W
03D36:  ADDLW  53
03D38:  MOVWF  FE9
03D3A:  MOVLW  01
03D3C:  ADDWFC 03,W
03D3E:  MOVWF  FEA
03D40:  MOVF   FEF,W
03D42:  SUBLW  18
03D44:  BTFSS  FD8.0
03D46:  BRA    3F06
....................          {
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = rxChar;
03D48:  CLRF   xE5
03D4A:  MOVFF  428,5E4
03D4E:  CLRF   xE7
03D50:  MOVLW  B5
03D52:  MOVWF  xE6
03D54:  MOVLB  0
03D56:  CALL   081A
03D5A:  MOVFF  02,5C3
03D5E:  MOVFF  01,5C2
03D62:  MOVLW  06
03D64:  MOVLB  5
03D66:  ADDWF  xC2,F
03D68:  MOVLW  00
03D6A:  ADDWFC xC3,F
03D6C:  CLRF   xE5
03D6E:  MOVFF  428,5E4
03D72:  CLRF   xE7
03D74:  MOVLW  B5
03D76:  MOVWF  xE6
03D78:  MOVLB  0
03D7A:  CALL   081A
03D7E:  MOVFF  02,5C5
03D82:  MOVFF  01,5C4
03D86:  MOVLW  02
03D88:  MOVLB  5
03D8A:  ADDWF  01,W
03D8C:  MOVWF  01
03D8E:  MOVLW  00
03D90:  ADDWFC 02,W
03D92:  MOVWF  03
03D94:  MOVF   01,W
03D96:  ADDLW  53
03D98:  MOVWF  FE9
03D9A:  MOVLW  01
03D9C:  ADDWFC 03,W
03D9E:  MOVWF  FEA
03DA0:  CLRF   xE5
03DA2:  MOVFF  FEF,5E4
03DA6:  CLRF   xE7
03DA8:  MOVLW  19
03DAA:  MOVWF  xE6
03DAC:  MOVLB  0
03DAE:  CALL   081A
03DB2:  MOVFF  02,03
03DB6:  MOVF   01,W
03DB8:  MOVLB  5
03DBA:  ADDWF  xC2,F
03DBC:  MOVF   02,W
03DBE:  ADDWFC xC3,F
03DC0:  CLRF   xE5
03DC2:  MOVFF  428,5E4
03DC6:  CLRF   xE7
03DC8:  MOVLW  B5
03DCA:  MOVWF  xE6
03DCC:  MOVLB  0
03DCE:  CALL   081A
03DD2:  MOVFF  01,5C4
03DD6:  MOVLW  01
03DD8:  MOVLB  5
03DDA:  ADDWF  01,W
03DDC:  MOVWF  01
03DDE:  MOVLW  00
03DE0:  ADDWFC 02,W
03DE2:  MOVWF  03
03DE4:  MOVF   01,W
03DE6:  ADDLW  53
03DE8:  MOVWF  FE9
03DEA:  MOVLW  01
03DEC:  ADDWFC 03,W
03DEE:  MOVWF  FEA
03DF0:  MOVF   FEF,W
03DF2:  ADDWF  xC2,W
03DF4:  MOVWF  01
03DF6:  MOVLW  00
03DF8:  ADDWFC xC3,W
03DFA:  MOVWF  03
03DFC:  MOVF   01,W
03DFE:  ADDLW  53
03E00:  MOVWF  FE9
03E02:  MOVLW  01
03E04:  ADDWFC 03,W
03E06:  MOVWF  FEA
03E08:  MOVFF  5C1,FEF
....................             SERcmd[SWI].chrIndex += 1;
03E0C:  CLRF   xE5
03E0E:  MOVFF  428,5E4
03E12:  CLRF   xE7
03E14:  MOVLW  B5
03E16:  MOVWF  xE6
03E18:  MOVLB  0
03E1A:  CALL   081A
03E1E:  MOVFF  01,5C2
03E22:  MOVLW  01
03E24:  MOVLB  5
03E26:  ADDWF  01,W
03E28:  MOVWF  01
03E2A:  MOVLW  00
03E2C:  ADDWFC 02,W
03E2E:  MOVWF  03
03E30:  MOVF   01,W
03E32:  ADDLW  53
03E34:  MOVWF  FE9
03E36:  MOVLW  01
03E38:  ADDWFC 03,W
03E3A:  MOVWF  FEA
03E3C:  MOVLW  01
03E3E:  ADDWF  FEF,W
03E40:  MOVWF  FEF
....................             SERcmd[SWI].p[SERcmd[SWI].paramIndex][SERcmd[SWI].chrIndex] = '\0';
03E42:  CLRF   xE5
03E44:  MOVFF  428,5E4
03E48:  CLRF   xE7
03E4A:  MOVLW  B5
03E4C:  MOVWF  xE6
03E4E:  MOVLB  0
03E50:  CALL   081A
03E54:  MOVFF  02,5C3
03E58:  MOVFF  01,5C2
03E5C:  MOVLW  06
03E5E:  MOVLB  5
03E60:  ADDWF  xC2,F
03E62:  MOVLW  00
03E64:  ADDWFC xC3,F
03E66:  CLRF   xE5
03E68:  MOVFF  428,5E4
03E6C:  CLRF   xE7
03E6E:  MOVLW  B5
03E70:  MOVWF  xE6
03E72:  MOVLB  0
03E74:  CALL   081A
03E78:  MOVFF  02,5C5
03E7C:  MOVFF  01,5C4
03E80:  MOVLW  02
03E82:  MOVLB  5
03E84:  ADDWF  01,W
03E86:  MOVWF  01
03E88:  MOVLW  00
03E8A:  ADDWFC 02,W
03E8C:  MOVWF  03
03E8E:  MOVF   01,W
03E90:  ADDLW  53
03E92:  MOVWF  FE9
03E94:  MOVLW  01
03E96:  ADDWFC 03,W
03E98:  MOVWF  FEA
03E9A:  CLRF   xE5
03E9C:  MOVFF  FEF,5E4
03EA0:  CLRF   xE7
03EA2:  MOVLW  19
03EA4:  MOVWF  xE6
03EA6:  MOVLB  0
03EA8:  CALL   081A
03EAC:  MOVFF  02,03
03EB0:  MOVF   01,W
03EB2:  MOVLB  5
03EB4:  ADDWF  xC2,F
03EB6:  MOVF   02,W
03EB8:  ADDWFC xC3,F
03EBA:  CLRF   xE5
03EBC:  MOVFF  428,5E4
03EC0:  CLRF   xE7
03EC2:  MOVLW  B5
03EC4:  MOVWF  xE6
03EC6:  MOVLB  0
03EC8:  CALL   081A
03ECC:  MOVFF  01,5C4
03ED0:  MOVLW  01
03ED2:  MOVLB  5
03ED4:  ADDWF  01,W
03ED6:  MOVWF  01
03ED8:  MOVLW  00
03EDA:  ADDWFC 02,W
03EDC:  MOVWF  03
03EDE:  MOVF   01,W
03EE0:  ADDLW  53
03EE2:  MOVWF  FE9
03EE4:  MOVLW  01
03EE6:  ADDWFC 03,W
03EE8:  MOVWF  FEA
03EEA:  MOVF   FEF,W
03EEC:  ADDWF  xC2,W
03EEE:  MOVWF  01
03EF0:  MOVLW  00
03EF2:  ADDWFC xC3,W
03EF4:  MOVWF  03
03EF6:  MOVF   01,W
03EF8:  ADDLW  53
03EFA:  MOVWF  FE9
03EFC:  MOVLW  01
03EFE:  ADDWFC 03,W
03F00:  MOVWF  FEA
03F02:  CLRF   FEF
....................          }
03F04:  BRA    3F1C
....................          else
....................          {
....................             resetSERcmd(SWI); // exceed number of characters... reset capture
03F06:  MOVFF  428,5C2
03F0A:  MOVLB  0
03F0C:  CALL   083C
....................             fprintf(SERIAL, retData);
03F10:  MOVLW  04
03F12:  MOVWF  FEA
03F14:  MOVLW  29
03F16:  MOVWF  FE9
03F18:  RCALL  3A0C
03F1A:  MOVLB  5
....................          }
....................       }
03F1C:  MOVLB  0
03F1E:  BRA    3A30
03F20:  MOVLB  4
....................    }          
03F22:  MOVLB  0
03F24:  GOTO   7170 (RETURN)
.................... }
....................            
.................... /*****************************************************************************/
.................... /* serialInit ROUTINE  - Sets up serial port                                 */
.................... /*****************************************************************************/ 
.................... void serial_init()
.................... {
....................    for (int i = 0; i < numRecords; i++) 
*
009B6:  MOVLB  5
009B8:  CLRF   xC1
009BA:  MOVF   xC1,W
009BC:  SUBLW  03
009BE:  BNC   09CE
....................    {
....................       resetSERcmd(i);
009C0:  MOVFF  5C1,5C2
009C4:  MOVLB  0
009C6:  RCALL  083C
009C8:  MOVLB  5
009CA:  INCF   xC1,F
009CC:  BRA    09BA
....................    }
....................    enable_interrupts(INT_RDA);
009CE:  MOVLB  E
009D0:  BSF    xC0.5
009D2:  MOVLB  0
009D4:  GOTO   7158 (RETURN)
.................... }
.................... 
.................... 
.................... #endif
.................... 
.................... #include <pid.h>
.................... #ifndef pidcontroller
.................... #define pidcontroller
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... #include <math.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////                                                                    ////
.................... //// History:                                                           ////
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              ////
.................... ////                 The code now is small, much faster,                ////
.................... ////                 and more accurate.                                 ////
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   ////
.................... ////                 not return generic (int8 *) so type cast is done   ////
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication ////
.................... ////                 by its inverse to improve computation speed        ////
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   ////
.................... ////                 Updated routines include 64 bit versions of cos,   ////
.................... ////                 asin,atan,exp,log and dependant functions          ////
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    ////
.................... ////                 and log function                                   ////
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values ////
.................... ////                 greater then 10000000 and less then -10000000      ////
.................... ////                                                                    ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef MATH_H
.................... #define MATH_H
.................... 
.................... #ifdef PI
.................... #undef  PI
.................... #endif
.................... #define PI     3.1415926535897932
.................... 
.................... 
.................... #define SQRT2  1.4142135623730950
.................... 
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279};
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718};
.................... 
.................... ///////////////////////////// Round Functions //////////////////////////////
.................... 
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res;
....................    unsigned int16 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float32)(unsigned int16)y;
.................... 
....................  else if (y < 10000000.0)
....................    { 
....................       l = (unsigned int16)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float32)l);
....................       res = 32768.0*(float32)l;
....................       res += (float32)(unsigned int16)y;
....................    }
.................... 
....................  else
....................   res = y;
.................... 
....................  y = y - (float32)(unsigned int16)y;
.................... 
....................  if (s)
....................   res = -res;
.................... 
....................  if (y != 0)
....................  {
....................   if (s == 1 && n == 0)
....................    res -= 1.0;
.................... 
....................   if (s == 0 && n == 1)
....................    res += 1.0;
....................  }
....................  if (x == 0)
....................     res = 0;
.................... 
....................  return (res);
.................... }
.................... 
.................... // Overloaded Functions to take care for new Data types in PCD
.................... // Overloaded function CEIL_FLOOR() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res;
....................    unsigned int32 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float48)(unsigned int16)y;
.................... 
....................    else if (y < 549755813888.0)
....................    {
....................       l = (unsigned int32)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float48)l);
....................       res = 32768.0*(float48)l;
....................       res += (float48)(unsigned int16)y;
....................    }
....................    else
....................    {  
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float48)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... 
.................... 
.................... // Overloaded function CEIL_FLOOR() for data type - Float64
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res;
....................    int64 l;
....................    int1 s;
.................... 
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y <= 32768.0)
....................       res = (float64)(unsigned int16)y;
....................    else if (y < 4503599627370496.0)
....................    {
....................       l = (int64)(y*0.000030517578125);
....................       y = 32768.0*(y*0.000030517578125 - (float64)l);
....................       res = 32768.0*(float64)l;
....................       res += (float64)(unsigned int16)y;
....................    }
....................    else
....................    {
....................       res = y;
....................       y = 0.0;
....................    }
....................    
....................    if(y != 0)
....................       y = y - (float64)(unsigned int16)y;
.................... 
....................    if (s)
....................       res = -res;
.................... 
....................    if (y != 0)
....................    {
....................       if (s == 1 && n == 0)
....................          res -= 1.0;
.................... 
....................       if (s == 0 && n == 1)
....................          res += 1.0;
....................    }
....................    
....................    if (x == 0)
....................       res = 0;
.................... 
....................    return (res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float floor(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds down the number x.
.................... // Date : N/A
.................... //
.................... float32 floor(float32 x)
.................... {
....................    return CEIL_FLOOR(x,0);
.................... }
.................... // Following 2 functions are overloaded functions of floor() for PCD
.................... // Overloaded function floor() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 floor(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... 
.................... // Overloaded function floor() for data type - Float64
.................... float64 floor(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 0);
.................... }
.................... #endif
.................... 
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float ceil(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : rounds up the number x.
.................... // Date : N/A
.................... //
.................... float32 ceil(float32 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... // Following 2 functions are overloaded functions of ceil() for PCD
.................... // Overloaded function ceil() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ceil(float48 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... 
.................... // Overloaded function ceil() for data type - Float64
.................... float64 ceil(float64 x)
.................... {
....................    return CEIL_FLOOR(x, 1);
.................... }
.................... #endif
.................... 
....................  ////////////////////////////////////////////////////////////////////////////
.................... //   float fabs(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the absolute value of floating point number x
.................... // Returns : returns the absolute value of x
.................... // Date : N/A
.................... //
.................... #define fabs abs
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float fmod(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the floating point remainder of x/y
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the
.................... // magnitude of y. If y is zero then a domain error occurs.
.................... // Date : N/A
.................... //
.................... 
.................... float fmod(float32 x,float32 y)
.................... {
....................    float32 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... //Overloaded function for fmod() for PCD
.................... // Overloaded function fmod() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 fmod(float48 x,float48 y)
.................... {
....................    float48 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... // Overloaded function fmod() for data type - Float64
.................... float64 fmod(float64 x,float64 y)
.................... {
....................    float64 i;
....................    if (y!=0.0)
....................    {
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y);
....................       return(x-(i*y));
....................    }
....................    else
....................    {
....................    #ifdef _ERRNO
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    }
.................... }
.................... #endif
.................... //////////////////// Exponential and logarithmic functions ////////////////////
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float exp(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (e^x)
.................... // Date : N/A
.................... //
.................... #define LN2 0.6931471805599453
.................... #define LN2_INV 1.4426950408889634073
.................... 
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093,
....................                      0.0554965651,  0.240227138,  0.693147172};
.................... 
.................... 
.................... float32 exp(float32 x)
.................... {
....................    float32 y, res, r;
....................    #if defined(__PCD__)
....................    int8 data1;
....................    #endif
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... #if !defined(__PCD__)
....................    *((unsigned int8 *)(&res)) = n + 0x7F;
.................... #endif
.................... 
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+3)) = data1;
.................... #endif
.................... 
....................    y = y*LN2_INV - (float32)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded function for exp() for PCD
.................... // Overloaded function exp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 exp(float48 x)
.................... {
....................    float48 y, res, r;
....................    int8 data1;
....................    signed int8 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 88.722838)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    n = (signed int16)(x*LN2_INV);
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
....................    data1 = n+0x7F;
....................    if(bit_test(data1,0))
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7);
....................    rotate_right(&data1,1);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&res)+5)) = data1;
.................... 
....................    y = y*LN2_INV - (float48)n;
.................... 
....................    r = pe[0]*y + pe[1];
....................    r = r*y + pe[2];
....................    r = r*y + pe[3];
....................    r = r*y + pe[4];
....................    r = r*y + pe[5];
.................... 
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... 
.................... // Overloaded function exp() for data type - Float64
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011,
....................                           8.71486547014137e-009,9.84458531538385e-008,
....................                           1.32588296983536e-006,1.52489283823016e-005,
....................                           0.000154037598423921,0.00133335487036216,
....................                           0.00961812936407326,0.0555041086222122,
....................                           0.240226506962827,0.693147180559823};
.................... 
.................... float64 exp(float64 x)
.................... {
....................    float64 y, res, r;
....................    unsigned int16 data1, data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x > 709.7827128)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x*LN2_INV;
....................    n = (signed int16)y;
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       n = -n;
....................       y = -y;
....................    }
.................... 
....................    res = 0.0;
.................... 
.................... #if !defined(__PCD__)
....................    *((unsigned int16 *)(&res)) = n + 0x7F;
.................... #endif
....................    p= (((unsigned int16 *)(&res))+3);
....................    data1 = *p;
....................    data2 = *p;   
....................    data1 = n + 0x3FF;
....................    data1 = data1 <<4;
....................    if(bit_test(data2,15))
....................    bit_set(data1,15);
....................    data2 = data2 & 0x000F;
....................    data1 ^= data2;
.................... 
....................    *(((unsigned int16 *)(&res)+3)) = data1;
.................... 
.................... 
....................    y = y*LN2_INV - (float64)n;
.................... 
....................    r = pe_64[0]*y + pe_64[1];
....................    r = r*y + pe_64[2];
....................    r = r*y + pe_64[3];
....................    r = r*y + pe_64[4];
....................    r = r*y + pe_64[5];
....................    r = r*y + pe_64[6];
....................    r = r*y + pe_64[7];
....................    r = r*y + pe_64[8];
....................    r = r*y + pe_64[9];
....................    r = r*y + pe_64[10];
....................    r = r*y + pe_64[11];
....................    
....................    res = res*(1.0 + y*r);
.................... 
....................    if (s)
....................       res = 1.0/res;
....................    return(res);
.................... }
.................... #ENDIF
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217};
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the natural log of x
.................... // Date : N/A
.................... //
.................... float32 log(float32 x)
.................... {
....................    float32 y, res, r, y2;
....................    #if defined(__PCD__)
....................    unsigned int8  data1,data2;
....................    #endif
....................    signed int8 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... #if !defined(__PCD__)
....................     *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
.................... 
.................... #if defined(__PCD__) // Takes care of IEEE format
....................    data2 = *(((unsigned int8 *)(&y))+3);
....................    *(((unsigned int8 *)(&y))+3) = 0x3F;
....................    data1 = *(((unsigned int8 *)(&y))+2);
....................    bit_clear(data1,7);
....................    *(((unsigned int8 *)(&y))+2) = data1;
....................    if(bit_test(data2,7))
....................      bit_set(*(((unsigned int8 *)(&y))+3),7);
.................... #endif
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl[0]*y2 + pl[1];
.................... 
....................       r = ql[0]*y2 + ql[1];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
.................... #if !defined(__PCD__)
....................       n = *((unsigned int8 *)(&x)) - 0x7E;
.................... #endif
.................... #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&x)+3));
....................     rotate_left(&data1,1);
....................     data2 = *(((unsigned int8 *)(&x)+2));
....................     if(bit_test (data2,7))
....................       bit_set(data1,0);
....................     n = data1 - 0x7E;
.................... #endif
.................... 
....................       if (n<0) 
....................          r = -(float32)-n;
....................       else
....................          r = (float32)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... //Overloaded function for log() for PCD
.................... // Overloaded function log() for data type - Float48
.................... #if defined(__PCD__)
.................... // Overloaded function log() for data type - float64
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370,
....................                           -3.120535668274329, 2.000000000000000};
.................... 
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234,
....................                           1.113943039156721, -1.893601167470470};
.................... 
.................... float48 log(float48 x)
.................... {
....................    float48 y, res, r, y2;
....................    unsigned int8  data1,data2;
....................    signed int8 n;
.................... #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
.................... #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
.................... 
.................... #if !defined(__PCD__)
....................       *((unsigned int8 *)(&y)) = 0x7E; 
.................... #endif
....................       data2 = *(((unsigned int8 *)(&y))+5);
....................       *(((unsigned int8 *)(&y))+5) = 0x3F;
....................       data1 = *(((unsigned int8 *)(&y))+4);
....................       bit_clear(data1,7);
....................       *(((unsigned int8 *)(&y))+4) = data1;
.................... 
....................       if(bit_test(data2,7))
....................       bit_set(*(((unsigned int8 *)(&y))+4),7);
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0; 
....................       res = y*res/r;
.................... 
....................       data1 = *(((unsigned int8 *)(&x)+5));
....................       rotate_left(&data1,1);
....................       data2 = *(((unsigned int8 *)(&x)+4));
....................       if(bit_test (data2,7))
....................       bit_set(data1,0);
....................       
....................       n = data1 - 0x7E;
.................... 
....................       if (n<0)
....................       r = -(float48)-n;
....................       else
....................       r = (float48)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................    res = 0.0;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 log(float64 x)
.................... {
....................    float64 y, res, r, y2;
....................    unsigned int16  data1,data2;
....................    unsigned int16 *p;
....................    signed int16 n;
....................    #ifdef _ERRNO
....................    if(x <0)
....................    {
....................       errno=EDOM;
....................    }
....................    if(x ==0)
....................    {
....................       errno=ERANGE;
....................       return(0);
....................    }
....................    #endif
....................    y = x;
.................... 
....................    if (y != 1.0)
....................    {
....................    #if !defined(__PCD__)
....................        *((unsigned int8 *)(&y)) = 0x7E; 
....................    #endif
....................       p= (((unsigned int16 *)(&y))+3);
....................       data1 = *p;
....................       data2 = *p;
....................       data1 = 0x3FE;
....................       data1 = data1 <<4;
....................       if(bit_test (data2,15))
....................          bit_set(data1,15);
....................       data2 = data2 & 0x000F;
....................       data1 ^=data2;
.................... 
....................       *p = data1;
.................... 
....................       y = (y - 1.0)/(y + 1.0);
.................... 
....................       y2=y*y;
.................... 
....................       res = pl_64[0]*y2 + pl_64[1];
....................       res = res*y2 + pl_64[2];
....................       res = res*y2 + pl_64[3];
.................... 
....................       r = ql_64[0]*y2 + ql_64[1];
....................       r = r*y2 + ql_64[2];
....................       r = r*y2 + ql_64[3];
....................       r = r*y2 + 1.0;
.................... 
....................       res = y*res/r;
....................  
....................       p= (((unsigned int16 *)(&x))+3);
....................       data1 = *p;
....................       bit_clear(data1,15);
....................       data1 = data1 >>4;    
....................       n = data1 - 0x3FE;
.................... 
.................... 
....................       if (n<0)
....................          r = -(float64)-n;
....................       else
....................          r = (float64)n;
.................... 
....................       res += r*LN2;
....................    }
.................... 
....................    else
....................       res = 0.0;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... 
.................... #define LN10 2.3025850929940456
.................... #define LN10_INV 0.4342944819032518276
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float log10(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the the log base 10 of x
.................... // Date : N/A
.................... //
.................... float32 log10(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... //Overloaded functions for log10() for PCD
.................... // Overloaded function log10() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 log10(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... 
.................... // Overloaded function log10() for data type - Float64
.................... float64 log10(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = log(x);
....................    r = r*LN10_INV;
....................    return(r);
.................... }
.................... #endif
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float modf(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description :breaks the argument value int integral and fractional parts,
.................... // ach of which have the same sign as the argument.  It stores the integral part
.................... // as a float in the object pointed to by the iptr
.................... // Returns : returns the signed fractional part of value.
.................... // Date : N/A
.................... //
.................... 
.................... float32 modf(float32 value,float32 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... //Overloaded functions for modf() for PCD
.................... // Overloaded function modf() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 modf(float48 value,float48 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... // Overloaded function modf() for data type - Float64
.................... float64 modf(float64 value,float64 *iptr)
.................... {
....................    *iptr=(value < 0.0)? ceil(value): floor(value);
....................    return(value - *iptr);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pwr(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pwr(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       }
....................    }
.................... }
.................... //Overloaded functions for pwr() for PCD
.................... // Overloaded function pwr() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 pwr(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... // Overloaded function pwr() for data type - Float64
.................... float64 pwr(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Power functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float pow(float x,float y)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the value (x^y)
.................... // Date : N/A
.................... // Note : 0 is returned when the function will generate an imaginary number
.................... //
.................... float32 pow(float32 x,float32 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... //Overloaded functions for pow() for PCD
.................... // Overloaded function for pow() data type - Float48
.................... #if defined(__PCD__)
.................... float48 pow(float48 x,float48 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... 
.................... // Overloaded function pow() for data type - Float64
.................... float64 pow(float64 x,float64 y)
.................... {
....................    if(0 > x && fmod(y, 1) == 0) {
....................       if(fmod(y, 2) == 0) {
....................          return (exp(log(-x) * y));
....................       } else {
....................          return (-exp(log(-x) * y));
....................       }
....................    } else if(0 > x && fmod(y, 1) != 0) {
....................       return 0;
....................    } else {
....................       if(x != 0 || 0 >= y) {
....................          return (exp(log(x) * y));
....................       } else return 0;
....................    }
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sqrt(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the square root of x
.................... // Date : N/A
.................... //
.................... float32 sqrt(float32 x)
.................... {
....................    float32 y, res;
....................    #if defined(__PCD__)
....................    unsigned int16 data1,data2;
....................    #endif
....................    #if !defined(__PCD__)
....................    unsigned int8 *p;
....................    #endif
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);    
....................     if(bit_test(data2,7))    
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     data1 = *(((unsigned int8 *)(&y))+3);
....................     data2 = *(((unsigned int8 *)(&y))+2);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+3) = data1;
....................     *(((unsigned int8 *)(&y))+2) = data2;
....................     
....................   #endif
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for sqrt() for PCD
.................... // Overloaded function sqrt() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sqrt(float48 x)
.................... {
....................    float48 y, res;
....................    unsigned int16 data1,data2;
....................    unsigned int8 *p;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    
....................    #if !defined(__PCD__)
....................     p=&y;
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1);
....................    #endif
....................    
....................    #if defined(__PCD__)
....................     p = (((unsigned int8 *)(&y))+5);
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1 = ((data1+127) >>1);
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................   #endif
.................... 
....................    do {
....................       res=y;
....................       y+=(x/y);
.................... 
....................       #if !defined(__PCD__)
....................      (*p)--;
....................    #endif
....................    
....................     data1 = *(((unsigned int8 *)(&y))+5);
....................     data2 = *(((unsigned int8 *)(&y))+4);
....................     rotate_left(&data1,1);
....................     if(bit_test(data2,7))
....................        bit_set(data1,0);    
....................     data1--;
....................     bit_clear(data2,7);
....................     if(bit_test(data1,0))
....................        bit_set(data2,7);
....................     data1 = data1 >>1;
....................     *(((unsigned int8 *)(&y))+5) = data1;
....................     *(((unsigned int8 *)(&y))+4) = data2;
....................     
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function sqrt() for data type - Float64
.................... float64 sqrt(float64 x)
.................... {
....................    float64 y, res;
....................    unsigned int16 *p;
....................    unsigned int16 temp1,temp2;
.................... 
....................    #ifdef _ERRNO
....................    if(x < 0)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
.................... 
....................    if( x<=0.0)
....................       return(0.0);
.................... 
....................    y=x;
....................    p= (((unsigned int16 *)(&y))+3);
....................    temp1 = *p;
....................    temp2 = *p;
....................    bit_clear(temp1,15);
....................    temp1 = (temp1>>4)+1023;
....................    temp1 = temp1 >> 1;
....................    temp1 = (temp1<<4) & 0xFFF0;
....................    if(bit_test(temp2,15))
....................       bit_set(temp1,15);
....................    temp2 = temp2 & 0x000F;
....................    temp1 ^= temp2;
....................    
....................    (*p) = temp1;
....................    
....................    do {
....................       res=y;
....................       y+=(x/y);
....................      temp1 = *p;
....................      temp2 = *p;
....................      bit_clear(temp1,15);
....................      temp1 = (temp1>>4);
....................      temp1--;
....................      temp1 = (temp1<<4) & 0xFFF0;
....................      if(bit_test(temp2,15))
....................         bit_set(temp1,15);
....................      temp2 = temp2 & 0x000F;
....................      temp1 ^= temp2;
....................      (*p) = temp1;
.................... 
....................    } while(res != y);
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////// Trig Functions //////////////////////////////
.................... #ifdef PI_DIV_BY_TWO_INV
.................... #undef PI_DIV_BY_TWO_INV
.................... #endif
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134
.................... #ifdef PI_DIV_BY_TWO
.................... #undef PI_DIV_BY_TWO
.................... #endif
.................... #define PI_DIV_BY_TWO   1.5707963267948966
.................... #ifdef TWOBYPI
.................... #undef TWOBYPI
.................... #endif
.................... #define TWOBYPI          0.6366197723675813
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the cosine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 cos(float32 x)
.................... {
....................    float32 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float32 frac;
....................    float32 p[5] = {                    //by the series definition for cosine
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166663896921267,
....................       -0.00138883894522527,
....................        0.00002476138231734,
....................       -0.00000026070414770
....................       //-0.00000000001147,
....................       // 0.00000000000005
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 4; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... 
.................... //Overloaded functions for cos() for PCD
.................... // Overloaded function cos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cos(float48 x)
.................... {
....................    float48 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float48 frac;
....................    float48 p[6] = {                    //by the series definition for cosine
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! )
....................        0.04166666666667,
....................       -0.00138888888889,
....................        0.00002480158730,
....................       -0.00000027557319,
....................        0.00000000208767
....................    };
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 0.999999999781;
....................    t = t * t;
....................    for (i = 0; i <= 5; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... // Overloaded function cos() for data type - Float64
.................... float64 cos(float64 x)
.................... {
....................    float64 y, t, t2 = 1.0;
....................    unsigned int8 quad, i;
....................    float64 frac;
....................    float64 p_64[9] = {               //by the series definition for cosine
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )             
....................       0.04166666666656518,
....................      -0.00138888888851691,
....................       0.00002480158658490,
....................      -0.00000027557239796,
....................       0.00000000208715031,
....................      -0.00000000001126577,
....................       0.00000000000000427,
....................       0.00000000000000372};
.................... 
....................    if (x < 0) x = -x;                  // absolute value of input
.................... 
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input
....................    quad = quad % 4;                    // quadrant (0 to 3)
.................... 
....................    if (quad == 0 || quad == 2)
....................       t = frac * PI_DIV_BY_TWO;
....................    else if (quad == 1)
....................       t = (1-frac) * PI_DIV_BY_TWO;
....................    else // should be 3
....................       t = (frac-1) * PI_DIV_BY_TWO;
.................... 
....................    y = 1.0;
....................    t = t * t;
....................    for (i = 0; i <= 8; i++)
....................    {
....................       t2 = t2 * t;
....................       y = y + p_64[i] * t2;
....................    }
.................... 
....................    if (quad == 2 || quad == 1)
....................       y = -y;  // correct sign
.................... 
....................    return (y);
.................... }
.................... 
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the sine value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 sin(float32 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... //Overloaded functions for sin() for PCD
.................... // Overloaded function sin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sin(float48 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... 
.................... // Overloaded function sin() for data type - Float48
.................... float64 sin(float64 x)
.................... {
....................    return cos(x - PI_DIV_BY_TWO);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the tangent value of the angle x, which is in radian
.................... // Date : 9/20/2001
.................... //
.................... float32 tan(float32 x)
.................... {
....................    float32 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... //Overloaded functions for tan() for PCD
.................... // Overloaded function tan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tan(float48 x)
.................... {
....................    float48 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... 
.................... // Overloaded function tan() for data type - Float48
.................... float64 tan(float64 x)
.................... {
....................    float64 c, s;
.................... 
....................    c = cos(x);
....................    if (c == 0.0)
....................       return (1.0e+36);
.................... 
....................    s = sin(x);
....................    return(s/c);
.................... }
.................... #endif
.................... 
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290};
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290};
.................... 
.................... float32 ASIN_COS(float32 x, unsigned int8 n)
.................... {
....................    float32 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... 
.................... //Overloaded functions for ASIN_COS() for PCD
.................... // Overloaded function ASIN_COS() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 ASIN_COS(float48 x, unsigned int8 n)
.................... {
....................    float48 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas[0]*y2 + pas[1];
....................    res = res*y2 + pas[2];
.................... 
....................    r = qas[0]*y2 + qas[1];
....................    r = r*y2 + qas[2];
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... 
.................... // Overloaded function ASIN_COS() for data type - Float64
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907,
....................                  -0.360690137621842,0.024929451660228};
.................... 
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133,
....................                    0.052808872045749,-0.000662536036570};
....................                    
.................... float64 ASIN_COS(float64 x, unsigned int8 n)
.................... {
....................    float64 y, res, r, y2;
....................    int1 s;
....................    #ifdef _ERRNO
....................    if(x <-1 || x > 1)
....................    {
....................       errno=EDOM;
....................    }
....................    #endif
....................    s = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 0.5)
....................    {
....................       y = sqrt((1.0 - y)*0.5);
....................       n += 2;
....................    }
.................... 
....................    y2=y*y;
.................... 
....................    res = pas_64[4]*y2 + pas_64[3];
....................    res = res*y2 + pas_64[2];
....................    res = res*y2 + pas_64[1];
....................    res = res*y2 + pas_64[0];
.................... 
....................    r = qas_64[4]*y2 + qas_64[3];
....................    r = r*y2 + qas_64[2];
....................    r = r*y2 + qas_64[1];
....................    r = r*y2 + qas_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
....................    if (n & 2)     // |x| > 0.5
....................       res = PI_DIV_BY_TWO - 2.0*res;
....................    if (s)
....................       res = -res;
....................    if (n & 1)           // take arccos
....................       res = PI_DIV_BY_TWO - res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float asin(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arcsine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 asin(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... //Overloaded functions for asin() for PCD
.................... // Overloaded function asin() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 asin(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function asin() for data type - Float64
.................... float64 asin(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 0);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float acos(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arccosine value of the value x.
.................... // Date : N/A
.................... //
.................... float32 acos(float32 x)
.................... {
....................    float32 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... //Overloaded functions for acos() for PCD
.................... // Overloaded function acos() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 acos(float48 x)
.................... {
....................    float48 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... 
.................... // Overloaded function acos() for data type - Float64
.................... float64 acos(float64 x)
.................... {
....................    float64 r;
.................... 
....................    r = ASIN_COS(x, 1);
....................    return(r);
.................... }
.................... #endif
.................... 
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457};
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457};
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float atan(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : returns the arctangent value of the value x.
.................... // Date : N/A
.................... //
.................... float32 atan(float32 x)
.................... {
....................    float32 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... //Overloaded functions for atan() for PCD
.................... // Overloaded function atan() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan(float48 x)
.................... {
....................    float48 y, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
.................... 
....................    res = pat[0]*y*y + pat[1];
....................    res = res*y*y + pat[2];
....................    res = res*y*y + pat[3];
.................... 
....................    r = qat[0]*y*y + qat[1];
....................    r = r*y*y + qat[2];
....................    r = r*y*y + qat[3];
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... 
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449,
....................                    0.579678874003185,0.072162702162882,0.002281100141660};
.................... 
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393,
....................                    0.182482977188688,0.011155377971690,0.000100013019160};
.................... // Overloaded function atan() for data type - Float64
.................... float64 atan(float64 x)
.................... {
....................    float64 y,y2, res, r;
....................    int1 s, flag;
.................... 
....................    s = 0;
....................    flag = 0;
....................    y = x;
.................... 
....................    if (x < 0)
....................    {
....................       s = 1;
....................       y = -y;
....................    }
.................... 
....................    if (y > 1.0)
....................    {
....................       y = 1.0/y;
....................       flag = 1;
....................    }
....................    y2 = y*y;
....................    res = pat_64[5]*y2 + pat_64[4];
....................    res = res*y2 + pat_64[3];
....................    res = res*y2 + pat_64[2];
....................    res = res*y2 + pat_64[1];
....................    res = res*y2 + pat_64[0];
.................... 
....................    r = qat_64[5]*y2 + qat_64[4];
....................    r = r*y2 + qat_64[3];
....................    r = r*y2 + qat_64[2];
....................    r = r*y2 + qat_64[1];
....................    r = r*y2 + qat_64[0];
....................    r = r*y2 + 1.0;
.................... 
....................    res = y*res/r;
.................... 
.................... 
....................    if (flag)                              // for |x| > 1
....................       res = PI_DIV_BY_TWO - res;
....................    if (s)
....................       res = -res;
.................... 
....................    return(res);
.................... }
.................... #endif
.................... 
.................... /////////////////////////////////////////////////////////////////////////////
.................... //   float atan2(float y, float x)
.................... /////////////////////////////////////////////////////////////////////////////
.................... // Description :computes the principal value of arc tangent of y/x, using the
.................... // signs of both the arguments to determine the quadrant of the return value
.................... // Returns : returns the arc tangent of y/x.
.................... // Date : N/A
.................... //
.................... 
.................... float32 atan2(float32 y,float32 x)
.................... {
....................    float32 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... //Overloaded functions for atan2() for PCD
.................... // Overloaded function atan2() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 atan2(float48 y,float48 x)
.................... {
....................    float48 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... 
.................... // Overloaded function atan2() for data type - Float64
.................... float64 atan2(float64 y,float64 x)
.................... {
....................    float64 z;
....................    int1 sign;
....................    unsigned int8 quad;
....................    sign=0;
....................    quad=0; //quadrant
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1));
....................    if(y<0.0)
....................    {
....................       sign=1;
....................       y=-y;
....................    }
....................    if(x<0.0)
....................    {
....................       x=-x;
....................    }
....................    if (x==0.0)
....................    {
....................       if(y==0.0)
....................       {
....................       #ifdef _ERRNO
....................       {
....................          errno=EDOM;
....................       }
....................       #endif
....................       }
....................       else
....................       {
....................          if(sign)
....................          {
....................          return (-(PI_DIV_BY_TWO));
....................          }
....................          else
....................          {
....................          return (PI_DIV_BY_TWO);
....................          }
....................       }
....................    }
....................    else
....................    {
....................       z=y/x;
....................       switch(quad)
....................       {
....................          case 1:
....................          {
....................             return atan(z);
....................             break;
....................          }
....................          case 2:
....................          {
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122
....................             return (PI-atan(z));
....................             break;
....................          }
....................          case 3:
....................          {
....................             return (atan(z)-PI);
....................             break;
....................          }
....................          case 4:
....................          {
....................             return (-atan(z));
....................             break;
....................          }
....................       }
....................    }
.................... }
.................... #endif
.................... 
.................... //////////////////// Hyperbolic functions ////////////////////
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float cosh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic cosine value of x
.................... // Returns : returns the hyperbolic cosine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 cosh(float32 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... //Overloaded functions for cosh() for PCD
.................... // Overloaded function cosh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 cosh(float48 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function cosh() for data type - Float64
.................... float64 cosh(float64 x)
.................... {
....................    return ((exp(x)+exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float sinh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic sine value of x
.................... // Returns : returns the hyperbolic sine value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 sinh(float32 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... //Overloaded functions for sinh() for PCD
.................... // Overloaded function sinh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 sinh(float48 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... 
.................... // Overloaded function sinh() for data type - Float48
.................... float64 sinh(float64 x)
.................... {
.................... 
....................    return ((exp(x) - exp(-x))*0.5);
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float tanh(float x)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : Computes the hyperbolic tangent value of x
.................... // Returns : returns the hyperbolic tangent value of x
.................... // Date : N/A
.................... //
.................... 
.................... float32 tanh(float32 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... //Overloaded functions for tanh() for PCD
.................... // Overloaded function tanh() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 tanh(float48 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... 
.................... // Overloaded function tanh() for data type - Float64
.................... float64 tanh(float64 x)
.................... {
....................    return(sinh(x)/cosh(x));
.................... }
.................... #endif
.................... 
.................... ////////////////////////////////////////////////////////////////////////////
.................... //   float frexp(float x, signed int *exp)
.................... ////////////////////////////////////////////////////////////////////////////
.................... // Description : breaks a floating point number into a normalized fraction and an integral
.................... // power of 2. It stores the integer in the signed int object pointed to by exp.
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero,
.................... // both parts of the result are zero.
.................... // Date : N/A
.................... //
.................... 
.................... #define LOG2 .30102999566398119521
.................... #define LOG2_INV 3.32192809488736234787
.................... float32 frexp(float32 x, signed int8 *exp)
.................... {
....................    float32 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... //Overloaded functions for frexp() for PCD
.................... // Overloaded function frexp() for data type - Float48
.................... #if defined(__PCD__)
.................... float48 frexp(float48 x, signed int8 *exp)
.................... {
....................    float48 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... 
.................... // Overloaded function frexp() for data type - Float64
.................... float64 frexp(float64 x, signed int8 *exp)
.................... {
....................    float64 res;
....................    int1 sign = 0;
....................    if(x == 0.0)
....................    {
....................       *exp=0;
....................       return (0.0);
....................    }
....................    if(x < 0.0)
....................    {
....................      x=-x;
....................      sign=1;
....................    }
....................    if (x > 1.0)
....................    {
....................       *exp=(ceil(log10(x)*LOG2_INV));
....................       res=x/(pow(2, *exp));
....................       if (res == 1)
....................       {
....................          *exp=*exp+1;
....................           res=.5;
....................       }
....................    }
....................    else
....................    {
....................       if(x < 0.5)
....................       {
....................          *exp=-1;
....................          res=x*2;
....................       }
....................       else
....................       {
....................          *exp=0;
....................           res=x;
....................       }
....................    }
....................    if(sign)
....................    {
....................       res=-res;
....................    }
....................    return res;
.................... }
.................... #endif
.................... 
.................... //////////////////////////////////////////////////////////////////////////////
.................... //   float ldexp(float x, signed int *exp)
.................... //////////////////////////////////////////////////////////////////////////////
.................... // Description : multiplies a floating point number by an integral power of 2.
.................... // Returns : returns the value of x times 2 raised to the power exp.
.................... // Date : N/A
.................... //
.................... 
.................... float32 ldexp(float32 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... //Overloaded functions for ldexp() for PCD
.................... // Overloaded function ldexp() for data type - Float48
.................... 
.................... #if defined(__PCD__)
.................... float48 ldexp(float48 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... // Overloaded function ldexp() for data type - Float64
.................... float64 ldexp(float64 value, signed int8 exp)
.................... {
....................    return (value * pow(2,exp));
.................... }
.................... #endif
.................... 
.................... #endif
.................... 
.................... 
.................... /*****************************************************************************/
.................... /* UPDATE the Control Variable (CV)                                          */
.................... /*****************************************************************************/
.................... void pid_update (channelMap ch){
....................    float err = PID[ch].SP - PID[ch].PV;   // error = set value - measured
....................    PID[ch].I += (err * PID[ch].kI);       // integral value 
....................    float P = err * PID[ch].kP;            // proportional value
....................    float D = PID[ch].kD * (PID[ch].PV - PID[ch].PVold); // derivative value
....................    PID[ch].CV = P + PID[ch].I + D;        // new control variable
....................    if (PID[ch].CV > 100) 
....................    {
....................       PID[ch].CV = 100;// limit output to 100%
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* PID Task - looks for change to PV and updates CV                          */
.................... /*****************************************************************************/
.................... void pid_task(channelMap ch){
....................    static int index = 0;
....................    if (adcVals[ch].pReal != PID[ch].PV) pid_update(ch);
....................    if ((index++) >= numChannels) index = 0;
.................... }
.................... 
.................... #endif
.................... 
.................... #include <eventTimer.h>
.................... #ifndef timeout
.................... #define timeout
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/           
.................... /* Global timers used by all routnes                                         */
.................... /* timeoutReg0-2 are used for timeouts. Other routines monitor the value of  */
.................... /* intTimeoutReg. On boot, they will be loaded from EEProm. Any              */
.................... /* configuration changes will be changed in EEprom, hence will be restored on*/
.................... /* subsequent boot.                                                          */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* Register definitions                                                      */
.................... /*****************************************************************************/
.................... //!unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... //!unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... //!unsigned int32 timeoutReg2 = 0;
.................... //!unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... unsigned int32 timeCounter = 0;
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT_INIT initializes the timer                                        */
.................... /*****************************************************************************/
.................... void event_timer_init()
.................... {        
....................    disable_interrupts(INT_TIMER1);
009D8:  MOVLB  E
009DA:  BCF    xC1.0
....................    setup_timer_1(T1_INTERNAL|T1_DIV_BY_1);
009DC:  MOVLW  01
009DE:  MOVWF  FD1
009E0:  MOVLW  07
009E2:  MOVWF  FCE
009E4:  CLRF   FCF
009E6:  CLRF   FD0
....................    timeoutReg0 = 0;  // clear all the timers
009E8:  MOVLB  1
009EA:  CLRF   x44
009EC:  CLRF   x43
009EE:  CLRF   x42
009F0:  CLRF   x41
....................    timeoutReg1 = 0;
009F2:  CLRF   x48
009F4:  CLRF   x47
009F6:  CLRF   x46
009F8:  CLRF   x45
....................    timeoutReg2 = 0;
009FA:  CLRF   x4C
009FC:  CLRF   x4B
009FE:  CLRF   x4A
00A00:  CLRF   x49
....................    intTimeoutReg = 50;
00A02:  CLRF   x4E
00A04:  MOVLW  32
00A06:  MOVWF  x4D
....................    enable_interrupts(INT_TIMER1);
00A08:  MOVLB  E
00A0A:  BSF    xC1.0
00A0C:  MOVLB  0
00A0E:  GOTO   715C (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* TIMEOUT INTERRUPT decrements the timeout registers every second           */
.................... /*****************************************************************************/
.................... #INT_TIMER1
.................... void TIMER1_isr(void) 
*
0021E:  MOVLB  0
.................... {
....................    set_timer1(0x0BDB); // load timer register to allow 10 millisecond interupts
00220:  MOVLW  0B
00222:  MOVWF  FCD
00224:  MOVLW  DB
00226:  MOVWF  FCC
00228:  NOP   
....................    if (timeoutReg0 > 10) timeoutReg0 -= 10; else timeoutReg0 = 0;
0022A:  MOVLB  1
0022C:  MOVF   x44,F
0022E:  BNZ   023E
00230:  MOVF   x43,F
00232:  BNZ   023E
00234:  MOVF   x42,F
00236:  BNZ   023E
00238:  MOVF   x41,W
0023A:  SUBLW  0A
0023C:  BC    024C
0023E:  MOVLW  0A
00240:  SUBWF  x41,F
00242:  MOVLW  00
00244:  SUBWFB x42,F
00246:  SUBWFB x43,F
00248:  SUBWFB x44,F
0024A:  BRA    0254
0024C:  CLRF   x44
0024E:  CLRF   x43
00250:  CLRF   x42
00252:  CLRF   x41
....................    if (timeoutReg1 > 10) timeoutReg1 -= 10; else timeoutReg1 = 0;
00254:  MOVF   x48,F
00256:  BNZ   0266
00258:  MOVF   x47,F
0025A:  BNZ   0266
0025C:  MOVF   x46,F
0025E:  BNZ   0266
00260:  MOVF   x45,W
00262:  SUBLW  0A
00264:  BC    0274
00266:  MOVLW  0A
00268:  SUBWF  x45,F
0026A:  MOVLW  00
0026C:  SUBWFB x46,F
0026E:  SUBWFB x47,F
00270:  SUBWFB x48,F
00272:  BRA    027C
00274:  CLRF   x48
00276:  CLRF   x47
00278:  CLRF   x46
0027A:  CLRF   x45
....................    if (timeoutReg2 > 10) timeoutReg2 -= 10; else timeoutReg2 = 0;
0027C:  MOVF   x4C,F
0027E:  BNZ   028E
00280:  MOVF   x4B,F
00282:  BNZ   028E
00284:  MOVF   x4A,F
00286:  BNZ   028E
00288:  MOVF   x49,W
0028A:  SUBLW  0A
0028C:  BC    029C
0028E:  MOVLW  0A
00290:  SUBWF  x49,F
00292:  MOVLW  00
00294:  SUBWFB x4A,F
00296:  SUBWFB x4B,F
00298:  SUBWFB x4C,F
0029A:  BRA    02A4
0029C:  CLRF   x4C
0029E:  CLRF   x4B
002A0:  CLRF   x4A
002A2:  CLRF   x49
....................    if (intTimeoutReg != 0) // INTERRUPTING TIMER
002A4:  MOVF   x4D,F
002A6:  BNZ   02AC
002A8:  MOVF   x4E,F
002AA:  BZ    02E8
....................    {
....................       timeCounter+=10;
002AC:  MOVLW  0A
002AE:  MOVLB  4
002B0:  ADDWF  xD0,F
002B2:  MOVLW  00
002B4:  ADDWFC xD1,F
002B6:  ADDWFC xD2,F
002B8:  ADDWFC xD3,F
....................       if (timeCounter >= intTimeoutReg)
002BA:  MOVF   xD3,F
002BC:  BNZ   02D8
002BE:  MOVF   xD2,F
002C0:  BNZ   02D8
002C2:  MOVLB  1
002C4:  MOVF   x4E,W
002C6:  MOVLB  4
002C8:  SUBWF  xD1,W
002CA:  BNC   02E6
002CC:  BNZ   02D8
002CE:  MOVLB  1
002D0:  MOVF   x4D,W
002D2:  MOVLB  4
002D4:  SUBWF  xD0,W
002D6:  BNC   02E6
....................       {
....................          sensor_monitor_interrupt_task();
002D8:  MOVLB  0
002DA:  BRA    01E0
....................          timeCounter = 0;
002DC:  MOVLB  4
002DE:  CLRF   xD3
002E0:  CLRF   xD2
002E2:  CLRF   xD1
002E4:  CLRF   xD0
002E6:  MOVLB  1
....................       }
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <commandHandler.c>
.................... #ifndef cmdHandlerC
.................... #define cmdHandlerC
.................... #include <commandHandler.h>
.................... #ifndef cmdHandler
.................... #define cmdHandler
.................... #include <parameters.h>
.................... #ifndef parameters
.................... #define parameters
.................... 
.................... //#define use_ext_eeprom
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS                                                                */
.................... /* Global parameters used by all routines                                    */
.................... /* These defaults are defined below. On first boot, they will be stored in   */
.................... /* EEProm. On subsequent boots, they will be reloaded from EEProm. Any       */
.................... /* configuation changes will be changed in EEprom, hence will be restored on */
.................... /* subsequent boot. All params start at page boundaries!!                    */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #include <stddef.h>
.................... #include <stdlib.h>
.................... 
.................... typedef enum channelMap {chX, chY}; // Piezo channels
.................... typedef enum channelMode {MANUAL, MAGSNS}; // Voltage or Magnetic Sensor Control
.................... //!typedef enum sensorType {kmxp1000, kmxp2000}; // Magsensors
.................... 
.................... /*****************************************************************************/
.................... /* CAT24C04 EEProm --- page size = 16 bytes, Write when LSB=0 Read when LSB=1*/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... #define EE_Slave_Addr 0xA0
.................... #define writeProtectPin EE_WP
.................... #define pageSize 16
.................... // EEProm is on 12C bus 1
.................... #use i2c(master, fast, sda=PIN_C4, scl=PIN_C3, FORCE_HW, STREAM=EEPROM)
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS PROTOTYPES START HERE                                           */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read);
.................... #endif
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length);
.................... void params_save_to_ee(void);
.................... void params_load_from_ee(void);
.................... void params_init(void);
.................... void params_invalidate(void);
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* PARAMETERS START HERE. All Params should have an EEPROM address that is   */
.................... /* at the start of an EERPOM page.                                           */ 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* PID Parameters                                                            */
.................... /*****************************************************************************/
.................... #define pid_params_ee_addr 0
.................... #define pid_params_length 128  // length in bytes
.................... struct pidParams
.................... {
....................    float kP;     // proportional gain
....................    float kI;     // integral gain
....................    float kD;     // derivative gain
....................    float SP;     // set point-- desired output
....................    float PV;     // process variable-- measured output
....................    float PVold;  // oldPV value  
....................    float CV;     // control variable-- output -- 0 to 100%
....................    float I;      // integral value
.................... }PID[2];
.................... 
.................... /*****************************************************************************/
.................... /* Output Channel Map                                                        */
.................... /*****************************************************************************/
.................... #define channel_map_ee_addr 128
.................... #define channel_map_length 2  // length in bytes
.................... channelMap chMap[2] = {chX, chY};
.................... 
.................... /*****************************************************************************/
.................... /* Input Channel Mode                                                        */
.................... /*****************************************************************************/
.................... #define channel_mode_ee_addr 144
.................... #define channel_mode_length 2  // length in bytes
.................... channelMode chMode[2] = {MANUAL, MANUAL};
.................... 
.................... /*****************************************************************************/
.................... /* ADC Calibration Constants                                                 */
.................... /*****************************************************************************/
.................... #define adc_cal_params_ee_addr 160
.................... #define adc_cal_params_length 32  // length in bytes
.................... struct adcCalParms
.................... {
....................    float sinOS;
....................    float cosOS;
....................    float sinGain;
....................    float cosGain;
.................... } adcCal[2] = {
....................                 {0,0,1,1},
....................                 {0,0,1,1}
....................               };
.................... 
.................... /*****************************************************************************/
.................... /* Sensor Calibration Constants                                              */
.................... /*****************************************************************************/
.................... #define sensor_cal_params_ee_addr 192
.................... #define sensor_cal_params_length 48  // length in bytes
.................... struct sensorCalParams
.................... {
....................    float c0;
....................    float c1;
....................    float c2;
....................    float c3;
....................    float c4;
....................    float c5;
.................... } sensorCal[2] = {
....................                     {0,1,0,0,0,0},
....................                     {0,1,0,0,0,0}
....................                  };
.................... 
.................... // fifth order polynomial constants
.................... 
.................... /*****************************************************************************/
.................... /* Monitor Calibration Constants                                             */
.................... /*****************************************************************************/
.................... #define mon_cal_params_ee_addr 240
.................... #define mon_cal_params_length 56  // length in bytes
.................... struct monCalParams
.................... {
....................    float vN15[2];  // offset and gain
....................    float v200[2];
....................    float v5V6[2];
....................    float v5VA[2];
....................    float v3V6X[2];
....................    float v3V3A[2];
....................    float v3V3D[2];
....................    
.................... }monCal = 
.................... {
....................    {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}, {0,1}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* MANUAL OUTPUT CTRL                                                        */
.................... /*****************************************************************************/
.................... #define man_op_vals_ee_addr 304
.................... #define man_op_vals_length 8
.................... float manualOutputValues[2] = {0,0};
.................... 
.................... /*****************************************************************************/
.................... /* PARAMS Valid                                                              */
.................... /*****************************************************************************/
.................... #define invalidate 0xFF
.................... #define isValid 0xAA
.................... #define params_valid_ee_addr 320
.................... #define params_valid_length 1  // length in bytes
.................... char paramsValid = isValid;
.................... // if data returns isValid from EEPROM then EEPROM has valid data
.................... 
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* VOLATILE PARAMETERS                                                       */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... struct mv
.................... {
....................    float vN15; // internal voltages
....................    float v200;
....................    float v5V6;
....................    float v5VA;
....................    float v3V6X;
....................    float v3V3A;
....................    float v3V3D;
.................... }monitorVals;
.................... 
.................... struct adcV
.................... {
....................    float sinRaw;    // adc raw count data
....................    float cosRaw;    // adc raw count data
....................    float sinCounts; // calibrated counts
....................    float cosCounts; // calibrated counts
....................    float p0;               // position in units of pole-pitch
....................    int8  npoles;           // number of poles passed
....................    float pReal;            // real position
.................... }adcVals[2] = 
.................... {
....................    {0,0,0,0,0},
....................    {0,0,0,0,0}
.................... };
.................... 
.................... // used with timeouts
.................... unsigned int32 timeoutReg0 = 0; //All timers are defined in milliseconds, 
.................... unsigned int32 timeoutReg1 = 0; //with a resolution of 10ms
.................... unsigned int32 timeoutReg2 = 0;
.................... unsigned int16 intTimeoutReg = 0; // interrupting use for more precise timing
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... /* FUNCTIONS START HERE                                                      */
.................... /*****************************************************************************/
.................... /*****************************************************************************/
.................... 
.................... /*****************************************************************************/
.................... /* ee_send_start --- sends the start messsage to the eeprom and set the addr */
.................... /*****************************************************************************/
.................... #ifdef use_ext_eeprom
.................... void ee_send_start(unsigned int16 address, BOOLEAN read = TRUE)
.................... {
....................    unsigned int8 romAddr = (unsigned int8)(address & 0x00FF);
....................    unsigned int8 slaveAddr = EE_Slave_Addr;
....................    #ifdef writeProtectPin
....................    output_low(writeProtectPin); // for write operations, clr WP pin
....................    #endif
....................    if (address > 0xFF) // if address > 8 bits
....................    { //add upper address bits (LSB of slave reserved are R/!W) 
....................       slaveAddr |= (unsigned int8)((address >> 7) & 0x000E) ;   
....................    }
....................    i2c_start(EEPROM);   // send start pulse on bus
....................    delay_ms(1);
....................    i2c_write(EEPROM, slaveAddr); // send slave address with R/!W clr (WRITE)
....................    i2c_write(EEPROM, romAddr); // rom address
....................    if (read) 
....................    {
....................       slaveAddr |= 0x01; // set the read bit
....................       delay_ms(1);
....................       i2c_start(EEPROM);
....................       delay_ms(1);
....................       i2c_write (EEPROM, slaveAddr); // send slave with R!W set (READ)
....................       #ifdef writeProtectPin
....................       output_high(writeProtectPin); // for read operations, set WP pin
....................       #endif
....................    }
.................... }
.................... #endif
.................... /*****************************************************************************/
.................... /* SAVE REGISTER TO EEPROM                                                   */
.................... /* note all registers are saved at a page boundary for simplicity            */
.................... /*****************************************************************************/
.................... void ee_save_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    int pageCnt = length/pageSize;
....................    int lastPageLength = length%pageSize;
....................    
....................    int i = 0; // number of pages to write
....................    int j = 0; // number of characters to write on last page
....................    
....................    for ( i = 0; i < pageCnt ; i++)  // pages to writes
....................    {
....................       ee_send_start(eeLocation, FALSE); // start the right
....................       for (j = 0; j < pageSize ; j++) // write 16 bytes (one page)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................       i2c_stop();
....................       delay_ms(5);
....................       eeLocation += pageSize;
....................    }   
....................    if (lastPageLength > 0)
....................    {
....................       ee_send_start(eeLocation, FALSE);
....................       for (j = 0; j < lastPageLength; j++)
....................       {
....................          i2c_write(EEPROM, *(reg + j + (i * pageSize)));
....................          delay_ms(1);
....................       }
....................    }   
....................    i2c_stop(EEPROM);
....................    delay_ms(3);
....................    #ifdef writeProtectPin
....................    output_high(writeProtectPin); // for read operations, set WP pin
....................    #endif  
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       write_eeprom(eeLocation+i, *(reg + i));
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* READ REGISTER FROM EEPROM                                                 */
.................... /*****************************************************************************/
.................... void ee_load_reg(unsigned int8 *reg, unsigned int16 eeLocation, unsigned int8 length)
.................... #ifdef use_ext_eeprom
.................... {
....................    ee_send_start(eeLocation, TRUE);
....................    for (int i = 0; i < length; i++)
....................    {
....................       unsigned int8 data = i2c_read(EEPROM,1); // acknoledge after each byte
....................       *(reg + i) = data;
....................    }
....................    i2c_read(EEPROM,0); // dummy read without acknowlege
....................    delay_ms(1);
....................    i2c_stop(EEPROM); // end page read, must preceed stop
....................    delay_ms(1);
.................... }
.................... #else
.................... {
....................    int i = 0;
....................    for (i = 0; i < length; i++)
....................    {
....................       *(reg + i) = read_eeprom(eeLocation+i);
....................    }
.................... }
.................... #endif
.................... 
.................... /*****************************************************************************/
.................... /* SAVE TO ALL PARAMS EEPROM                                                 */
.................... /*****************************************************************************/
.................... void params_save_to_ee()
.................... {
....................    ee_save_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    delay_ms(1);
....................    ee_save_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    delay_ms(1);
....................    ee_save_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    delay_ms(1);
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
.................... }
.................... /*****************************************************************************/
.................... /* LOAD ALL PARAMS FROM EEPROM                                               */
.................... /*****************************************************************************/
.................... void params_load_from_ee()
.................... {
....................    ee_load_reg(&PID, pid_params_ee_addr, pid_params_length);
....................    ee_load_reg(&chMap, channel_map_ee_addr, channel_map_length);
....................    ee_load_reg(&chMode, channel_mode_ee_addr, channel_mode_length);
....................    ee_load_reg(&adcCal, adc_cal_params_ee_addr, adc_cal_params_length);
....................    ee_load_reg(&sensorCal, sensor_cal_params_ee_addr, sensor_cal_params_length);
....................    ee_load_reg(&monCal, mon_cal_params_ee_addr, mon_cal_params_length);
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INITIALIZE PARAMS -- Include in main... Run on boot                       */
.................... /*****************************************************************************/
.................... void params_init()
.................... {
....................    ee_load_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
....................    delay_ms(1);
....................    if (paramsValid != isValid)
....................    {
....................       paramsValid = isValid;
....................       params_save_to_ee(); // saves the base parameters on first boot
....................    }
....................    else
....................    {
....................       params_load_from_ee();
....................    }
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* INVALIDATE PARAMS -- Restarting will load defauts                         */
.................... /*****************************************************************************/
.................... void params_invalidate()
.................... {
....................    paramsValid = invalidate;
....................    ee_save_reg(&paramsValid, params_valid_ee_addr, params_valid_length);
.................... }
.................... 
.................... #endif
.................... 
.................... 
002E8:  MOVLB  E
002EA:  BCF    xC9.0
002EC:  MOVLB  0
002EE:  GOTO   006E
.................... #define hwID 'D'   // DiFCS
.................... 
.................... /*****************************************************************************/
.................... /* RESPONSE MESSAGES                                                         */
.................... /*****************************************************************************/
.................... typedef struct response {
....................    int8 id;
....................    char *msg;
.................... } resp;
.................... 
.................... //!#define INVALID_DATA "error - invalid data"
.................... //!#define invalidTime "error - invalid TO value"
.................... //!#define overrun "error - buffer overrun"
.................... //!#define dcVoltage "VDC:%f1"
.................... //!#define USBVoltage "VUSB:%f"
.................... //!#define USBupstream "VUSBup:%f"
.................... //!#define plus5V "5V Rail:%f"
.................... //!#define plus3V3 "3V3 Rai:%f"
.................... //!#define allVoltages "All Voltages = %f, %f, %f, %f, %f"
.................... //!#define USBdownstream "USB downstream status:\r\nPG:%s\r\nch0:%s\r\nch1:%s"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC MESSGAGE DUMP                                                  */
.................... /*****************************************************************************/
.................... //!#define voltageMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f"
.................... //!#define TimerMsg "T0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\Tint:%Lu\r\nTtick:%Lu"
.................... //!#define ioStatusMsg "Inputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... //!#define diagnosticMsg "V0:%f\r\nV1:%f\r\nV2:%f\r\nV3:%f\r\nV4:%f\r\nT0:%Lu\r\nT1:%Lu\r\nT2:%Lu\r\nTint:%Lu\r\nTtick:%Lu\r\nInputs:%u\r\nOutputs:%u\r\nStatus:%u"
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND PROTOTYPES                                             */
.................... /*****************************************************************************/
.................... int8 getRev(unsigned int8);                // gr 
.................... int8 getSN(unsigned int8);                 // gs
.................... 
.................... int8 getOPchMap(unsigned int8);            // gChMap,   {1|2}
.................... int8 setOPchMap(unsigned int8);            // sChMap,   {1|2}, {X|Y}
.................... 
.................... int8 getIPchMode(unsigned int8);           // gChMode,  {1|2}
.................... int8 setIPchMode(unsigned int8);           // sChMode,  {1|2}, {MANUAL|MAGSNS}
....................    
.................... int8 getPIDvals(unsigned int8);            // gPID,     {1|2}, {P|I|D}
.................... int8 setPIDvals(unsigned int8);            // sPID,     {1|2}, {P|I|D}, <float>
.................... 
.................... int8 getSetPoint(unsigned int8);           // gSP,      {1|2}
.................... int8 setSetPoint(unsigned int8);           // sSP,      {1|2}, <float>
.................... 
.................... int8 getAllSensorCalParams(unsigned int8); // gSCals,   {1|2}
.................... int8 getSensorCalParam(unsigned int8);     // gSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}
.................... int8 setSensorCalParam(unsigned int8);     // sSCal,    {1|2}, {c0|c1|c2|c3|c4|c5}, <float>
.................... 
.................... int8 getMonitorCalParam(unsigned int8);    // gMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}
.................... int8 setMonitorCalParam(unsigned int8);    // sMCal,    {N15|200|5V6|5VA|3V6X|3V3A|3V3D}, <float>, <float>
.................... int8 getMonitorValue(unsigned int8);       // gMon,     {N15|200|5V6|5VA|3V6X|3V3A|3V3D|all}
.................... 
.................... int8 getPIDdata(unsigned int8);            // gPIDdata, {1|2}
.................... 
.................... int8 getIPdata(unsigned int8);             // gIPdata,  {1|2}, {raw|calib|pos}
....................    
.................... int8 getManOPvals(unsigned int8);         // gManOP,    {1|2}  
.................... int8 setManOPvals(unsigned int8);         // gManOP,    {1|2}, <float>  
.................... 
.................... int8 invalidCmd(unsigned int8);
.................... 
.................... struct command {
....................    char *cmd_name;
....................    int8 (*cmd_func)(unsigned int8);
.................... };
.................... 
.................... BOOLEAN arg_is_float(char *);
.................... BOOLEAN is_valid_channel(char *);
.................... int8 hex_to_int(char);
.................... void echo_cmd(unsigned int8 rec);
.................... int8 command_parser(unsigned int8 rec);
.................... void command_handler_task();
.................... 
.................... #endif
.................... 
.................... 
.................... /* LIST OF DIAGNOSTIC COMMAND KEYWORDS AND THEIR FUNCTIONS */
.................... struct command cmd_list[] = {
....................    {"gr",       &getRev},
....................    {"gs",       &getSN},
....................    {"gChMap",   &getOPchMap},
....................    {"sChMap",   &setOPchMap},
....................    {"gChMode",  &getIPchMode},
....................    {"sChMode",  &setIPchMode},
....................    {"gPID",     &getPIDvals},
....................    {"sPID",     &setPIDvals},
....................    {"gSP",      &getSetPoint},
....................    {"sSP",      &setSetPoint},
....................    {"gSCals",   &getAllSensorCalParams},
....................    {"gSCal",    &getSensorCalParam},
....................    {"sSCal",    &setSensorCalParam},
....................    {"gMCal",    &getMonitorCalParam},
....................    {"sMCal",    &setMonitorCalParam},
....................    {"gMon",     &getMonitorValue},
....................    {"gPIDdata", &getPIDdata},
....................    {"gIPdata",  &getIPdata},
....................    {"\0", &invalidCmd}
.................... };
.................... 
.................... /* LIST OF RESPONSE MESSAGES */
.................... enum resp_e { 
....................    SUCCESS,
....................    INV_CMD,
....................    INV_PARAM 
.................... };
.................... 
.................... resp resp_list[] = {
....................    {SUCCESS, "SUCCESS"},
....................    {INV_CMD, "INVALID COMMAND"},
....................    {INV_PARAM, "INVALID PARAMETER"}
.................... };
.................... 
.................... /*****************************************************************************/
.................... /* DIAGNOSTIC COMMAND DEFINITIONS                                            */
.................... /*****************************************************************************/
....................                           
.................... int8 getRev(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", version);
*
040AC:  MOVLW  04
040AE:  MOVLB  5
040B0:  MOVWF  xE9
040B2:  MOVLW  29
040B4:  MOVWF  xE8
040B6:  MOVLB  0
040B8:  RCALL  3FBC
040BA:  MOVFF  02,03
040BE:  MOVF   01,W
040C0:  ADDLW  29
040C2:  MOVLB  5
040C4:  MOVWF  xCC
040C6:  MOVLW  04
040C8:  ADDWFC 02,W
040CA:  MOVWF  xCD
040CC:  MOVFF  FE8,4CE
040D0:  MOVFF  5CC,4CD
040D4:  MOVLW  F2
040D6:  MOVWF  FF6
040D8:  MOVLW  02
040DA:  MOVWF  FF7
040DC:  MOVLB  0
040DE:  RCALL  408C
040E0:  MOVLW  2C
040E2:  MOVLB  5
040E4:  MOVWF  xF7
040E6:  MOVLB  0
040E8:  RCALL  406C
....................    return SUCCESS;
040EA:  MOVLW  00
040EC:  MOVWF  01
040EE:  RETURN 0
.................... }
.................... 
.................... int8 getSN(unsigned int8 rec){
....................    sprintf(retData+strlen(retData), "%s,", serialID);
040F0:  MOVLW  04
040F2:  MOVLB  5
040F4:  MOVWF  xE9
040F6:  MOVLW  29
040F8:  MOVWF  xE8
040FA:  MOVLB  0
040FC:  RCALL  3FBC
040FE:  MOVFF  02,03
04102:  MOVF   01,W
04104:  ADDLW  29
04106:  MOVLB  5
04108:  MOVWF  xCC
0410A:  MOVLW  04
0410C:  ADDWFC 02,W
0410E:  MOVWF  xCD
04110:  MOVFF  FE8,4CE
04114:  MOVFF  5CC,4CD
04118:  MOVLW  FC
0411A:  MOVWF  FF6
0411C:  MOVLW  02
0411E:  MOVWF  FF7
04120:  MOVLB  0
04122:  RCALL  408C
04124:  MOVLW  2C
04126:  MOVLB  5
04128:  MOVWF  xF7
0412A:  MOVLB  0
0412C:  RCALL  406C
....................    return SUCCESS;
0412E:  MOVLW  00
04130:  MOVWF  01
04132:  RETURN 0
.................... }
.................... 
.................... int8 getOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04588:  MOVLB  5
0458A:  CLRF   xE5
0458C:  MOVFF  5C0,5E4
04590:  CLRF   xE7
04592:  MOVLW  B5
04594:  MOVWF  xE6
04596:  MOVLB  0
04598:  CALL   081A
0459C:  MOVFF  02,5CE
045A0:  MOVFF  01,5CD
045A4:  MOVLW  06
045A6:  MOVLB  5
045A8:  ADDWF  xCD,F
045AA:  MOVLW  00
045AC:  ADDWFC xCE,F
045AE:  MOVLW  32
045B0:  ADDWF  xCD,W
045B2:  MOVWF  01
045B4:  MOVLW  00
045B6:  ADDWFC xCE,W
045B8:  MOVWF  03
045BA:  MOVF   01,W
045BC:  ADDLW  53
045BE:  MOVWF  01
045C0:  MOVLW  01
045C2:  ADDWFC 03,F
045C4:  MOVFF  01,5CD
045C8:  MOVFF  03,5CE
045CC:  MOVFF  03,5E7
045D0:  MOVFF  01,5E6
045D4:  MOVLB  0
045D6:  RCALL  4134
045D8:  MOVF   01,F
045DA:  BNZ   45E4
045DC:  MOVLW  02
045DE:  MOVWF  01
045E0:  BRA    46F2
045E2:  BRA    4640
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
045E4:  MOVLB  5
045E6:  CLRF   xE5
045E8:  MOVFF  5C0,5E4
045EC:  CLRF   xE7
045EE:  MOVLW  B5
045F0:  MOVWF  xE6
045F2:  MOVLB  0
045F4:  CALL   081A
045F8:  MOVFF  02,5CE
045FC:  MOVFF  01,5CD
04600:  MOVLW  06
04602:  MOVLB  5
04604:  ADDWF  xCD,F
04606:  MOVLW  00
04608:  ADDWFC xCE,F
0460A:  MOVLW  32
0460C:  ADDWF  xCD,W
0460E:  MOVWF  01
04610:  MOVLW  00
04612:  ADDWFC xCE,W
04614:  MOVWF  03
04616:  MOVF   01,W
04618:  ADDLW  53
0461A:  MOVWF  01
0461C:  MOVLW  01
0461E:  ADDWFC 03,F
04620:  MOVFF  01,5CD
04624:  MOVFF  03,5CE
04628:  MOVFF  03,5E7
0462C:  MOVFF  01,5E6
04630:  CLRF   xE9
04632:  CLRF   xE8
04634:  MOVLW  0A
04636:  MOVWF  xEA
04638:  MOVLB  0
0463A:  RCALL  4224
0463C:  MOVFF  01,5CC
....................    
....................    /*** GET CHANNEL MAP ***************/ 
....................    if      (0 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'X');
04640:  MOVLW  01
04642:  MOVLB  5
04644:  SUBWF  xCC,W
04646:  MOVWF  xCE
04648:  CLRF   xD0
0464A:  MOVLW  60
0464C:  MOVWF  xCF
0464E:  MOVLB  0
04650:  CALL   37F6
04654:  BTFSC  01.0
04656:  BRA    4694
04658:  MOVLW  04
0465A:  MOVLB  5
0465C:  MOVWF  xE9
0465E:  MOVLW  29
04660:  MOVWF  xE8
04662:  MOVLB  0
04664:  RCALL  3FBC
04666:  MOVFF  02,03
0466A:  MOVF   01,W
0466C:  ADDLW  29
0466E:  MOVLB  5
04670:  MOVWF  xCD
04672:  MOVLW  04
04674:  ADDWFC 02,W
04676:  MOVWF  xCE
04678:  MOVFF  FE8,4CE
0467C:  MOVFF  5CD,4CD
04680:  MOVLW  58
04682:  MOVWF  xF7
04684:  MOVLB  0
04686:  RCALL  406C
04688:  MOVLW  2C
0468A:  MOVLB  5
0468C:  MOVWF  xF7
0468E:  MOVLB  0
04690:  RCALL  406C
04692:  BRA    46EE
....................    else if (1 == chMap[arg1-1]) sprintf(retData+strlen(retData), "%c,", 'Y');
04694:  MOVLW  01
04696:  MOVLB  5
04698:  SUBWF  xCC,W
0469A:  MOVWF  xCE
0469C:  CLRF   xD0
0469E:  MOVLW  60
046A0:  MOVWF  xCF
046A2:  MOVLB  0
046A4:  CALL   37F6
046A8:  BTFSS  01.0
046AA:  BRA    46E8
046AC:  MOVLW  04
046AE:  MOVLB  5
046B0:  MOVWF  xE9
046B2:  MOVLW  29
046B4:  MOVWF  xE8
046B6:  MOVLB  0
046B8:  RCALL  3FBC
046BA:  MOVFF  02,03
046BE:  MOVF   01,W
046C0:  ADDLW  29
046C2:  MOVLB  5
046C4:  MOVWF  xCD
046C6:  MOVLW  04
046C8:  ADDWFC 02,W
046CA:  MOVWF  xCE
046CC:  MOVFF  FE8,4CE
046D0:  MOVFF  5CD,4CD
046D4:  MOVLW  59
046D6:  MOVWF  xF7
046D8:  MOVLB  0
046DA:  RCALL  406C
046DC:  MOVLW  2C
046DE:  MOVLB  5
046E0:  MOVWF  xF7
046E2:  MOVLB  0
046E4:  RCALL  406C
046E6:  BRA    46EE
....................    else return INV_PARAM;
046E8:  MOVLW  02
046EA:  MOVWF  01
046EC:  BRA    46F2
....................    
....................    return SUCCESS;
046EE:  MOVLW  00
046F0:  MOVWF  01
046F2:  RETURN 0
.................... }
.................... 
.................... int8 setOPchMap(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04736:  MOVLB  5
04738:  CLRF   xE5
0473A:  MOVFF  5C0,5E4
0473E:  CLRF   xE7
04740:  MOVLW  B5
04742:  MOVWF  xE6
04744:  MOVLB  0
04746:  CALL   081A
0474A:  MOVFF  02,5CF
0474E:  MOVFF  01,5CE
04752:  MOVLW  06
04754:  MOVLB  5
04756:  ADDWF  xCE,F
04758:  MOVLW  00
0475A:  ADDWFC xCF,F
0475C:  MOVLW  32
0475E:  ADDWF  xCE,W
04760:  MOVWF  01
04762:  MOVLW  00
04764:  ADDWFC xCF,W
04766:  MOVWF  03
04768:  MOVF   01,W
0476A:  ADDLW  53
0476C:  MOVWF  01
0476E:  MOVLW  01
04770:  ADDWFC 03,F
04772:  MOVFF  01,5CE
04776:  MOVFF  03,5CF
0477A:  MOVFF  03,5E7
0477E:  MOVFF  01,5E6
04782:  MOVLB  0
04784:  RCALL  4134
04786:  MOVF   01,F
04788:  BNZ   4792
0478A:  MOVLW  02
0478C:  MOVWF  01
0478E:  BRA    48E4
04790:  BRA    47EE
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04792:  MOVLB  5
04794:  CLRF   xE5
04796:  MOVFF  5C0,5E4
0479A:  CLRF   xE7
0479C:  MOVLW  B5
0479E:  MOVWF  xE6
047A0:  MOVLB  0
047A2:  CALL   081A
047A6:  MOVFF  02,5CF
047AA:  MOVFF  01,5CE
047AE:  MOVLW  06
047B0:  MOVLB  5
047B2:  ADDWF  xCE,F
047B4:  MOVLW  00
047B6:  ADDWFC xCF,F
047B8:  MOVLW  32
047BA:  ADDWF  xCE,W
047BC:  MOVWF  01
047BE:  MOVLW  00
047C0:  ADDWFC xCF,W
047C2:  MOVWF  03
047C4:  MOVF   01,W
047C6:  ADDLW  53
047C8:  MOVWF  01
047CA:  MOVLW  01
047CC:  ADDWFC 03,F
047CE:  MOVFF  01,5CE
047D2:  MOVFF  03,5CF
047D6:  MOVFF  03,5E7
047DA:  MOVFF  01,5E6
047DE:  CLRF   xE9
047E0:  CLRF   xE8
047E2:  MOVLW  0A
047E4:  MOVWF  xEA
047E6:  MOVLB  0
047E8:  RCALL  4224
047EA:  MOVFF  01,5CC
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
047EE:  MOVLB  5
047F0:  CLRF   xE5
047F2:  MOVFF  5C0,5E4
047F6:  CLRF   xE7
047F8:  MOVLW  B5
047FA:  MOVWF  xE6
047FC:  MOVLB  0
047FE:  CALL   081A
04802:  MOVFF  02,5CF
04806:  MOVFF  01,5CE
0480A:  MOVLW  06
0480C:  MOVLB  5
0480E:  ADDWF  xCE,F
04810:  MOVLW  00
04812:  ADDWFC xCF,F
04814:  MOVLW  4B
04816:  ADDWF  xCE,W
04818:  MOVWF  01
0481A:  MOVLW  00
0481C:  ADDWFC xCF,W
0481E:  MOVWF  03
04820:  MOVF   01,W
04822:  ADDLW  53
04824:  MOVWF  01
04826:  MOVLW  01
04828:  ADDWFC 03,F
0482A:  MOVFF  01,5CE
0482E:  MOVFF  03,5CF
04832:  MOVFF  03,5E9
04836:  MOVFF  01,5E8
0483A:  MOVLB  0
0483C:  CALL   3FBC
04840:  MOVFF  02,03
04844:  MOVF   01,W
04846:  SUBLW  01
04848:  BNZ   484E
0484A:  MOVF   03,F
0484C:  BZ    4856
0484E:  MOVLW  02
04850:  MOVWF  01
04852:  BRA    48E4
04854:  BRA    4898
....................    else arg2 = SERcmd[rec].p[3];
04856:  MOVLB  5
04858:  CLRF   xE5
0485A:  MOVFF  5C0,5E4
0485E:  CLRF   xE7
04860:  MOVLW  B5
04862:  MOVWF  xE6
04864:  MOVLB  0
04866:  CALL   081A
0486A:  MOVFF  02,5CF
0486E:  MOVFF  01,5CE
04872:  MOVLW  06
04874:  MOVLB  5
04876:  ADDWF  xCE,F
04878:  MOVLW  00
0487A:  ADDWFC xCF,F
0487C:  MOVLW  4B
0487E:  ADDWF  xCE,W
04880:  MOVWF  01
04882:  MOVLW  00
04884:  ADDWFC xCF,W
04886:  MOVWF  03
04888:  MOVF   01,W
0488A:  ADDLW  53
0488C:  MOVWF  01
0488E:  MOVLW  01
04890:  ADDWFC 03,F
04892:  MOVFF  01,5CD
04896:  MOVLB  0
....................    
....................    /*** SET CHANNEL MAP ***************/
....................    if      ('X' == arg2) chMap[arg1-1] = chX;
04898:  MOVLB  5
0489A:  MOVF   xCD,W
0489C:  SUBLW  58
0489E:  BNZ   48B8
048A0:  MOVLW  01
048A2:  SUBWF  xCC,W
048A4:  MOVWF  xCE
048A6:  MOVWF  xE3
048A8:  CLRF   xE4
048AA:  CLRF   xE6
048AC:  MOVLW  60
048AE:  MOVWF  xE5
048B0:  MOVLB  0
048B2:  RCALL  46F4
048B4:  BRA    48E0
048B6:  MOVLB  5
....................    else if ('Y' == arg2) chMap[arg1-1] = chY;
048B8:  MOVF   xCD,W
048BA:  SUBLW  59
048BC:  BNZ   48D8
048BE:  MOVLW  01
048C0:  SUBWF  xCC,W
048C2:  MOVWF  xCE
048C4:  MOVWF  xE3
048C6:  MOVLW  01
048C8:  MOVWF  xE4
048CA:  CLRF   xE6
048CC:  MOVLW  60
048CE:  MOVWF  xE5
048D0:  MOVLB  0
048D2:  RCALL  46F4
048D4:  BRA    48E0
048D6:  MOVLB  5
....................    else return INV_PARAM;
048D8:  MOVLW  02
048DA:  MOVWF  01
048DC:  MOVLB  0
048DE:  BRA    48E4
....................    
....................    return SUCCESS;
048E0:  MOVLW  00
048E2:  MOVWF  01
048E4:  RETURN 0
.................... }
.................... 
.................... int8 getIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
048E6:  MOVLB  5
048E8:  CLRF   xE5
048EA:  MOVFF  5C0,5E4
048EE:  CLRF   xE7
048F0:  MOVLW  B5
048F2:  MOVWF  xE6
048F4:  MOVLB  0
048F6:  CALL   081A
048FA:  MOVFF  02,5CE
048FE:  MOVFF  01,5CD
04902:  MOVLW  06
04904:  MOVLB  5
04906:  ADDWF  xCD,F
04908:  MOVLW  00
0490A:  ADDWFC xCE,F
0490C:  MOVLW  32
0490E:  ADDWF  xCD,W
04910:  MOVWF  01
04912:  MOVLW  00
04914:  ADDWFC xCE,W
04916:  MOVWF  03
04918:  MOVF   01,W
0491A:  ADDLW  53
0491C:  MOVWF  01
0491E:  MOVLW  01
04920:  ADDWFC 03,F
04922:  MOVFF  01,5CD
04926:  MOVFF  03,5CE
0492A:  MOVFF  03,5E7
0492E:  MOVFF  01,5E6
04932:  MOVLB  0
04934:  CALL   4134
04938:  MOVF   01,F
0493A:  BNZ   4944
0493C:  MOVLW  02
0493E:  MOVWF  01
04940:  BRA    4A4E
04942:  BRA    49A0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04944:  MOVLB  5
04946:  CLRF   xE5
04948:  MOVFF  5C0,5E4
0494C:  CLRF   xE7
0494E:  MOVLW  B5
04950:  MOVWF  xE6
04952:  MOVLB  0
04954:  CALL   081A
04958:  MOVFF  02,5CE
0495C:  MOVFF  01,5CD
04960:  MOVLW  06
04962:  MOVLB  5
04964:  ADDWF  xCD,F
04966:  MOVLW  00
04968:  ADDWFC xCE,F
0496A:  MOVLW  32
0496C:  ADDWF  xCD,W
0496E:  MOVWF  01
04970:  MOVLW  00
04972:  ADDWFC xCE,W
04974:  MOVWF  03
04976:  MOVF   01,W
04978:  ADDLW  53
0497A:  MOVWF  01
0497C:  MOVLW  01
0497E:  ADDWFC 03,F
04980:  MOVFF  01,5CD
04984:  MOVFF  03,5CE
04988:  MOVFF  03,5E7
0498C:  MOVFF  01,5E6
04990:  CLRF   xE9
04992:  CLRF   xE8
04994:  MOVLW  0A
04996:  MOVWF  xEA
04998:  MOVLB  0
0499A:  RCALL  4224
0499C:  MOVFF  01,5CC
....................    
....................    /*** GET INPUT MAP *****************/
....................    if      (0 == chMode[arg1-1]) sprintf(retData+strlen(retData), "VOLTAGE,");
049A0:  MOVLW  01
049A2:  MOVLB  5
049A4:  SUBWF  xCC,W
049A6:  MOVWF  xCE
049A8:  CLRF   xD0
049AA:  MOVLW  61
049AC:  MOVWF  xCF
049AE:  MOVLB  0
049B0:  CALL   37F6
049B4:  BTFSC  01.0
049B6:  BRA    49F2
049B8:  MOVLW  04
049BA:  MOVLB  5
049BC:  MOVWF  xE9
049BE:  MOVLW  29
049C0:  MOVWF  xE8
049C2:  MOVLB  0
049C4:  CALL   3FBC
049C8:  MOVFF  02,03
049CC:  MOVF   01,W
049CE:  ADDLW  29
049D0:  MOVLB  5
049D2:  MOVWF  xCD
049D4:  MOVLW  04
049D6:  ADDWFC 02,W
049D8:  MOVWF  xCE
049DA:  MOVFF  FE8,4CE
049DE:  MOVFF  5CD,4CD
049E2:  MOVLW  02
049E4:  MOVWF  FF6
049E6:  MOVLW  03
049E8:  MOVWF  FF7
049EA:  MOVLB  0
049EC:  CALL   408C
049F0:  BRA    4A4A
....................    else if (1 == chMode[arg1-1]) sprintf(retData+strlen(retData), "MAGSENS,");
049F2:  MOVLW  01
049F4:  MOVLB  5
049F6:  SUBWF  xCC,W
049F8:  MOVWF  xCE
049FA:  CLRF   xD0
049FC:  MOVLW  61
049FE:  MOVWF  xCF
04A00:  MOVLB  0
04A02:  CALL   37F6
04A06:  BTFSS  01.0
04A08:  BRA    4A44
04A0A:  MOVLW  04
04A0C:  MOVLB  5
04A0E:  MOVWF  xE9
04A10:  MOVLW  29
04A12:  MOVWF  xE8
04A14:  MOVLB  0
04A16:  CALL   3FBC
04A1A:  MOVFF  02,03
04A1E:  MOVF   01,W
04A20:  ADDLW  29
04A22:  MOVLB  5
04A24:  MOVWF  xCD
04A26:  MOVLW  04
04A28:  ADDWFC 02,W
04A2A:  MOVWF  xCE
04A2C:  MOVFF  FE8,4CE
04A30:  MOVFF  5CD,4CD
04A34:  MOVLW  0C
04A36:  MOVWF  FF6
04A38:  MOVLW  03
04A3A:  MOVWF  FF7
04A3C:  MOVLB  0
04A3E:  CALL   408C
04A42:  BRA    4A4A
....................    else return INV_PARAM;
04A44:  MOVLW  02
04A46:  MOVWF  01
04A48:  BRA    4A4E
....................    
....................    return SUCCESS;
04A4A:  MOVLW  00
04A4C:  MOVWF  01
04A4E:  RETURN 0
.................... }
.................... 
.................... int8 setIPchMode(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char *arg2;
....................    char *s_manual = "MANUAL";
04A50:  MOVLW  4D
04A52:  MOVLB  5
04A54:  MOVWF  xD1
04A56:  MOVLW  41
04A58:  MOVWF  xD2
04A5A:  MOVLW  4E
04A5C:  MOVWF  xD3
04A5E:  MOVLW  55
04A60:  MOVWF  xD4
04A62:  MOVLW  41
04A64:  MOVWF  xD5
04A66:  MOVLW  4C
04A68:  MOVWF  xD6
04A6A:  CLRF   xD7
04A6C:  MOVLW  05
04A6E:  MOVWF  xD0
04A70:  MOVLW  D1
04A72:  MOVWF  xCF
....................    char *s_magsns = "MAGSNS";
04A74:  MOVLW  4D
04A76:  MOVWF  xDA
04A78:  MOVLW  41
04A7A:  MOVWF  xDB
04A7C:  MOVLW  47
04A7E:  MOVWF  xDC
04A80:  MOVLW  53
04A82:  MOVWF  xDD
04A84:  MOVLW  4E
04A86:  MOVWF  xDE
04A88:  MOVLW  53
04A8A:  MOVWF  xDF
04A8C:  CLRF   xE0
04A8E:  MOVLW  05
04A90:  MOVWF  xD9
04A92:  MOVLW  DA
04A94:  MOVWF  xD8
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
04A96:  CLRF   xE5
04A98:  MOVFF  5C0,5E4
04A9C:  CLRF   xE7
04A9E:  MOVLW  B5
04AA0:  MOVWF  xE6
04AA2:  MOVLB  0
04AA4:  CALL   081A
04AA8:  MOVFF  02,5E2
04AAC:  MOVFF  01,5E1
04AB0:  MOVLW  06
04AB2:  MOVLB  5
04AB4:  ADDWF  xE1,F
04AB6:  MOVLW  00
04AB8:  ADDWFC xE2,F
04ABA:  MOVLW  32
04ABC:  ADDWF  xE1,W
04ABE:  MOVWF  01
04AC0:  MOVLW  00
04AC2:  ADDWFC xE2,W
04AC4:  MOVWF  03
04AC6:  MOVF   01,W
04AC8:  ADDLW  53
04ACA:  MOVWF  01
04ACC:  MOVLW  01
04ACE:  ADDWFC 03,F
04AD0:  MOVFF  01,5E1
04AD4:  MOVFF  03,5E2
04AD8:  MOVFF  03,5E7
04ADC:  MOVFF  01,5E6
04AE0:  MOVLB  0
04AE2:  CALL   4134
04AE6:  MOVF   01,F
04AE8:  BNZ   4AF2
04AEA:  MOVLW  02
04AEC:  MOVWF  01
04AEE:  BRA    4C68
04AF0:  BRA    4B50
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04AF2:  MOVLB  5
04AF4:  CLRF   xE5
04AF6:  MOVFF  5C0,5E4
04AFA:  CLRF   xE7
04AFC:  MOVLW  B5
04AFE:  MOVWF  xE6
04B00:  MOVLB  0
04B02:  CALL   081A
04B06:  MOVFF  02,5E2
04B0A:  MOVFF  01,5E1
04B0E:  MOVLW  06
04B10:  MOVLB  5
04B12:  ADDWF  xE1,F
04B14:  MOVLW  00
04B16:  ADDWFC xE2,F
04B18:  MOVLW  32
04B1A:  ADDWF  xE1,W
04B1C:  MOVWF  01
04B1E:  MOVLW  00
04B20:  ADDWFC xE2,W
04B22:  MOVWF  03
04B24:  MOVF   01,W
04B26:  ADDLW  53
04B28:  MOVWF  01
04B2A:  MOVLW  01
04B2C:  ADDWFC 03,F
04B2E:  MOVFF  01,5E1
04B32:  MOVFF  03,5E2
04B36:  MOVFF  03,5E7
04B3A:  MOVFF  01,5E6
04B3E:  CLRF   xE9
04B40:  CLRF   xE8
04B42:  MOVLW  0A
04B44:  MOVWF  xEA
04B46:  MOVLB  0
04B48:  CALL   4224
04B4C:  MOVFF  01,5CC
....................    
....................    if (0 == strlen(SERcmd[rec].p[3])) return INV_PARAM;
04B50:  MOVLB  5
04B52:  CLRF   xE5
04B54:  MOVFF  5C0,5E4
04B58:  CLRF   xE7
04B5A:  MOVLW  B5
04B5C:  MOVWF  xE6
04B5E:  MOVLB  0
04B60:  CALL   081A
04B64:  MOVFF  02,5E2
04B68:  MOVFF  01,5E1
04B6C:  MOVLW  06
04B6E:  MOVLB  5
04B70:  ADDWF  xE1,F
04B72:  MOVLW  00
04B74:  ADDWFC xE2,F
04B76:  MOVLW  4B
04B78:  ADDWF  xE1,W
04B7A:  MOVWF  01
04B7C:  MOVLW  00
04B7E:  ADDWFC xE2,W
04B80:  MOVWF  03
04B82:  MOVF   01,W
04B84:  ADDLW  53
04B86:  MOVWF  01
04B88:  MOVLW  01
04B8A:  ADDWFC 03,F
04B8C:  MOVFF  01,5E1
04B90:  MOVFF  03,5E2
04B94:  MOVFF  03,5E9
04B98:  MOVFF  01,5E8
04B9C:  MOVLB  0
04B9E:  CALL   3FBC
04BA2:  MOVFF  02,03
04BA6:  MOVF   01,W
04BA8:  BNZ   4BB6
04BAA:  MOVF   03,F
04BAC:  BNZ   4BB6
04BAE:  MOVLW  02
04BB0:  MOVWF  01
04BB2:  BRA    4C68
04BB4:  BRA    4BFC
....................    else arg2 = SERcmd[rec].p[3];
04BB6:  MOVLB  5
04BB8:  CLRF   xE5
04BBA:  MOVFF  5C0,5E4
04BBE:  CLRF   xE7
04BC0:  MOVLW  B5
04BC2:  MOVWF  xE6
04BC4:  MOVLB  0
04BC6:  CALL   081A
04BCA:  MOVFF  02,5E2
04BCE:  MOVFF  01,5E1
04BD2:  MOVLW  06
04BD4:  MOVLB  5
04BD6:  ADDWF  xE1,F
04BD8:  MOVLW  00
04BDA:  ADDWFC xE2,F
04BDC:  MOVLW  4B
04BDE:  ADDWF  xE1,W
04BE0:  MOVWF  01
04BE2:  MOVLW  00
04BE4:  ADDWFC xE2,W
04BE6:  MOVWF  03
04BE8:  MOVF   01,W
04BEA:  ADDLW  53
04BEC:  MOVWF  01
04BEE:  MOVLW  01
04BF0:  ADDWFC 03,F
04BF2:  MOVFF  01,5CD
04BF6:  MOVFF  03,5CE
04BFA:  MOVLB  0
....................    
....................    /*** SET INPUT MAP *****************/
....................    if      (0 == strcmp(s_manual, arg2)) chMode[arg1-1] = MANUAL;
04BFC:  MOVFF  5D0,5E5
04C00:  MOVFF  5CF,5E4
04C04:  MOVFF  5CE,5E7
04C08:  MOVFF  5CD,5E6
04C0C:  CALL   3FF4
04C10:  MOVF   01,F
04C12:  BNZ   4C2C
04C14:  MOVLW  01
04C16:  MOVLB  5
04C18:  SUBWF  xCC,W
04C1A:  MOVWF  xE1
04C1C:  MOVWF  xE3
04C1E:  CLRF   xE4
04C20:  CLRF   xE6
04C22:  MOVLW  61
04C24:  MOVWF  xE5
04C26:  MOVLB  0
04C28:  RCALL  46F4
04C2A:  BRA    4C64
....................    else if (0 == strcmp(s_magsns, arg2)) chMode[arg1-1] = MAGSNS;
04C2C:  MOVFF  5D9,5E5
04C30:  MOVFF  5D8,5E4
04C34:  MOVFF  5CE,5E7
04C38:  MOVFF  5CD,5E6
04C3C:  CALL   3FF4
04C40:  MOVF   01,F
04C42:  BNZ   4C5E
04C44:  MOVLW  01
04C46:  MOVLB  5
04C48:  SUBWF  xCC,W
04C4A:  MOVWF  xE1
04C4C:  MOVWF  xE3
04C4E:  MOVLW  01
04C50:  MOVWF  xE4
04C52:  CLRF   xE6
04C54:  MOVLW  61
04C56:  MOVWF  xE5
04C58:  MOVLB  0
04C5A:  RCALL  46F4
04C5C:  BRA    4C64
....................    else return INV_PARAM;
04C5E:  MOVLW  02
04C60:  MOVWF  01
04C62:  BRA    4C68
....................    
....................    return SUCCESS;
04C64:  MOVLW  00
04C66:  MOVWF  01
04C68:  RETURN 0
.................... }
.................... 
.................... int8 getPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/ 
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
04F2A:  MOVLB  5
04F2C:  CLRF   xE5
04F2E:  MOVFF  5C0,5E4
04F32:  CLRF   xE7
04F34:  MOVLW  B5
04F36:  MOVWF  xE6
04F38:  MOVLB  0
04F3A:  CALL   081A
04F3E:  MOVFF  02,5CF
04F42:  MOVFF  01,5CE
04F46:  MOVLW  06
04F48:  MOVLB  5
04F4A:  ADDWF  xCE,F
04F4C:  MOVLW  00
04F4E:  ADDWFC xCF,F
04F50:  MOVLW  32
04F52:  ADDWF  xCE,W
04F54:  MOVWF  01
04F56:  MOVLW  00
04F58:  ADDWFC xCF,W
04F5A:  MOVWF  03
04F5C:  MOVF   01,W
04F5E:  ADDLW  53
04F60:  MOVWF  01
04F62:  MOVLW  01
04F64:  ADDWFC 03,F
04F66:  MOVFF  01,5CE
04F6A:  MOVFF  03,5CF
04F6E:  MOVFF  03,5E7
04F72:  MOVFF  01,5E6
04F76:  MOVLB  0
04F78:  CALL   4134
04F7C:  MOVF   01,F
04F7E:  BNZ   4F88
04F80:  MOVLW  02
04F82:  MOVWF  01
04F84:  BRA    5202
04F86:  BRA    4FE6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
04F88:  MOVLB  5
04F8A:  CLRF   xE5
04F8C:  MOVFF  5C0,5E4
04F90:  CLRF   xE7
04F92:  MOVLW  B5
04F94:  MOVWF  xE6
04F96:  MOVLB  0
04F98:  CALL   081A
04F9C:  MOVFF  02,5CF
04FA0:  MOVFF  01,5CE
04FA4:  MOVLW  06
04FA6:  MOVLB  5
04FA8:  ADDWF  xCE,F
04FAA:  MOVLW  00
04FAC:  ADDWFC xCF,F
04FAE:  MOVLW  32
04FB0:  ADDWF  xCE,W
04FB2:  MOVWF  01
04FB4:  MOVLW  00
04FB6:  ADDWFC xCF,W
04FB8:  MOVWF  03
04FBA:  MOVF   01,W
04FBC:  ADDLW  53
04FBE:  MOVWF  01
04FC0:  MOVLW  01
04FC2:  ADDWFC 03,F
04FC4:  MOVFF  01,5CE
04FC8:  MOVFF  03,5CF
04FCC:  MOVFF  03,5E7
04FD0:  MOVFF  01,5E6
04FD4:  CLRF   xE9
04FD6:  CLRF   xE8
04FD8:  MOVLW  0A
04FDA:  MOVWF  xEA
04FDC:  MOVLB  0
04FDE:  CALL   4224
04FE2:  MOVFF  01,5CC
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
04FE6:  MOVLB  5
04FE8:  CLRF   xE5
04FEA:  MOVFF  5C0,5E4
04FEE:  CLRF   xE7
04FF0:  MOVLW  B5
04FF2:  MOVWF  xE6
04FF4:  MOVLB  0
04FF6:  CALL   081A
04FFA:  MOVFF  02,5CF
04FFE:  MOVFF  01,5CE
05002:  MOVLW  06
05004:  MOVLB  5
05006:  ADDWF  xCE,F
05008:  MOVLW  00
0500A:  ADDWFC xCF,F
0500C:  MOVLW  4B
0500E:  ADDWF  xCE,W
05010:  MOVWF  01
05012:  MOVLW  00
05014:  ADDWFC xCF,W
05016:  MOVWF  03
05018:  MOVF   01,W
0501A:  ADDLW  53
0501C:  MOVWF  01
0501E:  MOVLW  01
05020:  ADDWFC 03,F
05022:  MOVFF  01,5CE
05026:  MOVFF  03,5CF
0502A:  MOVFF  03,5E9
0502E:  MOVFF  01,5E8
05032:  MOVLB  0
05034:  CALL   3FBC
05038:  MOVFF  02,03
0503C:  MOVF   01,W
0503E:  SUBLW  01
05040:  BNZ   5046
05042:  MOVF   03,F
05044:  BZ    504E
05046:  MOVLW  02
05048:  MOVWF  01
0504A:  BRA    5202
0504C:  BRA    508E
....................    else arg2 = SERcmd[rec].p[3][0];
0504E:  MOVLB  5
05050:  CLRF   xE5
05052:  MOVFF  5C0,5E4
05056:  CLRF   xE7
05058:  MOVLW  B5
0505A:  MOVWF  xE6
0505C:  MOVLB  0
0505E:  CALL   081A
05062:  MOVFF  02,5CF
05066:  MOVFF  01,5CE
0506A:  MOVLW  06
0506C:  MOVLB  5
0506E:  ADDWF  xCE,F
05070:  MOVLW  00
05072:  ADDWFC xCF,F
05074:  MOVLW  4B
05076:  ADDWF  xCE,F
05078:  MOVLW  00
0507A:  ADDWFC xCF,F
0507C:  MOVLW  53
0507E:  ADDWF  xCE,W
05080:  MOVWF  FE9
05082:  MOVLW  01
05084:  ADDWFC xCF,W
05086:  MOVWF  FEA
05088:  MOVFF  FEF,5CD
0508C:  MOVLB  0
....................    
....................    /*** GET P, I, or D VALUE **********/
....................    if      ('P' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kP);
0508E:  MOVLB  5
05090:  MOVF   xCD,W
05092:  SUBLW  50
05094:  BNZ   5102
05096:  MOVLW  04
05098:  MOVWF  xE9
0509A:  MOVLW  29
0509C:  MOVWF  xE8
0509E:  MOVLB  0
050A0:  CALL   3FBC
050A4:  MOVFF  02,03
050A8:  MOVF   01,W
050AA:  ADDLW  29
050AC:  MOVLB  5
050AE:  MOVWF  xCE
050B0:  MOVLW  04
050B2:  ADDWFC 02,W
050B4:  MOVWF  xCF
050B6:  MOVLW  01
050B8:  SUBWF  xCC,W
050BA:  MULLW  20
050BC:  MOVF   FF3,W
050BE:  CLRF   xD1
050C0:  MOVWF  xD0
050C2:  MOVLW  20
050C4:  ADDWF  xD0,W
050C6:  MOVWF  FE9
050C8:  MOVLW  00
050CA:  ADDWFC xD1,W
050CC:  MOVWF  FEA
050CE:  MOVFF  FEF,5EA
050D2:  MOVFF  FEC,5EB
050D6:  MOVFF  FEC,5EC
050DA:  MOVFF  FEC,5ED
050DE:  MOVFF  5CF,4CE
050E2:  MOVFF  5CE,4CD
050E6:  MOVLW  89
050E8:  MOVWF  FE9
050EA:  MOVLW  02
050EC:  MOVWF  xEE
050EE:  MOVLB  0
050F0:  RCALL  4D78
050F2:  MOVLW  2C
050F4:  MOVLB  5
050F6:  MOVWF  xF7
050F8:  MOVLB  0
050FA:  CALL   406C
050FE:  BRA    51FE
05100:  MOVLB  5
....................    else if ('I' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kI);
05102:  MOVF   xCD,W
05104:  SUBLW  49
05106:  BNZ   517C
05108:  MOVLW  04
0510A:  MOVWF  xE9
0510C:  MOVLW  29
0510E:  MOVWF  xE8
05110:  MOVLB  0
05112:  CALL   3FBC
05116:  MOVF   01,W
05118:  ADDLW  29
0511A:  MOVLB  5
0511C:  MOVWF  xCE
0511E:  MOVLW  04
05120:  ADDWFC 02,W
05122:  MOVWF  xCF
05124:  MOVLW  01
05126:  SUBWF  xCC,W
05128:  MULLW  20
0512A:  MOVF   FF3,W
0512C:  CLRF   xD1
0512E:  MOVWF  xD0
05130:  MOVLW  04
05132:  ADDWF  xD0,W
05134:  MOVWF  01
05136:  MOVLW  00
05138:  ADDWFC xD1,W
0513A:  MOVWF  03
0513C:  MOVF   01,W
0513E:  ADDLW  20
05140:  MOVWF  FE9
05142:  MOVLW  00
05144:  ADDWFC 03,W
05146:  MOVWF  FEA
05148:  MOVFF  FEF,5EA
0514C:  MOVFF  FEC,5EB
05150:  MOVFF  FEC,5EC
05154:  MOVFF  FEC,5ED
05158:  MOVFF  5CF,4CE
0515C:  MOVFF  5CE,4CD
05160:  MOVLW  89
05162:  MOVWF  FE9
05164:  MOVLW  02
05166:  MOVWF  xEE
05168:  MOVLB  0
0516A:  RCALL  4D78
0516C:  MOVLW  2C
0516E:  MOVLB  5
05170:  MOVWF  xF7
05172:  MOVLB  0
05174:  CALL   406C
05178:  BRA    51FE
0517A:  MOVLB  5
....................    else if ('D' == arg2) sprintf(retData+strlen(retData), "%f,", PID[arg1-1].kD);
0517C:  MOVF   xCD,W
0517E:  SUBLW  44
05180:  BNZ   51F6
05182:  MOVLW  04
05184:  MOVWF  xE9
05186:  MOVLW  29
05188:  MOVWF  xE8
0518A:  MOVLB  0
0518C:  CALL   3FBC
05190:  MOVF   01,W
05192:  ADDLW  29
05194:  MOVLB  5
05196:  MOVWF  xCE
05198:  MOVLW  04
0519A:  ADDWFC 02,W
0519C:  MOVWF  xCF
0519E:  MOVLW  01
051A0:  SUBWF  xCC,W
051A2:  MULLW  20
051A4:  MOVF   FF3,W
051A6:  CLRF   xD1
051A8:  MOVWF  xD0
051AA:  MOVLW  08
051AC:  ADDWF  xD0,W
051AE:  MOVWF  01
051B0:  MOVLW  00
051B2:  ADDWFC xD1,W
051B4:  MOVWF  03
051B6:  MOVF   01,W
051B8:  ADDLW  20
051BA:  MOVWF  FE9
051BC:  MOVLW  00
051BE:  ADDWFC 03,W
051C0:  MOVWF  FEA
051C2:  MOVFF  FEF,5EA
051C6:  MOVFF  FEC,5EB
051CA:  MOVFF  FEC,5EC
051CE:  MOVFF  FEC,5ED
051D2:  MOVFF  5CF,4CE
051D6:  MOVFF  5CE,4CD
051DA:  MOVLW  89
051DC:  MOVWF  FE9
051DE:  MOVLW  02
051E0:  MOVWF  xEE
051E2:  MOVLB  0
051E4:  RCALL  4D78
051E6:  MOVLW  2C
051E8:  MOVLB  5
051EA:  MOVWF  xF7
051EC:  MOVLB  0
051EE:  CALL   406C
051F2:  BRA    51FE
051F4:  MOVLB  5
....................    else return INV_PARAM;
051F6:  MOVLW  02
051F8:  MOVWF  01
051FA:  MOVLB  0
051FC:  BRA    5202
....................    
....................    return SUCCESS;
051FE:  MOVLW  00
05200:  MOVWF  01
05202:  RETURN 0
.................... }
.................... 
.................... int8 setPIDvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
*
05526:  MOVLB  5
05528:  CLRF   xE5
0552A:  MOVFF  5C0,5E4
0552E:  CLRF   xE7
05530:  MOVLW  B5
05532:  MOVWF  xE6
05534:  MOVLB  0
05536:  CALL   081A
0553A:  MOVFF  02,5D3
0553E:  MOVFF  01,5D2
05542:  MOVLW  06
05544:  MOVLB  5
05546:  ADDWF  xD2,F
05548:  MOVLW  00
0554A:  ADDWFC xD3,F
0554C:  MOVLW  32
0554E:  ADDWF  xD2,W
05550:  MOVWF  01
05552:  MOVLW  00
05554:  ADDWFC xD3,W
05556:  MOVWF  03
05558:  MOVF   01,W
0555A:  ADDLW  53
0555C:  MOVWF  01
0555E:  MOVLW  01
05560:  ADDWFC 03,F
05562:  MOVFF  01,5D2
05566:  MOVFF  03,5D3
0556A:  MOVFF  03,5E7
0556E:  MOVFF  01,5E6
05572:  MOVLB  0
05574:  CALL   4134
05578:  MOVF   01,F
0557A:  BNZ   5584
0557C:  MOVLW  02
0557E:  MOVWF  01
05580:  BRA    582E
05582:  BRA    55E2
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05584:  MOVLB  5
05586:  CLRF   xE5
05588:  MOVFF  5C0,5E4
0558C:  CLRF   xE7
0558E:  MOVLW  B5
05590:  MOVWF  xE6
05592:  MOVLB  0
05594:  CALL   081A
05598:  MOVFF  02,5D3
0559C:  MOVFF  01,5D2
055A0:  MOVLW  06
055A2:  MOVLB  5
055A4:  ADDWF  xD2,F
055A6:  MOVLW  00
055A8:  ADDWFC xD3,F
055AA:  MOVLW  32
055AC:  ADDWF  xD2,W
055AE:  MOVWF  01
055B0:  MOVLW  00
055B2:  ADDWFC xD3,W
055B4:  MOVWF  03
055B6:  MOVF   01,W
055B8:  ADDLW  53
055BA:  MOVWF  01
055BC:  MOVLW  01
055BE:  ADDWFC 03,F
055C0:  MOVFF  01,5D2
055C4:  MOVFF  03,5D3
055C8:  MOVFF  03,5E7
055CC:  MOVFF  01,5E6
055D0:  CLRF   xE9
055D2:  CLRF   xE8
055D4:  MOVLW  0A
055D6:  MOVWF  xEA
055D8:  MOVLB  0
055DA:  CALL   4224
055DE:  MOVFF  01,5CC
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
055E2:  MOVLB  5
055E4:  CLRF   xE5
055E6:  MOVFF  5C0,5E4
055EA:  CLRF   xE7
055EC:  MOVLW  B5
055EE:  MOVWF  xE6
055F0:  MOVLB  0
055F2:  CALL   081A
055F6:  MOVFF  02,5D3
055FA:  MOVFF  01,5D2
055FE:  MOVLW  06
05600:  MOVLB  5
05602:  ADDWF  xD2,F
05604:  MOVLW  00
05606:  ADDWFC xD3,F
05608:  MOVLW  4B
0560A:  ADDWF  xD2,W
0560C:  MOVWF  01
0560E:  MOVLW  00
05610:  ADDWFC xD3,W
05612:  MOVWF  03
05614:  MOVF   01,W
05616:  ADDLW  53
05618:  MOVWF  01
0561A:  MOVLW  01
0561C:  ADDWFC 03,F
0561E:  MOVFF  01,5D2
05622:  MOVFF  03,5D3
05626:  MOVFF  03,5E9
0562A:  MOVFF  01,5E8
0562E:  MOVLB  0
05630:  CALL   3FBC
05634:  MOVFF  02,03
05638:  MOVF   01,W
0563A:  SUBLW  01
0563C:  BNZ   5642
0563E:  MOVF   03,F
05640:  BZ    564A
05642:  MOVLW  02
05644:  MOVWF  01
05646:  BRA    582E
05648:  BRA    568A
....................    else arg2 = SERcmd[rec].p[3][0];
0564A:  MOVLB  5
0564C:  CLRF   xE5
0564E:  MOVFF  5C0,5E4
05652:  CLRF   xE7
05654:  MOVLW  B5
05656:  MOVWF  xE6
05658:  MOVLB  0
0565A:  CALL   081A
0565E:  MOVFF  02,5D3
05662:  MOVFF  01,5D2
05666:  MOVLW  06
05668:  MOVLB  5
0566A:  ADDWF  xD2,F
0566C:  MOVLW  00
0566E:  ADDWFC xD3,F
05670:  MOVLW  4B
05672:  ADDWF  xD2,F
05674:  MOVLW  00
05676:  ADDWFC xD3,F
05678:  MOVLW  53
0567A:  ADDWF  xD2,W
0567C:  MOVWF  FE9
0567E:  MOVLW  01
05680:  ADDWFC xD3,W
05682:  MOVWF  FEA
05684:  MOVFF  FEF,5CD
05688:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[4], '\0'))) return INV_PARAM;
0568A:  MOVLB  5
0568C:  CLRF   xE5
0568E:  MOVFF  5C0,5E4
05692:  CLRF   xE7
05694:  MOVLW  B5
05696:  MOVWF  xE6
05698:  MOVLB  0
0569A:  CALL   081A
0569E:  MOVFF  02,5D3
056A2:  MOVFF  01,5D2
056A6:  MOVLW  06
056A8:  MOVLB  5
056AA:  ADDWF  xD2,F
056AC:  MOVLW  00
056AE:  ADDWFC xD3,F
056B0:  MOVLW  64
056B2:  ADDWF  xD2,W
056B4:  MOVWF  01
056B6:  MOVLW  00
056B8:  ADDWFC xD3,W
056BA:  MOVWF  03
056BC:  MOVF   01,W
056BE:  ADDLW  53
056C0:  MOVWF  01
056C2:  MOVLW  01
056C4:  ADDWFC 03,F
056C6:  MOVFF  01,5D2
056CA:  MOVFF  03,5D3
056CE:  MOVFF  03,5D6
056D2:  MOVFF  01,5D5
056D6:  CLRF   xD8
056D8:  CLRF   xD7
056DA:  MOVLB  0
056DC:  RCALL  5204
056DE:  MOVFF  03,618
056E2:  MOVFF  02,617
056E6:  MOVFF  01,616
056EA:  MOVFF  00,615
056EE:  CALL   1D24
056F2:  MOVFF  02,5D3
056F6:  MOVFF  01,5D2
056FA:  MOVFF  02,5D6
056FE:  MOVFF  01,5D5
05702:  RCALL  5464
05704:  MOVF   01,F
05706:  BNZ   5710
05708:  MOVLW  02
0570A:  MOVWF  01
0570C:  BRA    582E
0570E:  BRA    5774
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
05710:  MOVLB  5
05712:  CLRF   xE5
05714:  MOVFF  5C0,5E4
05718:  CLRF   xE7
0571A:  MOVLW  B5
0571C:  MOVWF  xE6
0571E:  MOVLB  0
05720:  CALL   081A
05724:  MOVFF  02,5D3
05728:  MOVFF  01,5D2
0572C:  MOVLW  06
0572E:  MOVLB  5
05730:  ADDWF  xD2,F
05732:  MOVLW  00
05734:  ADDWFC xD3,F
05736:  MOVLW  64
05738:  ADDWF  xD2,W
0573A:  MOVWF  01
0573C:  MOVLW  00
0573E:  ADDWFC xD3,W
05740:  MOVWF  03
05742:  MOVF   01,W
05744:  ADDLW  53
05746:  MOVWF  01
05748:  MOVLW  01
0574A:  ADDWFC 03,F
0574C:  MOVFF  01,5D2
05750:  MOVFF  03,5D3
05754:  MOVFF  03,5D6
05758:  MOVFF  01,5D5
0575C:  CLRF   xD8
0575E:  CLRF   xD7
05760:  MOVLB  0
05762:  RCALL  5204
05764:  MOVFF  03,5D1
05768:  MOVFF  02,5D0
0576C:  MOVFF  01,5CF
05770:  MOVFF  00,5CE
....................    
....................    /*** SET P, I, or D VALUE **********/
....................    if      ('P' == arg2) PID[arg1-1].kP = arg3;
05774:  MOVLB  5
05776:  MOVF   xCD,W
05778:  SUBLW  50
0577A:  BNZ   57A6
0577C:  MOVLW  01
0577E:  SUBWF  xCC,W
05780:  MULLW  20
05782:  MOVF   FF3,W
05784:  CLRF   xD3
05786:  MOVWF  xD2
05788:  MOVLW  20
0578A:  ADDWF  xD2,W
0578C:  MOVWF  FE9
0578E:  MOVLW  00
05790:  ADDWFC xD3,W
05792:  MOVWF  FEA
05794:  MOVFF  5CE,FEF
05798:  MOVFF  5CF,FEC
0579C:  MOVFF  5D0,FEC
057A0:  MOVFF  5D1,FEC
057A4:  BRA    5828
....................    else if ('I' == arg2) PID[arg1-1].kI = arg3;
057A6:  MOVF   xCD,W
057A8:  SUBLW  49
057AA:  BNZ   57E2
057AC:  MOVLW  01
057AE:  SUBWF  xCC,W
057B0:  MULLW  20
057B2:  MOVF   FF3,W
057B4:  CLRF   xD3
057B6:  MOVWF  xD2
057B8:  MOVLW  04
057BA:  ADDWF  xD2,W
057BC:  MOVWF  01
057BE:  MOVLW  00
057C0:  ADDWFC xD3,W
057C2:  MOVWF  03
057C4:  MOVF   01,W
057C6:  ADDLW  20
057C8:  MOVWF  FE9
057CA:  MOVLW  00
057CC:  ADDWFC 03,W
057CE:  MOVWF  FEA
057D0:  MOVFF  5CE,FEF
057D4:  MOVFF  5CF,FEC
057D8:  MOVFF  5D0,FEC
057DC:  MOVFF  5D1,FEC
057E0:  BRA    5828
....................    else if ('D' == arg2) PID[arg1-1].kD = arg3;
057E2:  MOVF   xCD,W
057E4:  SUBLW  44
057E6:  BNZ   581E
057E8:  MOVLW  01
057EA:  SUBWF  xCC,W
057EC:  MULLW  20
057EE:  MOVF   FF3,W
057F0:  CLRF   xD3
057F2:  MOVWF  xD2
057F4:  MOVLW  08
057F6:  ADDWF  xD2,W
057F8:  MOVWF  01
057FA:  MOVLW  00
057FC:  ADDWFC xD3,W
057FE:  MOVWF  03
05800:  MOVF   01,W
05802:  ADDLW  20
05804:  MOVWF  FE9
05806:  MOVLW  00
05808:  ADDWFC 03,W
0580A:  MOVWF  FEA
0580C:  MOVFF  5CE,FEF
05810:  MOVFF  5CF,FEC
05814:  MOVFF  5D0,FEC
05818:  MOVFF  5D1,FEC
0581C:  BRA    5828
....................    else return INV_PARAM;
0581E:  MOVLW  02
05820:  MOVWF  01
05822:  MOVLB  0
05824:  BRA    582E
05826:  MOVLB  5
....................    
....................    return SUCCESS;
05828:  MOVLW  00
0582A:  MOVWF  01
0582C:  MOVLB  0
0582E:  RETURN 0
.................... }
.................... 
.................... int8 getSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05830:  MOVLB  5
05832:  CLRF   xE5
05834:  MOVFF  5C0,5E4
05838:  CLRF   xE7
0583A:  MOVLW  B5
0583C:  MOVWF  xE6
0583E:  MOVLB  0
05840:  CALL   081A
05844:  MOVFF  02,5CE
05848:  MOVFF  01,5CD
0584C:  MOVLW  06
0584E:  MOVLB  5
05850:  ADDWF  xCD,F
05852:  MOVLW  00
05854:  ADDWFC xCE,F
05856:  MOVLW  32
05858:  ADDWF  xCD,W
0585A:  MOVWF  01
0585C:  MOVLW  00
0585E:  ADDWFC xCE,W
05860:  MOVWF  03
05862:  MOVF   01,W
05864:  ADDLW  53
05866:  MOVWF  01
05868:  MOVLW  01
0586A:  ADDWFC 03,F
0586C:  MOVFF  01,5CD
05870:  MOVFF  03,5CE
05874:  MOVFF  03,5E7
05878:  MOVFF  01,5E6
0587C:  MOVLB  0
0587E:  CALL   4134
05882:  MOVF   01,F
05884:  BNZ   588E
05886:  MOVLW  02
05888:  MOVWF  01
0588A:  BRA    5964
0588C:  BRA    58EC
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
0588E:  MOVLB  5
05890:  CLRF   xE5
05892:  MOVFF  5C0,5E4
05896:  CLRF   xE7
05898:  MOVLW  B5
0589A:  MOVWF  xE6
0589C:  MOVLB  0
0589E:  CALL   081A
058A2:  MOVFF  02,5CE
058A6:  MOVFF  01,5CD
058AA:  MOVLW  06
058AC:  MOVLB  5
058AE:  ADDWF  xCD,F
058B0:  MOVLW  00
058B2:  ADDWFC xCE,F
058B4:  MOVLW  32
058B6:  ADDWF  xCD,W
058B8:  MOVWF  01
058BA:  MOVLW  00
058BC:  ADDWFC xCE,W
058BE:  MOVWF  03
058C0:  MOVF   01,W
058C2:  ADDLW  53
058C4:  MOVWF  01
058C6:  MOVLW  01
058C8:  ADDWFC 03,F
058CA:  MOVFF  01,5CD
058CE:  MOVFF  03,5CE
058D2:  MOVFF  03,5E7
058D6:  MOVFF  01,5E6
058DA:  CLRF   xE9
058DC:  CLRF   xE8
058DE:  MOVLW  0A
058E0:  MOVWF  xEA
058E2:  MOVLB  0
058E4:  CALL   4224
058E8:  MOVFF  01,5CC
....................    
....................    /*** GET SETPOINT ******************/ 
....................    sprintf(retData+strlen(retData), "%f,", PID[arg1-1].SP);
058EC:  MOVLW  04
058EE:  MOVLB  5
058F0:  MOVWF  xE9
058F2:  MOVLW  29
058F4:  MOVWF  xE8
058F6:  MOVLB  0
058F8:  CALL   3FBC
058FC:  MOVF   01,W
058FE:  ADDLW  29
05900:  MOVLB  5
05902:  MOVWF  xCD
05904:  MOVLW  04
05906:  ADDWFC 02,W
05908:  MOVWF  xCE
0590A:  MOVLW  01
0590C:  SUBWF  xCC,W
0590E:  MULLW  20
05910:  MOVF   FF3,W
05912:  CLRF   xD0
05914:  MOVWF  xCF
05916:  MOVLW  0C
05918:  ADDWF  xCF,W
0591A:  MOVWF  01
0591C:  MOVLW  00
0591E:  ADDWFC xD0,W
05920:  MOVWF  03
05922:  MOVF   01,W
05924:  ADDLW  20
05926:  MOVWF  FE9
05928:  MOVLW  00
0592A:  ADDWFC 03,W
0592C:  MOVWF  FEA
0592E:  MOVFF  FEF,5EA
05932:  MOVFF  FEC,5EB
05936:  MOVFF  FEC,5EC
0593A:  MOVFF  FEC,5ED
0593E:  MOVFF  5CE,4CE
05942:  MOVFF  5CD,4CD
05946:  MOVLW  89
05948:  MOVWF  FE9
0594A:  MOVLW  02
0594C:  MOVWF  xEE
0594E:  MOVLB  0
05950:  CALL   4D78
05954:  MOVLW  2C
05956:  MOVLB  5
05958:  MOVWF  xF7
0595A:  MOVLB  0
0595C:  CALL   406C
....................    return SUCCESS;
05960:  MOVLW  00
05962:  MOVWF  01
05964:  RETURN 0
.................... }
.................... 
.................... int8 setSetPoint(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/   
....................    int8  arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05966:  MOVLB  5
05968:  CLRF   xE5
0596A:  MOVFF  5C0,5E4
0596E:  CLRF   xE7
05970:  MOVLW  B5
05972:  MOVWF  xE6
05974:  MOVLB  0
05976:  CALL   081A
0597A:  MOVFF  02,5D2
0597E:  MOVFF  01,5D1
05982:  MOVLW  06
05984:  MOVLB  5
05986:  ADDWF  xD1,F
05988:  MOVLW  00
0598A:  ADDWFC xD2,F
0598C:  MOVLW  32
0598E:  ADDWF  xD1,W
05990:  MOVWF  01
05992:  MOVLW  00
05994:  ADDWFC xD2,W
05996:  MOVWF  03
05998:  MOVF   01,W
0599A:  ADDLW  53
0599C:  MOVWF  01
0599E:  MOVLW  01
059A0:  ADDWFC 03,F
059A2:  MOVFF  01,5D1
059A6:  MOVFF  03,5D2
059AA:  MOVFF  03,5E7
059AE:  MOVFF  01,5E6
059B2:  MOVLB  0
059B4:  CALL   4134
059B8:  MOVF   01,F
059BA:  BNZ   59C4
059BC:  MOVLW  02
059BE:  MOVWF  01
059C0:  BRA    5B4C
059C2:  BRA    5A22
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
059C4:  MOVLB  5
059C6:  CLRF   xE5
059C8:  MOVFF  5C0,5E4
059CC:  CLRF   xE7
059CE:  MOVLW  B5
059D0:  MOVWF  xE6
059D2:  MOVLB  0
059D4:  CALL   081A
059D8:  MOVFF  02,5D2
059DC:  MOVFF  01,5D1
059E0:  MOVLW  06
059E2:  MOVLB  5
059E4:  ADDWF  xD1,F
059E6:  MOVLW  00
059E8:  ADDWFC xD2,F
059EA:  MOVLW  32
059EC:  ADDWF  xD1,W
059EE:  MOVWF  01
059F0:  MOVLW  00
059F2:  ADDWFC xD2,W
059F4:  MOVWF  03
059F6:  MOVF   01,W
059F8:  ADDLW  53
059FA:  MOVWF  01
059FC:  MOVLW  01
059FE:  ADDWFC 03,F
05A00:  MOVFF  01,5D1
05A04:  MOVFF  03,5D2
05A08:  MOVFF  03,5E7
05A0C:  MOVFF  01,5E6
05A10:  CLRF   xE9
05A12:  CLRF   xE8
05A14:  MOVLW  0A
05A16:  MOVWF  xEA
05A18:  MOVLB  0
05A1A:  CALL   4224
05A1E:  MOVFF  01,5CC
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
05A22:  MOVLB  5
05A24:  CLRF   xE5
05A26:  MOVFF  5C0,5E4
05A2A:  CLRF   xE7
05A2C:  MOVLW  B5
05A2E:  MOVWF  xE6
05A30:  MOVLB  0
05A32:  CALL   081A
05A36:  MOVFF  02,5D2
05A3A:  MOVFF  01,5D1
05A3E:  MOVLW  06
05A40:  MOVLB  5
05A42:  ADDWF  xD1,F
05A44:  MOVLW  00
05A46:  ADDWFC xD2,F
05A48:  MOVLW  4B
05A4A:  ADDWF  xD1,W
05A4C:  MOVWF  01
05A4E:  MOVLW  00
05A50:  ADDWFC xD2,W
05A52:  MOVWF  03
05A54:  MOVF   01,W
05A56:  ADDLW  53
05A58:  MOVWF  01
05A5A:  MOVLW  01
05A5C:  ADDWFC 03,F
05A5E:  MOVFF  01,5D1
05A62:  MOVFF  03,5D2
05A66:  MOVFF  03,5D6
05A6A:  MOVFF  01,5D5
05A6E:  CLRF   xD8
05A70:  CLRF   xD7
05A72:  MOVLB  0
05A74:  CALL   5204
05A78:  MOVFF  03,618
05A7C:  MOVFF  02,617
05A80:  MOVFF  01,616
05A84:  MOVFF  00,615
05A88:  CALL   1D24
05A8C:  MOVFF  02,5D2
05A90:  MOVFF  01,5D1
05A94:  MOVFF  02,5D6
05A98:  MOVFF  01,5D5
05A9C:  RCALL  5464
05A9E:  MOVF   01,F
05AA0:  BNZ   5AAA
05AA2:  MOVLW  02
05AA4:  MOVWF  01
05AA6:  BRA    5B4C
05AA8:  BRA    5B10
....................    else arg2 = strtod(SERcmd[rec].p[3], '\0');
05AAA:  MOVLB  5
05AAC:  CLRF   xE5
05AAE:  MOVFF  5C0,5E4
05AB2:  CLRF   xE7
05AB4:  MOVLW  B5
05AB6:  MOVWF  xE6
05AB8:  MOVLB  0
05ABA:  CALL   081A
05ABE:  MOVFF  02,5D2
05AC2:  MOVFF  01,5D1
05AC6:  MOVLW  06
05AC8:  MOVLB  5
05ACA:  ADDWF  xD1,F
05ACC:  MOVLW  00
05ACE:  ADDWFC xD2,F
05AD0:  MOVLW  4B
05AD2:  ADDWF  xD1,W
05AD4:  MOVWF  01
05AD6:  MOVLW  00
05AD8:  ADDWFC xD2,W
05ADA:  MOVWF  03
05ADC:  MOVF   01,W
05ADE:  ADDLW  53
05AE0:  MOVWF  01
05AE2:  MOVLW  01
05AE4:  ADDWFC 03,F
05AE6:  MOVFF  01,5D1
05AEA:  MOVFF  03,5D2
05AEE:  MOVFF  03,5D6
05AF2:  MOVFF  01,5D5
05AF6:  CLRF   xD8
05AF8:  CLRF   xD7
05AFA:  MOVLB  0
05AFC:  CALL   5204
05B00:  MOVFF  03,5D0
05B04:  MOVFF  02,5CF
05B08:  MOVFF  01,5CE
05B0C:  MOVFF  00,5CD
....................    
....................    /*** SET SETPOINT ******************/ 
....................    PID[arg1-1].SP = arg2;
05B10:  MOVLW  01
05B12:  MOVLB  5
05B14:  SUBWF  xCC,W
05B16:  MULLW  20
05B18:  MOVF   FF3,W
05B1A:  CLRF   xD2
05B1C:  MOVWF  xD1
05B1E:  MOVLW  0C
05B20:  ADDWF  xD1,W
05B22:  MOVWF  01
05B24:  MOVLW  00
05B26:  ADDWFC xD2,W
05B28:  MOVWF  03
05B2A:  MOVF   01,W
05B2C:  ADDLW  20
05B2E:  MOVWF  FE9
05B30:  MOVLW  00
05B32:  ADDWFC 03,W
05B34:  MOVWF  FEA
05B36:  MOVFF  5CD,FEF
05B3A:  MOVFF  5CE,FEC
05B3E:  MOVFF  5CF,FEC
05B42:  MOVFF  5D0,FEC
....................    
....................    return SUCCESS;
05B46:  MOVLW  00
05B48:  MOVWF  01
05B4A:  MOVLB  0
05B4C:  RETURN 0
.................... }
.................... 
.................... int8 getAllSensorCalParams(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05B4E:  MOVLB  5
05B50:  CLRF   xE5
05B52:  MOVFF  5C0,5E4
05B56:  CLRF   xE7
05B58:  MOVLW  B5
05B5A:  MOVWF  xE6
05B5C:  MOVLB  0
05B5E:  CALL   081A
05B62:  MOVFF  02,5CE
05B66:  MOVFF  01,5CD
05B6A:  MOVLW  06
05B6C:  MOVLB  5
05B6E:  ADDWF  xCD,F
05B70:  MOVLW  00
05B72:  ADDWFC xCE,F
05B74:  MOVLW  32
05B76:  ADDWF  xCD,W
05B78:  MOVWF  01
05B7A:  MOVLW  00
05B7C:  ADDWFC xCE,W
05B7E:  MOVWF  03
05B80:  MOVF   01,W
05B82:  ADDLW  53
05B84:  MOVWF  01
05B86:  MOVLW  01
05B88:  ADDWFC 03,F
05B8A:  MOVFF  01,5CD
05B8E:  MOVFF  03,5CE
05B92:  MOVFF  03,5E7
05B96:  MOVFF  01,5E6
05B9A:  MOVLB  0
05B9C:  CALL   4134
05BA0:  MOVF   01,F
05BA2:  BNZ   5BAC
05BA4:  MOVLW  02
05BA6:  MOVWF  01
05BA8:  BRA    5EBE
05BAA:  BRA    5C0A
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05BAC:  MOVLB  5
05BAE:  CLRF   xE5
05BB0:  MOVFF  5C0,5E4
05BB4:  CLRF   xE7
05BB6:  MOVLW  B5
05BB8:  MOVWF  xE6
05BBA:  MOVLB  0
05BBC:  CALL   081A
05BC0:  MOVFF  02,5CE
05BC4:  MOVFF  01,5CD
05BC8:  MOVLW  06
05BCA:  MOVLB  5
05BCC:  ADDWF  xCD,F
05BCE:  MOVLW  00
05BD0:  ADDWFC xCE,F
05BD2:  MOVLW  32
05BD4:  ADDWF  xCD,W
05BD6:  MOVWF  01
05BD8:  MOVLW  00
05BDA:  ADDWFC xCE,W
05BDC:  MOVWF  03
05BDE:  MOVF   01,W
05BE0:  ADDLW  53
05BE2:  MOVWF  01
05BE4:  MOVLW  01
05BE6:  ADDWFC 03,F
05BE8:  MOVFF  01,5CD
05BEC:  MOVFF  03,5CE
05BF0:  MOVFF  03,5E7
05BF4:  MOVFF  01,5E6
05BF8:  CLRF   xE9
05BFA:  CLRF   xE8
05BFC:  MOVLW  0A
05BFE:  MOVWF  xEA
05C00:  MOVLB  0
05C02:  CALL   4224
05C06:  MOVFF  01,5CC
....................    
....................    /*** GET ALL SENSOR CAL PARAMS *****/
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
05C0A:  MOVLW  04
05C0C:  MOVLB  5
05C0E:  MOVWF  xE9
05C10:  MOVLW  29
05C12:  MOVWF  xE8
05C14:  MOVLB  0
05C16:  CALL   3FBC
05C1A:  MOVFF  02,03
05C1E:  MOVF   01,W
05C20:  ADDLW  29
05C22:  MOVLB  5
05C24:  MOVWF  xCD
05C26:  MOVLW  04
05C28:  ADDWFC 02,W
05C2A:  MOVWF  xCE
05C2C:  MOVLW  01
05C2E:  SUBWF  xCC,W
05C30:  MULLW  18
05C32:  MOVF   FF3,W
05C34:  CLRF   xD0
05C36:  MOVWF  xCF
05C38:  MOVLW  82
05C3A:  ADDWF  xCF,W
05C3C:  MOVWF  FE9
05C3E:  MOVLW  00
05C40:  ADDWFC xD0,W
05C42:  MOVWF  FEA
05C44:  MOVFF  FEF,5EA
05C48:  MOVFF  FEC,5EB
05C4C:  MOVFF  FEC,5EC
05C50:  MOVFF  FEC,5ED
05C54:  MOVFF  5CE,4CE
05C58:  MOVFF  5CD,4CD
05C5C:  MOVLW  89
05C5E:  MOVWF  FE9
05C60:  MOVLW  02
05C62:  MOVWF  xEE
05C64:  MOVLB  0
05C66:  CALL   4D78
05C6A:  MOVLW  2C
05C6C:  MOVLB  5
05C6E:  MOVWF  xF7
05C70:  MOVLB  0
05C72:  CALL   406C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
05C76:  MOVLW  04
05C78:  MOVLB  5
05C7A:  MOVWF  xE9
05C7C:  MOVLW  29
05C7E:  MOVWF  xE8
05C80:  MOVLB  0
05C82:  CALL   3FBC
05C86:  MOVF   01,W
05C88:  ADDLW  29
05C8A:  MOVLB  5
05C8C:  MOVWF  xCD
05C8E:  MOVLW  04
05C90:  ADDWFC 02,W
05C92:  MOVWF  xCE
05C94:  MOVLW  01
05C96:  SUBWF  xCC,W
05C98:  MULLW  18
05C9A:  MOVF   FF3,W
05C9C:  CLRF   xD0
05C9E:  MOVWF  xCF
05CA0:  MOVLW  04
05CA2:  ADDWF  xCF,W
05CA4:  MOVWF  01
05CA6:  MOVLW  00
05CA8:  ADDWFC xD0,W
05CAA:  MOVWF  03
05CAC:  MOVF   01,W
05CAE:  ADDLW  82
05CB0:  MOVWF  FE9
05CB2:  MOVLW  00
05CB4:  ADDWFC 03,W
05CB6:  MOVWF  FEA
05CB8:  MOVFF  FEF,5EA
05CBC:  MOVFF  FEC,5EB
05CC0:  MOVFF  FEC,5EC
05CC4:  MOVFF  FEC,5ED
05CC8:  MOVFF  5CE,4CE
05CCC:  MOVFF  5CD,4CD
05CD0:  MOVLW  89
05CD2:  MOVWF  FE9
05CD4:  MOVLW  02
05CD6:  MOVWF  xEE
05CD8:  MOVLB  0
05CDA:  CALL   4D78
05CDE:  MOVLW  2C
05CE0:  MOVLB  5
05CE2:  MOVWF  xF7
05CE4:  MOVLB  0
05CE6:  CALL   406C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
05CEA:  MOVLW  04
05CEC:  MOVLB  5
05CEE:  MOVWF  xE9
05CF0:  MOVLW  29
05CF2:  MOVWF  xE8
05CF4:  MOVLB  0
05CF6:  CALL   3FBC
05CFA:  MOVF   01,W
05CFC:  ADDLW  29
05CFE:  MOVLB  5
05D00:  MOVWF  xCD
05D02:  MOVLW  04
05D04:  ADDWFC 02,W
05D06:  MOVWF  xCE
05D08:  MOVLW  01
05D0A:  SUBWF  xCC,W
05D0C:  MULLW  18
05D0E:  MOVF   FF3,W
05D10:  CLRF   xD0
05D12:  MOVWF  xCF
05D14:  MOVLW  08
05D16:  ADDWF  xCF,W
05D18:  MOVWF  01
05D1A:  MOVLW  00
05D1C:  ADDWFC xD0,W
05D1E:  MOVWF  03
05D20:  MOVF   01,W
05D22:  ADDLW  82
05D24:  MOVWF  FE9
05D26:  MOVLW  00
05D28:  ADDWFC 03,W
05D2A:  MOVWF  FEA
05D2C:  MOVFF  FEF,5EA
05D30:  MOVFF  FEC,5EB
05D34:  MOVFF  FEC,5EC
05D38:  MOVFF  FEC,5ED
05D3C:  MOVFF  5CE,4CE
05D40:  MOVFF  5CD,4CD
05D44:  MOVLW  89
05D46:  MOVWF  FE9
05D48:  MOVLW  02
05D4A:  MOVWF  xEE
05D4C:  MOVLB  0
05D4E:  CALL   4D78
05D52:  MOVLW  2C
05D54:  MOVLB  5
05D56:  MOVWF  xF7
05D58:  MOVLB  0
05D5A:  CALL   406C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
05D5E:  MOVLW  04
05D60:  MOVLB  5
05D62:  MOVWF  xE9
05D64:  MOVLW  29
05D66:  MOVWF  xE8
05D68:  MOVLB  0
05D6A:  CALL   3FBC
05D6E:  MOVF   01,W
05D70:  ADDLW  29
05D72:  MOVLB  5
05D74:  MOVWF  xCD
05D76:  MOVLW  04
05D78:  ADDWFC 02,W
05D7A:  MOVWF  xCE
05D7C:  MOVLW  01
05D7E:  SUBWF  xCC,W
05D80:  MULLW  18
05D82:  MOVF   FF3,W
05D84:  CLRF   xD0
05D86:  MOVWF  xCF
05D88:  MOVLW  0C
05D8A:  ADDWF  xCF,W
05D8C:  MOVWF  01
05D8E:  MOVLW  00
05D90:  ADDWFC xD0,W
05D92:  MOVWF  03
05D94:  MOVF   01,W
05D96:  ADDLW  82
05D98:  MOVWF  FE9
05D9A:  MOVLW  00
05D9C:  ADDWFC 03,W
05D9E:  MOVWF  FEA
05DA0:  MOVFF  FEF,5EA
05DA4:  MOVFF  FEC,5EB
05DA8:  MOVFF  FEC,5EC
05DAC:  MOVFF  FEC,5ED
05DB0:  MOVFF  5CE,4CE
05DB4:  MOVFF  5CD,4CD
05DB8:  MOVLW  89
05DBA:  MOVWF  FE9
05DBC:  MOVLW  02
05DBE:  MOVWF  xEE
05DC0:  MOVLB  0
05DC2:  CALL   4D78
05DC6:  MOVLW  2C
05DC8:  MOVLB  5
05DCA:  MOVWF  xF7
05DCC:  MOVLB  0
05DCE:  CALL   406C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
05DD2:  MOVLW  04
05DD4:  MOVLB  5
05DD6:  MOVWF  xE9
05DD8:  MOVLW  29
05DDA:  MOVWF  xE8
05DDC:  MOVLB  0
05DDE:  CALL   3FBC
05DE2:  MOVF   01,W
05DE4:  ADDLW  29
05DE6:  MOVLB  5
05DE8:  MOVWF  xCD
05DEA:  MOVLW  04
05DEC:  ADDWFC 02,W
05DEE:  MOVWF  xCE
05DF0:  MOVLW  01
05DF2:  SUBWF  xCC,W
05DF4:  MULLW  18
05DF6:  MOVF   FF3,W
05DF8:  CLRF   xD0
05DFA:  MOVWF  xCF
05DFC:  MOVLW  10
05DFE:  ADDWF  xCF,W
05E00:  MOVWF  01
05E02:  MOVLW  00
05E04:  ADDWFC xD0,W
05E06:  MOVWF  03
05E08:  MOVF   01,W
05E0A:  ADDLW  82
05E0C:  MOVWF  FE9
05E0E:  MOVLW  00
05E10:  ADDWFC 03,W
05E12:  MOVWF  FEA
05E14:  MOVFF  FEF,5EA
05E18:  MOVFF  FEC,5EB
05E1C:  MOVFF  FEC,5EC
05E20:  MOVFF  FEC,5ED
05E24:  MOVFF  5CE,4CE
05E28:  MOVFF  5CD,4CD
05E2C:  MOVLW  89
05E2E:  MOVWF  FE9
05E30:  MOVLW  02
05E32:  MOVWF  xEE
05E34:  MOVLB  0
05E36:  CALL   4D78
05E3A:  MOVLW  2C
05E3C:  MOVLB  5
05E3E:  MOVWF  xF7
05E40:  MOVLB  0
05E42:  CALL   406C
....................    sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
05E46:  MOVLW  04
05E48:  MOVLB  5
05E4A:  MOVWF  xE9
05E4C:  MOVLW  29
05E4E:  MOVWF  xE8
05E50:  MOVLB  0
05E52:  CALL   3FBC
05E56:  MOVF   01,W
05E58:  ADDLW  29
05E5A:  MOVLB  5
05E5C:  MOVWF  xCD
05E5E:  MOVLW  04
05E60:  ADDWFC 02,W
05E62:  MOVWF  xCE
05E64:  MOVLW  01
05E66:  SUBWF  xCC,W
05E68:  MULLW  18
05E6A:  MOVF   FF3,W
05E6C:  CLRF   xD0
05E6E:  MOVWF  xCF
05E70:  MOVLW  14
05E72:  ADDWF  xCF,W
05E74:  MOVWF  01
05E76:  MOVLW  00
05E78:  ADDWFC xD0,W
05E7A:  MOVWF  03
05E7C:  MOVF   01,W
05E7E:  ADDLW  82
05E80:  MOVWF  FE9
05E82:  MOVLW  00
05E84:  ADDWFC 03,W
05E86:  MOVWF  FEA
05E88:  MOVFF  FEF,5EA
05E8C:  MOVFF  FEC,5EB
05E90:  MOVFF  FEC,5EC
05E94:  MOVFF  FEC,5ED
05E98:  MOVFF  5CE,4CE
05E9C:  MOVFF  5CD,4CD
05EA0:  MOVLW  89
05EA2:  MOVWF  FE9
05EA4:  MOVLW  02
05EA6:  MOVWF  xEE
05EA8:  MOVLB  0
05EAA:  CALL   4D78
05EAE:  MOVLW  2C
05EB0:  MOVLB  5
05EB2:  MOVWF  xF7
05EB4:  MOVLB  0
05EB6:  CALL   406C
....................    
....................    return SUCCESS;
05EBA:  MOVLW  00
05EBC:  MOVWF  01
05EBE:  RETURN 0
.................... }
.................... 
.................... int8 getSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    char arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
05EC0:  MOVLB  5
05EC2:  CLRF   xE5
05EC4:  MOVFF  5C0,5E4
05EC8:  CLRF   xE7
05ECA:  MOVLW  B5
05ECC:  MOVWF  xE6
05ECE:  MOVLB  0
05ED0:  CALL   081A
05ED4:  MOVFF  02,5CF
05ED8:  MOVFF  01,5CE
05EDC:  MOVLW  06
05EDE:  MOVLB  5
05EE0:  ADDWF  xCE,F
05EE2:  MOVLW  00
05EE4:  ADDWFC xCF,F
05EE6:  MOVLW  32
05EE8:  ADDWF  xCE,W
05EEA:  MOVWF  01
05EEC:  MOVLW  00
05EEE:  ADDWFC xCF,W
05EF0:  MOVWF  03
05EF2:  MOVF   01,W
05EF4:  ADDLW  53
05EF6:  MOVWF  01
05EF8:  MOVLW  01
05EFA:  ADDWFC 03,F
05EFC:  MOVFF  01,5CE
05F00:  MOVFF  03,5CF
05F04:  MOVFF  03,5E7
05F08:  MOVFF  01,5E6
05F0C:  MOVLB  0
05F0E:  CALL   4134
05F12:  MOVF   01,F
05F14:  BNZ   5F1E
05F16:  MOVLW  02
05F18:  MOVWF  01
05F1A:  BRA    6312
05F1C:  BRA    5F7C
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
05F1E:  MOVLB  5
05F20:  CLRF   xE5
05F22:  MOVFF  5C0,5E4
05F26:  CLRF   xE7
05F28:  MOVLW  B5
05F2A:  MOVWF  xE6
05F2C:  MOVLB  0
05F2E:  CALL   081A
05F32:  MOVFF  02,5CF
05F36:  MOVFF  01,5CE
05F3A:  MOVLW  06
05F3C:  MOVLB  5
05F3E:  ADDWF  xCE,F
05F40:  MOVLW  00
05F42:  ADDWFC xCF,F
05F44:  MOVLW  32
05F46:  ADDWF  xCE,W
05F48:  MOVWF  01
05F4A:  MOVLW  00
05F4C:  ADDWFC xCF,W
05F4E:  MOVWF  03
05F50:  MOVF   01,W
05F52:  ADDLW  53
05F54:  MOVWF  01
05F56:  MOVLW  01
05F58:  ADDWFC 03,F
05F5A:  MOVFF  01,5CE
05F5E:  MOVFF  03,5CF
05F62:  MOVFF  03,5E7
05F66:  MOVFF  01,5E6
05F6A:  CLRF   xE9
05F6C:  CLRF   xE8
05F6E:  MOVLW  0A
05F70:  MOVWF  xEA
05F72:  MOVLB  0
05F74:  CALL   4224
05F78:  MOVFF  01,5CC
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
05F7C:  MOVLB  5
05F7E:  CLRF   xE5
05F80:  MOVFF  5C0,5E4
05F84:  CLRF   xE7
05F86:  MOVLW  B5
05F88:  MOVWF  xE6
05F8A:  MOVLB  0
05F8C:  CALL   081A
05F90:  MOVFF  02,5CF
05F94:  MOVFF  01,5CE
05F98:  MOVLW  06
05F9A:  MOVLB  5
05F9C:  ADDWF  xCE,F
05F9E:  MOVLW  00
05FA0:  ADDWFC xCF,F
05FA2:  MOVLW  4B
05FA4:  ADDWF  xCE,W
05FA6:  MOVWF  01
05FA8:  MOVLW  00
05FAA:  ADDWFC xCF,W
05FAC:  MOVWF  03
05FAE:  MOVF   01,W
05FB0:  ADDLW  53
05FB2:  MOVWF  01
05FB4:  MOVLW  01
05FB6:  ADDWFC 03,F
05FB8:  MOVFF  01,5CE
05FBC:  MOVFF  03,5CF
05FC0:  MOVFF  03,5E9
05FC4:  MOVFF  01,5E8
05FC8:  MOVLB  0
05FCA:  CALL   3FBC
05FCE:  MOVFF  02,03
05FD2:  MOVF   01,W
05FD4:  SUBLW  01
05FD6:  BNZ   5FDC
05FD8:  MOVF   03,F
05FDA:  BZ    5FE4
05FDC:  MOVLW  02
05FDE:  MOVWF  01
05FE0:  BRA    6312
05FE2:  BRA    6024
....................    else arg2 = SERcmd[rec].p[3][0];
05FE4:  MOVLB  5
05FE6:  CLRF   xE5
05FE8:  MOVFF  5C0,5E4
05FEC:  CLRF   xE7
05FEE:  MOVLW  B5
05FF0:  MOVWF  xE6
05FF2:  MOVLB  0
05FF4:  CALL   081A
05FF8:  MOVFF  02,5CF
05FFC:  MOVFF  01,5CE
06000:  MOVLW  06
06002:  MOVLB  5
06004:  ADDWF  xCE,F
06006:  MOVLW  00
06008:  ADDWFC xCF,F
0600A:  MOVLW  4B
0600C:  ADDWF  xCE,F
0600E:  MOVLW  00
06010:  ADDWFC xCF,F
06012:  MOVLW  53
06014:  ADDWF  xCE,W
06016:  MOVWF  FE9
06018:  MOVLW  01
0601A:  ADDWFC xCF,W
0601C:  MOVWF  FEA
0601E:  MOVFF  FEF,5CD
06022:  MOVLB  0
....................    
....................    /*** GET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c0);
06024:  MOVLB  5
06026:  MOVF   xCD,W
06028:  SUBLW  30
0602A:  BNZ   609A
0602C:  MOVLW  04
0602E:  MOVWF  xE9
06030:  MOVLW  29
06032:  MOVWF  xE8
06034:  MOVLB  0
06036:  CALL   3FBC
0603A:  MOVFF  02,03
0603E:  MOVF   01,W
06040:  ADDLW  29
06042:  MOVLB  5
06044:  MOVWF  xCE
06046:  MOVLW  04
06048:  ADDWFC 02,W
0604A:  MOVWF  xCF
0604C:  MOVLW  01
0604E:  SUBWF  xCC,W
06050:  MULLW  18
06052:  MOVF   FF3,W
06054:  CLRF   xD1
06056:  MOVWF  xD0
06058:  MOVLW  82
0605A:  ADDWF  xD0,W
0605C:  MOVWF  FE9
0605E:  MOVLW  00
06060:  ADDWFC xD1,W
06062:  MOVWF  FEA
06064:  MOVFF  FEF,5EA
06068:  MOVFF  FEC,5EB
0606C:  MOVFF  FEC,5EC
06070:  MOVFF  FEC,5ED
06074:  MOVFF  5CF,4CE
06078:  MOVFF  5CE,4CD
0607C:  MOVLW  89
0607E:  MOVWF  FE9
06080:  MOVLW  02
06082:  MOVWF  xEE
06084:  MOVLB  0
06086:  CALL   4D78
0608A:  MOVLW  2C
0608C:  MOVLB  5
0608E:  MOVWF  xF7
06090:  MOVLB  0
06092:  CALL   406C
06096:  BRA    630E
06098:  MOVLB  5
....................    else if ('1' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c1);
0609A:  MOVF   xCD,W
0609C:  SUBLW  31
0609E:  BNZ   6116
060A0:  MOVLW  04
060A2:  MOVWF  xE9
060A4:  MOVLW  29
060A6:  MOVWF  xE8
060A8:  MOVLB  0
060AA:  CALL   3FBC
060AE:  MOVF   01,W
060B0:  ADDLW  29
060B2:  MOVLB  5
060B4:  MOVWF  xCE
060B6:  MOVLW  04
060B8:  ADDWFC 02,W
060BA:  MOVWF  xCF
060BC:  MOVLW  01
060BE:  SUBWF  xCC,W
060C0:  MULLW  18
060C2:  MOVF   FF3,W
060C4:  CLRF   xD1
060C6:  MOVWF  xD0
060C8:  MOVLW  04
060CA:  ADDWF  xD0,W
060CC:  MOVWF  01
060CE:  MOVLW  00
060D0:  ADDWFC xD1,W
060D2:  MOVWF  03
060D4:  MOVF   01,W
060D6:  ADDLW  82
060D8:  MOVWF  FE9
060DA:  MOVLW  00
060DC:  ADDWFC 03,W
060DE:  MOVWF  FEA
060E0:  MOVFF  FEF,5EA
060E4:  MOVFF  FEC,5EB
060E8:  MOVFF  FEC,5EC
060EC:  MOVFF  FEC,5ED
060F0:  MOVFF  5CF,4CE
060F4:  MOVFF  5CE,4CD
060F8:  MOVLW  89
060FA:  MOVWF  FE9
060FC:  MOVLW  02
060FE:  MOVWF  xEE
06100:  MOVLB  0
06102:  CALL   4D78
06106:  MOVLW  2C
06108:  MOVLB  5
0610A:  MOVWF  xF7
0610C:  MOVLB  0
0610E:  CALL   406C
06112:  BRA    630E
06114:  MOVLB  5
....................    else if ('2' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c2);
06116:  MOVF   xCD,W
06118:  SUBLW  32
0611A:  BNZ   6192
0611C:  MOVLW  04
0611E:  MOVWF  xE9
06120:  MOVLW  29
06122:  MOVWF  xE8
06124:  MOVLB  0
06126:  CALL   3FBC
0612A:  MOVF   01,W
0612C:  ADDLW  29
0612E:  MOVLB  5
06130:  MOVWF  xCE
06132:  MOVLW  04
06134:  ADDWFC 02,W
06136:  MOVWF  xCF
06138:  MOVLW  01
0613A:  SUBWF  xCC,W
0613C:  MULLW  18
0613E:  MOVF   FF3,W
06140:  CLRF   xD1
06142:  MOVWF  xD0
06144:  MOVLW  08
06146:  ADDWF  xD0,W
06148:  MOVWF  01
0614A:  MOVLW  00
0614C:  ADDWFC xD1,W
0614E:  MOVWF  03
06150:  MOVF   01,W
06152:  ADDLW  82
06154:  MOVWF  FE9
06156:  MOVLW  00
06158:  ADDWFC 03,W
0615A:  MOVWF  FEA
0615C:  MOVFF  FEF,5EA
06160:  MOVFF  FEC,5EB
06164:  MOVFF  FEC,5EC
06168:  MOVFF  FEC,5ED
0616C:  MOVFF  5CF,4CE
06170:  MOVFF  5CE,4CD
06174:  MOVLW  89
06176:  MOVWF  FE9
06178:  MOVLW  02
0617A:  MOVWF  xEE
0617C:  MOVLB  0
0617E:  CALL   4D78
06182:  MOVLW  2C
06184:  MOVLB  5
06186:  MOVWF  xF7
06188:  MOVLB  0
0618A:  CALL   406C
0618E:  BRA    630E
06190:  MOVLB  5
....................    else if ('3' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c3);
06192:  MOVF   xCD,W
06194:  SUBLW  33
06196:  BNZ   620E
06198:  MOVLW  04
0619A:  MOVWF  xE9
0619C:  MOVLW  29
0619E:  MOVWF  xE8
061A0:  MOVLB  0
061A2:  CALL   3FBC
061A6:  MOVF   01,W
061A8:  ADDLW  29
061AA:  MOVLB  5
061AC:  MOVWF  xCE
061AE:  MOVLW  04
061B0:  ADDWFC 02,W
061B2:  MOVWF  xCF
061B4:  MOVLW  01
061B6:  SUBWF  xCC,W
061B8:  MULLW  18
061BA:  MOVF   FF3,W
061BC:  CLRF   xD1
061BE:  MOVWF  xD0
061C0:  MOVLW  0C
061C2:  ADDWF  xD0,W
061C4:  MOVWF  01
061C6:  MOVLW  00
061C8:  ADDWFC xD1,W
061CA:  MOVWF  03
061CC:  MOVF   01,W
061CE:  ADDLW  82
061D0:  MOVWF  FE9
061D2:  MOVLW  00
061D4:  ADDWFC 03,W
061D6:  MOVWF  FEA
061D8:  MOVFF  FEF,5EA
061DC:  MOVFF  FEC,5EB
061E0:  MOVFF  FEC,5EC
061E4:  MOVFF  FEC,5ED
061E8:  MOVFF  5CF,4CE
061EC:  MOVFF  5CE,4CD
061F0:  MOVLW  89
061F2:  MOVWF  FE9
061F4:  MOVLW  02
061F6:  MOVWF  xEE
061F8:  MOVLB  0
061FA:  CALL   4D78
061FE:  MOVLW  2C
06200:  MOVLB  5
06202:  MOVWF  xF7
06204:  MOVLB  0
06206:  CALL   406C
0620A:  BRA    630E
0620C:  MOVLB  5
....................    else if ('4' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c4);
0620E:  MOVF   xCD,W
06210:  SUBLW  34
06212:  BNZ   628A
06214:  MOVLW  04
06216:  MOVWF  xE9
06218:  MOVLW  29
0621A:  MOVWF  xE8
0621C:  MOVLB  0
0621E:  CALL   3FBC
06222:  MOVF   01,W
06224:  ADDLW  29
06226:  MOVLB  5
06228:  MOVWF  xCE
0622A:  MOVLW  04
0622C:  ADDWFC 02,W
0622E:  MOVWF  xCF
06230:  MOVLW  01
06232:  SUBWF  xCC,W
06234:  MULLW  18
06236:  MOVF   FF3,W
06238:  CLRF   xD1
0623A:  MOVWF  xD0
0623C:  MOVLW  10
0623E:  ADDWF  xD0,W
06240:  MOVWF  01
06242:  MOVLW  00
06244:  ADDWFC xD1,W
06246:  MOVWF  03
06248:  MOVF   01,W
0624A:  ADDLW  82
0624C:  MOVWF  FE9
0624E:  MOVLW  00
06250:  ADDWFC 03,W
06252:  MOVWF  FEA
06254:  MOVFF  FEF,5EA
06258:  MOVFF  FEC,5EB
0625C:  MOVFF  FEC,5EC
06260:  MOVFF  FEC,5ED
06264:  MOVFF  5CF,4CE
06268:  MOVFF  5CE,4CD
0626C:  MOVLW  89
0626E:  MOVWF  FE9
06270:  MOVLW  02
06272:  MOVWF  xEE
06274:  MOVLB  0
06276:  CALL   4D78
0627A:  MOVLW  2C
0627C:  MOVLB  5
0627E:  MOVWF  xF7
06280:  MOVLB  0
06282:  CALL   406C
06286:  BRA    630E
06288:  MOVLB  5
....................    else if ('5' == arg2) sprintf(retData+strlen(retData), "%f,", sensorCal[arg1-1].c5);
0628A:  MOVF   xCD,W
0628C:  SUBLW  35
0628E:  BNZ   6306
06290:  MOVLW  04
06292:  MOVWF  xE9
06294:  MOVLW  29
06296:  MOVWF  xE8
06298:  MOVLB  0
0629A:  CALL   3FBC
0629E:  MOVF   01,W
062A0:  ADDLW  29
062A2:  MOVLB  5
062A4:  MOVWF  xCE
062A6:  MOVLW  04
062A8:  ADDWFC 02,W
062AA:  MOVWF  xCF
062AC:  MOVLW  01
062AE:  SUBWF  xCC,W
062B0:  MULLW  18
062B2:  MOVF   FF3,W
062B4:  CLRF   xD1
062B6:  MOVWF  xD0
062B8:  MOVLW  14
062BA:  ADDWF  xD0,W
062BC:  MOVWF  01
062BE:  MOVLW  00
062C0:  ADDWFC xD1,W
062C2:  MOVWF  03
062C4:  MOVF   01,W
062C6:  ADDLW  82
062C8:  MOVWF  FE9
062CA:  MOVLW  00
062CC:  ADDWFC 03,W
062CE:  MOVWF  FEA
062D0:  MOVFF  FEF,5EA
062D4:  MOVFF  FEC,5EB
062D8:  MOVFF  FEC,5EC
062DC:  MOVFF  FEC,5ED
062E0:  MOVFF  5CF,4CE
062E4:  MOVFF  5CE,4CD
062E8:  MOVLW  89
062EA:  MOVWF  FE9
062EC:  MOVLW  02
062EE:  MOVWF  xEE
062F0:  MOVLB  0
062F2:  CALL   4D78
062F6:  MOVLW  2C
062F8:  MOVLB  5
062FA:  MOVWF  xF7
062FC:  MOVLB  0
062FE:  CALL   406C
06302:  BRA    630E
06304:  MOVLB  5
....................    else return INV_PARAM;
06306:  MOVLW  02
06308:  MOVWF  01
0630A:  MOVLB  0
0630C:  BRA    6312
....................    
....................    return SUCCESS;
0630E:  MOVLW  00
06310:  MOVWF  01
06312:  RETURN 0
.................... }
.................... 
.................... int8 setSensorCalParam(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char  arg2;
....................    float arg3;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
06314:  MOVLB  5
06316:  CLRF   xE5
06318:  MOVFF  5C0,5E4
0631C:  CLRF   xE7
0631E:  MOVLW  B5
06320:  MOVWF  xE6
06322:  MOVLB  0
06324:  CALL   081A
06328:  MOVFF  02,5D3
0632C:  MOVFF  01,5D2
06330:  MOVLW  06
06332:  MOVLB  5
06334:  ADDWF  xD2,F
06336:  MOVLW  00
06338:  ADDWFC xD3,F
0633A:  MOVLW  32
0633C:  ADDWF  xD2,W
0633E:  MOVWF  01
06340:  MOVLW  00
06342:  ADDWFC xD3,W
06344:  MOVWF  03
06346:  MOVF   01,W
06348:  ADDLW  53
0634A:  MOVWF  01
0634C:  MOVLW  01
0634E:  ADDWFC 03,F
06350:  MOVFF  01,5D2
06354:  MOVFF  03,5D3
06358:  MOVFF  03,5E7
0635C:  MOVFF  01,5E6
06360:  MOVLB  0
06362:  CALL   4134
06366:  MOVF   01,F
06368:  BNZ   6372
0636A:  MOVLW  02
0636C:  MOVWF  01
0636E:  BRA    66D6
06370:  BRA    63D0
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06372:  MOVLB  5
06374:  CLRF   xE5
06376:  MOVFF  5C0,5E4
0637A:  CLRF   xE7
0637C:  MOVLW  B5
0637E:  MOVWF  xE6
06380:  MOVLB  0
06382:  CALL   081A
06386:  MOVFF  02,5D3
0638A:  MOVFF  01,5D2
0638E:  MOVLW  06
06390:  MOVLB  5
06392:  ADDWF  xD2,F
06394:  MOVLW  00
06396:  ADDWFC xD3,F
06398:  MOVLW  32
0639A:  ADDWF  xD2,W
0639C:  MOVWF  01
0639E:  MOVLW  00
063A0:  ADDWFC xD3,W
063A2:  MOVWF  03
063A4:  MOVF   01,W
063A6:  ADDLW  53
063A8:  MOVWF  01
063AA:  MOVLW  01
063AC:  ADDWFC 03,F
063AE:  MOVFF  01,5D2
063B2:  MOVFF  03,5D3
063B6:  MOVFF  03,5E7
063BA:  MOVFF  01,5E6
063BE:  CLRF   xE9
063C0:  CLRF   xE8
063C2:  MOVLW  0A
063C4:  MOVWF  xEA
063C6:  MOVLB  0
063C8:  CALL   4224
063CC:  MOVFF  01,5CC
....................    
....................    if (1 != strlen(SERcmd[rec].p[3])) return INV_PARAM;
063D0:  MOVLB  5
063D2:  CLRF   xE5
063D4:  MOVFF  5C0,5E4
063D8:  CLRF   xE7
063DA:  MOVLW  B5
063DC:  MOVWF  xE6
063DE:  MOVLB  0
063E0:  CALL   081A
063E4:  MOVFF  02,5D3
063E8:  MOVFF  01,5D2
063EC:  MOVLW  06
063EE:  MOVLB  5
063F0:  ADDWF  xD2,F
063F2:  MOVLW  00
063F4:  ADDWFC xD3,F
063F6:  MOVLW  4B
063F8:  ADDWF  xD2,W
063FA:  MOVWF  01
063FC:  MOVLW  00
063FE:  ADDWFC xD3,W
06400:  MOVWF  03
06402:  MOVF   01,W
06404:  ADDLW  53
06406:  MOVWF  01
06408:  MOVLW  01
0640A:  ADDWFC 03,F
0640C:  MOVFF  01,5D2
06410:  MOVFF  03,5D3
06414:  MOVFF  03,5E9
06418:  MOVFF  01,5E8
0641C:  MOVLB  0
0641E:  CALL   3FBC
06422:  MOVFF  02,03
06426:  MOVF   01,W
06428:  SUBLW  01
0642A:  BNZ   6430
0642C:  MOVF   03,F
0642E:  BZ    6438
06430:  MOVLW  02
06432:  MOVWF  01
06434:  BRA    66D6
06436:  BRA    6478
....................    else arg2 = SERcmd[rec].p[3][0];
06438:  MOVLB  5
0643A:  CLRF   xE5
0643C:  MOVFF  5C0,5E4
06440:  CLRF   xE7
06442:  MOVLW  B5
06444:  MOVWF  xE6
06446:  MOVLB  0
06448:  CALL   081A
0644C:  MOVFF  02,5D3
06450:  MOVFF  01,5D2
06454:  MOVLW  06
06456:  MOVLB  5
06458:  ADDWF  xD2,F
0645A:  MOVLW  00
0645C:  ADDWFC xD3,F
0645E:  MOVLW  4B
06460:  ADDWF  xD2,F
06462:  MOVLW  00
06464:  ADDWFC xD3,F
06466:  MOVLW  53
06468:  ADDWF  xD2,W
0646A:  MOVWF  FE9
0646C:  MOVLW  01
0646E:  ADDWFC xD3,W
06470:  MOVWF  FEA
06472:  MOVFF  FEF,5CD
06476:  MOVLB  0
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
06478:  MOVLB  5
0647A:  CLRF   xE5
0647C:  MOVFF  5C0,5E4
06480:  CLRF   xE7
06482:  MOVLW  B5
06484:  MOVWF  xE6
06486:  MOVLB  0
06488:  CALL   081A
0648C:  MOVFF  02,5D3
06490:  MOVFF  01,5D2
06494:  MOVLW  06
06496:  MOVLB  5
06498:  ADDWF  xD2,F
0649A:  MOVLW  00
0649C:  ADDWFC xD3,F
0649E:  MOVLW  4B
064A0:  ADDWF  xD2,W
064A2:  MOVWF  01
064A4:  MOVLW  00
064A6:  ADDWFC xD3,W
064A8:  MOVWF  03
064AA:  MOVF   01,W
064AC:  ADDLW  53
064AE:  MOVWF  01
064B0:  MOVLW  01
064B2:  ADDWFC 03,F
064B4:  MOVFF  01,5D2
064B8:  MOVFF  03,5D3
064BC:  MOVFF  03,5D6
064C0:  MOVFF  01,5D5
064C4:  CLRF   xD8
064C6:  CLRF   xD7
064C8:  MOVLB  0
064CA:  CALL   5204
064CE:  MOVFF  03,618
064D2:  MOVFF  02,617
064D6:  MOVFF  01,616
064DA:  MOVFF  00,615
064DE:  CALL   1D24
064E2:  MOVFF  02,5D3
064E6:  MOVFF  01,5D2
064EA:  MOVFF  02,5D6
064EE:  MOVFF  01,5D5
064F2:  CALL   5464
064F6:  MOVF   01,F
064F8:  BNZ   6502
064FA:  MOVLW  02
064FC:  MOVWF  01
064FE:  BRA    66D6
06500:  BRA    6568
....................    else arg3 = strtod(SERcmd[rec].p[4], '\0');
06502:  MOVLB  5
06504:  CLRF   xE5
06506:  MOVFF  5C0,5E4
0650A:  CLRF   xE7
0650C:  MOVLW  B5
0650E:  MOVWF  xE6
06510:  MOVLB  0
06512:  CALL   081A
06516:  MOVFF  02,5D3
0651A:  MOVFF  01,5D2
0651E:  MOVLW  06
06520:  MOVLB  5
06522:  ADDWF  xD2,F
06524:  MOVLW  00
06526:  ADDWFC xD3,F
06528:  MOVLW  64
0652A:  ADDWF  xD2,W
0652C:  MOVWF  01
0652E:  MOVLW  00
06530:  ADDWFC xD3,W
06532:  MOVWF  03
06534:  MOVF   01,W
06536:  ADDLW  53
06538:  MOVWF  01
0653A:  MOVLW  01
0653C:  ADDWFC 03,F
0653E:  MOVFF  01,5D2
06542:  MOVFF  03,5D3
06546:  MOVFF  03,5D6
0654A:  MOVFF  01,5D5
0654E:  CLRF   xD8
06550:  CLRF   xD7
06552:  MOVLB  0
06554:  CALL   5204
06558:  MOVFF  03,5D1
0655C:  MOVFF  02,5D0
06560:  MOVFF  01,5CF
06564:  MOVFF  00,5CE
....................    
....................    /*** SET SENSOR CAL PARAM **********/
....................    if      ('0' == arg2) sensorCal[arg1-1].c0 = arg3;
06568:  MOVLB  5
0656A:  MOVF   xCD,W
0656C:  SUBLW  30
0656E:  BNZ   659A
06570:  MOVLW  01
06572:  SUBWF  xCC,W
06574:  MULLW  18
06576:  MOVF   FF3,W
06578:  CLRF   xD3
0657A:  MOVWF  xD2
0657C:  MOVLW  82
0657E:  ADDWF  xD2,W
06580:  MOVWF  FE9
06582:  MOVLW  00
06584:  ADDWFC xD3,W
06586:  MOVWF  FEA
06588:  MOVFF  5CE,FEF
0658C:  MOVFF  5CF,FEC
06590:  MOVFF  5D0,FEC
06594:  MOVFF  5D1,FEC
06598:  BRA    66D0
....................    else if ('1' == arg2) sensorCal[arg1-1].c1 = arg3;
0659A:  MOVF   xCD,W
0659C:  SUBLW  31
0659E:  BNZ   65D6
065A0:  MOVLW  01
065A2:  SUBWF  xCC,W
065A4:  MULLW  18
065A6:  MOVF   FF3,W
065A8:  CLRF   xD3
065AA:  MOVWF  xD2
065AC:  MOVLW  04
065AE:  ADDWF  xD2,W
065B0:  MOVWF  01
065B2:  MOVLW  00
065B4:  ADDWFC xD3,W
065B6:  MOVWF  03
065B8:  MOVF   01,W
065BA:  ADDLW  82
065BC:  MOVWF  FE9
065BE:  MOVLW  00
065C0:  ADDWFC 03,W
065C2:  MOVWF  FEA
065C4:  MOVFF  5CE,FEF
065C8:  MOVFF  5CF,FEC
065CC:  MOVFF  5D0,FEC
065D0:  MOVFF  5D1,FEC
065D4:  BRA    66D0
....................    else if ('2' == arg2) sensorCal[arg1-1].c2 = arg3;
065D6:  MOVF   xCD,W
065D8:  SUBLW  32
065DA:  BNZ   6612
065DC:  MOVLW  01
065DE:  SUBWF  xCC,W
065E0:  MULLW  18
065E2:  MOVF   FF3,W
065E4:  CLRF   xD3
065E6:  MOVWF  xD2
065E8:  MOVLW  08
065EA:  ADDWF  xD2,W
065EC:  MOVWF  01
065EE:  MOVLW  00
065F0:  ADDWFC xD3,W
065F2:  MOVWF  03
065F4:  MOVF   01,W
065F6:  ADDLW  82
065F8:  MOVWF  FE9
065FA:  MOVLW  00
065FC:  ADDWFC 03,W
065FE:  MOVWF  FEA
06600:  MOVFF  5CE,FEF
06604:  MOVFF  5CF,FEC
06608:  MOVFF  5D0,FEC
0660C:  MOVFF  5D1,FEC
06610:  BRA    66D0
....................    else if ('3' == arg2) sensorCal[arg1-1].c3 = arg3;
06612:  MOVF   xCD,W
06614:  SUBLW  33
06616:  BNZ   664E
06618:  MOVLW  01
0661A:  SUBWF  xCC,W
0661C:  MULLW  18
0661E:  MOVF   FF3,W
06620:  CLRF   xD3
06622:  MOVWF  xD2
06624:  MOVLW  0C
06626:  ADDWF  xD2,W
06628:  MOVWF  01
0662A:  MOVLW  00
0662C:  ADDWFC xD3,W
0662E:  MOVWF  03
06630:  MOVF   01,W
06632:  ADDLW  82
06634:  MOVWF  FE9
06636:  MOVLW  00
06638:  ADDWFC 03,W
0663A:  MOVWF  FEA
0663C:  MOVFF  5CE,FEF
06640:  MOVFF  5CF,FEC
06644:  MOVFF  5D0,FEC
06648:  MOVFF  5D1,FEC
0664C:  BRA    66D0
....................    else if ('4' == arg2) sensorCal[arg1-1].c4 = arg3;
0664E:  MOVF   xCD,W
06650:  SUBLW  34
06652:  BNZ   668A
06654:  MOVLW  01
06656:  SUBWF  xCC,W
06658:  MULLW  18
0665A:  MOVF   FF3,W
0665C:  CLRF   xD3
0665E:  MOVWF  xD2
06660:  MOVLW  10
06662:  ADDWF  xD2,W
06664:  MOVWF  01
06666:  MOVLW  00
06668:  ADDWFC xD3,W
0666A:  MOVWF  03
0666C:  MOVF   01,W
0666E:  ADDLW  82
06670:  MOVWF  FE9
06672:  MOVLW  00
06674:  ADDWFC 03,W
06676:  MOVWF  FEA
06678:  MOVFF  5CE,FEF
0667C:  MOVFF  5CF,FEC
06680:  MOVFF  5D0,FEC
06684:  MOVFF  5D1,FEC
06688:  BRA    66D0
....................    else if ('5' == arg2) sensorCal[arg1-1].c5 = arg3;
0668A:  MOVF   xCD,W
0668C:  SUBLW  35
0668E:  BNZ   66C6
06690:  MOVLW  01
06692:  SUBWF  xCC,W
06694:  MULLW  18
06696:  MOVF   FF3,W
06698:  CLRF   xD3
0669A:  MOVWF  xD2
0669C:  MOVLW  14
0669E:  ADDWF  xD2,W
066A0:  MOVWF  01
066A2:  MOVLW  00
066A4:  ADDWFC xD3,W
066A6:  MOVWF  03
066A8:  MOVF   01,W
066AA:  ADDLW  82
066AC:  MOVWF  FE9
066AE:  MOVLW  00
066B0:  ADDWFC 03,W
066B2:  MOVWF  FEA
066B4:  MOVFF  5CE,FEF
066B8:  MOVFF  5CF,FEC
066BC:  MOVFF  5D0,FEC
066C0:  MOVFF  5D1,FEC
066C4:  BRA    66D0
....................    else return INV_PARAM;
066C6:  MOVLW  02
066C8:  MOVWF  01
066CA:  MOVLB  0
066CC:  BRA    66D6
066CE:  MOVLB  5
....................    
....................    return SUCCESS;
066D0:  MOVLW  00
066D2:  MOVWF  01
066D4:  MOVLB  0
066D6:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorCalParam(unsigned int8 rec){
....................    
....................    return SUCCESS;
066D8:  MOVLW  00
066DA:  MOVWF  01
066DC:  RETURN 0
.................... }
.................... 
.................... int8 setMonitorCalParam(unsigned int8 rec){
.................... 
....................    return SUCCESS;
066DE:  MOVLW  00
066E0:  MOVWF  01
066E2:  RETURN 0
.................... }
.................... 
.................... int8 getMonitorValue(unsigned int8 rec){
....................    
....................    return SUCCESS;
066E4:  MOVLW  00
066E6:  MOVWF  01
066E8:  RETURN 0
.................... }
.................... 
.................... int8 getPIDdata(unsigned int8 rec){
....................    
....................    return SUCCESS;
066EA:  MOVLW  00
066EC:  MOVWF  01
066EE:  RETURN 0
.................... }
.................... 
.................... int8 getIPdata(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8  arg1;
....................    char *arg2;
....................    char *s_raw = "raw";
*
067F0:  MOVLW  72
067F2:  MOVLB  5
067F4:  MOVWF  xD1
067F6:  MOVLW  61
067F8:  MOVWF  xD2
067FA:  MOVLW  77
067FC:  MOVWF  xD3
067FE:  CLRF   xD4
06800:  MOVLW  05
06802:  MOVWF  xD0
06804:  MOVLW  D1
06806:  MOVWF  xCF
....................    char *s_calibrated = "calib";
06808:  MOVLW  63
0680A:  MOVWF  xD7
0680C:  MOVLW  61
0680E:  MOVWF  xD8
06810:  MOVLW  6C
06812:  MOVWF  xD9
06814:  MOVLW  69
06816:  MOVWF  xDA
06818:  MOVLW  62
0681A:  MOVWF  xDB
0681C:  CLRF   xDC
0681E:  MOVLW  05
06820:  MOVWF  xD6
06822:  MOVLW  D7
06824:  MOVWF  xD5
....................    char *s_position = "pos";
06826:  MOVLW  70
06828:  MOVWF  xDF
0682A:  MOVLW  6F
0682C:  MOVWF  xE0
0682E:  MOVLW  73
06830:  MOVWF  xE1
06832:  CLRF   xE2
06834:  MOVLW  05
06836:  MOVWF  xDE
06838:  MOVLW  DF
0683A:  MOVWF  xDD
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
0683C:  CLRF   xE5
0683E:  MOVFF  5C0,5E4
06842:  CLRF   xE7
06844:  MOVLW  B5
06846:  MOVWF  xE6
06848:  MOVLB  0
0684A:  CALL   081A
0684E:  MOVFF  02,5E4
06852:  MOVFF  01,5E3
06856:  MOVLW  06
06858:  MOVLB  5
0685A:  ADDWF  xE3,F
0685C:  MOVLW  00
0685E:  ADDWFC xE4,F
06860:  MOVLW  32
06862:  ADDWF  xE3,W
06864:  MOVWF  01
06866:  MOVLW  00
06868:  ADDWFC xE4,W
0686A:  MOVWF  03
0686C:  MOVF   01,W
0686E:  ADDLW  53
06870:  MOVWF  01
06872:  MOVLW  01
06874:  ADDWFC 03,F
06876:  MOVFF  01,5E3
0687A:  MOVFF  03,5E4
0687E:  MOVFF  03,5E7
06882:  MOVFF  01,5E6
06886:  MOVLB  0
06888:  CALL   4134
0688C:  MOVF   01,F
0688E:  BNZ   6898
06890:  MOVLW  02
06892:  MOVWF  01
06894:  BRA    6B72
06896:  BRA    68F6
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
06898:  MOVLB  5
0689A:  CLRF   xE5
0689C:  MOVFF  5C0,5E4
068A0:  CLRF   xE7
068A2:  MOVLW  B5
068A4:  MOVWF  xE6
068A6:  MOVLB  0
068A8:  CALL   081A
068AC:  MOVFF  02,5E4
068B0:  MOVFF  01,5E3
068B4:  MOVLW  06
068B6:  MOVLB  5
068B8:  ADDWF  xE3,F
068BA:  MOVLW  00
068BC:  ADDWFC xE4,F
068BE:  MOVLW  32
068C0:  ADDWF  xE3,W
068C2:  MOVWF  01
068C4:  MOVLW  00
068C6:  ADDWFC xE4,W
068C8:  MOVWF  03
068CA:  MOVF   01,W
068CC:  ADDLW  53
068CE:  MOVWF  01
068D0:  MOVLW  01
068D2:  ADDWFC 03,F
068D4:  MOVFF  01,5E3
068D8:  MOVFF  03,5E4
068DC:  MOVFF  03,5E7
068E0:  MOVFF  01,5E6
068E4:  CLRF   xE9
068E6:  CLRF   xE8
068E8:  MOVLW  0A
068EA:  MOVWF  xEA
068EC:  MOVLB  0
068EE:  CALL   4224
068F2:  MOVFF  01,5CC
....................    
....................    /*** GET INPUT DATA ****************/
....................    if      (0 == strcmp(s_raw, arg2)) {
068F6:  MOVFF  5D0,5E5
068FA:  MOVFF  5CF,5E4
068FE:  MOVFF  5CE,5E7
06902:  MOVFF  5CD,5E6
06906:  CALL   3FF4
0690A:  MOVF   01,F
0690C:  BNZ   69E4
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].sinRaw);
0690E:  MOVLW  04
06910:  MOVLB  5
06912:  MOVWF  xE9
06914:  MOVLW  29
06916:  MOVWF  xE8
06918:  MOVLB  0
0691A:  CALL   3FBC
0691E:  MOVFF  02,03
06922:  MOVF   01,W
06924:  ADDLW  29
06926:  MOVLB  5
06928:  MOVWF  xE3
0692A:  MOVLW  04
0692C:  ADDWFC 02,W
0692E:  MOVWF  xE4
06930:  MOVLW  01
06932:  SUBWF  xCC,W
06934:  MULLW  19
06936:  MOVF   FF3,W
06938:  CLRF   xE6
0693A:  MOVWF  xE5
0693C:  MOVLW  0F
0693E:  ADDWF  xE5,W
06940:  MOVWF  FE9
06942:  MOVLW  01
06944:  ADDWFC xE6,W
06946:  MOVWF  FEA
06948:  MOVFF  FEF,5EC
0694C:  MOVFF  FEC,5ED
06950:  MOVFF  FEC,5E9
06954:  MOVFF  FEC,5EA
06958:  MOVFF  5E4,4CE
0695C:  MOVFF  5E3,4CD
06960:  MOVLW  10
06962:  MOVWF  FE9
06964:  MOVLB  0
06966:  RCALL  66F0
06968:  MOVLW  2C
0696A:  MOVLB  5
0696C:  MOVWF  xF7
0696E:  MOVLB  0
06970:  CALL   406C
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].cosRaw);
06974:  MOVLW  04
06976:  MOVLB  5
06978:  MOVWF  xE9
0697A:  MOVLW  29
0697C:  MOVWF  xE8
0697E:  MOVLB  0
06980:  CALL   3FBC
06984:  MOVF   01,W
06986:  ADDLW  29
06988:  MOVLB  5
0698A:  MOVWF  xE3
0698C:  MOVLW  04
0698E:  ADDWFC 02,W
06990:  MOVWF  xE4
06992:  MOVLW  01
06994:  SUBWF  xCC,W
06996:  MULLW  19
06998:  MOVF   FF3,W
0699A:  CLRF   xE6
0699C:  MOVWF  xE5
0699E:  MOVLW  04
069A0:  ADDWF  xE5,W
069A2:  MOVWF  01
069A4:  MOVLW  00
069A6:  ADDWFC xE6,W
069A8:  MOVWF  03
069AA:  MOVF   01,W
069AC:  ADDLW  0F
069AE:  MOVWF  FE9
069B0:  MOVLW  01
069B2:  ADDWFC 03,W
069B4:  MOVWF  FEA
069B6:  MOVFF  FEF,5EC
069BA:  MOVFF  FEC,5ED
069BE:  MOVFF  FEC,5E7
069C2:  MOVFF  FEC,5E8
069C6:  MOVFF  5E4,4CE
069CA:  MOVFF  5E3,4CD
069CE:  MOVLW  10
069D0:  MOVWF  FE9
069D2:  MOVLB  0
069D4:  RCALL  66F0
069D6:  MOVLW  2C
069D8:  MOVLB  5
069DA:  MOVWF  xF7
069DC:  MOVLB  0
069DE:  CALL   406C
....................    }
069E2:  BRA    6B6E
....................    else if (0 == strcmp(s_calibrated, arg2)) {
069E4:  MOVFF  5D6,5E5
069E8:  MOVFF  5D5,5E4
069EC:  MOVFF  5CE,5E7
069F0:  MOVFF  5CD,5E6
069F4:  CALL   3FF4
069F8:  MOVF   01,F
069FA:  BNZ   6ADA
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].sinCounts);
069FC:  MOVLW  04
069FE:  MOVLB  5
06A00:  MOVWF  xE9
06A02:  MOVLW  29
06A04:  MOVWF  xE8
06A06:  MOVLB  0
06A08:  CALL   3FBC
06A0C:  MOVF   01,W
06A0E:  ADDLW  29
06A10:  MOVLB  5
06A12:  MOVWF  xE3
06A14:  MOVLW  04
06A16:  ADDWFC 02,W
06A18:  MOVWF  xE4
06A1A:  MOVLW  01
06A1C:  SUBWF  xCC,W
06A1E:  MULLW  19
06A20:  MOVF   FF3,W
06A22:  CLRF   xE6
06A24:  MOVWF  xE5
06A26:  MOVLW  08
06A28:  ADDWF  xE5,W
06A2A:  MOVWF  01
06A2C:  MOVLW  00
06A2E:  ADDWFC xE6,W
06A30:  MOVWF  03
06A32:  MOVF   01,W
06A34:  ADDLW  0F
06A36:  MOVWF  FE9
06A38:  MOVLW  01
06A3A:  ADDWFC 03,W
06A3C:  MOVWF  FEA
06A3E:  MOVFF  FEF,5EC
06A42:  MOVFF  FEC,5ED
06A46:  MOVFF  FEC,5E7
06A4A:  MOVFF  FEC,5E8
06A4E:  MOVFF  5E4,4CE
06A52:  MOVFF  5E3,4CD
06A56:  MOVLW  10
06A58:  MOVWF  FE9
06A5A:  MOVLB  0
06A5C:  RCALL  66F0
06A5E:  MOVLW  2C
06A60:  MOVLB  5
06A62:  MOVWF  xF7
06A64:  MOVLB  0
06A66:  CALL   406C
....................       sprintf(retData+strlen(retData), "%Ld,", adcVals[arg1-1].cosCounts);
06A6A:  MOVLW  04
06A6C:  MOVLB  5
06A6E:  MOVWF  xE9
06A70:  MOVLW  29
06A72:  MOVWF  xE8
06A74:  MOVLB  0
06A76:  CALL   3FBC
06A7A:  MOVF   01,W
06A7C:  ADDLW  29
06A7E:  MOVLB  5
06A80:  MOVWF  xE3
06A82:  MOVLW  04
06A84:  ADDWFC 02,W
06A86:  MOVWF  xE4
06A88:  MOVLW  01
06A8A:  SUBWF  xCC,W
06A8C:  MULLW  19
06A8E:  MOVF   FF3,W
06A90:  CLRF   xE6
06A92:  MOVWF  xE5
06A94:  MOVLW  0C
06A96:  ADDWF  xE5,W
06A98:  MOVWF  01
06A9A:  MOVLW  00
06A9C:  ADDWFC xE6,W
06A9E:  MOVWF  03
06AA0:  MOVF   01,W
06AA2:  ADDLW  0F
06AA4:  MOVWF  FE9
06AA6:  MOVLW  01
06AA8:  ADDWFC 03,W
06AAA:  MOVWF  FEA
06AAC:  MOVFF  FEF,5EC
06AB0:  MOVFF  FEC,5ED
06AB4:  MOVFF  FEC,5E7
06AB8:  MOVFF  FEC,5E8
06ABC:  MOVFF  5E4,4CE
06AC0:  MOVFF  5E3,4CD
06AC4:  MOVLW  10
06AC6:  MOVWF  FE9
06AC8:  MOVLB  0
06ACA:  RCALL  66F0
06ACC:  MOVLW  2C
06ACE:  MOVLB  5
06AD0:  MOVWF  xF7
06AD2:  MOVLB  0
06AD4:  CALL   406C
....................    }
06AD8:  BRA    6B6E
....................    else if (0 == strcmp(s_position, arg2)) {
06ADA:  MOVFF  5DE,5E5
06ADE:  MOVFF  5DD,5E4
06AE2:  MOVFF  5CE,5E7
06AE6:  MOVFF  5CD,5E6
06AEA:  CALL   3FF4
06AEE:  MOVF   01,F
06AF0:  BNZ   6B68
....................       sprintf(retData+strlen(retData), "%f,", adcVals[arg1-1].pReal);
06AF2:  MOVLW  04
06AF4:  MOVLB  5
06AF6:  MOVWF  xE9
06AF8:  MOVLW  29
06AFA:  MOVWF  xE8
06AFC:  MOVLB  0
06AFE:  CALL   3FBC
06B02:  MOVF   01,W
06B04:  ADDLW  29
06B06:  MOVLB  5
06B08:  MOVWF  xE3
06B0A:  MOVLW  04
06B0C:  ADDWFC 02,W
06B0E:  MOVWF  xE4
06B10:  MOVLW  01
06B12:  SUBWF  xCC,W
06B14:  MULLW  19
06B16:  MOVF   FF3,W
06B18:  CLRF   xE6
06B1A:  MOVWF  xE5
06B1C:  MOVLW  15
06B1E:  ADDWF  xE5,W
06B20:  MOVWF  01
06B22:  MOVLW  00
06B24:  ADDWFC xE6,W
06B26:  MOVWF  03
06B28:  MOVF   01,W
06B2A:  ADDLW  0F
06B2C:  MOVWF  FE9
06B2E:  MOVLW  01
06B30:  ADDWFC 03,W
06B32:  MOVWF  FEA
06B34:  MOVFF  FEF,5EA
06B38:  MOVFF  FEC,5EB
06B3C:  MOVFF  FEC,5EC
06B40:  MOVFF  FEC,5ED
06B44:  MOVFF  5E4,4CE
06B48:  MOVFF  5E3,4CD
06B4C:  MOVLW  89
06B4E:  MOVWF  FE9
06B50:  MOVLW  02
06B52:  MOVWF  xEE
06B54:  MOVLB  0
06B56:  CALL   4D78
06B5A:  MOVLW  2C
06B5C:  MOVLB  5
06B5E:  MOVWF  xF7
06B60:  MOVLB  0
06B62:  CALL   406C
....................    }
06B66:  BRA    6B6E
....................    else return INV_PARAM;
06B68:  MOVLW  02
06B6A:  MOVWF  01
06B6C:  BRA    6B72
....................    
....................    return SUCCESS;
06B6E:  MOVLW  00
06B70:  MOVWF  01
06B72:  RETURN 0
.................... }
.................... 
.................... int8 getManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
....................    
....................    /*** GET MANUAL OUTPUT VALUE ***************/ 
....................    sprintf(retData+strlen(retData), "%f,", manualOutputValues[arg1-1]);
....................    
....................    return SUCCESS;
.................... }
.................... 
.................... int8 setManOPvals(unsigned int8 rec){
....................    /*** ARG CHECKS ********************/
....................    int8 arg1;
....................    float arg2;
....................    
....................    if (!is_valid_channel(SERcmd[rec].p[2])) return INV_PARAM;
....................    else arg1 = strtoul(SERcmd[rec].p[2],'\0',10);
....................    
....................    if (!arg_is_float(strtod(SERcmd[rec].p[3], '\0'))) return INV_PARAM;
....................    else arg2 = SERcmd[rec].p[3];
....................    
....................    /*** SET MANUAL OUTPUT VALUE ***************/
....................    manualOutputValues[arg1-1] = arg2;
....................    
....................    return SUCCESS;
.................... }
.................... 
.................... int8 invalidCmd(unsigned int8 rec){
....................    return INV_CMD;
06B74:  MOVLW  01
06B76:  MOVWF  01
06B78:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ARG VALIDATION HELPER FUNCS                                               */
.................... /*****************************************************************************/
.................... BOOLEAN arg_is_float(char *arg){
*
05464:  MOVLB  5
05466:  BCF    xD7.0
....................    BOOLEAN decimal = FALSE;
....................    for (int i=0; i<strlen(arg); i++){
05468:  CLRF   xD8
0546A:  MOVFF  5D6,5E9
0546E:  MOVFF  5D5,5E8
05472:  MOVLB  0
05474:  CALL   3FBC
05478:  MOVFF  02,03
0547C:  MOVF   01,W
0547E:  MOVF   03,F
05480:  BNZ   548C
05482:  MOVF   01,W
05484:  MOVLB  5
05486:  SUBWF  xD8,W
05488:  BC    551E
0548A:  MOVLB  0
....................       if (!isdigit(arg[i])){
0548C:  MOVLB  5
0548E:  MOVF   xD8,W
05490:  ADDWF  xD5,W
05492:  MOVWF  FE9
05494:  MOVLW  00
05496:  ADDWFC xD6,W
05498:  MOVWF  FEA
0549A:  MOVFF  FEF,5D9
0549E:  MOVF   xD9,W
054A0:  SUBLW  2F
054A2:  BC    54AA
054A4:  MOVF   xD9,W
054A6:  SUBLW  39
054A8:  BC    5516
....................          // Check for negative sign
....................          if ('-' != arg[i]){
054AA:  MOVF   xD8,W
054AC:  ADDWF  xD5,W
054AE:  MOVWF  FE9
054B0:  MOVLW  00
054B2:  ADDWFC xD6,W
054B4:  MOVWF  FEA
054B6:  MOVF   FEF,W
054B8:  SUBLW  2D
054BA:  BZ    54E6
....................             // Check for decimal
....................             if ('.' != arg[i]) return FALSE;
054BC:  MOVF   xD8,W
054BE:  ADDWF  xD5,W
054C0:  MOVWF  FE9
054C2:  MOVLW  00
054C4:  ADDWFC xD6,W
054C6:  MOVWF  FEA
054C8:  MOVF   FEF,W
054CA:  SUBLW  2E
054CC:  BZ    54D6
054CE:  MOVLW  00
054D0:  MOVWF  01
054D2:  BRA    5522
054D4:  BRA    54E4
....................             else if  (decimal) return FALSE;
054D6:  BTFSS  xD7.0
054D8:  BRA    54E2
054DA:  MOVLW  00
054DC:  MOVWF  01
054DE:  BRA    5522
054E0:  BRA    54E4
....................             else decimal = TRUE;
054E2:  BSF    xD7.0
....................          }
054E4:  BRA    5516
....................          else if (0 != i) return FALSE;
054E6:  MOVF   xD8,F
054E8:  BZ    54F2
054EA:  MOVLW  00
054EC:  MOVWF  01
054EE:  BRA    5522
054F0:  BRA    5516
....................          else if (1 == strlen(arg)) return FALSE;
054F2:  MOVFF  5D6,5E9
054F6:  MOVFF  5D5,5E8
054FA:  MOVLB  0
054FC:  CALL   3FBC
05500:  MOVFF  02,03
05504:  MOVF   01,W
05506:  SUBLW  01
05508:  BNZ   5518
0550A:  MOVF   03,F
0550C:  BNZ   5518
0550E:  MOVLW  00
05510:  MOVWF  01
05512:  MOVLB  5
05514:  BRA    5522
05516:  MOVLB  0
....................       }
05518:  MOVLB  5
0551A:  INCF   xD8,F
0551C:  BRA    546A
....................    }
....................    return TRUE;
0551E:  MOVLW  01
05520:  MOVWF  01
05522:  MOVLB  0
05524:  RETURN 0
.................... }
.................... 
.................... BOOLEAN is_valid_channel(char *arg){
....................     if (1 != strlen(arg)) return FALSE;
*
04134:  MOVFF  5E7,5E9
04138:  MOVFF  5E6,5E8
0413C:  RCALL  3FBC
0413E:  MOVFF  02,03
04142:  MOVF   01,W
04144:  SUBLW  01
04146:  BNZ   414C
04148:  MOVF   03,F
0414A:  BZ    4154
0414C:  MOVLW  00
0414E:  MOVWF  01
04150:  BRA    4182
04152:  BRA    417A
....................     else if ('1' != arg[0] && '2' != arg[0]) return FALSE;
04154:  MOVLB  5
04156:  MOVFF  5E6,FE9
0415A:  MOVFF  5E7,FEA
0415E:  MOVF   FEF,W
04160:  SUBLW  31
04162:  BZ    417C
04164:  MOVFF  5E6,FE9
04168:  MOVFF  5E7,FEA
0416C:  MOVF   FEF,W
0416E:  SUBLW  32
04170:  BZ    417C
04172:  MOVLW  00
04174:  MOVWF  01
04176:  MOVLB  0
04178:  BRA    4182
0417A:  MOVLB  5
....................     return TRUE;
0417C:  MOVLW  01
0417E:  MOVWF  01
04180:  MOVLB  0
04182:  RETURN 0
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* ASCII HEX CHARACTER TO INT                                                */
.................... /*****************************************************************************/
.................... int8 hex_to_int(char ascii){
....................    if (ascii >= '0' && ascii <= '9') return ascii-'0';
*
03F82:  MOVLB  5
03F84:  MOVF   xCB,W
03F86:  SUBLW  2F
03F88:  BC    3F9A
03F8A:  MOVF   xCB,W
03F8C:  SUBLW  39
03F8E:  BNC   3F9A
03F90:  MOVLW  30
03F92:  SUBWF  xCB,W
03F94:  MOVWF  01
03F96:  BRA    3FB6
03F98:  BRA    3FB6
....................    else if (ascii >= 'A' && ascii <= 'F') return ascii-'A'+10;
03F9A:  MOVF   xCB,W
03F9C:  SUBLW  40
03F9E:  BC    3FB2
03FA0:  MOVF   xCB,W
03FA2:  SUBLW  46
03FA4:  BNC   3FB2
03FA6:  MOVLW  41
03FA8:  SUBWF  xCB,W
03FAA:  ADDLW  0A
03FAC:  MOVWF  01
03FAE:  BRA    3FB6
03FB0:  BRA    3FB6
....................    else return 0xFF;
03FB2:  MOVLW  FF
03FB4:  MOVWF  01
03FB6:  MOVLB  0
03FB8:  GOTO   6C1E (RETURN)
.................... }
.................... 
.................... /*****************************************************************************/
.................... /* COMMAND HANDLER/PARSER FUNCS                                              */
.................... /*****************************************************************************/
.................... void echo_cmd(unsigned int8 rec){
....................    fprintf(SERIAL, "%c", SERcmd[rec].t);
....................    while (SERcmd[rec].recReadIndex <= SERcmd[rec].recWriteIndex)
....................    {
....................       if (SERcmd[rec].recReadIndex != 0) fprintf(SERIAL, "%c", delimiter);
....................       fprintf(SERIAL, "%s", SERcmd[rec].p[SERcmd[rec].recReadIndex]);
....................       SERcmd[rec].recReadIndex++;
....................    }
....................    SERcmd[rec].recReadIndex=0;
.................... }
.................... 
.................... int8 command_parser(unsigned int8 rec){
*
06B7A:  MOVLB  5
06B7C:  CLRF   xE5
06B7E:  MOVFF  5C2,5E4
06B82:  CLRF   xE7
06B84:  MOVLW  B5
06B86:  MOVWF  xE6
06B88:  MOVLB  0
06B8A:  CALL   081A
06B8E:  MOVFF  02,5CB
06B92:  MOVFF  01,5CA
06B96:  MOVLW  06
06B98:  MOVLB  5
06B9A:  ADDWF  xCA,F
06B9C:  MOVLW  00
06B9E:  ADDWFC xCB,F
06BA0:  MOVLW  53
06BA2:  ADDWF  xCA,W
06BA4:  MOVWF  01
06BA6:  MOVLW  01
06BA8:  ADDWFC xCB,W
06BAA:  MOVWF  03
06BAC:  MOVFF  01,5C3
06BB0:  MOVWF  xC4
06BB2:  CLRF   xE5
06BB4:  MOVFF  5C2,5E4
06BB8:  CLRF   xE7
06BBA:  MOVLW  B5
06BBC:  MOVWF  xE6
06BBE:  MOVLB  0
06BC0:  CALL   081A
06BC4:  MOVFF  02,5CD
06BC8:  MOVFF  01,5CC
06BCC:  MOVLW  06
06BCE:  MOVLB  5
06BD0:  ADDWF  xCC,F
06BD2:  MOVLW  00
06BD4:  ADDWFC xCD,F
06BD6:  MOVLW  19
06BD8:  ADDWF  xCC,W
06BDA:  MOVWF  01
06BDC:  MOVLW  00
06BDE:  ADDWFC xCD,W
06BE0:  MOVWF  03
06BE2:  MOVF   01,W
06BE4:  ADDLW  53
06BE6:  MOVWF  01
06BE8:  MOVLW  01
06BEA:  ADDWFC 03,F
06BEC:  MOVFF  01,5C5
06BF0:  MOVFF  03,5C6
06BF4:  CLRF   xC7
06BF6:  CLRF   xC8
....................    char *cmd_adr = SERcmd[rec].p[0];
....................    char *cmd_str = SERcmd[rec].p[1];
.................... //!   int8 devID = input_a();
....................    int8 devID = 0;
....................    int8 i = 0;
....................    
....................    if (hwID == cmd_adr[0]){
06BF8:  MOVFF  5C3,FE9
06BFC:  MOVFF  5C4,FEA
06C00:  MOVF   FEF,W
06C02:  SUBLW  44
06C04:  BTFSS  FD8.2
06C06:  BRA    6CF6
....................       if (hex_to_int(cmd_adr[1]) == (devID & 0x0F)){
06C08:  MOVLW  01
06C0A:  ADDWF  xC3,W
06C0C:  MOVWF  FE9
06C0E:  MOVLW  00
06C10:  ADDWFC xC4,W
06C12:  MOVWF  FEA
06C14:  MOVFF  FEF,5CB
06C18:  MOVLB  0
06C1A:  GOTO   3F82
06C1E:  MOVFF  01,5CA
06C22:  MOVLB  5
06C24:  MOVF   xC7,W
06C26:  ANDLW  0F
06C28:  SUBWF  01,W
06C2A:  BNZ   6CEE
....................          while (0 != strlen(cmd_list[i].cmd_name)){
06C2C:  MOVF   xC8,W
06C2E:  MULLW  04
06C30:  MOVF   FF3,W
06C32:  CLRF   xCB
06C34:  MOVWF  xCA
06C36:  MOVLW  D4
06C38:  ADDWF  xCA,W
06C3A:  MOVWF  FE9
06C3C:  MOVLW  04
06C3E:  ADDWFC xCB,W
06C40:  MOVWF  FEA
06C42:  MOVFF  FEC,5E9
06C46:  MOVF   FED,F
06C48:  MOVFF  FEF,5E8
06C4C:  MOVLB  0
06C4E:  CALL   3FBC
06C52:  MOVFF  02,03
06C56:  MOVF   01,W
06C58:  BNZ   6C5E
06C5A:  MOVF   03,F
06C5C:  BZ    6CE4
....................             if (0 == strcmp(cmd_str, cmd_list[i].cmd_name))
06C5E:  MOVLB  5
06C60:  MOVF   xC8,W
06C62:  MULLW  04
06C64:  MOVF   FF3,W
06C66:  CLRF   xCB
06C68:  MOVWF  xCA
06C6A:  MOVLW  D4
06C6C:  ADDWF  xCA,W
06C6E:  MOVWF  FE9
06C70:  MOVLW  04
06C72:  ADDWFC xCB,W
06C74:  MOVWF  FEA
06C76:  MOVFF  FEC,5E7
06C7A:  MOVF   FED,F
06C7C:  MOVFF  FEF,5E6
06C80:  MOVFF  5C6,5E5
06C84:  MOVFF  5C5,5E4
06C88:  MOVLB  0
06C8A:  CALL   3FF4
06C8E:  MOVF   01,F
06C90:  BNZ   6CDC
....................             {
....................                int8 return_code = cmd_list[i].cmd_func(rec);
06C92:  MOVLB  5
06C94:  MOVF   xC8,W
06C96:  MULLW  04
06C98:  MOVF   FF3,W
06C9A:  CLRF   xCB
06C9C:  MOVWF  xCA
06C9E:  MOVLW  02
06CA0:  ADDWF  xCA,W
06CA2:  MOVWF  01
06CA4:  MOVLW  00
06CA6:  ADDWFC xCB,W
06CA8:  MOVWF  03
06CAA:  MOVF   01,W
06CAC:  ADDLW  D4
06CAE:  MOVWF  01
06CB0:  MOVLW  04
06CB2:  ADDWFC 03,F
06CB4:  MOVFF  01,5CA
06CB8:  MOVFF  03,5CB
06CBC:  MOVFF  03,FEA
06CC0:  MOVFF  01,FE9
06CC4:  MOVFF  5C2,5C0
06CC8:  MOVLB  0
06CCA:  CALL   00BC
06CCE:  MOVFF  01,5C9
....................                return return_code;
06CD2:  MOVLB  5
06CD4:  MOVFF  5C9,01
06CD8:  BRA    6CFA
06CDA:  MOVLB  0
....................             }
....................             i++;
06CDC:  MOVLB  5
06CDE:  INCF   xC8,F
06CE0:  BRA    6C2C
06CE2:  MOVLB  0
....................          }
....................          return INV_CMD; // INVALID_CMD
06CE4:  MOVLW  01
06CE6:  MOVWF  01
06CE8:  MOVLB  5
06CEA:  BRA    6CFA
....................       } else return 254; // NOT THIS ADDRESS
06CEC:  BRA    6CF4
06CEE:  MOVLW  FE
06CF0:  MOVWF  01
06CF2:  BRA    6CFA
....................    } else return 255; // NOT THIS DEVICE TYPE
06CF4:  BRA    6CFA
06CF6:  MOVLW  FF
06CF8:  MOVWF  01
06CFA:  MOVLB  0
06CFC:  GOTO   6D36 (RETURN)
.................... }
.................... 
.................... void command_handler_task(){
....................    while (getNextSERReadIndex())
*
06D28:  GOTO   3F28
06D2C:  MOVF   01,F
06D2E:  BZ    6E08
....................    {
....................       int8 return_code = command_parser(SRI);
06D30:  MOVFF  427,5C2
06D34:  BRA    6B7A
06D36:  MOVFF  01,5C1
....................       //echo_cmd(SRI);
....................       sprintf(retData + strlen(retData), "%s", resp_list[return_code].msg);
06D3A:  MOVLW  04
06D3C:  MOVLB  5
06D3E:  MOVWF  xE9
06D40:  MOVLW  29
06D42:  MOVWF  xE8
06D44:  MOVLB  0
06D46:  CALL   3FBC
06D4A:  MOVF   01,W
06D4C:  ADDLW  29
06D4E:  MOVLB  5
06D50:  MOVWF  xC2
06D52:  MOVLW  04
06D54:  ADDWFC 02,W
06D56:  MOVWF  xC3
06D58:  MOVF   xC1,W
06D5A:  MULLW  03
06D5C:  MOVF   FF3,W
06D5E:  CLRF   xC5
06D60:  MOVWF  xC4
06D62:  MOVLW  01
06D64:  ADDWF  xC4,W
06D66:  MOVWF  01
06D68:  MOVLW  00
06D6A:  ADDWFC xC5,W
06D6C:  MOVWF  03
06D6E:  MOVF   01,W
06D70:  ADDLW  8D
06D72:  MOVWF  FE9
06D74:  MOVLW  05
06D76:  ADDWFC 03,W
06D78:  MOVWF  FEA
06D7A:  MOVFF  FEC,5C5
06D7E:  MOVF   FED,F
06D80:  MOVFF  FEF,5C4
06D84:  MOVFF  5C3,4CE
06D88:  MOVFF  5C2,4CD
06D8C:  MOVFF  4CE,FEA
06D90:  MOVFF  4CD,FE9
06D94:  CLRF   FEF
06D96:  MOVFF  5C5,FEA
06D9A:  MOVFF  5C4,FE9
06D9E:  MOVLB  0
06DA0:  BRA    6D00
....................       fprintf(SERIAL, "%s,%s", SERcmd[SRI].p[0], retData);
06DA2:  MOVLB  5
06DA4:  CLRF   xE5
06DA6:  MOVFF  427,5E4
06DAA:  CLRF   xE7
06DAC:  MOVLW  B5
06DAE:  MOVWF  xE6
06DB0:  MOVLB  0
06DB2:  CALL   081A
06DB6:  MOVFF  02,5C3
06DBA:  MOVFF  01,5C2
06DBE:  MOVLW  06
06DC0:  MOVLB  5
06DC2:  ADDWF  xC2,F
06DC4:  MOVLW  00
06DC6:  ADDWFC xC3,F
06DC8:  MOVLW  53
06DCA:  ADDWF  xC2,W
06DCC:  MOVWF  01
06DCE:  MOVLW  01
06DD0:  ADDWFC xC3,W
06DD2:  MOVWF  03
06DD4:  MOVFF  01,5C4
06DD8:  MOVWF  xC5
06DDA:  MOVWF  FEA
06DDC:  MOVFF  01,FE9
06DE0:  MOVLB  0
06DE2:  CALL   3A0C
06DE6:  MOVLW  2C
06DE8:  MOVLB  5
06DEA:  MOVWF  xC8
06DEC:  MOVLB  0
06DEE:  CALL   39E4
06DF2:  MOVLW  04
06DF4:  MOVWF  FEA
06DF6:  MOVLW  29
06DF8:  MOVWF  FE9
06DFA:  CALL   3A0C
....................       
....................       resetSERcmd(SRI);
06DFE:  MOVFF  427,5C2
06E02:  CALL   083C
06E06:  BRA    6D28
....................    }
06E08:  GOTO   7172 (RETURN)
.................... }
.................... 
.................... #endif
.................... 
.................... 
.................... void main()
06E0C:  CLRF   FF8
06E0E:  BCF    FF2.5
06E10:  BSF    07.7
06E12:  MOVLB  E
06E14:  MOVLW  55
06E16:  MOVWF  x9B
06E18:  MOVLW  AA
06E1A:  MOVWF  x9B
06E1C:  BCF    x9B.0
06E1E:  MOVLW  17
06E20:  MOVWF  xB0
06E22:  MOVLW  13
06E24:  MOVWF  xB2
06E26:  MOVLW  09
06E28:  MOVWF  x8A
06E2A:  MOVLW  0A
06E2C:  MOVWF  x8B
06E2E:  MOVLW  11
06E30:  MOVWF  xEB
06E32:  MOVLW  12
06E34:  MOVWF  xED
06E36:  MOVLW  10
06E38:  MOVWF  xF4
06E3A:  MOVLW  0F
06E3C:  MOVWF  xF5
06E3E:  MOVLW  09
06E40:  MOVWF  xF8
06E42:  MOVLW  55
06E44:  MOVWF  x9B
06E46:  MOVLW  AA
06E48:  MOVWF  x9B
06E4A:  BSF    x9B.0
06E4C:  CLRF   xD8
06E4E:  CLRF   xD5
06E50:  CLRF   xD7
06E52:  MOVLW  08
06E54:  MOVWF  xD9
06E56:  MOVLW  60
06E58:  MOVWF  xD3
06E5A:  MOVLW  AA
06E5C:  MOVLB  0
06E5E:  MOVWF  xF2
06E60:  MOVLB  1
06E62:  CLRF   x44
06E64:  CLRF   x43
06E66:  CLRF   x42
06E68:  CLRF   x41
06E6A:  CLRF   x48
06E6C:  CLRF   x47
06E6E:  CLRF   x46
06E70:  CLRF   x45
06E72:  CLRF   x4C
06E74:  CLRF   x4B
06E76:  CLRF   x4A
06E78:  CLRF   x49
06E7A:  CLRF   x4E
06E7C:  CLRF   x4D
06E7E:  MOVLB  E
06E80:  BCF    x91.5
06E82:  MOVLW  00
06E84:  MOVWF  x90
06E86:  MOVLW  0F
06E88:  MOVWF  x8E
06E8A:  MOVLW  2A
06E8C:  MOVWF  x91
06E8E:  MOVLW  F4
06E90:  MOVWF  F88
06E92:  MOVWF  F88
06E94:  MOVWF  F88
06E96:  BCF    F95.5
06E98:  MOVLW  40
06E9A:  MOVWF  F94
06E9C:  MOVLW  9F
06E9E:  MOVWF  F92
06EA0:  MOVLW  2A
06EA2:  MOVWF  F95
06EA4:  MOVLW  93
06EA6:  MOVWF  F89
06EA8:  MOVWF  F89
06EAA:  MOVLB  4
06EAC:  CLRF   x27
06EAE:  CLRF   x28
06EB0:  CLRF   xC9
06EB2:  CLRF   xCA
06EB4:  BCF    xCB.0
06EB6:  CLRF   xCC
06EB8:  BSF    F9E.3
06EBA:  MOVLW  7C
06EBC:  MOVWF  F9A
06EBE:  MOVLW  00
06EC0:  MOVWF  F9B
06EC2:  MOVLW  A6
06EC4:  MOVWF  F9D
06EC6:  MOVLW  90
06EC8:  MOVWF  F9C
06ECA:  MOVLW  93
06ECC:  MOVWF  F89
06ECE:  BCF    F84.5
06ED0:  CLRF   xCE
06ED2:  CLRF   xCD
06ED4:  CLRF   xD3
06ED6:  CLRF   xD2
06ED8:  CLRF   xD1
06EDA:  CLRF   xD0
06EDC:  MOVLB  F
06EDE:  CLRF   x0C
06EE0:  CLRF   x14
06EE2:  CLRF   x1C
06EE4:  CLRF   x21
06EE6:  CLRF   x29
06EE8:  CLRF   x35
06EEA:  CLRF   x36
06EEC:  CLRF   x37
06EEE:  CLRF   x34
06EF0:  CLRF   x31
06EF2:  CLRF   x32
06EF4:  CLRF   x33
06EF6:  CLRF   x30
06EF8:  MOVLW  40
06EFA:  MOVLB  4
06EFC:  MOVWF  xD7
06EFE:  MOVLW  AC
06F00:  MOVWF  xD6
06F02:  MOVLW  40
06F04:  MOVWF  xDB
06F06:  MOVLW  F0
06F08:  MOVWF  xDA
06F0A:  MOVLW  45
06F0C:  MOVWF  xDF
06F0E:  MOVLW  88
06F10:  MOVWF  xDE
06F12:  MOVLW  47
06F14:  MOVWF  xE3
06F16:  MOVLW  36
06F18:  MOVWF  xE2
06F1A:  MOVLW  48
06F1C:  MOVWF  xE7
06F1E:  MOVLW  E6
06F20:  MOVWF  xE6
06F22:  MOVLW  4A
06F24:  MOVWF  xEB
06F26:  MOVLW  50
06F28:  MOVWF  xEA
06F2A:  MOVLW  4F
06F2C:  MOVWF  xEF
06F2E:  MOVLW  2A
06F30:  MOVWF  xEE
06F32:  MOVLW  55
06F34:  MOVWF  xF3
06F36:  MOVLW  26
06F38:  MOVWF  xF2
06F3A:  MOVLW  58
06F3C:  MOVWF  xF7
06F3E:  MOVLW  30
06F40:  MOVWF  xF6
06F42:  MOVLW  59
06F44:  MOVWF  xFB
06F46:  MOVLW  66
06F48:  MOVWF  xFA
06F4A:  MOVLW  5B
06F4C:  MOVWF  xFF
06F4E:  MOVLW  4E
06F50:  MOVWF  xFE
06F52:  MOVLW  5E
06F54:  MOVLB  5
06F56:  MOVWF  x03
06F58:  MOVLW  C0
06F5A:  MOVWF  x02
06F5C:  MOVLW  63
06F5E:  MOVWF  x07
06F60:  MOVLW  14
06F62:  MOVWF  x06
06F64:  MOVLW  66
06F66:  MOVWF  x0B
06F68:  MOVLW  D8
06F6A:  MOVWF  x0A
06F6C:  MOVLW  66
06F6E:  MOVWF  x0F
06F70:  MOVLW  DE
06F72:  MOVWF  x0E
06F74:  MOVLW  66
06F76:  MOVWF  x13
06F78:  MOVLW  E4
06F7A:  MOVWF  x12
06F7C:  MOVLW  66
06F7E:  MOVWF  x17
06F80:  MOVLW  EA
06F82:  MOVWF  x16
06F84:  MOVLW  67
06F86:  MOVWF  x1B
06F88:  MOVLW  F0
06F8A:  MOVWF  x1A
06F8C:  MOVLW  6B
06F8E:  MOVWF  x1F
06F90:  MOVLW  74
06F92:  MOVWF  x1E
06F94:  BRA    7104
06F96:  DATA 02,00
06F98:  DATA 1A,00
06F9A:  DATA 00,01
06F9C:  DATA 00,60
06F9E:  DATA 02,09
06FA0:  DATA C0,00
06FA2:  DATA 05,80
06FA4:  DATA 7F,00
06FA6:  DATA 00,00
06FA8:  DATA 7F,0B
06FAA:  DATA C0,00
06FAC:  DATA 05,80
06FAE:  DATA 7F,00
06FB0:  DATA 00,00
06FB2:  DATA 7F,07
06FB4:  DATA C0,00
06FB6:  DATA 01,80
06FB8:  DATA 7F,17
06FBA:  DATA C0,00
06FBC:  DATA 01,80
06FBE:  DATA 7F,17
06FC0:  DATA C0,00
06FC2:  DATA 01,80
06FC4:  DATA 7F,07
06FC6:  DATA C0,00
06FC8:  DATA 01,80
06FCA:  DATA 7F,07
06FCC:  DATA C0,00
06FCE:  DATA 01,80
06FD0:  DATA 7F,07
06FD2:  DATA C0,00
06FD4:  DATA 01,80
06FD6:  DATA 7F,07
06FD8:  DATA C0,00
06FDA:  DATA 01,80
06FDC:  DATA 7F,07
06FDE:  DATA C0,00
06FE0:  DATA 01,80
06FE2:  DATA 7F,07
06FE4:  DATA C0,00
06FE6:  DATA 01,80
06FE8:  DATA 7F,0B
06FEA:  DATA C0,00
06FEC:  DATA 32,41
06FEE:  DATA 0F,00
06FF0:  DATA 04,01
06FF2:  DATA 4F,00
06FF4:  DATA 00,00
06FF6:  DATA 00,3C
06FF8:  DATA 44,8D
06FFA:  DATA 00,01
06FFC:  DATA 04,CF
06FFE:  DATA 00,02
07000:  DATA 04,D4
07002:  DATA 20,05
07004:  DATA 02,04
07006:  DATA D8,23
07008:  DATA 05,02
0700A:  DATA 04,DC
0700C:  DATA 26,05
0700E:  DATA 02,04
07010:  DATA E0,2D
07012:  DATA 05,02
07014:  DATA 04,E4
07016:  DATA 34,05
07018:  DATA 02,04
0701A:  DATA E8,3C
0701C:  DATA 05,02
0701E:  DATA 04,EC
07020:  DATA 44,05
07022:  DATA 02,04
07024:  DATA F0,49
07026:  DATA 05,02
07028:  DATA 04,F4
0702A:  DATA 4E,05
0702C:  DATA 02,04
0702E:  DATA F8,52
07030:  DATA 05,02
07032:  DATA 04,FC
07034:  DATA 56,05
07036:  DATA 02,05
07038:  DATA 00,5D
0703A:  DATA 05,02
0703C:  DATA 05,04
0703E:  DATA 63,05
07040:  DATA 02,05
07042:  DATA 08,69
07044:  DATA 05,02
07046:  DATA 05,0C
07048:  DATA 6F,05
0704A:  DATA 02,05
0704C:  DATA 10,75
0704E:  DATA 05,02
07050:  DATA 05,14
07052:  DATA 7A,05
07054:  DATA 02,05
07056:  DATA 18,83
07058:  DATA 05,02
0705A:  DATA 05,1C
0705C:  DATA 8B,05
0705E:  DATA 6A,05
07060:  DATA 20,67
07062:  DATA 72,00
07064:  DATA 67,73
07066:  DATA 00,67
07068:  DATA 43,68
0706A:  DATA 4D,61
0706C:  DATA 70,00
0706E:  DATA 73,43
07070:  DATA 68,4D
07072:  DATA 61,70
07074:  DATA 00,67
07076:  DATA 43,68
07078:  DATA 4D,6F
0707A:  DATA 64,65
0707C:  DATA 00,73
0707E:  DATA 43,68
07080:  DATA 4D,6F
07082:  DATA 64,65
07084:  DATA 00,67
07086:  DATA 50,49
07088:  DATA 44,00
0708A:  DATA 73,50
0708C:  DATA 49,44
0708E:  DATA 00,67
07090:  DATA 53,50
07092:  DATA 00,73
07094:  DATA 53,50
07096:  DATA 00,67
07098:  DATA 53,43
0709A:  DATA 61,6C
0709C:  DATA 73,00
0709E:  DATA 67,53
070A0:  DATA 43,61
070A2:  DATA 6C,00
070A4:  DATA 73,53
070A6:  DATA 43,61
070A8:  DATA 6C,00
070AA:  DATA 67,4D
070AC:  DATA 43,61
070AE:  DATA 6C,00
070B0:  DATA 73,4D
070B2:  DATA 43,61
070B4:  DATA 6C,00
070B6:  DATA 67,4D
070B8:  DATA 6F,6E
070BA:  DATA 00,67
070BC:  DATA 50,49
070BE:  DATA 44,64
070C0:  DATA 61,74
070C2:  DATA 61,00
070C4:  DATA 67,49
070C6:  DATA 50,64
070C8:  DATA 61,74
070CA:  DATA 61,04
070CC:  DATA C0,00
070CE:  DATA 32,80
070D0:  DATA 96,05
070D2:  DATA 01,9E
070D4:  DATA 05,02
070D6:  DATA AE,05
070D8:  DATA 53,55
070DA:  DATA 43,43
070DC:  DATA 45,53
070DE:  DATA 53,00
070E0:  DATA 49,4E
070E2:  DATA 56,41
070E4:  DATA 4C,49
070E6:  DATA 44,20
070E8:  DATA 43,4F
070EA:  DATA 4D,4D
070EC:  DATA 41,4E
070EE:  DATA 44,00
070F0:  DATA 49,4E
070F2:  DATA 56,41
070F4:  DATA 4C,49
070F6:  DATA 44,20
070F8:  DATA 50,41
070FA:  DATA 52,41
070FC:  DATA 4D,45
070FE:  DATA 54,45
07100:  DATA 52,00
07102:  DATA 00,00
07104:  MOVLW  00
07106:  MOVWF  FF8
07108:  MOVLW  6F
0710A:  MOVWF  FF7
0710C:  MOVLW  96
0710E:  MOVWF  FF6
07110:  TBLRD*+
07112:  MOVF   FF5,W
07114:  MOVWF  00
07116:  XORLW  00
07118:  BZ    7140
0711A:  TBLRD*+
0711C:  MOVF   FF5,W
0711E:  MOVWF  01
07120:  BTFSC  FE8.7
07122:  BRA    712E
07124:  ANDLW  3F
07126:  MOVWF  FEA
07128:  TBLRD*+
0712A:  MOVFF  FF5,FE9
0712E:  BTFSC  01.6
07130:  TBLRD*+
07132:  BTFSS  01.6
07134:  TBLRD*+
07136:  MOVFF  FF5,FEE
0713A:  DCFSNZ 00,F
0713C:  BRA    7110
0713E:  BRA    7132
07140:  CLRF   FF8
.................... {
....................    IO_init();                    // set up IO 
07142:  MOVLB  0
07144:  GOTO   0316
....................    params_init();                // load parameters
07148:  GOTO   05BE
....................    monitor_init();               // initialize internal ADC for voltage and current telemetry
0714C:  GOTO   075E
....................    control_init();               // initialize the output control DACs
07150:  GOTO   07F6
....................    serial_init();                // setup the serial port
07154:  GOTO   09B6
....................    event_timer_init();
07158:  GOTO   09D8
.................... //!   setup_wdt(WDT_512MS);
....................    enable_interrupts(GLOBAL);
0715C:  MOVLW  C0
0715E:  IORWF  FF2,F
.................... 
....................    while(TRUE)
....................    {
.................... //!      restart_wdt();
....................       internal_monitor_task();   //Update monitored voltage and currents etc
07160:  GOTO   0DB6
....................       sensor_monitor_task();     //get magnetoresistive sensor data
07164:  GOTO   3716
....................       control_task();            //output control
07168:  GOTO   396C
....................       serial_task();             //serial port 
0716C:  GOTO   3A30
....................       command_handler_task();    //execute commands
07170:  BRA    6D28
....................       
....................       delay_ms(500);
07172:  MOVLW  02
07174:  MOVLB  5
07176:  MOVWF  xC1
07178:  MOVLW  FA
0717A:  MOVWF  xC4
0717C:  MOVLB  0
0717E:  CALL   03AC
07182:  MOVLB  5
07184:  DECFSZ xC1,F
07186:  BRA    7178
07188:  MOVLB  0
0718A:  BRA    7160
....................    }
.................... }
0718C:  SLEEP 

Configuration Fuses:
   Word  1: FF8C   NOEXTOSC RSTOSC_HFINTRC_64MHZ NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV19 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
